;;;Ikarus Scheme -- A compiler for R6RS Scheme.
;;;Copyright (C) 2006,2007,2008  Abdulaziz Ghuloum
;;;Modified by Marco Maggi.
;;;
;;;This program is free software:  you can redistribute it and/or modify
;;;it under  the terms of  the GNU General  Public License version  3 as
;;;published by the Free Software Foundation.
;;;
;;;This program is  distributed in the hope that it  will be useful, but
;;;WITHOUT  ANY   WARRANTY;  without   even  the  implied   warranty  of
;;;MERCHANTABILITY or  FITNESS FOR  A PARTICULAR  PURPOSE.  See  the GNU
;;;General Public License for more details.
;;;
;;;You should  have received a  copy of  the GNU General  Public License
;;;along with this program.  If not, see <http://www.gnu.org/licenses/>.


#!vicare
(library (ikarus.intel-assembler)
  (export
    assemble-sources
    assembler-property-key)
  (import (except (vicare)
		  fixnum-width
		  greatest-fixnum
		  least-fixnum)
    ;;NOTE  This library  is needed  to build  a  new boot  image.  Let's  try to  do
    ;;everything here without loading external  libraries.  (Marco Maggi; Thu Sep 25,
    ;;2014)
    (ikarus.compiler.condition-types)
    (prefix (ikarus.code-objects)
	    code-objects::)
    (except (vicare system $codes)
	    assembler-property-key))

  (module (wordsize boot.case-word-size off-code-data)
    (include "ikarus.compiler.scheme-objects-layout.scm" #t))


;;;; introduction
;;
;;As reference for Intel Architecture instructions  we can look at (URL last verified
;;on Fri Oct 24, 2014):
;;
;;   IntelÂ® 64 and IA-32 Architectures Software Developer Manuals
;;   <http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html>
;;
;;and search especially for:
;;
;;   Intel 64  and IA-32 Architectures  Software Developer's Manual  Combined Volumes
;;   2A, 2B, and 2C: Instruction Set Reference, A-Z.
;;
;;which  has a  nice, clickable,  index of  supported instruction  mnemonics.  For  a
;;quickly searchable list of x86 Assembly  instructions (both Intel notation and AT&T
;;notation) see also:
;;
;;   Wikipedia  contributors.   "X86  instruction  listings."   Wikipedia,  The  Free
;;   Encyclopedia.   Wikipedia,  The Free  Encyclopedia,  30  Aug.  2014.   Web.   24
;;   Oct. 2014.  <https://en.wikipedia.org/wiki/X86_instruction_listings>
;;
;;
;;General notes
;;-------------
;;
;;Almost  all the  Assembly language  instructions used  by Vicare  act upon  machine
;;words;  which means  32-bit integers  on 32-bit  platforms and  64-bit integers  on
;;64-bit platforms.
;;
;;The only high-level  Assembly instructions acting upon bytes are:  BSET, BREF; they
;;are used to access bytes and octets in the data area of bytevector, flonum and code
;;Scheme  objects.  Both  BSET  and  BREF are  implemented  with  the Intel  Assembly
;;instruction MOVB.
;;
;;The only high-level Assembly instructions  acting upon 32-bit integers are: MSET32,
;;MREF32; they are used to access  Unicode code points representing characters in the
;;data area  of string Scheme objects.   Both MSET32 and MREF32  are implemented with
;;the Intel Assembly instruction MOV32.
;;
;;The code is generated by previous compiler passes using 32-bit register names (EAX,
;;EBX, ...)   and this compiler  pass takes care  of replacing them  with appropriate
;;64-bit opcodes when assembling for a 64-bit platform.
;;
;;NOTE  The high-level  Assembly instruction  BSWAP!  is  implemented with  the Intel
;;Assembly  instruction BSWAP,  which does  *not* act  on byte  operands: as  used by
;;Vicare, it reverses the byte order of a machine word operand.
;;
;;NOTE Some  Assembly instructions accept  an immediate integer constant  as operand,
;;embedded in the instruction opcode.  The Intel architecture only supports immediate
;;constants of size: 8-bit, 16-bit, 32-bit;  there is no support for 64-bit immediate
;;constants.  The code  refers to integers that can be  embedded as "small operands",
;;while 64-bit constants are "big operands".  Whenever we have to assemble code using
;;a 64-bit  constant: we have  to load it  into a 64-bit  CPU register, then  use the
;;register as operand.
;;
;;
;;About this compiler pass
;;------------------------
;;
;;The purpose of this compiler pass  is to convert symbolic expressions, representing
;;Assembly language  code, into code objects  that can be executed  and serialised in
;;FASL files.  To  understand this compiler pass we need  to understand:
;;
;;* The  internals of code  objects and associated  relocation vectors.  For  this we
;;should read the documentation in Texinfo format.
;;
;;* The structure of opcodes of machine code for the Intel Architecture.  For this we
;;need to study the Intel Architecture manuals.
;;
;;
;;About the input symbolic expressions
;;------------------------------------
;;
;;The input to this compiler pass is a list of symbolic expressions:
;;
;;   (?code-object-sexp ...)
;;
;;each of which has the format:
;;
;;   (code-object-sexp
;;     (number-of-free-vars:	?num)
;;     (annotation:		?annotation)
;;     (label			?label)
;;     ?asm-instr-sexp ...)
;;
;;examples of ?ASM-INSTR-SEXP are:
;;
;;   (movl (obj +) %eax)
;;   (movl (disp %eax 19) %eax)
;;   (movl 8 (disp -8 %esp))
;;   (movl 16 (disp -16 %esp))
;;   (movl %eax %edi)
;;   (movl -16 %eax)
;;   (jmp (disp -3 %edi))
;;
;;Among the input Assembly instructions symbolic expressions, notice the following:
;;
;;(label ?gensym)
;;
;;   Represents  a  machine-code  entry-point:  the target  of  a  jump  instruction.
;;   Somewhere in the code there is a corresponding instruction like:
;;
;;      (jmp (label ?gensym))
;;
;;   where the  jump instruction can  be conditioned or  not.  The LABEL  sexp itself
;;   does not generate code it just causes the current position in the code object to
;;   be associated to the ?GENSYM.
;;
;;(label-address ?gensym)
;;
;;   Represents the  address of a  machine-code entry: the target  of a jump  or call
;;   instruction.  The functions that are referenced in recordised code by a CODE-LOC
;;   are represented in the input by this sexp.  The LABEL-ADDRESS sexp is present in
;;   the input where the address is actually used.
;;


;;;; syntax helpers

(define-syntax __module_who__
  (identifier-syntax 'assemble-sources))

(define-syntax ($for-each/stx stx)
  ;;Like FOR-HEACH, but expand the loop inline.   The "function" to be mapped must be
  ;;specified by an identifier or lambda form because it is evaluated multiple times.
  ;;
  ;;This implementation:  is tail recursive,  assumes proper list arguments  of equal
  ;;length.
  ;;
  (syntax-case stx ()
    ((_ ?func ?ell0 ?ell ...)
     (with-syntax (((T ...) (generate-temporaries #'(?ell ...))))
       #'(let loop ((t ?ell0) (T ?ell) ...)
	   (when (pair? t)
	     (?func (car t) (car T) ...)
	     (loop  (cdr t) (cdr T) ...)))))
    ))

;;; --------------------------------------------------------------------

(define-syntax-rule (fxadd2 ?op)
  (fx+ ?op 2))

(define-syntax-rule (fxadd3 ?op)
  (fx+ ?op 3))

(define-syntax-rule (fxadd4 ?op)
  (fx+ ?op 4))

(define-syntax fxincr!
  (syntax-rules ()
    ((_ ?op)
     (fxincr! ?op 1))
    ((_ ?op 0)
     ?op)
    ((_ ?op 1)
     (set! ?op (fxadd1 ?op)))
    ((_ ?op 2)
     (set! ?op (fxadd2 ?op)))
    ((_ ?op 3)
     (set! ?op (fxadd3 ?op)))
    ((_ ?op 4)
     (set! ?op (fxadd4 ?op)))
    ((_ ?op ?N)
     (set! ?op (fx+ ?op ?N)))
    ))

;; ------------------------------------------------------------

(define-syntax-rule (define-entry-predicate ?who ?symbol)
  (define (?who x)
    (and (pair? x)
	 (eq? (car x) '?symbol))))


;;;; helpers

(define-constant LEAST-S32-INTEGER
  -2147483648)	#;(- (expt 2 31))

(define-constant GREATEST-S32-INTEGER
  +2147483647)	#;(- (expt 2 31) 1)

;;; --------------------------------------------------------------------

(define-syntax-rule (%compiler-internal-error who ?message . ?irritants)
  (compiler-internal-error __module_who__ who ?message . ?irritants))

;;; --------------------------------------------------------------------

(define* (%compute-code-size octets-and-labels)
  ;;Non-tail recursive  function.  Given a  list holding octets-as-fixnums  and label
  ;;sexps: compute  and return the number  of bytes needed to  hold the corresponding
  ;;binary code.  Such number of bytes will be the minimum size of the data area in a
  ;;code object.
  ;;
  (fold-right (lambda (x size)
		(if (fixnum? x)
		    (fxadd1 size)
		  (case (car x)
		    ((byte)
		     (fxadd1 size))
		    ((local-relative)
		     ;;These entries  represent Assembly  label entry  points located
		     ;;through displacements from the  current position in the binary
		     ;;code.  These labels are local  to the unit of compilation (for
		     ;;example: local the body of a CLAMBDA).
		     ;;
		     ;;We reserve 32-bit to store  such displacements, on both 32-bit
		     ;;and 64-bit platforms.
		     (fxadd4 size))
		    ((relative)
		     ;;These entries  represent Assembly  label entry  points located
		     ;;through displacements from the  current position in the binary
		     ;;code.  These labels are not  local to the unit of compilation:
		     ;;they are meant to be used  to jump-call a CLAMBDA from another
		     ;;CLAMBDA.
		     ;;
		     ;;We reserve 32-bit to store  such displacements, on both 32-bit
		     ;;and 64-bit platforms.
		     ;;
		     ;;NOTE At present it seems  this RELATIVE reference to labels is
		     ;;never used.  (Marco Maggi; Tue Aug 4, 2015)
		     ;;
		     ;;FIXME On  64-bit platforms we  should reserve 64 bits  for the
		     ;;relative  displacement and  appropriately  implement the  jump
		     ;;instruction.  (Marco Maggi; Tue Aug 4, 2015)
		     (fxadd4 size))
		    ((label)
		     size)
		    ((word reloc-word reloc-word+ label-address code-object-self-machine-word-index foreign-label)
		     (fx+ size wordsize))
		    ((bottom-code)
		     (fx+ size (%compute-code-size (cdr x))))
		    (else
		     (%compiler-internal-error __who__ "unknown instruction" x)))))
    0
    octets-and-labels))

;;; --------------------------------------------------------------------
;;; symbols properties

(module (assembler-property-key)

  (define (assembler-property-key)
    ASSEMBLER-PROPERTY-KEY)

  (define-syntax (compile-time-gensym stx)
    ;;Generate a gensym at expand time and expand to the quoted symbol.
    ;;
    (syntax-case stx ()
      ((_ ?template)
       (let* ((tmp (syntax->datum #'?template))
	      (fxs (vector->list (foreign-call "ikrt_current_time_fixnums_2")))
	      (str (apply string-append tmp (map (lambda (N)
						   (string-append "." (number->string N)))
					      fxs)))
	      (sym (gensym str)))
	 (with-syntax
	     ((SYM (datum->syntax #'here sym)))
	   (fprintf (current-error-port) "expand-time gensym ~a\n" sym)
	   #'(quote SYM))))))

  (define-constant ASSEMBLER-PROPERTY-KEY
    (compile-time-gensym "assembler-property-key"))

  #| end of module |# )


(module (assemble-sources)

  (define (assemble-sources thunk?-label code-object-sexp*)
    ;;This is the entry point in the assembler.
    ;;
    ;;The argument CODE-OBJECT-SEXP* is a list of symbolic expressions:
    ;;
    ;;   (?code-object-sexp ...)
    ;;
    ;;each of which has the format:
    ;;
    ;;   (code-object-sexp
    ;;     (number-of-free-vars:	?num)
    ;;     (annotation:			?annotation)
    ;;     (label			?label)
    ;;     ?asm-instr-sexp ...)
    ;;
    ;;Return a list of code objects.
    ;;
    (let ((code.num-of-freevars*  (map %sexp.number-of-free-vars code-object-sexp*))
	  (code.annotation*       (map %sexp.annotation          code-object-sexp*))
	  (code.asm-instr-sexp**  (map %sexp.asm-instr-sexp*     code-object-sexp*)))
      (let* ((octets-and-sexps* (map convert-instructions  code.asm-instr-sexp**))
	     (octets-and-sexps* (map %optimize-local-jumps octets-and-sexps*)))
	(let ((code-size*  (map %compute-code-size         octets-and-sexps*))
	      (reloc-size* (map %compute-reloc-vector-size octets-and-sexps*)))
	  (let ((code-objects* (map code-objects::make-code code-size* code.num-of-freevars*))
		(reloc-vector* (map make-vector             reloc-size*)))
	    (let ((reloc** (map store-binary-code-in-code-objects
			     code-objects* octets-and-sexps*)))
	      (for-each
		  (lambda (code-object reloc-vector reloc*)
		    (for-each
			(make-reloc-vector-record-filler thunk?-label code-object reloc-vector)
		      reloc*))
		code-objects* reloc-vector* reloc**)
	      ;;Store the reloc vectors in the associated code objects.  Process each
	      ;;code object with the C function "ik_relocate_code()".
	      (for-each code-objects::set-code-reloc-vector! code-objects* reloc-vector*)
	      ;;Store the annotations in the associated code objects.
	      (for-each (lambda (code annotation)
			  (when annotation
			    (code-objects::set-code-annotation! code annotation)))
		code-objects* code.annotation*)
	      code-objects*))))))

;;; --------------------------------------------------------------------

  (define (%sexp.number-of-free-vars sexp)
    ;;Given as  argument a CODE-OBJECT-SEXP  symbolic expression: extract  and return
    ;;the value of the NUMBER-OF-FREE-VARS: field.
    ;;
    (let ((field-sexp (cadr sexp)))
      (assert (eq? (car field-sexp) 'number-of-free-vars:))
      (cadr field-sexp)))

  (define (%sexp.annotation sexp)
    ;;Given as  argument a CODE-OBJECT-SEXP  symbolic expression: extract  and return
    ;;the value of the ANNOTATION: field.
    ;;
    (let ((field-sexp (caddr sexp)))
      (assert (eq? (car field-sexp) 'annotation:))
      (cadr field-sexp)))

  (define (%sexp.asm-instr-sexp* sexp)
    ;;Given as  argument a CODE-OBJECT-SEXP  symbolic expression: extract  and return
    ;;the  list  of  Assembly instructions.   We  know  that  the  first is  a  label
    ;;definition.
    ;;
    (receive-and-return (asm-instr-sexp*)
	(cdddr sexp)
      (assert (eq? 'label (caar asm-instr-sexp*)))))

;;; --------------------------------------------------------------------

  (define (%optimize-local-jumps octets-and-sexps)
    ;;Scan OCTETS-AND-SEXPS and  collect the LABEL entries, which  are "local"; then
    ;;scan again OCTETS-AND-SEXPS and mutate  the RELATIVE entries referencing local
    ;;labels to be LOCAL-RELATIVE entries.
    ;;
    ;;Notice that this function does NOT modify the spine of OCTETS-AND-SEXPS in any
    ;;way; it just mutates some of the entry's CARs.
    ;;
    ;;A reference to label is local if OCTETS-AND-SEXPS contains an entry like:
    ;;
    ;;   (label ?name)
    ;;
    ;;and an entry like:
    ;;
    ;;   (jmp (relative ?name))
    ;;
    ;;in this case we can convert the latter to:
    ;;
    ;;   (jmp (local-relative ?name))
    ;;
    ;;which  can be  implemented with  a  faster jump  instruction that  jumps to  an
    ;;address relative to the current instruction pointer.
    ;;
    (let ((locals '())
	  (G      (gensym)))

      (define (%mark-labels-with-property x)
	;;Non-tail recursive function.
	;;
	(when (pair? x)
	  (case (car x)
	    ((label)
	     (putprop (cdr x) G 'local)
	     (set! locals (cons (cdr x) locals)))
	    ((bottom-code)
	     (for-each %mark-labels-with-property (cdr x))))))

      (define (%relative->local-relative x)
	;;Non-tail recursive function.
	;;
	(when (pair? x)
	  (case (car x)
	    ((relative)
	     (when (eq? (getprop (cdr x) G) 'local)
	       (set-car! x 'local-relative)))
	    ((bottom-code)
	     (for-each %relative->local-relative (cdr x))))))

      (for-each %mark-labels-with-property octets-and-sexps)
      (for-each %relative->local-relative  octets-and-sexps)
      ;;Clean up the property lists of label symbols.
      ($for-each/stx (lambda (x)
		       (remprop x G))
	locals)
      octets-and-sexps))

;;; --------------------------------------------------------------------

  (define* (%compute-reloc-vector-size octets-and-sexps)
    ;;Compute the  length of the relocation  vector needed to relocate  a code object
    ;;holding the binary code in OCTETS-AND-SEXPS.
    ;;
    (fold-right (lambda (x ac)
		  (if (fixnum? x)
		      ac
		    (case (car x)
		      ((word byte label code-object-self-machine-word-index local-relative)
		       ac)
		      ((reloc-word foreign-label)
		       (fx+ ac 2))
		      ((relative reloc-word+ label-address)
		       (fx+ ac 3))
		      ((bottom-code)
		       (fx+ ac (%compute-reloc-vector-size (cdr x))))
		      (else
		       (%compiler-internal-error __who__
			 "unknown instr" x)))))
      0
      octets-and-sexps))

  #| end of module: ASSEMBLE-SOURCES |# )


(module (convert-instructions local-label-gensym?)

  ;;List of gensyms representing local Assembly label names.
  (define local-labels
    (make-parameter '()))

  (define (local-label-gensym? x)
    ;;Return true if X is a gensym in an entry:
    ;;
    ;;   (label ?gensym)
    ;;
    ;;representing a  local Assembly label  in the chunk  of code being  processed by
    ;;CONVERT-INSTRUCTION.
    ;;
    ;;Local Assembly labels are used, for example: to implement the local jumps in IF
    ;;syntaxes;  to  implement core  primitive  operation's  shortcuts and  interrupt
    ;;handlers; to implement CLAMBDA with multiple branches.
    ;;
    ;;FIXME Would  this be significantly  faster with an  EQ?  hashtable?  Or  is the
    ;;number of local labels usually small?   While compiling the boot image: most of
    ;;the times the list  of local labels has less than 15 items;  very rarely it has
    ;;hundreds of items.
    ;;
    (and (memq x (local-labels)) #t))

;;; --------------------------------------------------------------------

  (define (convert-instructions assembly-sexp*)
    (parametrise ((local-labels (%uncover-local-labels '() assembly-sexp*)))
      (fold-right %convert-single-sexp '() assembly-sexp*)))

  (define* (%convert-single-sexp assembly-sexp accum)
    ;;Non-tail  recursive function.   Convert ASSEMBLY-SEXP  into a  list of  fixnums
    ;;(representing  machine  code  octets)  and  sexps;  prepend  the  list  to  the
    ;;accumulator  list   ACCUM;  return  the   new  accumulator  list.    We  expect
    ;;ASSEMBLY-SEXP to have one of the formats:
    ;;
    ;;   (?assembly-instruction-mnemonic ?operand ...)
    ;;   (seq ?assembly-sexp0 ?assembly-sexp ...)
    ;;   (pad ?bytes-count ?assembly-sexp0 ?assembly-sexp ...)
    ;;
    ;;The items prepended to ACCUM can be fixnums or entries like the following:
    ;;
    ;;   (label . ?symbol)
    ;;   (label-address . ?symbol)
    ;;   (code-object-self-machine-word-index)
    ;;
    ;;NOTE The actual job of sexp instruction conversion is performed by the function
    ;;stored in the property list of the instruction name's symbol.
    ;;
    (define key
      (car assembly-sexp))
    (cond ((getprop key (assembler-property-key))
	   ;;Convert an assembly instruction specification.
	   ;;
	   => (lambda (prop)
		;;We expect PROP to have the format:
		;;
		;;   (?num-of-rand* . ?conversion-function)
		;;
		(let ((num-of-rand*         (car prop))
		      (conversion-function  (cdr prop))
		      (rand*                (cdr assembly-sexp)))
		  (define-syntax-rule (%with-checked-args ?num-of-rand* ?body-form)
		    (if (fx=? (length rand*) ?num-of-rand*)
			?body-form
		      (%error-incorrect-args __who__ assembly-sexp num-of-rand*)))
		  (case num-of-rand*
		    ((2)
		     (%with-checked-args 2
		       (conversion-function assembly-sexp accum (car rand*) (cadr rand*))))
		    ((1)
		     (%with-checked-args 1
		       (conversion-function assembly-sexp accum (car rand*))))
		    ((0)
		     (%with-checked-args 0
		       (conversion-function assembly-sexp accum)))
		    (else
		     (%with-checked-args num-of-rand*
		       (apply conversion-function assembly-sexp accum rand*)))))))

	  ((eq? key 'seq)
	   ;;Process a SEQ sexp.  A SEQ sexp has the format:
	   ;;
	   ;;   (seq . ?asm-sexps)
	   ;;
	   ;;where ?ASM-SEXPS is a list of assembly symbolic expressions.
	   ;;
	   (fold-right %convert-single-sexp accum (cdr assembly-sexp)))

	  ((eq? key 'pad)
	   ;;Process  a  PAD sexp.   Convert  the  assembly  code  and return  a  new
	   ;;accumulator list padded with a prefix of zeros.
	   ;;
	   ;;Here is an example PAD sexp, part of a non-tail function call:
	   ;;
	   ;;   (pad 10
	   ;;        (label call_label)
	   ;;        (call (disp -3 %edi)))
	   ;;
	   (let* ((pad-count      (cadr assembly-sexp))
		  (asm-sexps      (cddr assembly-sexp))
		  (new-accum.tail (fold-right %convert-single-sexp accum asm-sexps))
		  (prefix.len     (%compute-code-size (%extract-prefix accum new-accum.tail))))
	     (append (make-list (- pad-count prefix.len) 0)
		     new-accum.tail)))

	  (else
	   (%compiler-internal-error __who__
	     "unknown instruction" assembly-sexp))))

  (define (%extract-prefix old-accum new-accum)
    ;;Non-tail recursive function.  Expect NEW-ACCUM to be a list having OLD-ACCUM as
    ;;tail:
    ;;
    ;;   new-accum = (item0 item ... . old-accum)
    ;;
    ;;visit the  prefix of NEW-ACCUM  building a new list  holding the new  ITEMs and
    ;;filtering out the ITEMs being BOTTOM-CODE entries; return the resulting list.
    ;;
    (if (eq? old-accum new-accum)
	'()
      (let ((asm-sexp (car new-accum)))
	(define-syntax-rule (recur)
	  (%extract-prefix old-accum (cdr new-accum)))
	(if (bottom-code? asm-sexp)
	    ;;Skip BOTTOM-CODE sexp.
	    (recur)
	  (cons asm-sexp (recur))))))

  (define-entry-predicate bottom-code? bottom-code)

  (define (%error-incorrect-args who assembly-sexp expected-num-of-rand*)
    (%compiler-internal-error who
      (string-append "wrong number of operands in Assembly symbolic expression, expected "
		     (number->string expected-num-of-rand*))
      assembly-sexp))

;;; --------------------------------------------------------------------

  (define (%uncover-local-labels names accum)
    ;;Tail recursive function.  Expect ACCUM to be a list of Assembly sexps; NAMES is
    ;;initially null.  Iterate over ACCUM,  visiting PAD and SEQ entries recursively,
    ;;and  accumulate in  NAMES  a list  of  symbols being  the  gensyms in  symbolic
    ;;expressions:
    ;;
    ;;   (label ?gensym)
    ;;
    ;;All these  symbolic expressions represent  Assembly labels that are  "local" to
    ;;the chunk of code being compiled.  Return the resulting NAMES list.
    ;;
    (define-syntax-rule (recur ?names)
      (%uncover-local-labels ?names (cdr accum)))
    (if (pair? accum)
	(let ((entry (car accum)))
	  (if (pair? entry)
	      (case (car entry)
		((label)
		 ;;The ENTRY has the format:
		 ;;
		 ;;   (label ?gensym)
		 ;;
		 (let ()
		   (import ASSEMBLY-INSTRUCTION-OPERANDS-HELPERS)
		   (recur (cons (label-name entry) names))))
		((seq)
		 ;;The ENTRY has the format:
		 ;;
		 ;;   (seq ?assembly-sexp0 ?assembly-sexp ...)
		 ;;
		 (recur (%uncover-local-labels names (cdr entry))))
		((pad)
		 ;;The ENTRY has the format:
		 ;;
		 ;;   (pad ?bytes-count ?assembly-sexp0 ?assembly-sexp ...)
		 ;;
		 (recur (%uncover-local-labels names (cddr entry))))
		(else
		 (recur names)))
	    (recur names)))
      names))

  #| end of module |# )


(module (store-binary-code-in-code-objects)

  (define* (store-binary-code-in-code-objects x octets-and-sexps)
    ;;Loop over  the list  of entries  OCTETS-AND-SEXPS, filling the  data area  of X
    ;;accordingly.  X  is a code object.   OCTETS-AND-SEXPS is a list  of fixnums and
    ;;lists; the fixnums being binary code octects  to be stored in the code object's
    ;;data area, the lists representing entries for the relocation vector.
    ;;
    ;;Return a list representing data to build a relocation vector.
    ;;
    (define (loop octets-and-sexps idx reloc bot*)
      ;;IDX is  the index of  the next byte  to be filled  in the code  object's data
      ;;area.
      ;;
      ;;BOT* is  initially empty and  is filled with  subentries from the  entries in
      ;;OCTETS-AND-SEXPS  having key  BOTTOM-CODE; such  entries are  processed after
      ;;OCTETS-AND-SEXPS has been consumed.
      ;;
      (cond ((null? octets-and-sexps)
	     (if (null? bot*)
		 reloc
	       (loop (car bot*) idx reloc (cdr bot*))))
	    (else
	     (let ((entry (car octets-and-sexps)))
	       (if (fixnum? entry)
		   (begin
		     ;;Store a byte of binary code in the data area.
		     ($code-set! x idx entry)
		     (loop (cdr octets-and-sexps) (fxadd1 idx) reloc bot*))
		 (case (car entry)
		   ((byte)
		    ;;Store a byte of binary code in the data area.
		    ($code-set! x idx (cdr entry))
		    (loop (cdr octets-and-sexps) (fxadd1 idx) reloc bot*))

		   ((local-relative)
		    ;;Add an entry  to the relocation list; leave 4  bytes of room in
		    ;;the data area.
		    (loop (cdr octets-and-sexps) (fx+ idx 4) (cons (cons idx entry) reloc) bot*))

		   ((relative)
		    ;;Add an entry  to the relocation list; leave 4  bytes of room in
		    ;;the data area.
		    ;;
		    ;;NOTE At present  it seems this RELATIVE reference  to labels is
		    ;;never used.  (Marco Maggi; Tue Aug 4, 2015)
		    ;;
		    ;;FIXME On  64-bit platforms  we should reserve  64 bits  for the
		    ;;relative  displacement  and  appropriately implement  the  jump
		    ;;instruction.  (Marco Maggi; Tue Aug 4, 2015)
		    (loop (cdr octets-and-sexps) (fx+ idx 4) (cons (cons idx entry) reloc) bot*))

		   ((reloc-word reloc-word+ label-address foreign-label)
		    ;;Add an  entry to the relocation  list; leave a word  of room in
		    ;;the data area.
		    (loop (cdr octets-and-sexps) (fx+ idx wordsize) (cons (cons idx entry) reloc) bot*))

		   ((word)
		    ;;Store a machine  word in the data area.  This  is, for example,
		    ;;the case  of immediate Scheme  objects, that fit into  a single
		    ;;machine word.
		    (%set-code-word-as-fixnum! x idx (cdr entry))
		    (loop (cdr octets-and-sexps) (fx+ idx wordsize) reloc bot*))

		   ((code-object-self-machine-word-index)
		    ;;Store a machine  word in the data area of  the code object; the
		    ;;machine word represents the index (zero-based number of machine
		    ;;words) of  the current machine  word in the code  object's data
		    ;;area; the index is IDX itself.
		    ;;
		    ;;NOTE This machine  word can be used by machine  code to compute
		    ;;the address  of the  meta data  in the code  object, and  so to
		    ;;access, for example, the relocation vector.
		    ;;
		    (%set-code-word-as-fixnum! x idx idx)
		    (loop (cdr octets-and-sexps) (fx+ idx wordsize) reloc bot*))

		   ((label)
		    ;;This entry represents  an Assembly label; the label  is used as
		    ;;reference to  the current entry  point in the code  object: the
		    ;;machine word at offset IDX from the beginning of the data area.
		    ;;
		    ;;We store  informations about the  current location in  the code
		    ;;object in the label gensym's property list as:
		    ;;
		    ;;   (?code-object-reference ?offset-as-number-of-words)
		    ;;
		    ;;such value  will be used  later, when composing  the relocation
		    ;;vector, by entries of type LABEL-ADDRESS.
		    (%set-label-loc! (cdr entry) (list x idx))
		    (loop (cdr octets-and-sexps) idx reloc bot*))

		   ((bottom-code)
		    ;;Push this entry in BOT* to be processed at the end.
		    (loop (cdr octets-and-sexps) idx reloc (cons (cdr entry) bot*)))

		   (else
		    (%compiler-internal-error __who__ "unknown entry in octets and sexps" entry))))))))
    (loop octets-and-sexps 0 '() '()))

  (define* (%set-code-word-as-fixnum! code idx {x fixnum?})
    ;;Store a  machine word, whose value  is X, in the  data area of the  code object
    ;;CODE at index IDX.  The machine word is stored encoded as fixnum.
    ;;
    (boot.case-word-size
     ((32)
      ;;On 32-bit platforms, we know that X has a  payload of 32 - 2 = 30 bits in the
      ;;bit range [0, 29].  We split such bits as follows:
      ;;
      ;;            2         1         0
      ;;   987654321098765432109876543210
      ;;   |----------------------------| 30 bits
      ;;                           |----| 6 bits, bit range [0, 5]
      ;;                   |------|       8 bits, bit range [6, 13]
      ;;           |------|               8 bits, bit range [14, 21]
      ;;   |------|                       8 bits, bit range [22, 29]
      ;;
      ;;*  Bit  range  [0,  5]  is  stored  in  the  first  least  significant  byte,
      ;;left-shifted by 2 bits to represent the fixnum tag #b00.
      ;;
      ;;* Bit range [6, 13] is stored in the second byte.
      ;;
      ;;* Bit range [14, 21] is stored in the third byte.
      ;;
      ;;* Bit range [22, 29] is stored in the fourth byte.
      ;;
      ($code-set! code (fx+ idx 0) (fxsll (fxlogand x #x3F) 2))
      ($code-set! code (fx+ idx 1) (fxlogand (fxsra x  6) #xFF))
      ($code-set! code (fx+ idx 2) (fxlogand (fxsra x 14) #xFF))
      ($code-set! code (fx+ idx 3) (fxlogand (fxsra x 22) #xFF)))
     ((64)
      ;;On 64-bit platforms, we know that X has a  payload of 64 - 3 = 61 bits in the
      ;;bit range 0-60.  We split such bits as follows:
      ;;
      ;;   6         5         4         3         2         1         0
      ;;   0987654321098765432109876543210987654321098765432109876543210
      ;;   |-----------------------------------------------------------| 61 bits
      ;;                                                           |---| 5 bits, bit range [0, 4]
      ;;                                                   |------|      8 bits, bit range [5, 12]
      ;;                                           |------|              8 bits, bit range [13, 20]
      ;;                                   |------|                      8 bits, bit range [21, 28]
      ;;                           |------|                              8 bits, bit range [29, 36]
      ;;                   |------|                                      8 bits, bit range [37, 44]
      ;;           |------|                                              8 bits, bit range [45, 52]
      ;;   |------|                                                      8 bits, bit range [53, 60]
      ;;
      ;;* Bit range  0-4 is stored in the 1st  (least significant) byte, left-shifted
      ;;by 3 bits to represent the fixnum tag #b000.
      ;;
      ;;* Bit range [5, 12] is stored in the 2nd byte.
      ;;
      ;;* Bit range [13, 20] is stored in the 3rd byte.
      ;;
      ;;* Bit range [21, 28] is stored in the 4th byte.
      ;;
      ;;* Bit range [29, 36] is stored in the 5th byte.
      ;;
      ;;* Bit range [37, 44] is stored in the 6th byte.
      ;;
      ;;* Bit range [45, 52] is stored in the 7th byte.
      ;;
      ;;* Bit range [53, 60] is stored in the 8th byte.
      ;;
      ($code-set! code (fx+ idx 0) (fxsll (fxlogand x #x1F) 3))
      ($code-set! code (fx+ idx 1) (fxlogand (fxsra x  5) #xFF))
      ($code-set! code (fx+ idx 2) (fxlogand (fxsra x 13) #xFF))
      ($code-set! code (fx+ idx 3) (fxlogand (fxsra x 21) #xFF))
      ($code-set! code (fx+ idx 4) (fxlogand (fxsra x 29) #xFF))
      ($code-set! code (fx+ idx 5) (fxlogand (fxsra x 37) #xFF))
      ($code-set! code (fx+ idx 6) (fxlogand (fxsra x 45) #xFF))
      ($code-set! code (fx+ idx 7) (fxlogand (fxsra x 53) #xFF)))))

  (define* (%set-label-loc! x loc)
    (if (getprop x '*label-loc*)
	(%compiler-internal-error __who__ "label is already defined" x)
      (putprop x '*label-loc* loc)))

  #| end of module: STORE-BINARY-CODE-IN-CODE-OBJECTS |# )


(module (make-reloc-vector-record-filler)

  (define-syntax __who__
    (identifier-syntax 'make-reloc-vector-record-filler))

  (define (make-reloc-vector-record-filler thunk?-label code vec)
    ;;Return  a closure  to be  used  to add  records  to the  relocation vector  VEC
    ;;associated to the code object CODE.
    ;;
    (define reloc-idx 0)
    (lambda (r)
      (define val
	(let ((v (cddr r)))
	  (cond ((thunk?-label v)
		 => (lambda (label)
		      (let ((p (%label-loc label)))
			(cond ((fx= (length p) 2)
			       (let ((code (car  p))
				     (idx  (cadr p)))
				 (unless (fxzero? idx)
				   (%error "cannot create a thunk pointing" idx))
				 (receive-and-return (thunk)
				     (code-objects::code->thunk code)
				   (set-cdr! (cdr p) (list thunk)))))
			      (else
			       (caddr p))))))
		(else v))))
      (define-syntax key
	(identifier-syntax (cadr r)))
      (case key
	((reloc-word)
	 ;;Add  a record  of type  "vanilla object".   The value  is a  non-immediate
	 ;;Scheme object.
	 (let ((off (car r))) ;Offset into the data area of the code object.
	   (%store-first-word! vec reloc-idx IK_RELOC_RECORD_VANILLA_OBJECT_TAG off)
	   (vector-set! vec (fxadd1 reloc-idx) val)
	   (fxincr! reloc-idx 2)))

	((foreign-label)
	 ;;Add a  record of  type "foreign  address".  The value  is a  Scheme string
	 ;;representing the  name of a C  language function to be  called from Scheme
	 ;;code.
	 (let ((off  (car r)) ;Offset into the data area of the code object.
	       (name (string->utf8 val)))
	   (%store-first-word! vec reloc-idx IK_RELOC_RECORD_FOREIGN_ADDRESS_TAG off)
	   (vector-set! vec (fxadd1 reloc-idx) name)
	   (fxincr! reloc-idx 2)))

	((reloc-word+)
	 ;;Add a record of type "offset in object".
	 (let ((off  (car r)) ;Offset into the data area of the code object.
	       (obj  (car val))
	       (disp (cdr val)))
	   (%store-first-word! vec reloc-idx IK_RELOC_RECORD_OFFSET_IN_OBJECT_TAG off)
	   (vector-set! vec (fxadd1 reloc-idx) disp)
	   (vector-set! vec (fxadd2 reloc-idx) obj)
	   (fxincr! reloc-idx 3)))

	((label-address)
	 ;;Add  a  record  of  type  "offset  in object".   The  value  is  a  gensym
	 ;;representing an  Assembly label entry  point.  The referenced code  is one
	 ;;among: the entry  point of a common Assembly routine  (the return value of
	 ;;the functions  SL-*-LABEL); the entry  point of a "known"  Scheme function
	 ;;that was  represented by a  CODE-LOC struct; an  entry point in  this very
	 ;;code object.
	 ;;
	 ;;Being an entry point: it is the address of a code object, to which we must
	 ;;add an offset.   We retrieve informations about the  label's location from
	 ;;the label gensym's property list as:
	 ;;
	 ;;   (?code-object-reference ?fixnum-representing-offset-as-number-of-bytes)
	 ;;
	 ;;these values  are used to generate  the fields of the  relocation vector's
	 ;;record.
	 (let* ((off  (car r)) ;offset into the data area of the code object
		(loc  (%label-loc val))
		;;Reference to code object.
		(obj  (car  loc))
		;;Offset from the beginning of the code object's data area.
		(disp (cadr loc)))
	   (%store-first-word! vec reloc-idx IK_RELOC_RECORD_OFFSET_IN_OBJECT_TAG off)
	   (vector-set! vec (fxadd1 reloc-idx) (fx+ disp off-code-data))
	   (vector-set! vec (fxadd2 reloc-idx) obj))
	 (fxincr! reloc-idx 3))

	((local-relative)
	 ;;Let's imagine the following scenario in  Assembly language, in which a JMP
	 ;;instruction is used to jump directly  to another entry point by specifying
	 ;;the target address as an immediate value:
	 ;;
	 ;;      ...
	 ;;      jmp L_target
	 ;;      ...
	 ;;
	 ;;      ...
	 ;;   L_target:
	 ;;      ...
	 ;;
	 ;;such operation can be implemented also as:
	 ;;
	 ;;      ...
	 ;;      jmp-pc-relative (L_target - L_after_jmp)
	 ;;   L_after_jmp:
	 ;;      ...
	 ;;
	 ;;      ...
	 ;;   L_target:
	 ;;      ...
	 ;;
	 ;;in  which the  jump is  to the  address at  a computable  offset from  the
	 ;;JMP-PC-RELATIVE instruction;  the target address is  computed at run-time,
	 ;;by  the  CPU executing  the  JMP-PC-RELATIVE  instruction, by  adding  the
	 ;;constant offset "L_target  - L_after_jmp" to the value  of the Instruction
	 ;;Pointer Register (or Program Counter Register).
	 ;;
	 ;;When both the jump  instruction and the target label are  in the data area
	 ;;of  the  same  code  object:  the  constant  offset  can  be  computed  at
	 ;;compile-time and it  never changes.  There is  no need to add  a record to
	 ;;the relocation vector.
	 ;;
	 ;;The  constant offset  "L_target -  L_after_jmp" is  represented as  32-bit
	 ;;value, which we  compute here and store  directly in the data  area of the
	 ;;code object.
	 ;;
	 ;;            L_target          L_after_jmp
	 ;;                |                 |
	 ;;  meta data     v                 v
	 ;; |---------|----+-------------+---+------------| code object
	 ;;                                ^
	 ;;                                |
	 ;;                |.................| L_target-L_after_jmp
	 ;;
	 ;;           |....| disp        |...| 32 bits
	 ;;           |..................| off
	 ;;
	 (let* ((off  (car r)) ;Offset into the data area of the code object.
		(loc  (%label-loc val))
		(obj  (car  loc))
		(disp (cadr loc)))
	   (unless (eq? obj code)
	     (%error "source code object and target code object of \
                      a local relative jump are not the same"))
	   (let ((rel (fx- disp (fxadd4 off))))
	     ($code-set! code         off  (fxlogand        rel     #xFF))
	     ($code-set! code (fxadd1 off) (fxlogand (fxsra rel 8)  #xFF))
	     ($code-set! code (fxadd2 off) (fxlogand (fxsra rel 16) #xFF))
	     ($code-set! code (fxadd3 off) (fxlogand (fxsra rel 24) #xFF)))))

	((relative)
	 ;;Add a  record of type  "jump to  label-offset".  See the  documentation in
	 ;;Texinfo format about the code object and the relocation vector.
	 ;;
	 ;;NOTE At present it seems this  RELATIVE reference to labels is never used.
	 ;;(Marco Maggi; Tue Aug 4, 2015)
	 ;;
	 ;;FIXME  On 64-bit  platforms we  should reserve  64 bits  for the  relative
	 ;;displacement  and appropriately  implement the  jump instruction.   (Marco
	 ;;Maggi; Tue Aug 4, 2015)
	 (let* ((off  (car r))
		(loc  (%label-loc val))
		(obj  (car  loc))
		(disp (cadr loc)))
	   (unless (and (code? obj) (fixnum? disp))
	     (%error "invalid relative jump obj/disp" obj disp))
	   (%store-first-word! vec reloc-idx IK_RELOC_RECORD_JUMP_TO_LABEL_OFFSET_TAG off)
	   (vector-set! vec (fxadd1 reloc-idx) (fx+ disp off-code-data))
	   (vector-set! vec (fxadd2 reloc-idx) obj))
	 (fxincr! reloc-idx 3))

	(else
	 (%error "invalid entry key while filling relocation vector" key)))))

  (define-syntax-rule (%error ?message . ?irritants)
    (%compiler-internal-error __who__ ?message . ?irritants))

  (define-syntax %store-first-word!
    ;;
    ;;Here   we   left-shift  the   offset   so   that   we  can   Inclusive-OR   the
    ;;IK_RELOC_RECORD_*_TAG, which is 2 bits wide.
    ;;
    (syntax-rules (IK_RELOC_RECORD_VANILLA_OBJECT_TAG)
      ((_ ?vec ?reloc-idx IK_RELOC_RECORD_VANILLA_OBJECT_TAG ?binary-code.offset)
       (vector-set! ?vec ?reloc-idx               (fxsll ?binary-code.offset 2)))
      ((_ ?vec ?reloc-idx ?tag ?binary-code.offset)
       (vector-set! ?vec ?reloc-idx (fxlogor ?tag (fxsll ?binary-code.offset 2))))
      ))

  (define (%label-loc x)
    (or (getprop x '*label-loc*)
	(%compiler-internal-error __who__
	  "undefined label" x)))

  ;;Commented out because unused.  (Marco Maggi; Oct 9, 2012)
  ;;
  ;; (define-inline (unset-label-loc! x)
  ;;   (remprop x '*label-loc*))

  ;;The following constants  must be kept in sync with  the equivalent definitions in
  ;;the C language headers.
  (define-inline-constant IK_RELOC_RECORD_VANILLA_OBJECT_TAG		#b00)
  (define-inline-constant IK_RELOC_RECORD_FOREIGN_ADDRESS_TAG		#b01)
  (define-inline-constant IK_RELOC_RECORD_OFFSET_IN_OBJECT_TAG		#b10)
  (define-inline-constant IK_RELOC_RECORD_JUMP_TO_LABEL_OFFSET_TAG	#b11)
  #;(define-inline-constant IK_RELOC_RECORD_MASK_TAG			#b11)

  #| end of module |# )


(module ASSEMBLY-INSTRUCTION-OPERANDS-HELPERS
  ;;Assembly instructions operands can be:  8-bit or 32-bit immediate values; symbols
  ;;representing CPU register  names; memory references represented  by DISP symbolic
  ;;expressions.
  ;;
  ;;References to memory locations
  ;;------------------------------
  ;;
  ;;To access a value stored in a  memory location: we load the location address into
  ;;a register and then add an offset to the register; for example:
  ;;
  ;;   movl ?address, %ebx
  ;;   movl [%ebx + 8], %eax
  ;;
  ;;loads the machine word at %EBX+8 into %EAX.  To mutate a value stored in a memory
  ;;location: we load the location address into  a register and then add an offset to
  ;;the register; for example:
  ;;
  ;;   movl ?address, %ebx
  ;;   movl %eax, [%ebx + 8]
  ;;
  ;;stores the machine word in %EAX into %EBX+8.
  ;;
  ;;We always  use DISP sexps when  representing references to memory,  also when the
  ;;offset is zero.
  ;;
  ( ;;
   byte?		disp?		small-disp?

;;; enqueuing bytes in the accumulator
   CODE			CODE+r		ModRM

   ;; register operands
   register-index	reg-requires-REX.R-prefix?
   reg?			reg32?		reg8?		xmmreg?
   reg-eax?		reg-cl?

   REX.R		REX+r		REX+RM		RegReg
   C
   CR			CR*		CR*/no-rex
   CCR			CCR*		CCCR*		CCI32
   RM			jmp-pc-relative

   ;; immediate operands
   IMM			IMM32		IMM8		IMM*2
   imm?			imm32?		imm8?		immediate-int?
   imm-one?

   obj?
   byte			word		reloc-word	reloc-word+

   ;; label operands
   label?		label-address?	label?/local
   label-name

   ;; syntaxes
   case-mem/reg

   ;;These are commented out because unused.
   #;CODErr
   #;CODErri
   #;SIB
   #;obj+?
   )

;;; --------------------------------------------------------------------
;;; memory references

  (define (byte? x)
    (and (fixnum? x)
	 (fx<=? -128 x +127)))

  (define-entry-predicate disp? disp)

  (define (small-disp? x)
    (and (disp? x)
	 (byte? (cadr x))))

  (define (reg/mem? obj)
    (or (reg?  obj)
	(disp? obj)))

;;; --------------------------------------------------------------------
;;; register opeands

  (define-syntax-rule (reg? ?x)
    (assq ?x REGISTER-MAPPING))

  (define-syntax-rule (reg-eax? obj)
    (eq? obj '%eax))

  (define-syntax-rule (reg-cl? obj)
    (eq? obj '%cl))

  (let-syntax ((define-register-mapping-predicate
		 (syntax-rules ()
		   ((_ ?who ?val)
		    (define (?who x)
		      (cond ((assq x REGISTER-MAPPING)
			     => (lambda (x)
				  (eqv? (cadr x) ?val)))
			    (else #f)))))))
    (define-register-mapping-predicate reg8?   8)
    (define-register-mapping-predicate reg32?  32)
    (define-register-mapping-predicate xmmreg? 'xmm))

  (define* (register-index x)
    ;;X must be a symbol representing the name of a CPU register.  Query the table of
    ;;registers and return the IDX field from the relevant entry.
    ;;
    (cond ((assq x REGISTER-MAPPING)
	   => caddr)
	  (else
	   (%compiler-internal-error __who__ "expected symbol representing register name" x))))

  (define* (reg-requires-REX.R-prefix? x)
    ;;X must be a symbol representing the name of a CPU register.  Query the table of
    ;;registers and return the REX.R field from  the relevant entry: #t if use of the
    ;;register  requires  pushing  a REX.R  prefix  on  the  ACCUM  in front  of  the
    ;;instruction opcode; #f if no prefix is needed.
    ;;
    ;;NOTE The REX.R prefix  is needed only when the register is  a 64-bit one among:
    ;;%r8, %r9, %r10, %r11, %r12, %r13,  %r14, %r15, %r8l, %r9l, %r10l, %r11l, %r12l,
    ;;%r13l, %r14l, %r15l.
    ;;
    (cond ((assq x REGISTER-MAPPING)
	   => cadddr)
	  (else
	   (%compiler-internal-error __who__ "expected symbol representing CPU register name" x))))

  (define-constant REGISTER-MAPPING
;;;     reg  cls  idx  REX.R
    '((%eax   32    0  #f)
      (%ecx   32    1  #f)
      (%edx   32    2  #f)
      (%ebx   32    3  #f)
      (%esp   32    4  #f)
      (%ebp   32    5  #f)
      (%esi   32    6  #f)
      (%edi   32    7  #f)
      (%r8    32    0  #t)
      (%r9    32    1  #t)
      (%r10   32    2  #t)
      (%r11   32    3  #t)
      (%r12   32    4  #t)
      (%r13   32    5  #t)
      (%r14   32    6  #t)
      (%r15   32    7  #t)
      (%al     8    0  #f)
      (%cl     8    1  #f)
      (%dl     8    2  #f)
      (%bl     8    3  #f)
      (%ah     8    4  #f)
      (%ch     8    5  #f)
      (%dh     8    6  #f)
      (%bh     8    7  #f)
      (/0      0    0  #f)
      (/1      0    1  #f)
      (/2      0    2  #f)
      (/3      0    3  #f)
      (/4      0    4  #f)
      (/5      0    5  #f)
      (/6      0    6  #f)
      (/7      0    7  #f)
      (xmm0  xmm    0  #f)
      (xmm1  xmm    1  #f)
      (xmm2  xmm    2  #f)
      (xmm3  xmm    3  #f)
      (xmm4  xmm    4  #f)
      (xmm5  xmm    5  #f)
      (xmm6  xmm    6  #f)
      (xmm7  xmm    7  #f)
      (%r8l    8    0  #t)
      (%r9l    8    1  #t)
      (%r10l   8    2  #t)
      (%r11l   8    3  #t)
      (%r12l   8    4  #t)
      (%r13l   8    5  #t)
      (%r14l   8    6  #t)
      (%r15l   8    7  #t)
      ))

  ;;Commented out because unused.  (Marco Maggi; Wed Nov  5, 2014)
  ;;
  ;;(define (SIB s offset-register base-register ac)
  ;;  (cons (byte (fxlogor (register-index base-register)
  ;;                       (fxlogor (fxsll (register-index offset-register) 3)
  ;;                                (fxsll s 6))))
  ;;        ac))

;;; --------------------------------------------------------------------
;;; immediate operands: predicates

  (define (imm? x)
    (or (immediate-int?	x)
	(obj?		x)
	;;(obj+?	x)
	(label-address?	x)
	(foreign-label?	x)
	(label?		x)))

  (define-inline (immediate-int? x)
    (or (fixnum? x)
	(bignum? x)))

  (define-syntax-rule (imm8? ?x)
    (byte? ?x))

  (define (imm32? x)
    (boot.case-word-size
     ((32)
      (imm? x))
     ((64)
      (and (immediate-int? x)
	   (<= LEAST-S32-INTEGER x GREATEST-S32-INTEGER)))))

  (define (imm-one? obj)
    (and (fixnum? obj)
	 (fx=? 1 obj)))

;;; --------------------------------------------------------------------
;;; immediate operands: enqueuing

  (define* (IMM n ac)
    (cond ((immediate-int? n)
	   (boot.case-word-size
	    ((32)
	     (%IMM/imm32 n ac))
	    ((64)
	     ;;Prepend  to  the  accumulator  AC an  immediate  integer  value  least
	     ;;significant bytes first.
	     ;;
	     ;;  (IMM #xHHGGFFEEDDCCBBAA ac)
	     ;;  => `(#xAA #xBB #xCC #xDD #xEE #xFF #xGG #xHH . ,ac)
	     ;;
	     (cons* (byte n)
		    (byte (sra n 8))
		    (byte (sra n 16))
		    (byte (sra n 24))
		    (byte (sra n 32))
		    (byte (sra n 40))
		    (byte (sra n 48))
		    (byte (sra n 56))
		    ac))))
	  ((obj? n)
	   ;;The operand is a symbolic expression:
	   ;;
	   ;;   (obj ?val)
	   ;;
	   ;;in which ?VAL is a Scheme object to be handled as immediate value.
	   ;;
	   ;;If it is an immediate  Scheme object: the Scheme object's representation
	   ;;fits into a single machine word, so we generate a WORD entry; later this
	   ;;entry will  cause the machine  word representation  to be stored  in the
	   ;;code object as fixnum.
	   ;;
	   ;;If it  is a compound  Scheme object: the Scheme  object's representation
	   ;;must be allocated on the heap,  so we generate a RELOC-WORD entry; later
	   ;;this entry will cause the Scheme object to be included in the relocation
	   ;;vector.
	   ;;
	   (let ((v (cadr n)))
	     (cons (if (immediate? v)
		       (word v)
		     (reloc-word v))
		   ac)))

	  ;;Commented out because unused.  (Marco Maggi; Tue Nov 4, 2014)
	  ;;
	  ;; ((obj+? n)
	  ;;  (let ((v (cadr  n))
	  ;; 	 (d (caddr n)))
	  ;;    (cons (reloc-word+ v d) ac)))

	  ((label-address? n)
	   ;;The operand is a symbolic expression:
	   ;;
	   ;;   (label-address ?val)
	   ;;
	   ;;in which  ?VAL is a gensym  representing an Assembly label  entry point.
	   ;;The referenced code  is one among: the entry point  of a common Assembly
	   ;;routine (the return value of  the functions SL-*-LABEL); the entry point
	   ;;of a "known" Scheme function that  was represented by a CODE-LOC struct;
	   ;;an entry point in this very code object's machine code.
	   ;;
	   ;;Being an entry point: it the address  of a code object, to which we must
	   ;;add an  offset.  We  generate a LABEL-ADDRRESS  entry; later  this entry
	   ;;will be stored in the relocation vector of the code object.
	   ;;
	   #;(assert (gensym? (label-name n)))
	   (cons `(label-address . ,(label-name n))
		 ac))

	  ((foreign-label? n)
	   ;;The operand is a symbolic expression:
	   ;;
	   ;;   (foreign-label ?val)
	   ;;
	   ;;in which ?VAL is  a Scheme string representing the name  of a C function
	   ;;to be called from Scheme code.  We generate a FOREIGN-LABEL entry; later
	   ;;this entry  will cause the Scheme  string to be converted  to bytevector
	   ;;and included in the relocation vector.
	   ;;
	   #;(assert (string? (label-name n)))
	   (cons `(foreign-label . ,(label-name n))
		 ac))

	  ((label? n)
	   (%IMM/label n ac))

	  (else
	   (%compiler-internal-error __who__ "invalid" n))))

  (define* (IMM8 {n immediate-int?} ac)
    ;;Prepend to  the accumulator AC  a fixnum representing the  byte N, which  is an
    ;;immediate 8-bit value.
    ;;
    (cons (byte n) ac))

  (define* (IMM32 n ac)
    (boot.case-word-size
     ((32)
      (IMM n ac))
     ((64)
      (cond ((imm32? n)
	     (%IMM/imm32 n ac))
	    ((label? n)
	     (%IMM/label n ac))
	    (else
	     (%compiler-internal-error __who__ "invalid" n))))))

  (define (%IMM/label ival ac)
    (let* ((LN  (label-name ival))
	   (key (if (local-label-gensym? LN)
		    ;;The label  name LN  is a gensym  representing a  local Assembly
		    ;;label in the code  being processed by CONVERT-INSTRUCTIONS.  It
		    ;;means that  somewhere in  the code being  compiled there  is an
		    ;;element:
		    ;;
		    ;;   (label ?name)
		    ;;
		    ;;this  happens, for  example, in  the implementation  of the  IF
		    ;;syntax.
		    'local-relative
		  ;;The  label name  LN is  a gensym  representing an  Assembly label
		  ;;outside the  code being  processed by  CONVERT-INSTRUCTIONS.  The
		  ;;relative  reference  to  a  non-local  label  is  implemented  as
		  ;;relative displacement  from the current instruction  pointer; the
		  ;;displacement is computed when processing the relocation vector.
		  ;;
		  ;;NOTE At  present it  seems this RELATIVE  reference to  labels is
		  ;;never used.  (Marco Maggi; Tue Aug 4, 2015)
		  ;;
		  ;;FIXME  On 64-bit  platforms we  should  reserve 64  bits for  the
		  ;;relative  displacement  and   appropriately  implement  the  jump
		  ;;instruction.  (Marco Maggi; Tue Aug 4, 2015)
		  'relative)))
      (cons (cons key LN) ac)))

  (define (%IMM/imm32 n ac)
    ;;Prepend  to the  accumulator AC  an immediate  integer value  least significant
    ;;bytes first.
    ;;
    ;;  (IMM #xDDCCBBAA ac)
    ;;  => `(#xAA #xBB #xCC #xDD . ,ac)
    ;;
    ;;SRA = shift right arithmetic.
    ;;
    (cons* (byte n)
	   (byte (sra n 8))
	   (byte (sra n 16))
	   (byte (sra n 24))
	   ac))

  (module (IMM*2)

    (define* (IMM*2 ival1 ival2 ac)
      (cond ((and (immediate-int? ival1)
		  (obj?           ival2))
	     (let ((d ival1)
		   (v (cadr ival2)))
	       (cons (reloc-word+ v d) ac)))

	    ((and (immediate-int? ival2)
		  (obj?           ival1))
	     (IMM*2 ival2 ival1 ac))

	    ((and (immediate-int? ival1)
		  (immediate-int? ival2))
	     (IMM (bitwise-and (+ ival1 ival2) WORDSIZE-BITMASK)
		  ac))

	    (else
	     (%compiler-internal-error __who__ "invalid" ival1 ival2))))

    (define-constant WORDSIZE-BITMASK
      ;;On 32-bit platforms: this is an exact integer of 32 bits set to 1.
      ;;
      ;;On 64-bit platforms: this is an exact integer of 64 bits set to 1.
      ;;
      (- (expt 2 (* wordsize 8)) 1))

    #| end of module: IMM*2 |# )

;;; --------------------------------------------------------------------

  (define* (byte x)
    ;;Expect X to be an expression evaluating to an exact integer; extract and return
    ;;the 8 least significant bits from the integer.
    ;;
    (if (or (fixnum? x)
	    (bignum? x))
	(bitwise-and x #xFF)
      (%compiler-internal-error __who__ "expected byte operand" x)))

  (define-syntax-rule (word immediate-scheme-obj)
    ;;Create an  entry representing an  immediate Scheme  object that must  be stored
    ;;directly in the data area of the code object.
    ;;
    (cons 'word immediate-scheme-obj))

  (define-syntax-rule (reloc-word non-immediate-scheme-obj)
    ;;Create an  entry representing a  reference to non-immediate Scheme  object that
    ;;must be stored in the relocation vector.
    ;;
    (cons 'reloc-word non-immediate-scheme-obj))

  (define-syntax-rule (reloc-word+ non-immediate-scheme-obj displacement)
    ;;Create an entry representing a reference to machine word in the memory block of
    ;;a non-immediate Scheme object that must be stored in the relocation vector.
    ;;
    ;;DISPLACEMENT is  a fixnum representing  the offset  in bytes of  the referenced
    ;;word in the memory block of the Scheme object:
    ;;
    ;;                word
    ;;   |------------++++-----------| Scheme object
    ;;   |............|
    ;;    displacement
    ;;
    (cons* 'reloc-word+ non-immediate-scheme-obj displacement))

  (define-entry-predicate obj?	obj)

  ;;Commented out because unused.  (Marco Maggi; Tue Nov 4, 2014)
  ;;
  ;;(define-entry-predicate obj+? obj+)

;;; --------------------------------------------------------------------
;;; label operands

  (define-entry-predicate label? label)
  (define-entry-predicate label-address? label-address)
  (define-entry-predicate foreign-label? foreign-label)

  (define-syntax-rule (label-name ?x)
    (cadr ?x))

  (define (label?/local obj)
    (and (label? obj)
	 (local-label-gensym? (label-name obj))))

;;; --------------------------------------------------------------------
;;; pushing bytes on the accumulator

  (define (CODE n ac)
    ;;N must be a fixnum or bignum.
    ;;
    (cons (byte n) ac))

  (define (CODE+r n greek-rho ac)
    ;;N must be a  fixnum or bignum.  greek-rho must be a symbol  representing a CPU register
    ;;name.
    ;;
    (cons (byte (fxlogor n (register-index greek-rho)))
	  ac))

  (define (ModRM mod greek-rho greek-rho/greek-mu ac)
    ;;GREEK-RHO must be  a symbol representing a  CPU register name.  greek-rho/greek-mu must  be a register
    ;;name or a memory reference.
    ;;
    #;(assert (fixnum?  mod))
    #;(assert (reg?     greek-rho))
    #;(assert (reg/mem? greek-rho/greek-mu))
    (cons (byte (fxlogor (register-index greek-rho/greek-mu)
			 (fxlogor (fxsll (register-index greek-rho) 3)
				  (fxsll mod 6))))
	  (if (and (not (fx= mod 3))
		   (eq? greek-rho/greek-mu '%esp))
	      (cons (byte #x24) ac)
	    ac)))

  (define* (RegReg greek-rho_1 greek-rho_2 greek-rho_3 ac)
    ;;GREEK-RHO_1, GREEK-RHO_2, GREEK-RHO_3 must be symbols representing CPU register names.
    ;;
    (cond ((eq? greek-rho_3 '%esp)
	   (%compiler-internal-error __who__ "invalid src %esp"))
	  ((eq? greek-rho_1 '%ebp)
	   (%compiler-internal-error __who__ "invalid src %ebp"))
	  (else
	   (cons* (byte (fxlogor 4                    (fxsll (register-index greek-rho_1) 3)))
		  (byte (fxlogor (register-index greek-rho_2) (fxsll (register-index greek-rho_3) 3)))
		  ac))))

;;; --------------------------------------------------------------------

  (define* (REX.R bits ac)
    (boot.case-word-size
     ((32)
      (%compiler-internal-error __who__ "invalid use in 32-bit mode"))
     ((64)
      (cons (fxlogor #b01001000 bits) ac))))

  (define (REX+r r ac)
    (boot.case-word-size
     ((32)
      ac)
     ((64)
      (cond ((reg-requires-REX.R-prefix? r)
	     (REX.R #b001 ac))
	    (else
	     (REX.R #b000 ac))))))

  (define* (REX+RM r rm ac)
    ;;The argument  R must be a  register name.  The  argument RM must be  a register
    ;;name or a DISP sexp.
    ;;
    ;;This function is used for operands R and RM that have been already processed by
    ;;RM; so the result of:
    ;;
    ;;   (RM r rm ac)
    ;;
    ;;is already in  AC.  On 32-bit platforms:  nothing needs to be done,  so we just
    ;;return AC.  On  64-bit platforms: we need  to push on AC a  prefix generated by
    ;;REX.R.
    ;;
    #;(assert (reg? r))
    #;(assert (reg/mem? rm))
    (boot.case-word-size
     ((32)
      ac)
     ((64)
      (case-mem/reg rm
	((mem)
	 (if (reg-requires-REX.R-prefix? r)
	     (cond ((and (imm?   rm.base)
			 (reg32? rm.offset))
		    (if (reg-requires-REX.R-prefix? rm.offset)
			(REX.R #b101 ac)
		      (REX.R #b100 ac)))

		   ((and (imm?   rm.offset)
			 (reg32? rm.base))
		    (if (reg-requires-REX.R-prefix? rm.base)
			(REX.R #b101 ac)
		      (REX.R #b100 ac)))

		   ((and (reg32? rm.base)
			 (reg32? rm.offset))
		    (cond ((reg-requires-REX.R-prefix? rm.base)
			   (if (reg-requires-REX.R-prefix? rm.offset)
			       (REX.R #b111 ac)
			     (REX.R #b110 ac)))
			  ((reg-requires-REX.R-prefix? rm.offset)
			   (REX.R #b101 ac))
			  (else
			   (REX.R #b100 ac))))

		   ((and (imm? rm.base)
			 (imm? rm.offset))
		    (%compiler-internal-error __who__ "not here 4"))

		   (else
		    (%compiler-internal-error __who__ "unhandled" rm.base rm.offset)))
	   (cond ((and (imm?   rm.base)
		       (reg32? rm.offset))
		  (if (reg-requires-REX.R-prefix? rm.offset)
		      (REX.R #b001 ac)
		    (REX.R 0 ac)))

		 ((and (imm?   rm.offset)
		       (reg32? rm.base))
		  (if (reg-requires-REX.R-prefix? rm.base)
		      (REX.R #b001 ac)
		    (REX.R 0 ac)))

		 ((and (reg32? rm.base)
		       (reg32? rm.offset))
		  (cond ((reg-requires-REX.R-prefix? rm.base)
			 (if (reg-requires-REX.R-prefix? rm.offset)
			     (%compiler-internal-error __who__ "unhandled x1" rm.base rm.offset)
			   (REX.R #b010 ac)))
			((reg-requires-REX.R-prefix? rm.offset)
			 (%compiler-internal-error __who__ "unhandled x3" rm.base rm.offset))
			(else
			 (REX.R 0 ac))))

		 ((and (imm? rm.base)
		       (imm? rm.offset))
		  (REX.R 0 ac))

		 (else
		  (%compiler-internal-error __who__ "unhandled" rm.base rm.offset)))))
	((reg)
	 (let* ((bits 0)
		(bits (if (reg-requires-REX.R-prefix? r)
			  (fxlogor bits #b100)
			bits))
		(bits (if (reg-requires-REX.R-prefix? rm)
			  (fxlogor bits #b001)
			bits)))
	   (REX.R bits ac)))))))

  (define (C c ac)
    (boot.case-word-size
     ((32)
      (CODE c ac))
     ((64)
      (REX.R 0 (CODE c ac)))))

  (define (CR c r ac)
    (REX+r r (CODE+r c r ac)))

  (define (CR* c r rm ac)
    (REX+RM r rm (CODE c (RM r rm ac))))

  (define (CR*/no-rex c r rm ac)
    ;;This is like CR*, but without the REX+RM prefix.
    ;;
    (CODE c (RM r rm ac)))

  (define (CCR* c0 c1 r rm ac)
    (REX+RM r rm (CODE c0 (CODE c1 (RM r rm ac)))))

  (define (CCR c0 c1 r ac)
    (REX+r r (CODE c0 (CODE+r c1 r ac))))

  (define (CCCR* c0 c1 c2 r rm ac)
    (REX+RM r rm (CODE c0 (CODE c1 (CODE c2 (RM r rm ac))))))

  (define (CCI32 c0 c1 i32 ac)
    (CODE c0 (CODE c1 (IMM32 i32 ac))))

  (define* (RM /d dst ac)
    ;;The argument "/d" must  be a register.  The argument DST must  be a register or
    ;;memory reference.
    ;;
    #;(assert (reg? /d))
    #;(assert (reg/mem? dst))
    (case-mem/reg dst
      ((mem)
       (cond ((and (imm8?  dst.base)
		   (reg32? dst.offset))
	      (ModRM 1 /d dst.offset (IMM8 dst.base ac)))
	     ((and (imm?   dst.base)
		   (reg32? dst.offset))
	      (ModRM 2 /d dst.offset (IMM32 dst.base ac)))
	     ((and (imm8?  dst.offset)
		   (reg32? dst.base))
	      (ModRM 1 /d dst.base (IMM8 dst.offset ac)))
	     ((and (imm?   dst.offset)
		   (reg32? dst.base))
	      (ModRM 2 /d dst.base (IMM32 dst.offset ac)))
	     ((and (reg32? dst.base)
		   (reg32? dst.offset))
	      (RegReg /d dst.base dst.offset ac))
	     ((and (imm? dst.base)
		   (imm? dst.offset))
	      (ModRM 0 /d '/5 (IMM*2 dst.base dst.offset ac)))
	     (else
	      (%compiler-internal-error __who__ "invalid components in DISP operand" dst))))
      ((reg)
       (ModRM 3 /d dst ac))))

  (define* (jmp-pc-relative code0 code1 dst ac)
    (boot.case-word-size
     ((32)
      (%compiler-internal-error __who__ "no pc-relative jumps in 32-bit mode"))
     ((64)
      (let ((G (gensym "L_jump")))
	(CODE code0
	      (CODE code1 (cons* `(local-relative . ,G)
				 `(bottom-code (label . ,G)
					       (label-address . ,(label-name dst)))
				 ac)))))))

;;; --------------------------------------------------------------------

  (define-syntax (case-mem/reg stx)
    (syntax-case stx (mem reg else)
      ((_ ?operand
	  ((mem) ?mem-body0 ?mem-body ...)
	  ((reg) ?reg-body0 ?reg-body ...)
	  (else  ?else-body0 ?else-body ...))
       (identifier? #'?operand)
       (with-syntax
	   ((BASE    (identifier-suffix #'?operand ".base"))
	    (OFFSET  (identifier-suffix #'?operand ".offset")))
	 #'(cond ((disp? ?operand)
		  (let ((BASE   (cadr  ?operand))
			(OFFSET (caddr ?operand)))
		    ?mem-body0 ?mem-body ...))
		 ((reg?  ?operand)
		  ?reg-body0 ?reg-body ...)
		 (else
		  ?else-body0 ?else-body ...))))
      ((?key ?operand
	     ((mem) ?mem-body0 ?mem-body ...)
	     ((reg) ?reg-body0 ?reg-body ...))
       (identifier? #'?operand)
       #'(?key ?operand
	       ((mem) ?mem-body0 ?mem-body ...)
	       ((reg) ?reg-body0 ?reg-body ...)
	       (else
		(%compiler-internal-error __who__ "invalid operand, expected register or DISP sexp" ?operand))))
      ))

;;; --------------------------------------------------------------------

  ;;Commented out because unused.  (Marco Maggi; Wed Nov  5, 2014)
  ;;
  ;; (define* (CODErri c d s i ac)
  ;;   ;;Generate code for register+register+immediate operations?
  ;;   ;;
  ;;   (cond ((imm8? i)
  ;;          (CODE c (ModRM 1 d s (IMM8 i ac))))
  ;;         ((imm? i)
  ;;          (CODE c (ModRM 2 d s (IMM i ac))))
  ;;         (else
  ;;          (%compiler-internal-error __who__ "invalid i" i))))

  ;;Commented out because unused.  (Marco Maggi; Wed Nov  5, 2014)
  ;;
  ;; (define (CODErr c r1 r2 ac)
  ;;   ;;Generate code for register+register operations?
  ;;   ;;
  ;;   (CODE c (ModRM 3 r1 r2 ac)))

  #| end of module: ASSEMBLY-INSTRUCTION-OPERANDS-HELPERS |# )


(module ()
  ;;Notice that this  module exports nothing; this  is because its purpose  is to put
  ;;properties in the  property lists of the  symbols (ret, cltd, movl,  ...)  of the
  ;;assembly operations:
  ;;
  ;;   ret
  ;;   cltd
  ;;   movl src dst
  ;;   mov32 src dst
  ;;   movb src dst
  ;;   addl src dst
  ;;   subl src dst
  ;;   sall src dst
  ;;   shrl src dst
  ;;   sarl src dst
  ;;   andl src dst
  ;;   orl src dst
  ;;   xorl src dst
  ;;   leal src dst
  ;;   cmpl src dst
  ;;   imull src dst
  ;;   idivl dst
  ;;   pushl dst
  ;;   popl dst
  ;;   notl dst
  ;;   bswap dst
  ;;   negl dst
  ;;   jmp dst
  ;;   call dst
  ;;   movsd src dst
  ;;   cvtsi2sd src dst
  ;;   cvtsd2ss src dst
  ;;   cvtss2sd src dst
  ;;   movss src dst
  ;;   addsd src dst
  ;;   subsd src dst
  ;;   mulsd src dst
  ;;   divsd src dst
  ;;   ucomisd src dst
  ;;   ja dst
  ;;   jae dst
  ;;   jb dst
  ;;   jbe dst
  ;;   jg dst
  ;;   jge dst
  ;;   jl dst
  ;;   jle dst
  ;;   je dst
  ;;   jna dst
  ;;   jnae dst
  ;;   jnb dst
  ;;   jnbe dst
  ;;   jng dst
  ;;   jnge dst
  ;;   jnl dst
  ;;   jnle dst
  ;;   jne dst
  ;;   jo dst
  ;;   jp dst
  ;;   jnp dst
  ;;
  ;;and additionally to  the symbols (byte, byte-vector, int,  ...)  representing the
  ;;following datums:
  ;;
  ;;   byte x
  ;;   byte-vector x
  ;;   int a
  ;;   label L
  ;;   label-address L
  ;;   code-object-self-machine-word-index
  ;;   nop ac
  ;;
  (import ASSEMBLY-INSTRUCTION-OPERANDS-HELPERS)

  (define-syntax add-instructions
    (syntax-rules ()
      ((add-instructions ?asm-sexp ?accumulator
	 ((?name ?arg ...) ?body0 ?body ...)
	 ...)
       (begin
	 (add-single-instruction (?name ?asm-sexp ?accumulator ?arg ...)
	   ?body0 ?body ...)
	 ...))))

  (define-syntax add-single-instruction
    (syntax-rules ()
      ;;?NAME is a symbol representing  the Assembly instruction name (examples: ret,
      ;;cltd, movl, ...).
      ;;
      ;;?ASM-SEXP is an identifier used as first formal argument in the instruction's
      ;;conversion function.  It is bound to the symbolic expression representing the
      ;;full Assembly instruction:
      ;;
      ;;   (?assembly-instruction-mnemonic ?operand ...)
      ;;
      ;;?AC is  an identifier  user as  second formal  argument in  the instruction's
      ;;conversion function.  It is bound to the accumulator list.
      ;;
      ;;The ?ARG  formals are  additional arguments  to the  instruction's conversion
      ;;function.
      ;;
      ((_ (?name ?asm-sexp ?ac ?arg ...)
	  ?body0 ?body ...)
       (putprop '?name (assembler-property-key)
		(cons (length '(?arg ...))
		      ;;This LAMBDA builds the instruction's conversion function.
		      (lambda (?asm-sexp ?ac ?arg ...)
			(fluid-let-syntax
			    ((__who__ (identifier-syntax (quote ?name))))
			  ?body0 ?body ...)))))))

  (define-syntax (match-operands stx)
    (syntax-case stx (else)
      ((_ (?arg0 ?arg ...)
	  ((?pred0 ?pred ...) ?body0 ?body ...)
	  ...
	  (else ?else0 ?else ...))
       #'(cond ((and (?pred0 ?arg0)
		     (?pred  ?arg)
		     ...)
		?body0 ?body ...)
	       ...
	       (else
		?else0 ?else ...)))
      ((?key (?arg0 ?arg ...)
	     ((?pred0 ?pred ...) ?body0 ?body ...)
	     ...)
       (with-syntax
	   ((ASM-SEXP (datum->syntax #'?key 'asm-sexp)))
	 #'(?key (?arg0 ?arg ...)
		 ((?pred0 ?pred ...) ?body0 ?body ...)
		 ...
		 (else
		  (%compiler-internal-error __who__ "invalid instruction operands"
		    ASM-SEXP ?arg0 ?arg ...)))))
      ))

;;; --------------------------------------------------------------------

  ;;Store a function  in the properties list of symbols  being the names
  ;;of assembly instructions.
  ;;
  (add-instructions asm-sexp ac
    ((ret)			(CODE #xC3 ac))

    ((cltd)			(C #x99 ac))

    ((movl src dst)
     (match-operands (src dst)
       ((imm? reg?)		(CR #xB8 dst (IMM src ac)))
       ((imm? disp?)		(CR* #xC7 '/0 dst (IMM32 src ac)))
       ((reg? reg?)		(CR* #x89 src dst ac))
       ((reg? disp?)		(CR* #x89 src dst ac))
       ((disp? reg?)		(CR* #x8B dst src ac))))

    ((mov32 src dst)
     ;;FIXME (Abdulaziz Ghuloum)
     ;;
     ;;FIXME Fixme what?  (Marco Maggi; Thu Nov  6, 2014)
     (match-operands (src dst)
       ((imm? reg?)		(%compiler-internal-error __who__ "invalid operands" asm-sexp)) ;;;(CR  #xB8 dst (IMM32 src ac))
       ((imm? disp?)		(CR*/no-rex #xC7 '/0 dst (IMM32 src ac)))
       ((reg? reg?)		(%compiler-internal-error __who__ "invalid operands" asm-sexp)) ;;;(CR* #x89 src dst ac)
       ((reg? disp?)		(CR*/no-rex #x89 src dst ac))
       ((disp? reg?)		(boot.case-word-size
				 ((32)	(CR*        #x8B dst src ac))
				 ((64)	(CR*/no-rex #x8B dst src ac))))))

    ((movb src dst)
     (match-operands (src dst)
       ((imm8? disp?)		(CR* #xC6 '/0 dst (IMM8 src ac)))
       ((reg8? disp?)		(CR* #x88 src dst ac))
       ((disp? reg8?)		(CR* #x8A dst src ac))))

    ((addl src dst)
     (match-operands (src dst)
       ((imm8?  reg?)		(CR*  #x83 '/0 dst (IMM8  src ac)))
       ((imm32? reg-eax?)	(C    #x05         (IMM32 src ac)))
       ((imm32? reg?)		(CR*  #x81 '/0 dst (IMM32 src ac)))
       ((reg?   reg?)		(CR*  #x01 src dst ac))
       ((disp?  reg?)		(CR*  #x03 dst src ac))
       ((imm32? disp?)		(CR*  #x81 '/0 dst (IMM32 src ac)))
       ((reg?   disp?)		(CR*  #x01 src dst ac))))

    ((subl src dst)
     (match-operands (src dst)
       ((imm8?  reg?)		(CR*  #x83 '/5 dst (IMM8  src ac)))
       ((imm32? reg-eax?)	(C    #x2D         (IMM32 src ac)))
       ((imm32? reg?)		(CR*  #x81 '/5 dst (IMM32 src ac)))
       ((reg?   reg?)		(CR*  #x29 src dst ac))
       ((disp?  reg?)		(CR*  #x2B dst src ac))
       ((imm32? disp?)		(CR*  #x81 '/5 dst (IMM32 src ac)))
       ((reg?   disp?)		(CR*  #x29 src dst ac))))

    ((sall src dst)
     (match-operands (src dst)
       ((imm-one? reg?)		(CR* #xD1 '/4 dst ac))
       ((imm8?    reg?)		(CR* #xC1 '/4 dst (IMM8 src ac)))
       ((imm8?    disp?)	(CR* #xC1 '/4 dst (IMM8 src ac)))
       ((reg-cl?  reg?)		(CR* #xD3 '/4 dst ac))
       ((reg-cl?  disp?)	(CR* #xD3 '/4 dst ac))))

    ((shrl src dst)
     (match-operands (src dst)
       ((imm-one? reg?)		(CR* #xD1 '/5 dst ac))
       ((imm8?    reg?)		(CR* #xC1 '/5 dst (IMM8 src ac)))
       ((reg-cl?  reg?)		(CR* #xD3 '/5 dst ac))
       ((imm8?    disp?)	(CR* #xC1 '/5 dst (IMM8 src ac)))
       ((reg-cl?  disp?)	(CR* #xD3 '/5 dst ac))))

    ((sarl src dst)
     (match-operands (src dst)
       ((imm-one? reg?)		(CR* #xD1 '/7 dst ac))
       ((imm8?    reg?)		(CR* #xC1 '/7 dst (IMM8 src ac)))
       ((imm8?    disp?)	(CR* #xC1 '/7 dst (IMM8 src ac)))
       ((reg-cl?  reg?)		(CR* #xD3 '/7 dst ac))
       ((reg-cl?  disp?)	(CR* #xD3 '/7 dst ac))))

    ((andl src dst)
     (match-operands (src dst)
       ((imm8?  reg?)		(CR*  #x83 '/4 dst (IMM8  src ac)))
       ((imm32? disp?)		(CR*  #x81 '/4 dst (IMM32 src ac)))
       ((imm32? reg-eax?)	(C    #x25         (IMM32 src ac)))
       ((imm32? reg?)		(CR*  #x81 '/4 dst (IMM32 src ac)))
       ((reg?   reg?)		(CR*  #x21 src dst ac))
       ((reg?   disp?)		(CR*  #x21 src dst ac))
       ((disp?  reg?)		(CR*  #x23 dst src ac))))

    ((orl src dst)
     (match-operands (src dst)
       ((imm32? disp?)		(CR*  #x81 '/1 dst (IMM32 src ac)))
       ((reg?   disp?)		(CR*  #x09 src dst ac))
       ((imm8?  reg?)		(CR*  #x83 '/1 dst (IMM8  src ac)))
       ((imm32? reg-eax?)	(C    #x0D         (IMM32 src ac)))
       ((imm32? reg?)		(CR*  #x81 '/1 dst (IMM32 src ac)))
       ((reg?   reg?)		(CR*  #x09 src dst ac))
       ((disp?  reg?)		(CR*  #x0B dst src ac))))

    ((xorl src dst)
     (match-operands (src dst)
       ((imm8?  reg?)		(CR*  #x83 '/6 dst (IMM8  src ac)))
       ((imm8?  disp?)		(CR*  #x83 '/6 dst (IMM8  src ac)))
       ((imm32? reg-eax?)	(C    #x35         (IMM32 src ac)))
       ((reg?   reg?)		(CR*  #x31 src dst ac))
       ((disp?  reg?)		(CR*  #x33 dst src ac))
       ((reg?   disp?)		(CR*  #x31 src dst ac))))

    ((leal src dst)
     (match-operands (src dst)
       ((disp?  reg?)		(CR* #x8D dst src ac))))

    ((cmpl src dst)
     (match-operands (src dst)
       ((imm8?  reg?)		(CR*  #x83 '/7 dst (IMM8  src ac)))
       ((imm32? reg-eax?)	(C    #x3D         (IMM32 src ac)))
       ((imm32? reg?)		(CR*  #x81 '/7 dst (IMM32 src ac)))
       ((reg?   reg?)		(CR*  #x39 src dst ac))
       ((disp?  reg?)		(CR*  #x3B dst src ac))
       ((imm8?  disp?)		(CR*  #x83 '/7 dst (IMM8 src ac)))
       ((imm32? disp?)		(CR*  #x81 '/7 dst (IMM32 src ac)))))

    ((imull src dst)
     (match-operands (src dst)
       ((imm8?  reg?)		(CR*  #x6B dst  dst (IMM8  src ac)))
       ((imm32? reg?)		(CR*  #x69 dst  dst (IMM32 src ac)))
       ((reg?   reg?)		(CCR* #x0F #xAF dst src ac))
       ((disp?  reg?)		(CCR* #x0F #xAF dst src ac))))

    ((idivl dst)
     (match-operands (dst)
       ((reg?)			(CR* #xF7 '/7 dst ac))
       ((disp?)			(CR* #xF7 '/7 dst ac))))

    ((pushl dst)
     (match-operands (dst)
       ((imm8?)			(CODE #x6A (IMM8  dst ac)))
       ((imm32?)		(CODE #x68 (IMM32 dst ac)))
       ((reg?)			(CR   #x50     dst ac))
       ((disp?)			(CR*  #xFF '/6 dst ac))))

    ((popl dst)
     (match-operands (dst)
       ((reg?)			(CR  #x58     dst ac))
       ((disp?)			(CR* #x8F '/0 dst ac))))

    ((notl dst)
     (match-operands (dst)
       ((reg?)			(CR* #xF7 '/2 dst ac))
       ((disp?)			(CR* #xF7 '/7 dst ac))))

    ((bswap dst)
     (match-operands (dst)
       ((reg?)			(CCR #x0F #xC8 dst ac))))

    ((negl dst)
     (match-operands (dst)
       ((reg?)			(CR* #xF7 '/3 dst ac))))

    ((jmp dst)
     (match-operands (dst)
       ;;This branch is used when ASM-SEXP has the format:
       ;;
       ;;   (jmp (label ?name))
       ;;
       ;;and ?NAME is a gensym representing a  local Assembly label in the code being
       ;;processed  by CONVERT-INSTRUCTIONS.   It means  that somewhere  in the  code
       ;;being compiled there is an element:
       ;;
       ;;   (label ?name)
       ;;
       ;;this happens, for example, in the implementation of the IF syntax.
       ((label?/local)		(CODE #xE9 (cons `(local-relative . ,(label-name dst)) ac)))
       ((imm?)			(boot.case-word-size
				 ((32)		(CODE #xE9 (IMM32 dst ac)))
				 ((64)		(jmp-pc-relative #xFF #x25 dst ac))))
       ((disp?)			(CR*  #xFF '/4 dst ac))))

    ((call dst)
     (match-operands (dst)
       ((label?/local)		(CODE #xE8 (cons `(local-relative . ,(label-name dst)) ac)))
       ((imm?)			(boot.case-word-size
				 ((32)		(CODE #xE8 (IMM32 dst ac)))
				 ((64)		(jmp-pc-relative #xFF #x15 dst ac))))
       ((disp?)			(CR* #xFF '/2 dst ac))
       ((reg?)			(CR* #xFF '/2 dst ac))))

    ((movsd src dst)
     (match-operands (src dst)
       ((disp?   xmmreg?)	(CCCR* #xF2 #x0F #x10 dst src ac))
       ((xmmreg? disp?)		(CCCR* #xF2 #x0F #x11 src dst ac))))

    ((cvtsi2sd src dst)
     (match-operands (src dst)
       ((reg?  xmmreg?)		(CCCR* #xF2 #x0F #x2A src dst ac))
       ((disp? xmmreg?)		(CCCR* #xF2 #x0F #x2A dst src ac))))

    ((cvtsd2ss src dst)
     (match-operands (src dst)
       ((xmmreg? xmmreg?)	(CCCR* #xF2 #x0F #x5A src dst ac))))

    ((cvtss2sd src dst)
     (match-operands (src dst)
       ((xmmreg? xmmreg?)	(CCCR* #xF3 #x0F #x5A src dst ac))))

    ((movss src dst)
     (match-operands (src dst)
       ((disp?   xmmreg?)	(CCCR* #xF3 #x0F #x10 dst src ac))
       ((xmmreg? disp?)		(CCCR* #xF3 #x0F #x11 src dst ac))))

    ((addsd src dst)
     (match-operands (src dst)
       ((disp? xmmreg?)		(CCCR* #xF2 #x0F #x58 dst src ac))))

    ((subsd src dst)
     (match-operands (src dst)
       ((disp? xmmreg?)		(CCCR* #xF2 #x0F #x5C dst src ac))))

    ((mulsd src dst)
     (match-operands (src dst)
       ((disp? xmmreg?)		(CCCR* #xF2 #x0F #x59 dst src ac))))

    ((divsd src dst)
     (match-operands (src dst)
       ((disp? xmmreg?)		(CCCR* #xF2 #x0F #x5E dst src ac))))

    ((ucomisd src dst)
     (match-operands (src dst)
       ((disp? xmmreg?)		(CCCR* #x66 #x0F #x2E dst src ac))))

    ((ja   dst)			(CCI32 #x0F #x87 dst ac))
    ((jae  dst)			(CCI32 #x0F #x83 dst ac))
    ((jb   dst)			(CCI32 #x0F #x82 dst ac))
    ((jbe  dst)			(CCI32 #x0F #x86 dst ac))
    ((jg   dst)			(CCI32 #x0F #x8F dst ac))
    ((jge  dst)			(CCI32 #x0F #x8D dst ac))
    ((jl   dst)			(CCI32 #x0F #x8C dst ac))
    ((jle  dst)			(CCI32 #x0F #x8E dst ac))
    ((je   dst)			(CCI32 #x0F #x84 dst ac))
    ((jna  dst)			(CCI32 #x0F #x86 dst ac))
    ((jnae dst)			(CCI32 #x0F #x82 dst ac))
    ((jnb  dst)			(CCI32 #x0F #x83 dst ac))
    ((jnbe dst)			(CCI32 #x0F #x87 dst ac))
    ((jng  dst)			(CCI32 #x0F #x8E dst ac))
    ((jnge dst)			(CCI32 #x0F #x8C dst ac))
    ((jnl  dst)			(CCI32 #x0F #x8D dst ac))
    ((jnle dst)			(CCI32 #x0F #x8F dst ac))
    ((jne  dst)			(CCI32 #x0F #x85 dst ac))
    ((jo   dst)			(CCI32 #x0F #x80 dst ac))
    ((jp   dst)			(CCI32 #x0F #x8A dst ac))
    ((jnp  dst)			(CCI32 #x0F #x8B dst ac))

;;; --------------------------------------------------------------------

    ((byte x)
     (match-operands (x)
       ((byte?)			(cons (byte x) ac))))

    ((int a)			(IMM a ac))

    ((label L)
     (match-operands (L)
       ((symbol?)		(cons (cons 'label         L) ac))))

    ((label-address L)
     (match-operands (L)
       ((symbol?)		(cons (cons 'label-address L) ac))))

    ((code-object-self-machine-word-index)
     (cons '(code-object-self-machine-word-index) ac))

    ((byte-vector x)		(append (map byte (vector->list x)) ac))

    ((nop)			ac))

  #| end of module |# )


;;;; done

#| end of library |# )

;;; end of file
;; Local Variables:
;; coding: utf-8-unix
;; eval: (put 'add-instructions		'scheme-indent-function 2)
;; eval: (put 'add-single-instruction	'scheme-indent-function 1)
;; eval: (put '%with-checked-args	'scheme-indent-function 1)
;; eval: (put 'match-operands		'scheme-indent-function 1)
;; eval: (put '%compiler-internal-error	'scheme-indent-function 1)
;; eval: (put 'case-mem/reg		'scheme-indent-function 1)
;; End:
