@node iklib
@chapter Language extensions


@cindex Library @library{vicare}
@cindex @library{vicare}, library
@cindex Library @library{vicare language-extensions}
@cindex @library{vicare language-extensions}, library


In addition to the libraries listed in the @rnrs{6} standard,
@value{PRJNAME} offers more libraries which provide additional features;
here is a list of some of them:

@table @asis
@item @library{vicare}
It is a composite library, it exports a superset of all the supported
bindings of @rnrs{6}.

@item @library{vicare language-extensions}
It exports all the bindings exported by @library{vicare} that are
@strong{not} exported by @library{rnrs (6)}.

@item @library{vicare platform constants}
Exports one syntax identifier binding for each platform constant that
makes sense to access from Scheme.

@item @library{vicare platform utilities}
Defines helper functions to deal with platform specific issues;
@libsref{platform, Hosting platform utilities} for details.

@item @library{vicare platform features}
@cindex Library @library{vicare platform features}
@cindex @library{vicare platform features}, library
Exports an identifier syntax for every @code{HAVE_} symbol defined by
the configuration script @command{configure}; such syntaxes expand to a
boolean value: @true{} if the feature is available, @false{} otherwise.
@end table

@menu
* iklib libraries::             Extended @syntax{library} syntax.
* iklib programs::              Extended program syntax.
* iklib runtime::               Run-time configuration.
* iklib progname::              Finding the @value{EXECUTABLE} executable.
* iklib config::                Configuration options inspection.
* iklib cmdline::               Command line arguments.
* iklib env-inquiry::           Environment inquiry.
* iklib syntaxes::              Additional syntaxes.
* iklib unwind-protect::        The unwind--protection mechanism.
* iklib compensations::         Compensation stacks.
* iklib coroutines::            Running coroutines.
* iklib conditions::            Additional condition types.
* iklib reader::                Extensions to the reader.
* iklib expander::              Interface to the expander.
* iklib shared::                Shared structures graph notation.
* iklib environment::           Environments.
* iklib eval::                  Extended code evaluation.
* iklib cafe::                  Cafe.
* iklib procedures::            Procedures.
* iklib structs::               @value{PRJNAME}'s structs.
* iklib records::               Extensions to @rnrs{6} records.
* iklib promises::              Delay, force and promises.
* iklib booleans::              Additional boolean functions.
* iklib chars::                 Additional character functions.
* iklib keywords::              Keyword objects.
* iklib ipairs::                Immutable pairs.
* iklib lists::                 Additional list functions.
* iklib bytevectors::           Additional bytevector functions.
* iklib strings::               Additional string functions.
* iklib vectors::               Additional vector functions.
* iklib symbols::               Additional symbol functions.
* iklib fixnums::               Additional functions on fixnums.
* iklib flonums::               Additional functions on flonums.
* iklib numerics::              Additional functions on numbers.
* iklib enumerations::          Additional functions on enumerations.
* iklib hashtables::            Additional functions on hash tables.
* iklib load::                  Loading source files.
* iklib modules::               Local modules.
* iklib parameters::            Parameters.
* iklib gensym::                Gensyms.
* iklib printing::              Printing.
* iklib tracing::               Tracing for debugging.
* iklib timing::                Timing.
* iklib gc::                    Interfacing with garbage collection.
* iklib guardians::             Guardians and garbage collection.
* iklib engines::               Engines.
* iklib io::                    Input/output library.
* iklib pointers::              Handling pointer objects.
* iklib memory::                Memory management.
* iklib cstrings::              Raw C strings.
* iklib errno::                 Interface to @code{errno}.
* iklib time::                  Basic time and date functions.
* iklib readline::              Readline interface.
* iklib debug::                 Debugging utilities.
* iklib misc::                  Miscellaneous functions.
@end menu

@c page
@node iklib libraries
@section Extended @syntax{library} syntax


@menu
* iklib libraries options::     Library-specific options.
* iklib libraries foreign::     Loading host's foreign libraries.
@end menu

@c page
@node iklib libraries options
@subsection Library--specific options


@cindex @clause{options}, library clause
@cindex Library clause @clause{options}


@value{PRJNAME} extends the format of @syntax{library} forms by allowing
an optional @clause{options} clause:

@example
(library @meta{library-name}
  (options @meta{option} ...)
  (export  @meta{export-spec} ...)
  (import  @meta{import-spec} ...)
  . @meta{library-body})
@end example

@noindent
where each @meta{option} is a symbolic expression.  There can be a
single @clause{options} clause, before the @clause{export} one.


@defvr {Library Option} typed-language
Turn on the tagged language extensions (@pxref{types, The typed
language}).
@end defvr


@defvr {Library Option} strict-r6rs
Turn on strict support for @rnrs{6} language.
@end defvr


@c page
@node iklib libraries foreign
@subsection Loading host's foreign libraries


@cindex @clause{foreign-library}, library clause
@cindex Library clause @clause{foreign-library}


@value{PRJNAME} extends the format of @syntax{library} forms by allowing
an optional @clause{foreign-library} clause:

@example
(library @meta{library-name}
  (foreign-library @meta{shared-object-id})
  (export  @meta{export-spec} ...)
  (import  @meta{import-spec} ...)
  . @meta{library-body})
@end example

@noindent
where each @meta{shared-object-id} is a Scheme string object.  There can
be any number of @clause{foreign-library} clauses, before the
@clause{export} one.

The clause @clause{foreign-library} allows us to associate a host's
shared object to the Scheme library, so that, whenever the library is
expanded from source code or loaded from a @fasl{} file: the shared
object is dynamically loaded with a call to the operating system's
function @cfunc{dlopen}.  @ref{foreign} for details.

@c page
@node iklib programs
@section Extended program syntax


@menu
* iklib programs form::         Top-level program form.
* iklib programs options::      Program-specific options.
* iklib programs foreign::      Loading host's foreign libraries.
@end menu

@c page
@node iklib programs form
@subsection Top--level program form


@cindex @clause{program} top--level program form
@cindex top--level program form @clause{program}


The @rnrs{6} document specifies a compliant top--level program as:

@quotation
@dots{} a delimited piece of text, typically a file, that has the
following form:

@example
@meta{import-form} @meta{top-level-body}
@end example
@end quotation

@noindent
so it only specifies that it is ``delimited''; it means:

@itemize
@item
Any form can come before @meta{import-form}.

@item
Any form can come after @meta{top-level-body}.

@item
The delimited sequence can be wrapped into an implementation--defined
enclosing form.
@end itemize

@value{PRJNAME} gathers this freedom to accept two formats of top--level
programs:

@enumerate
@item
The standalone delimited sequence:

@lisp
(import @meta{import-spec} ...) @meta{body} ...
@end lisp

@item
A @syntax{program} form with the following syntax:

@lisp
(program @meta{program-name}
  @meta{config-form} ...
  (import @meta{import-spec} ...)
  . @meta{program-body})
@end lisp
@end enumerate

@noindent
where @meta{program-name} is meant to be a descriptive list of symbols
and the @meta{config-form} clauses allow additional configuration and
behaviour specification.

@c page
@node iklib programs options
@subsection Program-specific options


@cindex @clause{options}, program clause
@cindex Program clause @clause{options}


@value{PRJNAME} extends the format of top--level programs by allowing an
optional @clause{options} clause:

@lisp
(program @meta{program-name}
  (options @meta{option} ...)
  (import  @meta{import-spec} ...)
  . @meta{program-body})
@end lisp

@noindent
where each @meta{option} is a symbolic expression.  There can be only
one @clause{options} clause, before the @clause{import} one.

The following options are supported.


@defvr {Program Option} typed-language
Turn on the tagged language extensions (@pxref{types, The typed
language}).
@end defvr


@defvr {Program Option} strict-r6rs
Turn on strict support for @rnrs{6} language.
@end defvr

@c page
@node iklib programs foreign
@subsection Loading host's foreign libraries


@cindex @clause{foreign-library}, program clause
@cindex Program clause @clause{foreign-library}


@value{PRJNAME} extends the format of top--level programs by allowing an
optional @clause{foreign-library} clause:

@lisp
(program @meta{program-name}
  (foreign-library @meta{shared-object-id})
  (import  @meta{import-spec} ...)
  . @meta{program-body})
@end lisp

@noindent
where each @meta{shared-object-id} is a Scheme string object.  There can
be any number of @clause{foreign-library} clauses, before the
@clause{import} one.

The clause @clause{foreign-library} allows us to associate a host's
shared object to the Scheme program, so that, whenever the program is
expanded from source code or loaded from a @fasl{} file: the shared
object is dynamically loaded with a call to the operating system's
function @cfunc{dlopen}.  @ref{foreign} for details.

@c page
@node iklib runtime
@section Run-time configuration


@cindex @library{vicare system $runtime}, library
@cindex Library @library{vicare system $runtime}


The following syntactic bindings are exported by the library
@library{vicare system $runtime}.


@defun scheme-heap-nursery-size
@defunx scheme-heap-nursery-size @var{num-of-bytes}
Getter and setter for the size of the Scheme heap nursery's hot block
memory segment.  When called without arguments: return the current size.
When called with one argument: set a new size.

The exact integer @var{num-of-bytes} must fit into a platform's
@code{unsigned long} value, it must be positive and greater than
@math{3} @value{PRJNAME}'s page sizes, @math{4096 * 3 = 12288}.  The
given @var{num-of-bytes} value is normalised by rounding it to the least
exact multiple of @math{4096} greater than @var{num-of-bytes}.

The Scheme heap nursery's hot block memory segment is allocated at
process start--up, before loading the boot image.  While loading the
boot image: the hot block may be reallocated.  These first allocation
and reallocations cannot be configured with this function, we have to
use a command line argument (@pxref{using invoking,
scheme-heap-nursery-size}).

After boot image loading, if the Scheme heap nursery's hot block memory
segment is reallocated: the new hot block has the size configured with
this function.  Notice that, after boot image loading: hot block
reallocation may never happen (most likely it will never happen).
@end defun


@defun scheme-stack-size
@defunx scheme-stack-size @var{num-of-bytes}
Getter and setter for the size of the Scheme stack memory segment.  When
called without arguments: return the current size.  When called with one
argument: set a new size.

The exact integer @var{num-of-bytes} must fit into a platform's
@code{unsigned long} value, it must be positive and greater than
@math{3} @value{PRJNAME}'s page sizes, @math{4096 * 3 = 12288}.  The
given @var{num-of-bytes} value is normalised by rounding it to the least
exact multiple of @math{4096} greater than @var{num-of-bytes}.

The Scheme heap stack memory segment is allocated at process start--up,
before loading the boot image.  While loading the boot image: the stack
segment may be reallocated.  These first allocation and reallocations
cannot be configured with this function, we have to use a command line
argument (@pxref{using invoking, scheme-stack-size}).

After boot image loading, when the Scheme stack segment is reallocated:
the new segment has the size configured with this function.
@end defun

@c page
@node iklib progname
@section Finding the @value{EXECUTABLE} executable


The following bindings are exported by the library @library{vicare}.


@defun vicare-argv0
Return a bytevector holding the C string in the @code{argv[0]} argument
to the @cfunc{main} function of the current @value{PRJNAME} process.
@end defun


@defun vicare-argv0-string
Return a Scheme string holding the C string in the @code{argv[0]}
argument to the @cfunc{main} function of the current @value{PRJNAME}
process.
@end defun

@c page
@node iklib config
@section Configuration options inspection


The following bindings are exported by the library @library{vicare}.


@defun vicare-built-with-arguments-validation-enabled
Return @true{} if the package was installed along with procedure
arguments validation enabled; otherwise return @false{}.
@end defun


@defun vicare-built-with-descriptive-labels-generation
Return @true{} if the package was installed along with descriptive
labels generation; otherwise return @false{}.
@end defun


@defun vicare-built-with-srfi-enabled
Return @true{} if the package was installed along with the @srfi{}
libraries; otherwise return @false{}.
@end defun


@defun vicare-built-with-iconv-enabled
Return @true{} if the package was configured with bindings to Libiconv
enabled; otherwise return @false{}.
@end defun


@defun vicare-built-with-ffi-enabled
Return @true{} if the package was configured with bindings to Libffi
enabled; otherwise return @false{}.
@end defun


@defun vicare-built-with-posix-enabled
Return @true{} if the package was configured with @posix{} features
enabled; otherwise return @false{}.
@end defun


@defun vicare-built-with-glibc-enabled
Return @true{} if the package was configured with @gnu{} C Library
features enabled; otherwise return @false{}.
@end defun


@defun vicare-built-with-linux-enabled
Return @true{} if the package was configured with Linux features
enabled; otherwise return @false{}.
@end defun

@c page
@node iklib cmdline
@section Command line arguments


The following bindings are exported by the library @library{vicare}.


@deffn Parameter command-line-arguments
@cindex Parameter @func{command-line-arguments}
Hold the value returned by @func{command-line} as defined by @rnrs{6}.
It is initialised to the actual command line arguments from the
@value{PRJNAME} process execution.
@end deffn

@c page
@node iklib env-inquiry
@section Environment inquiry


@defun host-info
Return a string being the value @gnu{} Autoconf assigned to the
@code{target} variable.  Examples: @code{i686-pc-linux-gnu},
@code{x86_64-unknown-linux-gnu}.
@end defun


The @posix{} function @cfunc{uname} fills a data structure of type
@code{struct utsname} with strings representing a description of the
underlying platform.  @value{PRJNAME} defines objects of type
@code{utsname} to provide at the Scheme level such informations;
@code{utsname} objects are disjoint from all the other types.


@defun uname
Interface to the C function @cfunc{uname}, @manpage{uname, Get name and
information about current kernel}.  Build and return a new object of
type @code{utsname}.  If successful return the object, otherwise raise
an exception.
@end defun


@defun utsname? @var{obj}
Return @true{} if @var{obj} is an object of type @code{utsname},
otherwise return @false{}.
@end defun


@defun utsname-sysname @var{utsname}
@defunx utsname-nodename @var{utsname}
@defunx utsname-release @var{utsname}
@defunx utsname-version @var{utsname}
@defunx utsname-machine @var{utsname}
Accessors for the fields of the @var{utsname} object.  All the returned
values are strings.
@end defun


The following bindings are specified by @ansrfi{112}, exported by
@library{vicare} and reexported by the @srfi{}'s libraries,
@libsref{srfi env-inquiry spec, Specification}.

@defun implementation-name
Return the string @code{"vicare-scheme"}.
@end defun


@defun implementation-version
Return the @value{PRJNAME} version string.  Example:

@example
(import (vicare))
(implementation-version)        @result{} "0.3d4"
@end example
@end defun


@defun cpu-architecture
Return a Scheme string representing the contents of the field
@code{machine} of the @code{struct utsname} filled by @cfunc{uname}.
Example:

@example
(import (vicare))
(cpu-architecture)      @result{} "x86_64"
@end example
@end defun


@defun machine-name
Return a Scheme string representing the contents of the field
@code{nodename} of the @code{struct utsname} filled by @cfunc{uname}.
Example:

@example
(import (vicare))
(machine-name)          @result{} "governatore"
@end example
@end defun


@defun os-name
Return a Scheme string representing the contents of the field
@code{sysname} of the @code{struct utsname} filled by @cfunc{uname}.
Example:

@example
(import (vicare))
(os-name)               @result{} "Linux"
@end example
@end defun


@defun os-version
Return a Scheme string representing the contents of the field
@code{version} of the @code{struct utsname} filled by @cfunc{uname}.
Example:

@example
(import (vicare))
(os-version)
@result{} "#2 SMP Mon Sep 17 14:19:22 CDT 2012"
@end example
@end defun

@c page
@node iklib syntaxes
@section Additional syntaxes


@menu
* iklib syntaxes libraries::    Local libraries.
* iklib syntaxes lambdas::      @func{lambda}-like additional syntaxes.
* iklib syntaxes defines::      @func{define}-like additional syntaxes.
* iklib syntaxes defstxs::      @func{define-syntax}-like additional syntaxes.
* iklib syntaxes bindings::     Additional binding syntaxes.
* iklib syntaxes control::      Additional control flow syntaxes.
* iklib syntaxes loops::        Additional loop syntaxes.
* iklib syntaxes returnable::   Early return from code blocks.
* iklib syntaxes blocking::     Blocking raised exceptions.
* iklib syntaxes dynenv::       Capturing the current dynamic
                                environment.
* iklib syntaxes integrable::   Integrable expressions and functions.
* iklib syntaxes stale::        Declaring compiled library in
                                stale state.
* iklib syntaxes body::         Internal body.
* iklib syntaxes try::          The @func{try}, @func{catch}, @func{finally} syntaxes.
* iklib syntaxes splice1st::    Splice first form syntax.
* iklib syntaxes infix::        Infix to prefix transformer.
* iklib syntaxes increments::   Incrementing and decrementing.
* iklib syntaxes unsafe::       Unsafe binding variants.
* iklib syntaxes misc::         Miscellaneous syntaxes.
* iklib syntaxes properties::   Syntactic binding properties.
* iklib syntaxes predaux::      Predicate auxiliary functions.
* iklib syntaxes type-of::      Determining the type of expressions.
* iklib syntaxes expansion-of:: Inspecting expansion results.
* iklib syntaxes optim-of::     Inspecting optimisation results.
* iklib syntaxes assembly-of::  Inspecting assembly language results.
@end menu

@c page
@node iklib syntaxes libraries
@subsection Local libraries


@cindex @syntax{library}, standalone syntax
@cindex Syntax @syntax{library}


@rnrs{6} defines libraries to be top--level symbolic expressions; the
form @syntax{library} can appear only at the top--level; @ref{scheme
library form, Library form}.  @value{PRJNAME} extends the notion of
libraries by having the library @library{vicare} export a
@syntax{library} syntax; such syntax can be used anywhere a definition
can be used and the defined library can be imported in its region of
visibility.

The following is a perfectly valid Vicare program:

@lisp
(import (vicare))

(let ()
  (library (ciao)
    (export a)
    (import (rnrs))
    (define a 1))

  (library (hello)
    (export b)
    (import (rnrs))
    (define b 1))

  (import (ciao))
  (import (hello))

  (display (list a b)))
@end lisp

@c page
@node iklib syntaxes lambdas
@subsection @syntax{lambda}--like additional syntaxes


@menu
* iklib syntaxes lambdas named::  Named @syntax{lambda} syntaxes.
* iklib syntaxes lambdas star::   Validating @syntax{lambda} syntaxes.
@end menu

@c page
@node iklib syntaxes lambdas named
@subsubsection Named @syntax{lambda} syntaxes


@deffn Syntax named-lambda @meta{who} @meta{formals} . @meta{lambda-body}
Like @syntax{lambda}, but allows the specification of the identifier
@meta{who}, which is bound, as identifier syntax, to the fluid syntax
@syntax{__who__}.

@lisp
(define func
  (named-lambda it ()
    __who__))

(func)          @result{} it
@end lisp
@end deffn


@deffn Syntax named-case-lambda @meta{who} . @meta{case-lambda-clauses}
Like @syntax{case-lambda}, but allows the specification of the
identifier @meta{who}, which is bound, as identifier syntax, to the
fluid syntax @syntax{__who__}.

@lisp
(define func
  (named-case-lambda it
    (()
      __who__)))

(func)          @result{} it
@end lisp
@end deffn

@c page
@node iklib syntaxes lambdas star
@subsubsection Validating @syntax{lambda} syntaxes


The syntaxes @syntax{lambda*} and @syntax{case-lambda*} are similar to
@syntax{lambda} and @syntax{case-lambda} as defined by @rnrs{6}, but
they allow the specification of logic predicates to validate the
arguments and the return values; a logic predicate is a composition of
predicate expressions.  Examples:

@example
#!vicare
(import (vicare)
  (vicare system $fx))

(define add
  ;;Fail if called with a non-fixnum argument.
  (lambda* (@{a fixnum?@} @{b fixnum?@})
    ($fx+ a b)))

(define vec
  ;;Fail if attempting to return a non-vector.
  (lambda* (@{_ vector?@} fun)
    (fun 1 2)))

(add 1 2)       @result{} 3
(add 1 #\2)     @error{} &procedure-argument-violation

(vec vector)    @result{} #(1 2)
(vec list)      @error{} &expression-return-value-violation
@end example

@noindent
in the definition of the function bound to @func{vec}: notice that
@code{@{_ vector?@}} is not a function argument, it is a special
notation used to select a predicate to validate the return value.

In the extended @syntax{lambda*} and @syntax{case-lambda*} syntaxes the
@meta{pred-formals} can have any of the forms:

@example
(@meta{var} ...)
(@metao{var} @meta{var} ... . @meta{rest})
@meta{args}
@end example

Where in the standard @syntax{lambda} and @syntax{case-lambda} syntaxes an
identifier is used to name a formal argument, in the extended
@syntax{lambda*} and @syntax{case-lambda*} syntaxes each formal argument
@meta{var} can have any of the forms:

@example
@meta{id}
(brace @meta{id} @meta{logic-pred})
@end example

@noindent
where: @syntax{brace} is the identifier exported by @library{vicare};
@meta{id} is an identifier naming the formal argument.
@meta{logic-pred} must have one of the following recursive formats:

@example
@meta{logic-pred} = @meta{pred-id}
            | (and @metao{logic-pred} @meta{logic-pred} ...)
            | (or  @metao{logic-pred} @meta{logic-pred} ...)
            | (xor @metao{logic-pred} @meta{logic-pred} ...)
            | (not @meta{logic-pred})
@end example

@noindent
where: @meta{pred-id} is an identifier expanding and evaluating to a
predicate function accepting a single argument and returning true or
@false{}; @syntax{and}, @syntax{or}, @syntax{xor}, @syntax{not} are the
identifiers exported by @library{vicare}.

The formal argument @meta{rest} can have only one of the following
forms:

@example
@meta{rest-id}
(brace @meta{rest-id} @meta{logic-pred})
@end example

@noindent
and the formal argument @meta{args} can have one of the following forms:

@example
@meta{args-id}
(brace @meta{args-id} @meta{logic-pred})
@end example

@noindent
the @meta{logic-pred} for @meta{rest} and @meta{args} is applied to each
item in the proper list bound to @meta{rest-id} and @meta{args-id}.

The first item in the @meta{pred-formals} can have the special syntax:

@example
(brace _ @metao{logic-pred} @meta{logic-pred} ...)
@end example

@noindent
where @code{_} is the binding exported by @rsixlibrary{base}; in this
case such item does @strong{not} represent a formal argument, it just
selects predicates to validate the values returned by the last
@meta{body} form.

@c ------------------------------------------------------------

@deffn Syntax lambda* @meta{pred-formals} @metao{body} @meta{body} @dots{}
@deffnx Syntax named-lambda* @meta{who} @meta{pred-formals} @metao{body} @meta{body} @dots{}
Like the standard @syntax{lambda} and additionally allow the specification
of predicate functions to validate the arguments and the return value.
The formal arguments are handled according to the following rules:

@itemize
@item
When all the items in @meta{pred-formals} are as specified for the
standard @syntax{lambda}: this syntax is equivalent to @syntax{lambda} as
defined by @rnrs{6}.

@item
If the boot image has been compiled with procedure arguments validation
@strong{enabled}, and @meta{pred-formals} selects predicates to validate
the arguments: if a predicate fails for its formal argument, an
exception is raised using @condition{procedure-argument-violation}.

@item
If the boot image has been compiled with procedure arguments validation
@strong{disabled}, the predicate selections in @meta{pred-formals} are
ignored and @syntax{lambda*} behaves like the standard @syntax{lambda}.

@item
If the first element of @meta{pred-formals} has the format:

@example
(brace _ @metao{logic-pred} @meta{logic-pred} ...)
@end example

@noindent
the values returned by the last @meta{body} form are validated using the
given @meta{logic-pred}: if a predicate fails for its returned value, an
exception is raised using a compound condition object with component of
type @condition{expression-return-value-violation}.
@end itemize

When using @syntax{lambda*}, in addition the behaviour of
@syntax{lambda}, the fluid identifier syntax @code{__who__} is bound to
the quoted symbol @code{_}; the @syntax{named-lambda*} variant allows to
specify an identifier @meta{who} to be used as value for the
@syntax{__who__} fluid syntax.

Usage examples:

@itemize
@item
Function with two predicate arguments:

@example
#!vicare
(import (vicare))
(define f
  (lambda* (@{a number?@} @{b number?@})
    (list (number->string a) (number->string b))))

(f 1 2)         @result{} ("1" "2")
@end example

@item
Function with two mandatory arguments and the rest argument:

@example
#!vicare
(import (vicare))

(define f
  (lambda* (@{a number?@} @{b number?@} . @{rest number?@})
    (list (number->string a)
          (number->string b)
          (length rest))))

(f 1 2 3 4 5)           @result{} ("1" "2" 3)
@end example

@item
Function with the @meta{args} argument:

@example
#!vicare
(import (vicare))

(define f
  (lambda* @{args number?@}
    (length args)))

(f 1 2 3)               @result{} 3
@end example

@item
Function with a single validated return value:

@example
#!vicare
(import (vicare))

(define f
  (lambda* (@{_ fixnum?@} val)
    val))

(f 1)                   @result{} 1
@end example

@item
Function with multiple validated return values:

@example
#!vicare
(import (vicare))

(define f
  (lambda* (@{_ fixnum? string?@} a b)
    (values a b)))

(f 1 "2")               @result{} 1, "2"
@end example
@end itemize
@end deffn

@c ------------------------------------------------------------

@deffn Syntax case-lambda* @meta{pred-cl-clause} @dots{}
@deffnx Syntax named-case-lambda* @meta{who} @meta{pred-cl-clause} @dots{}
Like the standard @syntax{case-lambda} and additionally allow the
specification of logic predicates to validate the arguments and the
return values.  Clause by clause the formals are handled as explained
for @syntax{lambda*}.

When using @syntax{case-lambda*}, in addition to the behaviour of
@syntax{lambda}, the fluid identifier syntax @code{__who__} is bound to
the quoted symbol @code{_}; the @syntax{named-case-lamba*} variant
allows to specify an identifier @meta{who} to be used as value for the
@syntax{__who__} fluid syntax.

Usage examples:

@example
#!vicare
(import (vicare))

(define f
  (case-lambda*
   ((@{a number?@})
    (number->string a))))

(define g
  (case-lambda*
   (@{args list?@}
    (length args))))

(f 123)                 @result{} "123"
(g 1 2 3)               @result{} 3
@end example
@end deffn

@c page
@node iklib syntaxes defines
@subsection @func{define}--like additional syntaxes


@deffn Syntax case-define @meta{who} @metao{cl-clause} @meta{cl-clause} @dots{}
Convenience syntax which expands as follows:

@example
(case-define @meta{who} @metao{cl-clause} @meta{cl-clause} @dots{})
@expansion{} (define @meta{who}
      (case-lambda @metao{cl-clause} @meta{cl-clause} @dots{}))
@end example
@end deffn


@deffn Syntax define* @meta{who} @meta{expression}
@deffnx Syntax define* @meta{who}
@deffnx Syntax define* (@meta{who} . @meta{formals}) @metao{body} @meta{body} @dots{}
@deffnx Syntax define* (@meta{pred-who} . @meta{formals}) @metao{body} @meta{body} @dots{}
Like the standard @func{define} as defined by @rnrs{6}, but when
defining a function: allow the specification of logic predicates to
validate the arguments and return values.

Logic predicates specification is performed as explained for the
@func{lambda*} extended syntax (@pxref{iklib syntaxes lambdas}).  There
is an exception, where @func{lambda*} uses the @code{_} symbol to select
predicates for the returned values, @func{define*} uses the binding
identifier @meta{who}.

In addition, when defining a function or a variable with non--empty
right--hand side, the fluid identifier syntax @syntax{__who__} is bound
to the quoted symbol @meta{who}.

Usage examples:

@itemize
@item
Function with two predicate arguments:

@example
#!vicare
(import (vicare))

(define* (f @{a number?@} @{b number?@})
  (list (number->string a) (number->string b)))

(f 1 2)         @result{} ("1" "2")
@end example

@item
Function with two mandatory arguments and the rest argument:

@example
#!vicare
(import (vicare))

(define* (f @{a number?@} @{b number?@} . @{rest number?@})
  (list (number->string a)
        (number->string b)
        (length rest)))

(f 1 2 3 4 5)           @result{} ("1" "2" 3)
@end example

@item
Function with the @meta{args} argument:

@example
#!vicare
(import (vicare))

(define* (f . @{args number?@})
  (length args))

(f 1 2 3)               @result{} 3
@end example

@item
Function with a single validated return value:

@example
#!vicare
(import (vicare))

(define* (@{f fixnum?@} val)
  val)

(f 1)                   @result{} 1
@end example

@item
Function with multiple validated return values:

@example
#!vicare
(import (vicare))

(define* (@{f fixnum? string?@} a b)
  (values a b))

(f 1 "2")               @result{} 1, "2"
@end example

@item
Accessing the function name:

@example
(import (vicare))

(define* (f)
  __who__)

(f)     @result{} f
@end example

@item
Accessing the variable name:

@lisp
(import (vicare))

(define* a (list 'name __who__))
a       @result{} (name a)
@end lisp
@end itemize
@end deffn

@c ------------------------------------------------------------

@deffn Syntax case-define* @meta{who} @metao{pred-cl-clause} @meta{case-clause} @dots{}
Convenience syntax that expands to something similar to:

@example
(case-define* @meta{who} @metao{pred-cl-clause} @meta{pred-cl-clause} @dots{})
@expansion{} (define @meta{who}
      (case-lambda* @metao{pred-cl-clause} @meta{pred-cl-clause} @dots{}))
@end example

In addition the fluid identifier syntax @code{__who__} is bound to the
quoted symbol @meta{who}.
@end deffn

@c ------------------------------------------------------------

@deffn Syntax define-values @meta{formals} @metao{form} @meta{form} @dots{}
Evaluate the given forms and bind the, possibly multiple, result of the
last one to the given @meta{var} identifiers.  @var{formals} has the
same syntax of the @func{lambda} formals.

@example
(define-values (a b c)
  (values 1 2 3))

(list a b c)    @result{} (1 2 3)
@end example
@end deffn


@deffn Syntax define-constant-values @var{formals} @metao{form} @meta{form} @dots{}
Evaluate the given forms and bind the, possibly multiple, result of the
last one to the given formals identifiers; make the formals identifiers
immutable.  @var{formals} has the same syntax of the @func{lambda}
formals.

@example
(define-constant-values (a b c)
  (values 1 2 3))

(list a b c)    @result{} (1 2 3)
(set! a 99)     @error{} &syntax
@end example
@end deffn


@deffn Syntax define-inline (@meta{name} @meta{arg} @dots{} . @meta{rest}) @metao{body} @meta{body} @dots{}
Similar to @func{define}, but create a binding that is always expanded
inline and can @strong{neither} be invoked recursively @strong{nor} used
as function rgument.  This syntax only defines a syntax.

@example
(define-inline (incr x)
  (+ x 1))

(incr 2)        @result{} 3
@end example

In the example above, we can think of @code{(incr 2)} as expanding to:

@example
(let ((x 2))
  (+ x 1))
@end example
@end deffn


@deffn Syntax define-inline-constant @meta{name} @meta{expr}
@meta{expr} is evaluated only once at expand time, the result is
returned by the macro transformer bound to @meta{name}.  It is
impossible to modify the result of the expansion of @meta{name} by
acting upon @meta{name}.
@end deffn


@deffn Syntax define-integrable (@meta{name} @meta{arg} @dots{} . @meta{rest}) @metao{body} @meta{body} @dots{}
Similar to @func{define}, but create a binding that is always expanded
inline and @strong{can} be both invoked recursively and used as function
argument.  This syntax defines both a syntax and a function.

@example
(define-integrable (incr x)
  (+ x 1))

(incr 2)
@result{} 3

(map incr '(10 20 30)))
@result{} (11 21 31)
@end example

In the example above, we can think of @code{(incr 2)} as expanding to:

@example
((lambda (x)
   (+ x 1))
 2)
@end example
@end deffn

@c page
@node iklib syntaxes defstxs
@subsection @func{define-syntax}--like additional syntaxes


@deffn Syntax define-syntax @meta{name}
@deffnx Syntax define-syntax @meta{name} @meta{transformer}
@deffnx Syntax define-syntax (@meta{name} @meta{arg}) @metao{body} @meta{body} @dots{}
Like @func{define-syntax} defined by @rnrs{6}, but additionally accepts
the syntax:

@example
(define-syntax (@meta{name} @meta{arg}) @metao{body} @meta{body} @dots{})
@expansion{} (define-syntax @meta{name} (lambda (@meta{arg}) @metao{body} @meta{body} @dots{}))
@end example

@noindent
and the syntax:

@example
(define-syntax @meta{name})
@expansion{} (define-syntax @meta{name} (syntax-rules ()))
@end example
@end deffn


@deffn Syntax define-syntax* @meta{name}
@deffnx Syntax define-syntax* @meta{name} @meta{transformer}
@deffnx Syntax define-syntax* (@meta{name} @meta{arg}) @metao{body} @meta{body} @dots{}
Like @func{define-syntax} defined by Vicare.  Additionally, when the
last form is used: the fluid identifier syntax @code{__who__} is bound
to @meta{name}; the non-hygienic binding @func{synner} is introduced and
bound to a function.

@example
(define-syntax* (@meta{name} @meta{arg}) @metao{body} @meta{body} @dots{})
@expansion{} (define-syntax* (@meta{name} @meta{arg})
      (fluid-let-syntax
          ((__who__ (identifier-syntax (quote @meta{name}))))
        (letrec
            ((synner (case-lambda
                       ((message)
                        (synner message #f))
                       ((message subform)
                        (syntax-violation __who__
                           message @meta{arg} subform)))))
          @metao{body} @meta{body} @dots{})))
@end example
@end deffn


@deffn Syntax define-constant @meta{var} @meta{expr}
Like @func{define} but create an immutable binding.

@example
(define-constant X 1)
X               @result{} 1
(set! X 2)      @error{} &syntax
@end example
@end deffn


@deffn Syntax define-syntax-rule (@meta{name} @meta{pattern} @dots{} . @meta{rest}) @metao{body} @meta{body} @dots{}
Convenience syntax to define a @func{syntax-rules} transformer with a
single clause.  Expand to:

@example
(define-syntax-rule (@meta{name} @meta{pattern} @dots{} . @meta{rest})
  @metao{body} @meta{body} @dots{})
@expansion{} (define-syntax @meta{name}
      (syntax-rules ()
        ((_ @meta{pattern} @dots{} . @meta{rest})
         (begin @metao{body} @meta{body} @dots{}))))
@end example
@end deffn


@deffn Syntax define-auxiliary-syntaxes @metao{name} @meta{name} @dots{}
Define auxiliary syntaxes to be used as literal identifiers by
@func{syntax-rules}, @func{syntax-case} and similar macros; expand to:

@example
(define-syntax @metao{name} (syntax-rules ()))
(define-syntax @meta{name}  (syntax-rules ()))
@dots{}
@end example
@end deffn


@deffn Syntax define-alias @meta{alias-id} @meta{old-id}
Define a new binding for @meta{alias-id} as an alias for @meta{old-id},
which must be a bound identifier in the current lexical environment.

@example
(let ((a 1))
  (define-alias b a)
  b)
@result{} 1
@end example
@end deffn

@c page
@node iklib syntaxes bindings
@subsection Additional binding syntaxes


@deffn Syntax receive @meta{formals} @meta{expression} @metao{body} @meta{body} @dots{}
Expect @meta{expression} to evaluate to multiple values and bind such
values as specified by the @meta{formals}; evaluate the @meta{body} in
the region of such bindings.  The expansion is:

@example
(receive @meta{formals}
    @meta{expression}
  @metao{body} @meta{body} @dots{})
@expansion{} (call-with-values
        (lambda ()
          @meta{expression})
      (lambda @meta{formals}
        @metao{body} @meta{body} @dots{}))
@end example
@end deffn


@deffn Syntax receive-and-return (@meta{retval} @dots{}) @meta{expression} @metao{body} @meta{body} @dots{}
Expect @meta{expression} to evaluate to multiple values and bind such
values to the identifiers @meta{retval}; evaluate the @meta{body} forms
in the region of such bindings; return the values bound to
@meta{retval}.  The expansion is:

@example
(receive-and-return (@meta{retval} @dots{})
    @meta{expression}
  @metao{body} @meta{body} @dots{})
@expansion{} (call-with-values
        (lambda ()
          @meta{expression})
      (lambda (@meta{retval} @dots{})
        @metao{body} @meta{body} @dots{}
        (values @meta{retval} @dots{})))
@end example
@end deffn


@deffn Syntax let*-syntax ((@meta{lhs} @meta{rhs}) @dots{}) @metao{form} @meta{form} @dots{}
Similar to @func{let-syntax}, expands into nested @func{let-syntax}
forms:

@example
(let*-syntax () @meta{body})
@expansion{} (begin () @meta{body})

(let*-syntax ((@meta{lhs} @meta{rhs})) @meta{body})
@expansion{} (let-syntax ((@meta{lhs} @meta{rhs})) @meta{body})

(let*-syntax ((@metao{lhs} @metao{rhs})
              (@meta{lhs} @meta{rhs})
              ...)
  @meta{body})
@expansion{} (let-syntax ((@metao{lhs} @metao{rhs}))
      (let*-syntax ((@meta{lhs} @meta{rhs}) ...) @meta{body}))
@end example
@end deffn


@deffn Syntax let-constants ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
Like @func{let} but create immutable bindings.  Attempting to mutate the
bindings with @func{set!} will result in an expand time syntax
violation.
@end deffn


@deffn Syntax let*-constants ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
Like @func{let*} but create immutable bindings.  Attempting to mutate
the bindings with @func{set!} will result in an expand time syntax
violation.
@end deffn


@deffn Syntax letrec-constants ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
Like @func{letrec} but create immutable bindings.  Attempting to mutate
the bindings with @func{set!} will result in an expand time syntax
violation.
@end deffn


@deffn Syntax letrec*-constants ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
Like @func{letrec*} but create immutable bindings.  Attempting to mutate
the bindings with @func{set!} will result in an expand time syntax
violation.
@end deffn

@c page
@node iklib syntaxes control
@subsection Additional control flow syntaxes


@deffn Syntax begin0 @metao{expr} @meta{expr} ...
Evaluate all the expressions in the given order and return the return
values of @metao{expr}.  This syntax comes from the @rnrs{6} original
document, Appendix A ``Formal semantics''.

@example
(begin0
    1
  2)
@result{} 1
@end example
@end deffn


@deffn Syntax xor @meta{expr} ...
Exclusive @syntax{or}.  When expanded with no expressions: evaluate to
@false{}.
@end deffn


@deffn Macro case-identifiers @meta{expr} ((@metao{identifier} @meta{identifier} ...) @metao{sym-body} @meta{sym-body} ...) ...
@deffnx Macro case-identifiers @meta{expr} ((@metao{identifier} @meta{identifier} ...) @metao{sym-body} @meta{sym-body} ...) ... (else @metao{else-body} @meta{else-body} ...)
@deffnx {Auxiliary Syntax} else
Special implementation of @func{case} expecting only identifiers as
datums; identifiers are compared with @func{free-identifier=?}.
@func{else} must be the binding exported by @library{rnrs} and
@library{vicare}.

@meta{expr} must be an expression evaluating to an identifier, else the
behaviour is undefined.
@end deffn

@c page
@node iklib syntaxes loops
@subsection Additional loop syntaxes


@menu
* iklib syntaxes loops while::    Iterating with the @syntax{while} syntax.
* iklib syntaxes loops until::    Iterating with the @syntax{until} syntax.
* iklib syntaxes loops for::      Iterating with the @syntax{for} syntax.
* iklib syntaxes loops do::       Iterating with the @syntax{do} syntax.
* iklib syntaxes loops do*::      Iterating with the @syntax{do*} syntax.
* iklib syntaxes loops dolist::   Iterating with the @syntax{dolist} syntax.
* iklib syntaxes loops dotimes::  Iterating with the @syntax{dotimes} syntax.
* iklib syntaxes loops fluids::   Fluid bindings for loop syntaxes.
@end menu

@c page
@node iklib syntaxes loops while
@subsubsection Iterating with the @syntax{while} syntax


@deffn Syntax while @meta{test} @meta{body} ...
@deffnx {Auxiliary Syntax} continue
@deffnx {Auxiliary Syntax} break
If the expression @meta{test} evaluates to true: evaluate the body forms
@meta{body} and recurse; else return unspecified values.  In the body:
the syntax @func{continue} causes immediate looping to next iteration,
starting with the @meta{test}; the syntax @func{break} causes immediate
escaping out of the loop.
@end deffn

@c page
@node iklib syntaxes loops until
@subsubsection Iterating with the @syntax{until} syntax


@deffn Syntax until @meta{test} @meta{body} ...
@deffnx {Auxiliary Syntax} continue
@deffnx {Auxiliary Syntax} break
If the expression @meta{test} evaluates to false: evaluate the body
forms @meta{body} and recurse; else return unspecified values.  In the
body: the syntax @func{continue} causes immediate looping to next
iteration, starting with the @meta{test}; the syntax @func{break} causes
immediate escaping out of the loop.
@end deffn

@c page
@node iklib syntaxes loops for
@subsubsection Iterating with the @syntax{for} syntax


@deffn Syntax for (@meta{init} @meta{test} @meta{post}) @metao{body} @meta{body} @dots{}
@deffnx {Auxiliary Syntax} continue
@deffnx {Auxiliary Syntax} break
This is an iteration syntax similar to the C language @code{for}:

@example
(import (vicare))

(for ((define i 0) (< i 3) (set! i (+ 1 i)))
  (display i)
  (display #\space))
@print{} 0 1 2

(define i)
(for ((set! i 0) (< i 3) (set! i (+ 1 i)))
  (display i)
  (display #\space))
@print{} 0 1 2

(for ((begin
        (define i 5)
        (define j 10))
      (positive? i)
      (begin
        (set! i (+ -1 i))
        (set! j (+ -1 j))))
  (display i)
  (display #\space)
  (display j)
  (display #\space))
@print{} 5 10 4 9 3 8 2 7 1 6
@end example

The form @meta{init} can be a sequence of definitions and expressions;
it is evaluated first and only once; its return values are discarded.
The region of bindings defined by @meta{init} includes the @meta{test},
@meta{post} and @meta{body} forms.

The form @meta{test} must be an expression; it is evaluated at the
beginning of each iteration: if the result is true the next iteration
takes place, else the loop terminates.

The forms @meta{body} must be expressions; they are evaluated at each
iteration when the @meta{test} evaluates to true; the return values are
discarded.

The form @meta{post} must be an expression; it is evaluated at the end
of each iteration after the @meta{body} forms; the return values are
discarded.

The syntax @func{continue} can be used in the body to immediately exit
from the body and jump directly to the evaluation of @meta{post}.

The syntax @func{break} can be used in the body to immediately break out
of the loop and return to the continuation of @func{for}.
@end deffn

@c page
@node iklib syntaxes loops do
@subsubsection Iterating with the @syntax{do} syntax


@deffn Syntax do @meta{body} (while @meta{test})
@deffnx Syntax do @meta{body} (until @meta{test})
@deffnx {Auxiliary Syntax} while
@deffnx {Auxiliary Syntax} until
@deffnx {Auxiliary Syntax} continue
@deffnx {Auxiliary Syntax} break
These syntaxes extend the built--in @syntax{do} syntax as defined by
@rnrs{6}.

For @code{do ... (while ...)}:

@itemize
@item
Evaluate @meta{body} at least once, then: if the expression @meta{test}
evaluates to non--false loop; else return unspecified values.

@item
Using @syntax{continue} in the body cause a direct jump to the end of
the current iteration, evaluating the @meta{test}.

@item
Using the syntax @syntax{break} in the body causes immediate escaping
out of the loop; if arguments are given to @syntax{break}: they become
the return values of the syntax.
@end itemize

For @code{do ... (until ...)}:

@itemize
@item
Evaluate @meta{body} at least once, then if the expression @meta{test}
evaluates to false loop; else return unspecified values.

@item
Using @syntax{continue} in the body cause a direct jump to the end of
the current iteration, evaluating the @meta{test}.

@item
Using the syntax @syntax{break} in the body causes immediate escaping
out of the loop; if arguments are given to @syntax{break}: they become
the return values of the syntax.
@end itemize

For the standard syntax:

@itemize
@item
Using @syntax{continue} in the body cause a direct jump to the end of
the current iteration, evaluating the @meta{test}.

@item
Using the syntax @syntax{break} in the body causes immediate escaping
out of the loop; if arguments are given to @syntax{break}: they become
the return values of the syntax.
@end itemize
@end deffn

@c page
@node iklib syntaxes loops do*
@subsubsection Iterating with the @syntax{do*} syntax


@deffn Syntax do* ((@metai{variable} @metai{init} @metai{step}) @dots{}) (@meta{test} @meta{expression} @dots{}) @meta{command} @dots{}
This is like the standard @syntax{do} (@pxref{stdlib control, do}), but
the bindings and steppings are performed sequentially rather than in
unspecified order.  This syntax meant to be similar to the Common Lisp
syntax of the same name.
@end deffn

@c page
@node iklib syntaxes loops dolist
@subsubsection Iterating with the @syntax{dolist} syntax


@deffn Syntax dolist (@meta{var} @meta{list-expr}) @metao{body} @meta{body} @dots{}
@deffnx Syntax dolist (@meta{var} @meta{list-expr} @meta{result-expr}) @metao{body} @meta{body} @dots{}
Iterate of the list returned by @meta{list-expr} binding, at each
iteration, the next item from the list to @meta{var}; evaluate the
@meta{body} forms in the region of the binding.

If @meta{result-expr} is present: it is evaluated, in the region of
@meta{var}, to produce the return values.  If @meta{result-expr} is not
present: the return values are unspecified.

If @meta{list-expr} returns null and @meta{result-expr} is present: when
@meta{result-expr} is evaluated, @meta{var} is bound to null.

This syntax meant to be similar to the Common Lisp syntax of the same
name.

@lisp
(import (vicare) (vicare checks))

(with-result
  (dolist (A '(1 2 3))
    (add-result A)))
@result{} (#!void (1 2 3))

(with-result
  (dolist (A '(1 2 3) A)
    (add-result A)))
@result{} (() (1 2 3))

(with-result
  (let ((rv #f))
    (dolist (A '(1 2 3) rv)
      (add-result A)
      (when (even? A)
        (set! rv A)))))
@result{} (2 (1 2 3))

(with-result
  (dolist (A '() A)
    (add-result A)))
@result{} (() ())
@end lisp
@end deffn

@c page
@node iklib syntaxes loops dotimes
@subsubsection Iterating with the @syntax{dotimes} syntax


@deffn Syntax dotimes (@meta{var} @meta{count-expr}) @metao{body} @meta{body} @dots{}
@deffnx Syntax dotimes (@meta{var} @meta{count-expr} @meta{result-expr}) @metao{body} @meta{body} @dots{}
Iterate over exact integers from zero to the return value of
@meta{count-expr}, which must return a non--negative exact integer; at
each iteration: the next integer is bound to @meta{var}; evaluate the
@meta{body} forms in the region of the binding.

If @meta{result-expr} is present: it is evaluated, in the region of
@meta{var}, to produce the return values.  If @meta{result-expr} is not
present: the return values are unspecified.

This syntax meant to be similar to the Common Lisp syntax of the same
name.
@end deffn

@c page
@node iklib syntaxes loops fluids
@subsubsection Fluid bindings for loop syntaxes


@deffn {Fluid Syntax} continue
Causes the innermost @syntax{do}, @syntax{while}, @syntax{until} or
@syntax{for} loop to jump immediately to the next iteration.  Being a
fluid syntax: it is possible to use this keyword in custom syntaxes.
@end deffn


@deffn {Fluid Syntax} break @meta{expr} ...
Causes the innermost @syntax{do}, @syntax{while}, @syntax{until} or
@syntax{for} loop to exit immediately to the continuation of the whole
loop syntax.  When arguments are given: they are returned to the
continuation; when no arguments are given: zero values are returned.
Being a fluid syntax: it is possible to use this keyword in custom
syntaxes.
@end deffn


@value{PRJNAME} does @strong{not} bind @syntax{break} and
@syntax{continue} in uses of the named @syntax{let} syntax; this is
because:

@itemize
@item
Named @syntax{let} is a convenience syntax to define a recursive
function; recursive functions do not have the @syntax{break} and
@syntax{continue} operators in other languages.  In Scheme, all the loop
syntaxes are just convenience for a recursive function definition, but
the named @syntax{let} is more so.

@item
The operation performed by @syntax{continue} in a named @syntax{let} is
just performed by calling the function itself.  Calling the function is
more flexible because it allows tail calls and non--tail calls.

@item
The operation performed by @syntax{break} in a recursive function can be
performed using @syntax{returnable} and @syntax{return} in the body:

@example
(returnable
  (let loop ()
    ...
    (return)
    ...))
@end example

@item
By keeping named @syntax{let} clean of fluid bindings, we can more
freely use it as building block for custom loop syntaxes.
@end itemize

@c page
@node iklib syntaxes returnable
@subsection Early return from code blocks


The standardised Scheme languages do not define the common @code{return}
keyword present in many languages, like C and Python.  Despite this, it
is quite easy to obtain the ``early return'' functionality through the
use of continuations:

@example
(call/cc
    (lambda (return)
      (display 'before)
      (return 1)
      (display 'never)))
@print{} before
@result{} 1
@end example

Many programmers are used to the @code{return} keyword, so
@value{PRJNAME} includes some syntaxes to support it.  The use of all
these syntaxes involves the creation of a continuation, which is a
performance penalty.


@deffn {Fluid Syntax} return @meta{expr} ...
This syntax is meant to be used to return from some enclosing block,
returning the given optional arguments.  Being a fluid syntax: it is
possible to rebind this keyword in custom syntaxes.
@end deffn


@deffn Syntax returnable @metao{body} @meta{body} @dots{}
Like @func{begin}, but allow the use of the keyword @func{return} to
return values to the enclosing continuation.

@example
(returnable
  (display 'before)
  (return)
  (display 'never))
@print{} before

(returnable
  (display 'before)
  (return 1)
  (display 'never))
@print{} before
@result{} 1

(returnable
  (display 'before)
  (return 1 2)
  (display 'never))
@print{} before
@result{} 1 2
@end example
@end deffn

@c page
@node iklib syntaxes blocking
@subsection Blocking raised exceptions


Sometimes we want to block raised exceptions, for example when we are
already handling a previously raised exception.


@deffn Syntax with-blocked-exceptions @meta{thunk}
@deffnx Syntax with-blocked-exceptions @meta{exception-retvals-maker} @meta{thunk}
Evaluate @meta{thunk} and return its return values.

When used with one argument: if @meta{thunk} raises an exception, return
the raised object.

When used with two arguments: if @meta{thunk} raises an exception, apply
the procedure @meta{exception-retvals-maker} to the raised object and
return its return values.  Exceptions raised by
@meta{exception-retvals-maker} are @strong{not} blocked.
@end deffn


Usage examples:

@example
(import (vicare))

(with-blocked-exceptions
  (lambda ()
    (raise 99)))
@result{} 99

(with-blocked-exceptions
    (lambda (E)
      (values E 1 2 3))
  (lambda ()
    (raise 99)))
@result{} 99 1 2 3
@end example

@c page
@node iklib syntaxes dynenv
@subsection Capturing the current dynamic environment


@deffn Syntax with-current-dynamic-environment @meta{exception-retvals-maker} @meta{thunk}
Install and return a thunk that, wherever it is called, evaluates
@meta{thunk} in the dynamic environment of the macro use and returns its
return values.  If @meta{thunk} raises an exception: apply the procedure
@meta{exception-retvals-maker} to the raised object and return its
return values.

Exceptions raised by @meta{exception-retvals-maker} are @strong{not}
blocked.
@end deffn


Usage examples:

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(define parm
  (make-parameter #f))

(with-result
  (parametrise ((parm 'outer))
    (let* ((counter 0)
           (thunk   (parametrise ((parm 'inner))
                      (with-current-dynamic-environment
                          values
                        (lambda ()
                          (set! counter (+ 1 counter))
                          (add-result (list 'inside-thunk (parm))))))))
      (add-result (parm))
      (add-result 'calling-thunk-1)
      (thunk)
      (add-result 'calling-thunk-2)
      (thunk)
      counter)))
@result{} (2 (outer
       calling-thunk-1 (inside-thunk inner)
       calling-thunk-2 (inside-thunk inner)))

(with-result
  (parametrise ((parm 'outer))
    (let* ((counter 0)
           (thunk   (parametrise ((parm 'inner))
                      (with-current-dynamic-environment
                          values
                        (lambda ()
                          (set! counter (+ 1 counter))
                          (add-result (list 'inside-thunk (parm)))
                          (add-result 'raise-exception)
                          (raise 123))))))
      (add-result (parm))
      (add-result 'calling-thunk-1)
      (thunk)
      (add-result 'calling-thunk-2)
      (thunk)
      counter)))
@result{} (2 (outer
       calling-thunk-1 (inside-thunk inner) raise-exception
       calling-thunk-2 (inside-thunk inner) raise-exception))
@end example

@c page
@node iklib syntaxes integrable
@subsection Integrable expressions and functions


@cindex Function inlining
@cindex Function integration
@cindex Expression inlining
@cindex Expression integration
@cindex Inlining of functions and expressions
@cindex Integration of functions and expressions
@cindex Expanding functions inline
@cindex Expanding expressions inline


Compilers act upon ``compilation units'', which for @value{PRJNAME} are:
@rnrs{6} libraries, @rnrs{6} programs, symbolic expressions handed to
@func{eval}; the latter includes standalone expressions typed at the
@repl{}.  Under @value{PRJNAME}:

@itemize
@item
Whenever a function defined in a compilation unit is called in the same
compilation unit: the compiler has access to the source code, so it
@strong{always} attempts to integrate it (expand it inline); such
integration can succeed or fail depending on the cost of such operation.

@item
Whenever a function defined in a compilation unit is called in another
compilation unit: the compiler has @strong{no} access to the source
code, so it never attempts to integrate it.
@end itemize

@noindent
this scenario is somewhat different from the one of languages like C,
which make use of object files that allow inlining of functions defined
in other files.

Sometimes we do want to always integrate expressions, even across
compilation unit boundaries; for this purpose @value{PRJNAME} provides
@func{define-inline} to integrate expressions and
@func{define-integrable} to integrate functions.


@deffn Syntax define-inline (@meta{name} @meta{arg} ... . @meta{rest}) @metao{body} @meta{body} ...
Similar to @func{define}, but create a binding for an expression that is
always expanded inline and can @strong{neither} be invoked recursively
@strong{nor} used as function argument.  This syntax only defines a
syntax embedding the source code of the expression in a syntax object.

@example
(define-inline (incr x)
  (+ x 1))

(incr 2)        @result{} 3
@end example

In the example above, we can think of @code{(incr 2)} as expanding to:

@example
(let ((x 2))
  (+ x 1))
@end example
@end deffn


@deffn Syntax define-integrable (@meta{name} @meta{arg} ... . @meta{rest}) @metao{body} @meta{body} ...
Similar to @func{define}, but create a binding that is always expanded
inline and @strong{can} be both invoked recursively and used as function
argument.  This syntax defines both a syntax and a function, with the
syntax embedding the source code of the function in a syntax object.

@example
(define-integrable (incr x)
  (+ x 1))

(incr 2)
@result{} 3

(map incr '(10 20 30)))
@result{} (11 21 31)
@end example

In the example above, we can think of @code{(incr 2)} as expanding to:

@example
((lambda (x)
   (+ x 1))
 2)
@end example
@end deffn


@c page
@node iklib syntaxes stale
@subsection Declaring compiled library in stale state


@cindex Stale libraries
@cindex Libraries, stale with respect to source
@cindex Compiled libraries, stale with respect to source


@deffn Syntax stale-when @meta{stale-expr} @metao{body} @meta{body} @dots{}
Act like @func{begin}, but in addition causes an expression,
@meta{stale-expr}, to be registered in the state of a compiled library.
When such expression evaluates to false: the compiled library is stale
with respect to some source file.  See for example the @func{include}
syntax.
@end deffn

@c page
@node iklib syntaxes body
@subsection Internal body


@deffn Syntax internal-body @meta{definition} @dots{} @metao{expr} @meta{expr} @dots{}
Delimits an internal body, evaluating the definitions and then the
expression.  This syntax must be used in expression context.

@example
(import (vicare))

(let ()
  (define a 1)
  (display a)
  (internal-body
    (define b 2)
    (define c 3)
    (display a)
    (display b)
    (display c)))
@print{} 1123
@end example
@end deffn

@c page
@node iklib syntaxes try
@subsection The @func{try}, @func{catch}, @func{finally} syntaxes


The syntax @func{try} can be used to handle raised exceptions in
addition to the @rnrs{6}--defined syntaxes @func{with-exception-handler}
and @func{guard}.  The syntax is basically a wrapper for @func{guard}
from @rsixlibrary{exceptions} (@pxref{guard}).


@deffn Syntax try @meta{body} @meta{catch-clauses}
@deffnx Syntax try @meta{body} @meta{catch-clauses} @meta{finally-clause}
@deffnx Syntax try @meta{body} @meta{finally-clause}
@deffnx {Auxiliary Syntax} catch
@deffnx {Auxiliary Syntax} finally
@deffnx {Auxiliary Syntax} else
Evaluate the form @meta{body} and return its results.  If no exceptions
are raised by @meta{body}: before returning evaluate the
@meta{finally-clause}.  If an exception is raised by @meta{body}: handle
it with the @meta{catch-clauses} and, before returning, evaluate the
@meta{finally-clause}.

The @meta{catch-clauses} argument must have the format:

@example
(catch @meta{var} @metao{catch-clause} @meta{catch-clause} ...)
@end example

@noindent
where @meta{var} must be an identifier and every @meta{catch-clause} has
one of the forms:

@example
(@meta{pred} @metao{tag-body} @meta{tag-body} ...)
(else @metao{else-body} @meta{else-body} ...)
@end example

@noindent
where the optional @clause{else} clause must appear only once as last
one.  The @meta{pred} argument must have one of the following recursive
formats:

@example
@meta{pred} = (@meta{tag})
      | (and @metao{inner-pred} @meta{inner-pred} ...)
      | (or  @metao{inner-pred} @meta{inner-pred} ...)
      | (xor @metao{inner-pred} @meta{inner-pred} ...)
      | (not @meta{inner-pred})

@meta{inner-pred} = @meta{tag}
            | (and @metao{inner-pred} @meta{inner-pred} ...)
            | (or  @metao{inner-pred} @meta{inner-pred} ...)
            | (xor @metao{inner-pred} @meta{inner-pred} ...)
            | (not @meta{inner-pred})
@end example

@noindent
where: @meta{tag} is a condition object type identifier; @syntax{and},
@syntax{or}, @syntax{xor}, @syntax{not} are the identifiers exported by
@library{vicare}.

The @meta{finally-clause} must have the format:

@example
(finally @metao{finally-body} @meta{finally-body} ...)
@end example

@noindent
when the @clause{finally} clause is present: the @meta{body} is wrapped
into an unwind--protection syntax, @xref{iklib unwind-protect, The
unwind-protection mechanism}.

The following expansions take place:

@itemize
@item
No else, no finally.

@example
(try
   @meta{body}
  (catch @meta{var}
    ((@meta{tag})
     @metao{tag-body}
     @meta{tag-body}
     ...)
    ...))
@expansion{} (guard (@meta{var}
              ((is-a? @meta{var})
               @metao{tag-body}
               @meta{tag-body}
               ...)
              ...)
      @meta{body})
@end example

@item
Else, no finally.

@example
(try
   @meta{body}
  (catch @meta{var}
    ((@meta{tag})
     @metao{tag-body}
     @meta{tag-body}
     ...)
    ...)
    (else
     @metao{else-body}
     @meta{else-body}
     ...))
@expansion{} (guard (@meta{var}
              ((is-a? @meta{var} @metao{tag})
               @metao{tag-body}
               @meta{tag-body}
               ...)
               ...
              (else
               @metao{else-body}
               @meta{else-body}
               ...))
      @meta{body})
@end example

@item
Finally, no else.

@example
(try
   @meta{body}
  (catch @meta{var}
    ((@meta{tag})
     @metao{tag-body}
     @meta{tag-body}
     ...)
    ...)
  (finally
    @metao{finally-body}
    @meta{finally-body}
    ...))
@expansion{} (with-unwind-protection
        (lambda (dummy)
          @metao{finally-body}
          @meta{finally-body}
          ...)
      (lambda ()
        (guard (@meta{var}
                ((is-a? @meta{var} @metao{tag})
                 @metao{tag-body}
                 @meta{tag-body}
                 ...)
                ...)
            @meta{body})))
@end example

@item
Finally, no catch.

@example
(try
    @meta{body}
  (finally
    @metao{finally-body}
    @meta{finally-body}
    ...))
@expansion{} (with-unwind-protection
        (lambda (dummy)
          @metao{finally-body}
          @meta{finally-body}
          ...)
      (lambda ()
        @meta{body}))
@end example
@end itemize
@end deffn


Some usage examples without the @clause{finally} clause:

@example
(import (vicare))

(define-condition-type &this
    &error
  make-this-condition
  condition-this?
  (a condition-this.a)
  (b condition-this.b)
  (c condition-this.c))

(define (doit thunk)
  (try
      (thunk)
    (catch E
      ((&this)
       (list (condition-this.a E)
             (condition-this.b E)
             (condition-this.c E)))
      ((&message)
       (condition-message E))
      (else E))))

(doit (lambda ()
        (raise (make-this-condition 1 2 3))))
@result{} (1 2 3)

(doit (lambda ()
        (raise (make-message-condition "ciao"))))
@result{} "ciao"

(doit (lambda ()
        (raise 123)))
@result{} 123
@end example

Evaluation order tracking for @clause{finally} clauses:

@lisp
(with-result
  (try
      (add-result 'body)
    (catch E
      ((&error)   (add-result 'catch-error))
      ((&warning) (add-result 'catch-warning))
      (else       (add-result 'catch-else)))
    (finally
     (add-result 'finally))))
@result{} (body (body finally))

(with-result
  (try
      (begin
        (add-result 'body)
        (raise (make-warning)))
    (catch E
      ((&error)   (add-result 'catch-error))
      ((&warning) (add-result 'catch-warning))
      (else       (add-result 'catch-else)))
    (finally
     (add-result 'finally))))
@result{} (catch-warning (body catch-warning finally))
@end lisp

@c page
@node iklib syntaxes splice1st
@subsection Splice first form syntax


@deffn Syntax splice-first-expand @meta{form}
When the use of a @func{splice-first-expand} syntax appears as first
subform of an enclosing form, @meta{form} must have the format:

@example
(@meta{rator} @meta{rand} ...)
@end example

@noindent
and it is spliced in the enclosing form, then the result is expanded:

@example
((splice-first-expand (@meta{rator} @meta{rand} ...) @meta{arg} ...)
@expansion{} (@meta{rator} @meta{rand} ... @meta{arg} ...)
@end example

When the use of a @func{splice-first-expand} syntax appears as second or
subsequent subform: it expands into @meta{form} itself, which is then
expanded:

@example
(splice-first-expand @meta{form})
@expansion{} @meta{form}
@end example

This syntax must be used with care.
@end deffn


Usage examples:

@example
(import (vicare))

(splice-first-expand 123)               @result{} 123
(splice-first-expand (+ 1 2))           @result{} 3

((splice-first-expand (+)) 1 2)           @result{} 3
((splice-first-expand (+) 1 2) 3 4)       @expansion{} (+ 1 2 3 4)

(let-syntax ((doit (syntax-rules ()
                     ((_ ?arg ...)
                      (+ (square ?arg) ...)))))
  ((splice-first-expand (doit 1 2)) 3 4))
@expansion{} (+ (square 1) (square 2) (square 3) (square 4))

(let-syntax ((arg1 (identifier-syntax 1))
             (arg2 (identifier-syntax 2))
             (doit (syntax-rules ()
                     ((_ ?arg ...)
                      (+ (square ?arg) ...)))))
  ((splice-first-expand (doit arg1 arg2)) 3 4))
@expansion{} (+ (square 1) (square 2) (square 3) (square 4))

(let*-syntax ((arg1 (identifier-syntax 1))
              (arg2 (identifier-syntax 2))
              (doit (syntax-rules ()
                      ((_ ?arg ...)
                       (+ (square ?arg) ...))))
              (flop (syntax-rules ()
                      ((_ ?arg ...)
                       (splice-first-expand
                        (doit arg1 ?arg ...))))))
  ((flop arg2) 3 4))
@expansion{} (+ (square 1) (square 2) (square 3) (square 4))

(let*-syntax ((arg1 (identifier-syntax 1))
              (arg2 (identifier-syntax 2))
              (doit (syntax-rules ()
                      ((_ ?arg ...)
                       (+ (square ?arg) ...))))
              (flop (syntax-rules ()
                      ((_ ?arg ...)
                       (splice-first-expand
                        (doit arg1 ?arg ...)))))
              (flip (syntax-rules ()
                      ((_ ?arg ...)
                       (flop ?arg ...)))))
  ((flip arg2) 3 4))
@expansion{} (+ (square 1) (square 2) (square 3) (square 4))
@end example

@c page
@node iklib syntaxes infix
@subsection Infix to prefix transformer


@deffn Syntax infix @meta{obj} @dots{}
The @func{infix} macro converts the traditional infix notation for
mathematical expressions to the equivalent Scheme's prefix notation.
@func{infix} expands to a prefix expression to be evaluated at
run--time, in the lexical context of the macro use; as a special case
@code{(infix)} is equivalent to @code{(values)}.
@end deffn

The macro allows us to evaluate forms like:

@example
(infix atan(1, 2))      @expansion{} (atan 1 2)
(infix 1 + 2 + 3)       @expansion{} (+ (+ 1 2) 3)
(infix 1 + 2 * 3)       @expansion{} (+ 1 (* 2 3))
(infix (1 + 2) * 3)     @expansion{} (* (+ 1 2) 3)

(infix 2 expt 3 expt 4) @expansion{} (expt 2 (expt 3 4))
(infix 2 ** 3 ** 4)     @expansion{} (expt 2 (expt 3 4))

(infix - 5)             @expansion{} (- 5)
(infix + 5)             @expansion{} (+ 5)
(infix 5 !)             @expansion{} (factorial 5)

(infix 1 > 2 ? 3 + 4 : 5 * 6)
@expansion{} (if (> 1 2) (+ 3 4) (* 5 6))

(define a 1)
(define b 2)
(define c 3)
(infix cos(a) * tan(b) / c)
@expansion{} (/ (* (cos a) (tan b)) c)
@end example

@menu
* iklib syntaxes infix syntax:: Notes on the supported syntax.
* iklib syntaxes infix prec::   Operators precedence.
* iklib syntaxes infix notes::  Random notes on the features.
@end menu

@c page
@node iklib syntaxes infix syntax
@subsubsection Notes on the supported syntax


Some expression syntax interpretation rules:

@itemize
@item
Any Scheme value can be element of the input form; numbers and all the
other values are just put there as operands.

@example
#!vicare
(infix list("ciao", 'hello, '#ve(ascii "salut")))
@result{} ("ciao" hello #ve(ascii "salut"))
@end example

@item
The following bound identifiers exported by @library{vicare} are
interpreted as binary infix operators:

@example
+ - * / div div0 mod mod0 expt
fl+ fl- fl* fl/ flexpt
fx+ fx- fx* fxdiv fxdiv0 fxmod fxmod0
< > <= >= = !=
fx<? fx>? fx<=? fx>=? fx=?
fl<? fl>? fl<=? fl>=? fl=?
eq? eqv? equal?
and or xor
bitwise-and bitwise-ior bitwise-xor
bitwise-arithmetic-shift-left
bitwise-arithmetic-shift-right
fxand fxior fxxor
fxarithmetic-shift-left
fxarithmetic-shift-right
@end example

@noindent
in addition the following identifiers are recognised by their symbol
name and interpreted as aliases of binary infix operators:

@example
&&              @expansion{} and
\x23D0;\x23D0;  @expansion{} or
\x00AC;         @expansion{} not
\x2227;         @expansion{} and
\x2228;         @expansion{} or
\x22BB;         @expansion{} xor
==              @expansion{} =
<>              @expansion{} !=
\x00D7;         @expansion{} *
\x22C5;         @expansion{} *
**              @expansion{} expt
%               @expansion{} mod
&               @expansion{} bitwise-and
\x23D0;         @expansion{} bitwise-ior
^               @expansion{} bitwise-xor
<<              @expansion{} bitwise-arithmetic-shift-left
>>              @expansion{} bitwise-arithmetic-shift-right
@end example

@noindent
where the symbols with escape sequences are:

@table @samp
@item \x00AC;
Unicode character not sign.

@item \x00D7;
Unicode character times.

@item \x2227;
Unicode character logical and.

@item \x2228;
Unicode character logical or.

@item \x22BB;
Unicode character xor.

@item \x22C5;
Unicode character dot operator.

@item \x23D0;
Unicode character vertical bar extension.
@end table

@item
The following bound identifiers exported by @library{vicare} are
interpreted as unary prefix operators:

@example
+ - ++ --
fx+ fx- fl+ fl-
not bitwise-not fxnot
@end example

@noindent
in addition the following identifiers are recognised by their symbol
name and interpreted as aliases of unary prefix operators:

@example
!       @expansion{} not
~       @expansion{} bitwise-not
@end example

@item
The following bound identifiers exported by @library{vicare} are
interpreted as unary postfix operators:

@example
++ --
@end example

@noindent
in addition the following identifiers are recognised by their symbol
name and interpreted as aliases of unary postfix operators:

@example
!       @expansion{} factorial
@end example

@item
Almost all the binary infix operators are left--associative with the
exception of @func{expt} and @func{flexpt} which are right--associative:

@example
;; left-associative
(infix 10 - 5 - 3)              @expansion{} (- (- 10 5) 3)
(infix 10 - 5 - 3)              @expansion{} (- 10 5 3)
(infix 10 / 5 / 3)              @expansion{} (/ (/ 10 5) 3)
(infix 10 / 5 / 3)              @expansion{} (/ 10 5 3)

;; right-associative
(infix 10 expt 5 expt 3)        @expansion{} (expt 10 (expt 5 3))
@end example

@item
The identifiers @func{++} and @func{--} are unary operators that can be
applied to expressions both in prefix and postfix positions.  They
expand as follows:

@example
#!vicare
(infix ++ X)            @expansion{} (pre-incr! X)
(infix -- X)            @expansion{} (pre-decr! X)
(infix X ++)            @expansion{} (post-incr! X)
(infix X --)            @expansion{} (post-decr! X)
@end example

@noindent
where @func{pre-incr!}, @func{pre-decr!}, @func{post-incr!} and
@func{post-decr!} are the bindings exported by @library{vicare}.

@item
The ternary conditional operator involves the identifiers @func{?}  and
@func{:}, which are recognised by their symbol name.

@example
(infix 1 > 2 ? 3 + 4 : 5 * 6)
@expansion{} (if (> 1 2) (+ 3 4) (* 5 6))
@end example

@item
Identifiers which are not operators are interpreted as variable
references.

@item
If an identifier is followed by a left parenthesis: it is interpreted as
the binding of a procedure in a procedure application.  Procedure
application requires the arguments to be grouped in a list, using the
comma as separator.

@example
(define (fun a b c)
  (+ a b c))

(infix fun (1, 2, 3))   @expansion{} (fun 1 2 3)
@end example

@quotation
@strong{NOTE} The Scheme reader transforms the sequence:

@example
, @meta{form}
@end example

@noindent
into:

@example
(unsyntax @meta{form})
@end example

@noindent
so the list of arguments is:

@example
( @metai{arg} (unsyntax @meta{arg}) ... )
@end example

@rnrs{6} does not define the comma to be a delimiter, so writing:

@example
func (@metai{arg}, @meta{arg}, ...)
@end example

@noindent
with no space between the @meta{arg} and the comma is a syntax error in
strict @rnrs{6} implementations.  @value{PRJNAME} extends the reader to
handle the comma as a delimiter, so the above expression is valid in the
@func{infix} syntax.
@end quotation

@item
The identifiers @func{quote}, @func{quasiquote}, @func{syntax} and
@func{quasisyntax} are not subject to infix to prefix conversion; the
use of such syntaxes just expands to the prefix object:

@example
(infix (quote       ciao))  @expansion{} (quote ciao)
(infix (quasiquote  ciao))  @expansion{} (quasiquote ciao)
(infix (syntax      ciao))  @expansion{} (syntax ciao)
(infix (quasisyntax ciao))  @expansion{} (quasisyntax ciao)
@end example

@item
Matched left and right round parentheses are used to group
subexpressions, overriding operators precedence rules.
@end itemize

@c page
@node iklib syntaxes infix prec
@subsubsection Operators precedence


To determine sensible precedences for operators, we make the following
observations:

@itemize
@item
Logical operators (@func{and}, @func{or}, @func{not}, @dots{}) are meant
to be applied to predicate operand expressions and they return a boolean
value.

@item
Numeric comparison operators (@func{=}, @func{<}, @func{>}, @dots{}) are
meant to be applied to numeric operand expressions and they return a
boolean value.

@item
Arithmetic operators (@func{+}, @func{-}, @func{*}, @func{/}, @dots{})
are meant to be applied to numeric operand expressions and they return a
numeric value.

@item
The C language has established a tradition of writing expressions
containing bitwise operators @code{1 & 2 + ~ 3} meaning @code{(1 & 2) +
(~ 3)}, in which bitwise operators take precedence over every other
operator.

@item
It makes sense to write expressions like @code{1 < i and i < 4} meaning
@code{(1 < i) and (i < 4)}, because it makes no sense to interpret it as
@code{1 < (i and i) < 4}.

@item
It makes sense to write expressions like @code{1 + 2 < 3 + 4} meaning
@code{(1 + 2) < (3 + 4)}, because it makes no sense to interpret it as
@code{1 + (2 < 3) + 4}.
@end itemize

So @value{PRJNAME} defines operators precedence as follows, from high
precedence to low precedence:

@enumerate
@item
Procedure application: the left parenthesis preceeded by an identifier
starts a procedure application.

@item
Binary infix bitwise shift operators:

@example
bitwise-arithmetic-shift-left
bitwise-arithmetic-shift-right
fxarithmetic-shift-left
fxarithmetic-shift-right
@end example

@item
Unary prefix bitwise operators:

@example
bitwise-not fxnot
@end example

@item
Binary infix bitwise operators:

@example
bitwise-and bitwise-ior bitwise-xor
fxand fxior fxxor
@end example

@item
Unary prefix arithmetic operators:

@example
+ - ++ -- fx+ fx- fl+ fl-
@end example

@item
Unary postfix arithmetic operators:

@example
++ -- !
@end example

@item
Binary infix arithmetic exponentiation operators:

@example
expt flexpt
@end example

@item
Binary infix arithmetic modulo operators:

@example
mod mod0 fxmod fxmod0
@end example

@item
Binary infix multiplication and division arithmetic operators:

@example
* / div div0 fl* fl/ fx* fxdiv fxdiv0
@end example

@item
Binary infix addition and subtraction arithmetic operators:

@example
+ - fl+ fl- fx+ fx-
@end example

@item
Comparison operators:

@example
< > <= >= = !=
fx<? fx>? fx<=? fx>=? fx=?
fl<? fl>? fl<=? fl>=? fl=?
eq? eqv? equal?
@end example

@item
Unary prefix logical operators:

@example
not
@end example

@item
Binary infix logical operators:

@example
and or xor
@end example

@item
Ternary conditional operator @code{@dots{} ? @dots{} : @dots{}}.

@item
Procedure application arguments separator, which is the comma.
@end enumerate

Here some expansion examples:

@example
(infix ! 2 + 3)         @expansion{} (not (2 + 3))
(infix (! 2) + 3)       @error{} expected numeric argument

(infix fxnot 3)         @result{} -3
(infix fxnot 3 + 10)    @result{} 7

(infix ! cos(3))        @expansion{} (not (cos 3))
@end example

@c page
@node iklib syntaxes infix notes
@subsubsection Random notes on the features


@subsubheading About the exponentiation and bitwise XOR operators

The @func{infix} macro uses @samp{**} as exponentiation operator and
@samp{^} as bitwise XOR operator; this is controversial because a lot of
people, especially LaTeX users, is used to think of @samp{^} as
exponentiation operator.  The C language has established a tradition to
interpret @samp{^} as bitwise exclusive OR operator, and the Python
language has adopted it; @value{PRJNAME} sticks to it, too.

@subsubheading About the vertical bar

The C language has established a tradition of interpreting the single
vertical bar @samp{|} as bitwise inclusive OR operator and the double
vertical bar as @samp{||} as logical inclusive OR operator.

In the @rnrs{6} Scheme language the vertical bar is used in the block
comments delimiters @samp{#| @dots{} |#}.  @value{PRJNAME}'s source code
reader uses the vertical bar to specify symbols whose name does not
comply with @rnrs{6}, @ref{iklib reader stx, Miscellaneous additional
syntaxes}.  Some text editors for software programmers handle the
vertical bar specially in Scheme mode, in particular for syntax
highlighting.

It would be possible to extend @value{PRJNAME}'s reader to allow
@samp{|} and @samp{||} to be symbols, but, at present, this confuses
some text editors in a way that is not easy to fix.  So, for now, rather
than the vertical bar, @func{infix} recognises the Unicode character
vertical bar extension (@samp{\x23D0;}) as bitwise inclusive OR and the
double vertical bar extension as logical inclusive OR.

@c page
@node iklib syntaxes increments
@subsection Incrementing and decrementing


@deffn Syntax {++} @meta{expr}
@deffnx Syntax {++} @meta{expr} @meta{step}
Increment @meta{expr} by @meta{step} and return the result.  Both
@meta{expr} and @meta{step} must be expressions evaluating to a number
object; when @meta{step} is not given: it defaults to the fixnum
@code{1}.

As special case, when @meta{expr} is an identifier: the syntax expands
as follows:

@example
#!vicare
(++ @meta{id} @meta{step})
@expansion{} (begin
      (set! @meta{id} (+ @meta{id} @meta{step}))
      @meta{id})
@end example
@end deffn


@deffn Syntax pre-incr! @meta{expr}
@deffnx Syntax pre-incr! @meta{expr} @meta{step}
Alias for @func{++}.
@end deffn


@deffn Syntax post-incr! @meta{expr}
@deffnx Syntax post-incr! @meta{expr} @meta{step}
Increment @meta{expr} by @meta{step} and return the result.  Both
@meta{expr} and @meta{step} must be expressions evaluating to a number
object; when @meta{step} is not given: it defaults to the fixnum
@code{1}.

As special case, when @meta{expr} is an identifier: the syntax expands
as follows:

@example
(post-incr! @meta{id} @meta{step})
@expansion{} (receive-and-return (v)
        @meta{id}
      (set! @meta{id} (+ @meta{id} @meta{step})))
@end example
@end deffn


@deffn Syntax @code{--} @meta{expr}
@deffnx Syntax @code{--} @meta{expr} @meta{step}
Decrement @meta{expr} by @meta{step} and return the result.  Both
@meta{expr} and @meta{step} must be expressions evaluating to a number
object; when @meta{step} is not given: it defaults to the fixnum
@code{1}.

As special case, when @meta{expr} is an identifier: the syntax expands
as follows:

@example
#!vicare
(-- @meta{id} @meta{step})
@expansion{} (begin
      (set! @meta{id} (- @meta{id} @meta{step}))
      @meta{id})
@end example
@end deffn


@deffn Syntax pre-decr! @meta{expr}
@deffnx Syntax pre-decr! @meta{expr} @meta{step}
Alias for @func{--}.
@end deffn


@deffn Syntax post-decr! @meta{expr}
@deffnx Syntax post-decr! @meta{expr} @meta{step}
Decrement @meta{expr} by @meta{step} and return the result.  Both
@meta{expr} and @meta{step} must be expressions evaluating to a number
object; when @meta{step} is not given: it defaults to the fixnum
@code{1}.

As special case, when @meta{expr} is an identifier: the syntax expands
as follows:

@example
(post-decr! @meta{id} @meta{step})
@expansion{} (receive-and-return (v)
        @meta{id}
      (set! @meta{id} (- @meta{id} @meta{step})))
@end example
@end deffn

@c page
@node iklib syntaxes unsafe
@subsection Unsafe binding variants


Whenever we apply a function to a tuple of arguments of which we know at
compile--time the type is correct: we can avoid run--time arguments type
validation; it would be ideal to replace the call to an
argument--validating (safe) function with a call to a non--validating
(unsafe) function.  This is what the expander does with unsafe variants.

The @dfn{unsafe variant} of a function is a syntax object representing a
Scheme expression which, expanded by itself and evaluated at run--time,
returns a function that does not validate the type of its arguments.  As
example, the function:

@example
#!vicare
(import (vicare))

(define* (@{string-ref-fx fixnum?@} @{str string?@} @{idx fixnum?@})
  (import (vicare system $chars)
    (vicare system $strings))
  (assert (and (fx<=? 0 idx)
               (fx<?  idx (string-length str))))
  ($char->fixnum ($string-ref str idx)))
@end example

@noindent
can be split into:

@example
(define* (@{string-ref-fx fixnum?@} @{str string?@} @{idx fixnum?@})
  (unsafe.string-ref-fx str idx))

(define (unsafe.string-ref-fx str idx)
  (import (vicare system $chars)
          (vicare system $strings))
  (assert (and ($fxnonnegative? idx)
               ($fx< idx ($string-length str))))
  ($char->fixnum ($string-ref str idx)))
@end example

@noindent
where the function @func{unsafe.string-ref-fx} is an unsafe implementation of
@func{string-ref-fx}; in this case the syntax object:

@example
(syntax unsafe.string-ref-fx)
@end example

@noindent
is the unsafe variant of @func{string-ref-fx}; the unsafe variants
@api{} allows us to register this fact, for use by the expander, as
follows:

@example
(import (prefix (vicare expander) xp.))

(begin-for-syntax
  (xp.typed-procedure-variable.unsafe-variant-set!
     #'string-ref-fx #'unsafe.string-ref-fx))
@end example

All this infrastructure is automatically implemented by the expander
when we use the tagged language and the built--in @func{define} syntax;
the expander will use the prefix @samp{~} to generate the unsafe
function name.  So it is enough for us to write:

@example
#!vicare
(program (demo)
  (options typed-language)
  (import (vicare))

  (define (@{string-ref-fx <fixnum>@} @{str <string>@} @{idx <fixnum>@})
    (import (vicare system $chars)
      (vicare system $strings))
    (assert (and ($fxnonnegative? idx)
                 ($fx< idx ($string-length str))))
    ($char->fixnum ($string-ref str idx)))

  ---)
@end example

@noindent
whenever the expander finds:

@example
(string-ref-fx "ciao" 2)
@end example

@noindent
it can validate the arguments and replace the form with:

@example
(~string-ref-fx "ciao" 2)
@end example

We still need to hand--write validations involving multiple arguments.


@deffn Syntax unsafe @meta{safe.id}
Expand into the syntax object registered as unsafe variant of the
identifier @var{safe.id}; raise a syntax violation if @meta{safe.id} has
no unsafe variant.
@end deffn


The following syntactic bindings are exported by the library
@library{vicare expander}.


@defun typed-procedure-variable.unsafe-variant-set! @meta{safe.id} @meta{unsafe.stx}
Specify that the unsafe variant of the binding for the identifier
@meta{safe.id} is the expression in the syntax object @meta{unsafe.stx}.
@meta{unsafe.stx} is stored as syntax object and it is expanded and
evaluated at each use of the unsafe variant.
@end defun


@defun typed-procedure-variable.unsafe-variant @var{safe.id}
Return the syntax object registered as unsafe variant of the bound
identifier @var{safe.id}; return @false{} if @var{safe.id} has no unsafe
variant.
@end defun

@c page
@node iklib syntaxes misc
@subsection Miscellaneous syntaxes


@deffn Syntax endianness @meta{endianness-symbol}
Extend the syntax defined by @rnrs{6}.  The name of
@meta{endianness-symbol} must be a symbol describing an endianness.
Supported symbols are @code{big}, @code{little}, @code{network} an
@code{native}; @code{network} is converted to @code{big}, @code{native}
is converted to the return value of @code{(native-endianness)}.
@end deffn


@deffn {Fluid Syntax} __who__
A fluid syntax to be bound to the quoted name of the function being
executed; it can be used as argument for the @condition{who} condition
object.  It is meant to be used as follows:

@example
(define (func arg)
  (fluid-let-syntax
      ((__who__ (identifier-syntax (quote func))))
    ---))
@end example
@end deffn


@deffn {Identifier Syntax} __file__
Expand to a quoted string representing the source code location, for
example the source file pathname.
@end deffn


@deffn {Identifier Syntax} __line__
Expand to @false{} or a number representing the line number.
@end deffn


@deffn {Fluid Syntax} brace
A fluid syntax which is free to be bound to whatever user code needs.
When the Scheme code reader is in @code{#!vicare} mode: brace lists are
read as @func{brace} forms as follows:

@example
@{@}              @expansion{} (brace)
@{1 2 3@}         @expansion{} (brace 1 2 3)
@{1 . 2@}         @expansion{} (brace 1 . 2)
@end example
@end deffn


@deffn {Fluid Syntax} {<>}
A fluid syntax which is free to be bound to whatever user code needs.
It is meant to be a placeholder for some expression defined by the local
context; for example: it is used by the syntaxes @func{is-a?},
@func{slot-ref} and @func{slot-set!}.
@end deffn


@deffn Syntax begin-for-syntax @metao{body} @meta{body} @dots{}
@deffnx Syntax eval-for-expand @metao{body} @meta{body} @dots{}
Evaluate the @meta{body} forms at expand time; these syntaxes count as
definitions in a body.  Notice that definitions in the body are visible
by other code evaluated for expand:

@example
(begin-for-syntax
  (define a 1))

(begin-for-syntax
  (define b 2))

(begin-for-syntax
  (define c (+ a b)))

(define-syntax (doit stx)
  #`(quote (#,a #,b #,c)))

(doit)          @result{} (1 2 3)
@end example
@end deffn


@deffn Syntax set-cons! @meta{who} @meta{obj}
Expand to:

@example
(set! @meta{who} (cons @meta{obj} @meta{who}))
@end example
@end deffn


@deffn Syntax values->list @meta{expr}
Evaluate the expression and return its return values as a list.
Examples:

@example
(values->list 123)
@result{} (123)

(values->list (values 1 2 3))
@result{} (1 2 3)
@end example
@end deffn

@c page
@node iklib syntaxes properties
@subsection Syntactic binding properties


It is sometimes useful to attach properties to syntactic bindings; the
following @api{} does so.  The following functions will fail if the
argument @var{id} is not a bound identifier.


@defun syntactic-binding-putprop @var{id} @var{key} @var{value}
Like @func{putprop} for symbols, but set a property for the identifier
@var{id}.  @var{key} must be a symbol; @var{value} can be any values.
Return unspecified values.
@end defun


@defun syntactic-binding-getprop @var{id} @var{key}
Like @func{getprop} for symbols, but retrieve a property for the
identifier @var{id}.  @var{key} must be a symbol.  Return the property
value or @false{} if the property is not set.
@end defun


@defun syntactic-binding-remprop @var{id} @var{key}
Like @func{remprop} for symbols, but remove a property for the
identifier @var{id}; nothing happens if the property is not set.
@var{key} must be a symbol.  Return unspecified values.
@end defun


@defun syntactic-binding-property-list @var{id}
Like @func{property-list} for symbols, but retrieve the property list
for the identifier @var{id}.  Return the property list or null if no
property is set.
@end defun


We have to remember that when evaluating the syntax:

@example
(define-syntax @meta{lhs} @meta{rhs})
@end example

@noindent
the identifier @meta{lhs} is already bound when the expression
@meta{rhs} is evaluated to acquire the transformer function; the same
happens for:

@example
(letrec-syntax ((@meta{lhs} @meta{rhs}))
  @meta{body})
@end example

@noindent
but it does @strong{not} happen for:

@example
(let-syntax ((@meta{lhs} @meta{rhs}))
  @meta{body})
@end example

@noindent
when the expression @meta{rhs} is evaluated, the identifier @meta{lhs}
is still unbound.

So the following example will work:

@example
(define-syntax ciao
  (let ()
    (syntactic-binding-putprop #'ciao 'a 123)
    (lambda (stx) #t)))

(define-syntax (doit stx)
  (syntactic-binding-getprop #'ciao 'a))

(doit)          @result{} 123
@end example

@noindent
notice that here the syntax @func{ciao} is never used; the following
example will also work:

@example
(define-syntax (ciao stx)
  #t)

(define-syntax (doit stx)
  (syntactic-binding-getprop #'ciao 'a))

(begin-for-expand
  (syntactic-binding-putprop #'ciao 'a 123))

(doit)          @result{} 123
@end example

@noindent
and the following will work, too:

@example
(letrec-syntax
    ((ciao (let ()
             (syntactic-binding-putprop #'ciao 'a 123)
             (lambda (stx) #t))))
  (define-syntax (doit stx)
    (syntactic-binding-getprop #'ciao 'a))
  (doit))
@result{} 123
@end example

@noindent
to define a binding property for a syntax defined by @func{let-syntax}
we can do:

@example
(let-syntax ((ciao (lambda (stx) #t)))
  (define-syntax (doit stx)
    (syntactic-binding-getprop #'ciao 'a))
  (begin-for-expand
    (syntactic-binding-putprop #'ciao 'a 123))
  (doit))
@result{} 123
@end example

To define a binding property for a lexical variable bound by
@func{define}:

@example
(define ciao "ciao")

(define-syntax (doit stx)
  (syntactic-binding-getprop #'ciao 'a))

(begin-for-expand
  (syntactic-binding-putprop #'ciao 'a 123))

(doit)          @result{} 123
@end example

@noindent
and for one bound by @func{let}:

@example
(let ((ciao "ciao"))
  (define-syntax (doit stx)
    (syntactic-binding-getprop #'ciao 'a))
  (begin-for-expand
    (syntactic-binding-putprop #'ciao 'a 123))
  (doit))
@result{} 123
@end example

@c page
@node iklib syntaxes predaux
@subsection Predicate auxiliary functions


Predicate functions, both type predicates like @func{list?} and other
predicates, are used to validate procedure arguments and their return
values.  The predicates auxiliary functions @api{} assumes that it is
useful to associate to certain predicate procedures:

@itemize
@item
A procedure that validates a tuple of values and when failing: raises an
exception with condition object type
@condition{procedure-argument-violation}, @ref{iklib conditions procarg,
Procedure argument violations}.

@item
A procedure that validates a tuple of values and when failing: raises an
exception with condition object type
@condition{expression-return-value-violation}, @ref{iklib conditions
exprret, Expression return value violations}.
@end itemize

Such auxiliary functions are made available through syntactic binding
properties by just importing in the current lexical contour the
identifier bound to the predicate function.

As example, we can associate a procedure argument auxiliary function to
@func{list?} as follows:

@example
(define (assert-list-procedure-argument who obj)
  (if (list? obj)
      obj
    (procedure-argument-violation who
      "expected list object as argument" obj)))

(begin-for-syntax
  (set-predicate-assertion-procedure-argument-validation! #'list?
    #'assert-list-procedure-argument))

((predicate-procedure-argument-validation list?) 'hey '(1 2 3))
@result{} (1 2 3)

((predicate-procedure-argument-validation list?) 'hey '#(1 2 3))
@error{} &procedure-argument-violation
@end example

@noindent
and we can associate a return value auxiliary function to @func{list?}
as follows:

@example
(define (assert-list-return-value who obj)
  (if (list? obj)
      obj
    (expression-return-value-violation who
      "expected list object as argument" obj)))

(begin-for-syntax
  (set-predicate-assertion-return-value-validation! #'list?
    #'assert-list-return-value?))

((predicate-return-value-validation list?) 'hey '(1 2 3))
@result{} (1 2 3)

((predicate-return-value-validation list?) 'hey '#(1 2 3))
@error{} &expression-return-value-violation
@end example


@defun set-predicate-assertion-procedure-argument-validation! @var{pred-id} @var{valid-stx}
@defunx predicate-assertion-procedure-argument-validation @var{pred-id}
Setter and getter for assertion procedure associated to a predicate
function.

The setter specifies that the predicate identifier @var{pred-id} is
associated to the procedure argument validation function resulting from
the expansion and evaluation of the syntax object @var{valid-stx}.
@var{valid-stx} is stored as syntax object and it is expanded and
evaluated at each use of the validation function.
@end defun


@deffn Syntax predicate-procedure-argument-validation @meta{pred-id}
Expand into an expression representing the procedure argument validation
function associated to the predicate @meta{pred-id}.  If no validation
function is available: raise a syntax violation.
@end deffn


@defun set-predicate-assertion-return-value-validation! @var{pred-id} @var{valid-stx}
@defunx predicate-assertion-return-value-validation @var{pred-id}
Setter and getter for assertion procedure associated to a predicate
function.

The setter specifies that the predicate identifier @var{pred-id} is
associated to the return value validation function resulting from the
evaluation of the expansion and evaluation of the syntax object
@var{valid-stx}.  @var{valid-stx} is stored as syntax object and it is
expanded and evaluated at each use of the validation function.
@end defun


@deffn Syntax predicate-return-value-validation @meta{pred-id}
Expand into an expression representing the return value validation
function associated to the predicate @meta{pred-id}.  If no validation
function is available: raise a syntax violation.
@end deffn

@c page
@node iklib syntaxes type-of
@subsection Determining the type of expressions


@deffn Syntax type-of @meta{expr}
This syntax is for interactive use only.  Fully expand the given
expression in the current lexical environment and return a structure of
type @objtype{retvals-signature} representing the types of the tuple of
returned values.  The expression is @strong{not} evaluated, only
expanded; this means that the expansion side effects are performed.

Example session at the @repl{}:

@example
vicare> (type-of (values))
$1 = #["retvals-signature" ()]

vicare> (type-of (values 1 2))
$1 = #["retvals-signature" (#'<fixnum> #'<fixnum>)]

vicare> (type-of 123)
$1 = #["retvals-signature" (#'<fixnum>)]

vicare> (type-of ((lambda (@{_ symbol@}) 'ciao)))
$1 = #["retvals-signature" (#'<symbol>)]
@end example
@end deffn


@defun print-identifier-info @var{id}
Given an identifier object: print on the current error port a report on
its properties as identifier; return unspecified values.
@end defun

@c page
@node iklib syntaxes expansion-of
@subsection Inspecting expansion results


@deffn Syntax expansion-of @meta{expr}
This syntax is mostly for interactive use.  Fully expand the given
expression in the current lexical environment and return a symbolic
expression representing the resulting invoke code.  The expression is
@strong{not} evaluated, only expanded; this means that the expansion
side effects are performed.

As a special case if @meta{expr} is recognised as a @func{define} or
@func{define*} syntax use:

@example
(define  . @meta{stuff})
(define* . @meta{stuff})
@end example

@noindent
the expansion will be performed as if @meta{expr} is:

@example
(internal-body (define  . @meta{stuff}) (void))
(internal-body (define* . @meta{stuff}) (void))
@end example

@noindent
and the definition extracted from the result and reformatted.

Example session at the @repl{}:

@example
vicare> (import (vicare expander tags))
vicare> (print-gensym #f)

vicare> (expansion-of (+ 1 2))
$1 = ((primitive +) (quote 1) (quote 2))

vicare> (expansion-of (lambda (a b) (+ a b)))
$1 = (lambda (a b) ((primitive +) a b))

vicare> (internal-body
          (define-syntax (doit stx)
            (syntax-case stx ()
              ((_ ?a ?b)
               #'(vector ?a ?b))))
          (expansion-of (doit 1 2)))
$1 = ((primitive vector) (quote 1) (quote 2))

vicare> (internal-body
          (define-struct alpha
            (a b c))
          (define O
            (alpha (1 2 3)))
          (expansion-of (slot-ref O a)))
$1 = (alpha-a O)

vicare> (expansion-of (define (fun a) (+ 1 a)))
$1 = (define fun (lambda (a) ((primitive +) (quote 1) a)))
@end example
@end deffn


@deffn Syntax visit-code-of @meta{macro-id}
This syntax is mostly for interactive use.  Given the identifier of a
locally defined macro keyword: expand into a quoted symbolic expression
representing the expanded macro transformer.

Example session at the @repl{}:

@example
vicare> (print-gensym #f)
vicare> (define-syntax syn (lambda (stx) #'(void)))
vicare> (visit-code-of syn)
$1 = (lambda (stx) #<syntax expr=(void))
@end example
@end deffn


@deffn Syntax expansion-of* @metao{expr} @meta{expr} @dots{}
Like @syntax{expansion-of}, but wrap the input expression as follows:

@lisp
(internal-body @metao{expr} @meta{expr} @dots{} (void))
@end lisp

@noindent
this allows the expansion of definition forms.
@end deffn

@c page
@node iklib syntaxes optim-of
@subsection Inspecting optimisation results


@deffn Syntax optimisation-of @meta{expr}
This syntax is mostly for interactive use.  Fully expand the given
expression in the current lexical environment and apply the compiler's
optimisator to the resulting core language expression; return a symbolic
expression representing the resulting invoke code.  The expression is
@strong{not} evaluated, only expanded and optimised; this means that the
expansion side effects are performed.

@quotation
@strong{NOTE} Only expressions are expanded and optimised.  It makes no
sense to give a standalone @func{define} syntax to this macro; when a
standalone function definition is expanded and optimised: the function
is never called, so it is removed.
@end quotation

Example session at the @repl{}:

@example
vicare> (print-gensym #f)

vicare> (optimisation-of (+ 1 2))
$1 = 3
@end example

@quotation
@strong{NOTE} The level of optimisation of source code is configured by
the @option{-O} options; @option{-O0} turns off the source optimiser.
The default is equivalent to @option{-O2}.
@end quotation
@end deffn


@deffn Syntax optimisation-of* @metao{expr} @meta{expr} @dots{}
Like @syntax{optimisation-of}, but wrap the input expression as follows:

@lisp
(internal-body @metao{expr} @meta{expr} @dots{} (void))
@end lisp

@noindent
this allows the expansion and optimisation of definition forms.
Example of @repl{} session:

@example
vicare> (pretty-width 65)
vicare> (print-gensym #f)
vicare> (optimisation-of*
   (define-record-type frob)
   (define it (make-frob)))
$1 = (let* ((lex.frob-rtd_0
        (make-record-type-descriptor 'frob '#f '#f '#f '#f '#()))
       (lex.frob-rcd_0
        (make-record-constructor-descriptor lex.frob-rtd_0 '#f
          '#f))
       (lex.make-frob_0 (record-constructor lex.frob-rcd_0)))
  (begin (lex.make-frob_0) '#<void>))
@end example
@end deffn


@deffn Syntax further-optimisation-of @meta{expr}
Like @func{optimisation-of}, but in addition perform some compiler
passes that additionally optimise the code.

Example session:

@example
(further-optimisation-of
  (let ((x (read)))
    (when (fixnum? x)
      (gcd x 2))))
@result{} (let ((x_0 (read)))
     (if (fixnum? x_0)
         ($gcd-fixnum-fixnum
            (known x_0
              (T:fixnum T:non-false T:exact-real T:real
               T:exact-integer T:exact T:number T:immediate
               T:object))
            (known (constant 2)
              (T:fixnum T:positive T:non-false T:exact-real
               T:real T:exact-integer T:exact T:number
               T:immediate T:object)))
         (constant #<void>)))
@end example
@end deffn


@deffn Syntax further-optimisation-of* @metao{expr} @meta{expr} @dots{}
Like @syntax{further-optimisation-of}, but wrap the input expression as
follows:

@lisp
(internal-body @metao{expr} @meta{expr} @dots{} (void))
@end lisp

@noindent
this allows the expansion and optimisation of definition forms.  Example
of @repl{} session:

@example
vicare> (pretty-width 65)
vicare> (print-gensym #f)
vicare> (further-optimisation-of*
   (define-record-type frob)
   (define it (make-frob)))
$1 = (let* ((lex.frob-rtd_0
        (make-record-type-descriptor
          (known 'frob
            (T:symbol T:non-false T:nonimmediate T:object))
          (known '#f (T:false T:boolean T:immediate T:object))
          (known '#f (T:false T:boolean T:immediate T:object))
          (known '#f (T:false T:boolean T:immediate T:object))
          (known '#f (T:false T:boolean T:immediate T:object))
          (known '#()
            (T:vector T:non-false T:nonimmediate T:object))))
       (lex.frob-rcd_0
        (make-record-constructor-descriptor lex.frob-rtd_0
          (known '#f (T:false T:boolean T:immediate T:object))
          (known '#f (T:false T:boolean T:immediate T:object))))
       (lex.make-frob_0 (record-constructor lex.frob-rcd_0)))
  (begin
    ((known lex.make-frob_0
       (T:procedure T:non-false T:nonimmediate T:object)))
    '#<void>))
@end example
@end deffn

@c page
@node iklib syntaxes assembly-of
@subsection Inspecting assembly language results


@deffn Syntax assembly-of @meta{expr}
This syntax is mostly for interactive use.  Fully expand the given
expression in the current lexical environment and apply the compiler's
passes to the resulting core language expression as if to produce a code
object; return a list of sublists, each sublist representing assembly
language instructions for a code object.  The expression is @strong{not}
evaluated, only expanded and compiled to assembly; this means that the
expansion side effects are performed.

@quotation
@strong{NOTE} Only expressions are expanded and compiled.  It makes no
sense to give a standalone @func{define} syntax to this macro; when a
standalone function definition is expanded and optimised: the function
is never called, so it is removed.
@end quotation

@quotation
@strong{NOTE} At present the return value of this macro is not very
human friendly; some preprocessing and a specialised printer are needed.
@end quotation
@end deffn

@c page
@node iklib unwind-protect
@section The unwind--protection mechanism


Unwind--protection allows operations to be performed synchronously with
respect to the dynamic extent of a call to thunk; the mechanism is
sophisticated because there are multiple, sophisticated ways to exit the
dynamic extent of a function call.  The typical application is to
release resources, like input/output ports and database connections.
@ref{resources, Allocating and releasing resources}, for an overview of
resource management under @value{PRJNAME}.

To understand the unwind--protection mechanism we must understand the
concepts ``dynamic extent of a function call'' and ``dynamic
environment'' ad defined by @rnrs{6} (@pxref{scheme basic dynamic
extent}).  @ref{dynamic environment, Notes on the dynamic environment}.

The unwind--protection mechanism described here is used by
@value{PRJNAME} in: the implementation of compensations (@pxref{iklib
compensations}); the implementation of the syntax @syntax{try}
(@pxref{iklib syntaxes try}); the implementation of condition handlers
and restarts (@libsref{restarts, Signalling conditions and restarts}).

@quotation
@strong{NOTE} The unwind protection mechanism may misbehave in some
cases, so do not trust it blindly (@pxref{iklib unwind-protect
problems}).
@end quotation

@menu
* iklib unwind-protect intro::       Introduction to the unwind
                                     protection mechanism.
* iklib unwind-protect syntaxes::    Unwind-protection syntaxes.
* iklib unwind-protect dynamic::     On the meaning of dynamic extent
                                     termination.
* iklib unwind-protect except 1::    Raising non-continuable exceptions
                                     from the thunk.
* iklib unwind-protect except 2::    Raising continuable exceptions
                                     from the thunk.
* iklib unwind-protect except 3::    Raising exceptions from the
                                     unwind handler.
* iklib unwind-protect loops::       Use with loop syntaxes.
* iklib unwind-protect returnable::  Use with returnable bodies.
* iklib unwind-protect coroutines::  Use with coroutines.
* iklib unwind-protect reenter::     Handling reentering continuations.
* iklib unwind-protect dyn-env::     Clean-up thunks and the dynamic
                                     environment.
* iklib unwind-protect problems::    Known problems.
* iklib unwind-protect call/cc::     Unwinding @func{call/cc}.
@end menu

@c page
@node iklib unwind-protect intro
@subsection Introduction to the unwind--protection mechanism


The syntax @syntax{with-unwind-handler} implements the core mechanism;
@syntax{with-unwind-protection} is an alias for it.
@syntax{unwind-protect} offers a syntax similar to the one of the Common
Lisp macro with the same name.  The former is meant to be used as
follows:

@example
#!vicare
(import (vicare))

(let ((port (open-file-output-port "file.ext")))
  (with-unwind-handler
      (lambda (why)
        (close-output-port port))
    (lambda ()
      (put-bytevector port '#ve(ascii "ciao")))))

@end example

@noindent
and the latter as follows:

@example
#!vicare
(import (vicare))

(let ((port (open-file-output-port "file.ext")))
  (unwind-protect
      (put-bytevector port '#ve(ascii "ciao"))
    (close-output-port port)))
@end example

@noindent
first we allocate a resource (in this case the @var{port}); then we use
it in the body forms; finally we release it in the clean--up forms.

When using the mechanism:

@itemize
@item
We have to decide if we trust our code not to raise exceptions while evaluating the
in--guard and out--guard thunks of @func{dynamic-wind} calls.  These would be nasty
errors, because the dynamic environment would get corrupted and recovering correctly
might be impossible; so we must @strong{really} write and debug such in--guard and
out--guard thunks with care.

@item
We have to decide if we trust our code not to raise a second exception while serving
a first exception in an error handler.  Raising a continuable exception is fine only
if we actually continue.  Exceptions while handling exceptions are a hard problem to
solve in every language; the rough solution is to block exceptions raised by
exception handlers:

@lisp
(with-exception-handler
    (lambda (E)
      (with-blocked-exceptions
        (lambda ()
          (handle E))))
  (lambda ()
    (do-something-useful)))
@end lisp

@noindent
but it is not very satisfying.  Another possibility is:

@lisp
(define-condition-type &originally-raised
    &condition
  make-originally-raised-condition
  originally-raised-condition?
  (object originally-raised-object))

(with-exception-handler
    (lambda (E)
      (with-exception-handler
          (lambda (X)
            (raise-continuable
              (condition X
                (make-originally-raised-condition E))))
        (lambda ()
          (handle E))))
  (lambda ()
    (do-something-useful)))
@end lisp
@end itemize

If the bodacious answer to both the decisions is ``We trust'': we can nest at will
uses of @syntax{with-unwind-protection}:

@lisp
(define (outer)
  (with-unwind-protection
      (lambda (why)
        (outer-unwind-handler))
    (lambda ()
      (do-something-useful)
      (inner))))

(define (inner)
  (with-unwind-protection
      (lambda (why)
        (inner-unwind-handler))
    (lambda ()
      (do-some-other-useful-thing))))

(outer)
@end lisp

@noindent
@strong{beware}: unwind handlers are evaluated in the dynamic environment of the use
of @syntax{with-unwind-protection}.

Otherwise we must avoid error handlers to cause the execution flow to
cross an unwind protection boundary; we can do it by using compensations
and the standard @syntax{guard} syntax:

@lisp
(define (outer)
  (push-compensation-thunk
    (lambda ()
      (outer-unwind-handler)))
  (do-something-useful)
  (inner))

(define (inner)
  (push-compensation-thunk
    (lambda ()
      (inner-unwind-handler)))
  (do-some-other-useful-thing))

(with-compensations
  (with-blocked-exceptions
    (lambda ()
      (guard (E ((type-one-error? E)
                 (handle E))
                (else
                 (do-something-dammit!!!)))
        (outer)))))
@end lisp

@noindent
or by using the compensations and the @syntax{try} syntax defined by
@value{PRJNAME}:

@lisp
(define (outer)
  (push-compensation-thunk
    (lambda ()
      (outer-unwind-handler)))
  (do-something-useful)
  (inner))

(define (inner)
  (push-compensation-thunk
    (lambda ()
      (inner-unwind-handler)))
  (do-some-other-useful-thing))

(with-compensations
  (with-blocked-exceptions
    (lambda ()
      (try
          (outer)
        (catch E
          ((&type-one)
           (handle E))
          (else
           (do-something-dammit!!!)))))))
@end lisp

@noindent
@strong{beware}: compensation handlers are evaluated in the dynamic environment of
the use of @syntax{with-compensations}.

@c page
@node iklib unwind-protect syntaxes
@subsection Unwind--protection syntaxes


@deffn Syntax with-unwind-handler @meta{unwind-handler} @meta{thunk}
@deffnx Syntax with-unwind-protection @meta{unwind-handler} @meta{thunk}
These two syntaxes are aliases.  Call @meta{thunk} and then, when the
dynamic extent of the call @strong{terminates}, call the procedure
@meta{unwind-handler}.  When @meta{thunk} performs a normal return: the
return values of @meta{thunk} become the return values of
@func{with-unwind-handler}.

When called: @meta{unwind-handler} is applied to a Scheme symbol
representing the cause of the call: @samp{return}, @samp{escape},
@samp{exception}.  The argument @meta{unwind-handler} comes before the
argument @meta{thunk} for uniformity with @func{with-exception-handler},
@ref{stdlib exceptions exceptions, with-exception-handler}.

Notice that a function tail--call in @meta{thunk} is @strong{not} a
tail--call for @syntax{with-unwind-protection}.
@end deffn


@deffn Syntax unwind-protect @meta{body} @metao{cleanup} @meta{cleanup} ...
Simple wrapper for @syntax{with-unwind-protection} that provides a
syntax similar to that of Common Lisp's macro.  It is expanded to:

@example
(with-unwind-protection
    (lambda (dummy) @metao{cleanup} @meta{cleanup} ...)
  (lambda () @meta{body}))
@end example
@end deffn

@c page
@node iklib unwind-protect dynamic
@subsection On the meaning of dynamic extent termination


The concept of dynamic extent @dfn{termination} is defined by
@value{PRJNAME}'s unwind--protection mechanism and it is not a @rnrs{6}
concept.  In this discussion, we consider the syntax use:

@example
(with-unwind-protection @meta{unwind-handler} @meta{thunk})
@end example

@noindent
the procedure @meta{unwind-handler} is called when the dynamic extent of
the invocation of @meta{thunk} terminates; dynamic extent
@strong{termination} is different from dynamic extent @strong{exiting}
as determined by @func{dynamic-wind} (@pxref{dynamic-wind}).  When the
execution flow exits the dynamic extent of a function call: such extent
might also terminate, but not all the exits are also terminations.

The dynamic extent of a call to @meta{thunk} @strong{is} terminated, and
so @meta{unwind-handler} @strong{is} invoked, when:

@itemize
@item
@meta{thunk} performs a normal return.  @meta{unwind-handler} is applied
to the symbol @samp{return}.

@item
@meta{thunk} raises a continuable or non--continuable exception that is
intercepted by a use of @syntax{guard}, but only when a clause of
@syntax{guard} has a test expression returning non--false.

@lisp
(guard (E (@meta{test} @meta{expr}))
  (with-unwind-handler @meta{unwind-handler} @meta{thunk}))
@end lisp

This is what happens:

@enumerate
@item
The clause's @meta{test} expression is evaluated in the dynamic
environment of the use of @syntax{guard} and it returns non--false.

@item
@meta{unwind-handler} is applied to the symbol @samp{exception}, in the
dynamic environment of the use of @syntax{with-unwind-protection}, and
its return values discarded.

@item
The clause's @meta{expr} is evaluated in the dynamic environment of the
use of @syntax{guard} and its return values are returned to the
continuation of @syntax{guard}.
@end enumerate

@item
@meta{thunk} executes a use of the fluid syntaxes @syntax{break},
@syntax{continue} or @syntax{return}, as defined by the library
@library{vicare}, to escape from a form that encloses an
unwind--protection syntax.  @meta{unwind-handler} is applied to the
symbol @samp{escape}.

As bound by the loop syntaxes @syntax{while}, @syntax{until}, @dots{}
and the syntax @syntax{returnable}: these fluid syntaxes reinstate a
continuation at the beginning or outside of @syntax{while},
@syntax{until}, @dots{} and @syntax{returnable} and perform special
operations to terminate the dynamic extent of the call to @meta{thunk}
in an unwind--protection form.
@end itemize

@c ------------------------------------------------------------------------

The dynamic extent of a call to @meta{thunk} is @strong{not} terminated,
and so @meta{unwind-handler} is @strong{not} invoked, when:

@itemize
@item
@meta{thunk} raises a continuable exception by calling
@func{raise-continuable}, and such call performs a normal return to
@meta{thunk}.

@item
@meta{thunk} raises a continuable or non--continuable exception and an
exception handler terminates the process (for example by calling
@func{exit}).

@item
The unwind--protection syntax is used by a coroutine and @func{yield} is
called from within @meta{thunk} to hand control to another coroutine.

@item
An escape procedure is called from within @meta{thunk} to reinstate a
continuation outside @meta{thunk}, and the call to the escape procedure
is @strong{not} interfaced with the unwind--protection mechanism to
terminate the dynamic extent of the call to @meta{thunk}.
@end itemize

@c ------------------------------------------------------------------------

About the termination of the dynamic extent of @meta{thunk}, we must
acknowledge that:

@itemize
@item
There is @strong{no} guarantee that: after exiting, without terminating,
the dynamic extent of @meta{thunk} by reinstating a continuation, such
extent will be reentered later and continue to termination.

@item
If the dynamic extent of @meta{thunk} is terminated and an attempt to
reenter @meta{thunk} is performed: an exception is raised with compound
condition object containing a @condition{non-reinstatable} component
(@pxref{&non-reinstatable}).

@item
Obviously, if a call to @meta{unwind-handler} raises an exception: the
clean--up operations performed by @meta{unwind-handler} may fail, in
whole or in part, possibly leaving behind unreleased resources.

@item
If the call to @meta{thunk} raises an exception and a use of
@syntax{guard} intercepts it: if a test expression in a clause of
@syntax{guard} raises an exception, the @meta{unwind-handler} may not be
called.

While it is possible to @func{raise} any object: it is better to always
raise a condition object (possibly compound), so that the test
expressions in @syntax{guard} uses can just be condition object type
predicates; such predicates never raise exceptions.
@end itemize

@c ------------------------------------------------------------------------

If @meta{unwind-handler} raises an exception: such exception is blocked
and discarded.

@c page
@node iklib unwind-protect except 1
@subsection Raising non--continuable exceptions from the thunk


A non--continuable exception is raised with @func{raise}, which can be
applied to any object; the argument to @func{raise} becomes the ``raised
object''.  The purpose of raising a non--continuable exception is to
cause the application of a function, the current exception handler, to
the raised object; the exception handler is called in the dynamic
environment of the call to @func{raise}.

The execution flow is @strong{not} meant return to the caller of
@func{raise}, so the exception handler has only two options:

@enumerate
@item
Reinstate a previously saved continuation to jump out of the dynamic
environment in which the exception was raised.  The following example
shows the basic mechanism:

@example
(import (vicare))

(call/cc
    (lambda (escape)
      (with-exception-handler
          escape
        (lambda ()
          (raise 1)))))
@result{} 1
@end example

@noindent
Reinstating a continuation to jump out of the exception handler is what
the standard @syntax{guard} syntax does when it handles an exception;
@syntax{guard} does more than this.

@item
Raise the exception again, causing the invocation of the upper level
exception handler.  The following example shows the basic mechanism:

@example
(import (vicare))

(call/cc
    (lambda (escape)
      (with-exception-handler
          escape
        (lambda ()
          (with-exception-handler
              (lambda (E)
                (raise E))
            (lambda ()
              (raise 1)))))))
@result{} 1
@end example
@end enumerate

@c ------------------------------------------------------------------------

@subsubheading Handling exceptions by escaping

This is @strong{not} the correct way of interfacing with the
unwind--protection mechanism.  In the following example we see that
escaping from the exception handler skips the call to the
@meta{unwind-handler}.

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (call/cc
      (lambda (escape)
        (with-exception-handler
            (lambda (E)
              (add-result 'exception-handler)
              (escape E))
          (lambda ()
            (with-unwind-protection
                (lambda (why)
                  (add-result 'cleanup))
              (lambda ()
                (add-result 'thunk-in)
                (raise 123)
                (add-result 'thunk-out))))))))
@result{} (123 (thunk-in exception-handler))
@end example

@c ------------------------------------------------------------------------

@subsubheading Handling exceptions with @syntax{guard}

This is the correct way of interfacing with the unwind--protection
mechanism.

In the following example: the @meta{thunk} raises a non--continuable
exception, which is catched by the @syntax{else} clause of a
@syntax{guard} use; this is equivalent to escaping from an exception
handler, but it does evaluate the @meta{unwind-handler}.  We can see the
forms evaluation order.

@example
#!vicare
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E (else
             (add-result 'guard-else)
             E))
    (with-unwind-protection
        (lambda (why)
          (add-result 'cleanup))
      (lambda ()
        (add-result 'thunk-in)
        (raise 2)
        (add-result 'thunk-out)
        1))))
@result{} (2 (thunk-in cleanup guard-else))
@end example

In the following example: the @meta{thunk} raises a non--continuable
exception, which is catched by the clause of a @syntax{guard} use; the
clause has test and expression.  We can see the forms evaluation order.

@example
#!vicare
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E ((begin
               (add-result 'guard-test)
               #t)
             (add-result 'guard-expr)
             E))
    (with-unwind-protection
        (lambda (why)
          (add-result 'cleanup))
      (lambda ()
        (add-result 'thunk-in)
        (raise 2)
        (add-result 'thunk-out)
        1))))
@result{} (2 (thunk-in guard-test cleanup guard-expr))
@end example

The following example with two nested @syntax{guard} uses and two nested
@func{dynamic-wind} calls, makes it even more clear the sequence of
forms evaluation.  The clause of the inner @syntax{guard} has test
expression returning @false{}, so the exception is re--raised with
@func{raise-continuable}.

@example
#!vicare
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E ((begin
               (add-result 'outer-guard-test)
               #t)
             (add-result 'outer-guard-expr)
             E))
    (guard (E ((begin
                 (add-result 'inner-guard-test)
                 #f)
               (add-result 'inner-guard-expr)
               E))
      (dynamic-wind
          (lambda ()
            (add-result 'outer-before))
          (lambda ()
            (with-unwind-protection
                (lambda (why)
                  (add-result 'cleanup))
              (lambda ()
                (dynamic-wind
                    (lambda ()
                      (add-result 'inner-before))
                    (lambda ()
                      (add-result 'thunk-in)
                      (raise 2)
                      (add-result 'thunk-out)
                      1)
                    (lambda ()
                      (add-result 'inner-after))))))
          (lambda ()
            (add-result 'outer-after))))))
@result{} (2 (outer-before inner-before thunk-in inner-after outer-after
       inner-guard-test
       outer-before inner-before inner-after outer-after
       outer-guard-test
       outer-before inner-before inner-after cleanup outer-after
       outer-guard-expr))
@end example

Let's describe the sequence of operations:

@table @code
@item outer-before inner-before thunk-in
Everything goes fine until the @meta{thunk} reaches @code{thunk-in}.

@item *
The @meta{thunk} raises an exception.  The exception handler of the
inner @syntax{guard} is applied to the raised object.

@item inner-after outer-after
The continuation of the inner @syntax{guard} use is reinstated, the
dynamic extent of the call to @meta{thunk} is exited: the dynamic
environment unwinds.

@item inner-guard-test
The clause test expression of the inner @syntax{guard} is evaluated in
the dynamic environment of the @syntax{guard} use: it returns @false{}.

@item outer-before inner-before
The continuation of the inner @syntax{guard} exception handler is
reinstated, the dynamic extent of the call to @meta{thunk} is reentered:
the dynamic environment is restored.

@item *
The exception is raised again by applying @func{raise-continuable} to
the same raised object.  The exception handler of the outer
@syntax{guard} is applied to the raised object.

@item inner-after outer-after
The continuation of the outer @syntax{guard} use is reinstated, the
dynamic extent of the call to @meta{thunk} is exited: the dynamic
environment unwinds.

@item outer-guard-test
The clause test expression of the outer @syntax{guard} is evaluated in
the dynamic environment of the outer @syntax{guard}: it returns @true{}.

@item outer-before inner-before
The continuation of the of the outer @syntax{guard} exception handler is
reinstated, the dynamic extent of the call to @meta{thunk} is entered:
the dynamic environment is restored.

@item inner-after cleanup outer-after
The continuation of the outer @syntax{guard} clause is reinstated, the
the dynamic extent of the call to @meta{thunk} is exited: the dynamic
environment unwinds.  While unwinding: the @meta{thunk} is found
terminated and the @meta{unwind-handler} is called in the dynamic
environment of the @syntax{with-unwind-protection} use.

@item outer-guard-expr
The clause expression of the outer @syntax{guard} is evaluated in the
dynamic environment of the outer @syntax{guard}.
@end table

That's Scheme!

@c page
@node iklib unwind-protect except 2
@subsection Raising continuable exceptions from the thunk


A continuable exception is raised with @func{raise-continuable} and it
is a way to resume the execution of a chunk of code after raising an
exception.  This example shows the basic mechanism:

@example
(import (rnrs))
(with-exception-handler
    (lambda (E)
      (+ E 2))
  (lambda ()
    (raise-continuable 1)))
@result{} 3
@end example

The handling of a continuable exception can be the same of the handling
of a non--continuable exception; in addition the exception handler is
allowed to return.  In the latter case the dynamic extent of the call to
@meta{thunk} is @strong{not} exited, so @meta{unwind-handler} is not
called.

The following example shows what happens when @meta{thunk} raises a
continuable exception:

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (with-exception-handler
      (lambda (E)
        (add-result 'exception-handler)
        (+ E 2))
    (lambda ()
      (with-unwind-protection
          (lambda (why)
            (add-result 'cleanup))
        (lambda ()
          (add-result 'thunk-in)
          (begin0
              (raise-continuable 1)
            (add-result 'thunk-out)))))))
@result{} (3 (thunk-in exception-handler thunk-out cleanup))
@end example

@c page
@node iklib unwind-protect except 3
@subsection Raising exceptions from the unwind handler


When a thunk raises an exception and the current exception handler
raises another exception: the original exception is dropped if no
specific action is taken.  This is a common problem.  The following
example shows the mechanism.

@example
(import (vicare))

(call/cc
    (lambda (escape)
      (with-exception-handler
          escape
        (lambda ()
          (with-exception-handler
              (lambda (E)
                (raise 2))
            (lambda ()
              (raise 1)))))))
@result{} 2
@end example

What happens if @meta{unwind-handler} raises an exception?  It was
decided that such exceptions are to be blocked and discarded;
@meta{unwind-handler} procedures have to take care of themselves,
handling their own errors.  The following example shows the mechanism.

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E (else
             (add-result 'guard-else)
             E))
    (with-unwind-protection
        (lambda (why)
          (add-result 'cleanup-in)
          (raise 2)
          (add-result 'cleanup-out))
      (lambda ()
        (add-result 'thunk-in)
        (raise 1)
        (add-result 'thunk-out)))))
@result{} (1 (thunk-in cleanup-in guard-else))
@end example

@c page
@node iklib unwind-protect loops
@subsection Use with loop syntaxes


The unwind--protection mechanism has special integration with the loop
syntaxes defined by @library{vicare}; if an unwind--protection syntax is
used in the body of a loop as defined by @syntax{do}, @syntax{while},
@syntax{until}, @syntax{for} and @syntax{break} or @syntax{continue} are
used in the body forms: the cleanup forms are evaluated correctly.  We
have to remember that @syntax{break} and @syntax{continue} are
implemented by escaping continuations.

This example shows breaking out of a @syntax{while} syntax; the body and
the unwind handler are evaluated only once; @func{exit} is never called.

@example
#!vicare
(import (vicare))
(define x 3)
(define y #f)
(while (positive? x)
  (with-unwind-protection
      (lambda (why)
        (set! y #t))
    (lambda ()
      (-- x)
      (break)
      (exit))))
x @result{} 2
y @result{} #t
@end example

This example shows using @syntax{continue} in a @syntax{while} syntax;
the body and the unwind handler are evaluated @math{3} times;
@func{exit} is never called.

@example
#!vicare
(import (vicare))
(define x 3)
(define y 0)
(while (positive? x)
  (with-unwind-protection
      (lambda (why)
        (++ y))
    (lambda ()
      (-- x)
      (continue)
      (exit))))
x @result{} 0
y @result{} 3
@end example

@c page
@node iklib unwind-protect returnable
@subsection Use with returnable bodies


The unwind--protection mechanism has special integration with the
@syntax{returnable} syntax defined by @library{vicare}; if an
unwind--protection syntax is used in the body of @syntax{returnable} and
@syntax{return} is used in the body forms: the unwind handler is
evaluated correctly.  We have to remember that @syntax{return} is
implemented by an escaping continuation.

@example
#!vicare
(import (vicare))
(define y #f)
(returnable
  (with-unwind-protection
      (lambda (why)
        (set! y #t))
    (lambda ()
      (return 1))))
@result{} 1
y @result{} #t
@end example

@c page
@node iklib unwind-protect coroutines
@subsection Use with coroutines


Using the unwind--protection mechanism with coroutines is fine;
coroutines use @func{yield} to save the current continuation, give
control to the next coroutine and come back later; this mechanism does
not cause the @meta{unwind-handler} evaluation.

The following sample code finishes with the given return values and
lines printed:

@example
(import (vicare))

(define (print template . args)
  (apply fprintf (current-error-port) template args)
  (yield))

(define a #f)
(define b #f)
(define c #f)

(concurrently
  (lambda ()
    (unwind-protect
        (begin
          (set! a 1.1)
          (print "unwind-protect sub 1.1: ~a\n" a)
          (set! a 1.2)
          (print "unwind-protect sub 1.2: ~a\n" a)
          (set! a 1.3)
          (print "unwind-protect sub 1.3: ~a\n" a))
      (set! a 1.4)))
  (lambda ()
    (unwind-protect
        (begin
          (set! b 2.1)
          (print "unwind-protect sub 2.1: ~a\n" b)
          (set! b 2.2)
          (print "unwind-protect sub 2.2: ~a\n" b)
          (set! b 2.3)
          (print "unwind-protect sub 2.3: ~a\n" b))
      (set! b 2.4)))
  (lambda ()
    (unwind-protect
        (begin
          (set! c 3.1)
          (print "unwind-protect sub 3.1: ~a\n" c)
          (set! c 3.2)
          (print "unwind-protect sub 3.2: ~a\n" c)
          (set! c 3.3)
          (print "unwind-protect sub 3.3: ~a\n" c))
      (set! c 3.4))))

(values a b c)
@result{} 1.4 2.4 3.4
@print{} unwind-protect sub 1.1: 1.1
@print{} unwind-protect sub 2.1: 2.1
@print{} unwind-protect sub 1.2: 1.2
@print{} unwind-protect sub 3.1: 3.1
@print{} unwind-protect sub 2.2: 2.2
@print{} unwind-protect sub 1.3: 1.3
@print{} unwind-protect sub 3.2: 3.2
@print{} unwind-protect sub 2.3: 2.3
@print{} unwind-protect sub 3.3: 3.3
@end example

@c page
@node iklib unwind-protect reenter
@subsection Handling reentering continuations


After the @meta{unwind-handler} is called: we do @strong{not} want the
execution flow to reenter the @meta{thunk} in the same dynamic extent.
After the dynamic extent of a call to @meta{thunk} terminates, and the
@meta{unwind-handler} is called: we are forbidden to reenter the
@meta{thunk}; if we try to reenter: an exception of type
@condition{non-reinstatable} is raised.

The first problem with reentering is that the code in the @meta{thunk}
expects invariants in the state of the process that are no longer true;
for example: if @meta{unwind-handler} closes an input/output port, the
@meta{thunk} still expects it to be open.

Reentering might happen, for example, when using the @syntax{amb}
operator in the @meta{thunk}, @libsref{amb, McCarthy's @syntax{amb}
operator}.  This means we must be careful to use @syntax{amb} in a
@meta{thunk} only when the whole search never crosses the unwind
protection contour.

The following example shows how calling an escape procedure created in
the @meta{thunk} of a @syntax{with-unwind-protection} causes the
exception to be raised:

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E ((non-reinstatable-violation? E)
             (add-result 'violation)
             #t)
            (else E))
    (let ((rv (with-unwind-protection
                  (lambda (why)
                    (add-result 'cleanup))
                (lambda ()
                  (add-result 'body-in)
                  (begin0
                      (call/cc values)
                    (add-result 'body-out))))))
      (cond ((procedure? rv)
             (add-result 'reinstating)
             (rv 123))
            (else
             (add-result 'returning)
             rv)))))
@result{} (#t (body-in body-out cleanup reinstating violation))
@end example

@c page
@node iklib unwind-protect dyn-env
@subsection Clean--up thunks and the dynamic environment


As @rnrs{6} states:

@quotation
Some operations described in the report acquire information in addition
to their explicit arguments from the @emph{dynamic environment}.  For
example, @func{call/cc} accesses an implicit context established by
@func{dynamic-wind}, and the @func{raise} procedure accesses the current
exception handler.
@end quotation

@noindent
the typical example of values from the dynamic environment is
parameters, which indeed are implemented on top of @func{dynamic-wind}
(@pxref{iklib parameters}).  When using the unwind--protection
mechanism:

@example
(with-unwind-protection @meta{unwind-handler} @meta{thunk})
@end example

@noindent
the procedure @meta{unwind-handler} is called in the dynamic environment
of the use of @syntax{with-unwind-protection}.

For example, when escaping from @meta{thunk} with @syntax{return}:

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(define parm
  (make-parameter #f))

(with-result
  (parametrise ((parm 'outer-parm))
    (returnable
      (parametrise ((parm 'inner-parm))
        (with-unwind-protection
            (lambda (why)
              (add-result 'cleanup-in)
              (add-result (parm))
              (add-result 'cleanup-out))
          (lambda ()
            (add-result 'thunk-in)
            (add-result (parm))
            (return 2)
            (add-result 'thunk-out)
            1))))))
@result{} (2 (thunk-in inner-parm
       cleanup-in inner-parm cleanup-out))
@end example

@noindent
we see that, even though @syntax{return} reinstates the continuation of
@syntax{returnable}: @meta{unwind-handler} gathers the parameter value from
inside the use of @syntax{returnable}.

Even more descriptive is the case of raising an exception from
@meta{thunk} and catching it with @syntax{guard}:

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(define parm
  (make-parameter #f))

(with-result
  (parametrise ((parm 'outer-parm))
    (guard (E ((begin
                 (add-result 'guard-test-in)
                 (add-result (parm))
                 (add-result 'guard-test-out)
                 #t)
               (add-result 'guard-expr-in)
               (add-result (parm))
               (add-result 'guard-expr-out)
               E))
      (parametrise ((parm 'inner-parm))
        (with-unwind-protection
            (lambda (why)
              (add-result 'cleanup-in)
              (add-result (parm))
              (add-result 'cleanup-out))
          (lambda ()
            (add-result 'thunk-in)
            (add-result (parm))
            (raise 2)
            (add-result 'thunk-out)
            1))))))
@result{} (2 (thunk-in inner-parm
       guard-test-in outer-parm guard-test-out
       cleanup-in inner-parm cleanup-out
       guard-expr-in outer-parm guard-expr-out))
@end example

@noindent
both @meta{thunk} and @meta{unwind-handler} gather the inner value,
while the test and expression of the @syntax{guard} clause gather the
outer value, even though the execution order is intermixed.

Changing the environment inside @meta{thunk} does not affect
@meta{unwind-handler}:

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(define parm
  (make-parameter #f))

(with-result
  (parametrise ((parm 'outer-parm))
    (with-unwind-protection
        (lambda (why)
          (add-result 'cleanup-in)
          (add-result (parm))
          (add-result 'cleanup-out))
      (lambda ()
        (parametrise ((parm 'inner-parm))
          (add-result 'thunk-in)
          (add-result (parm))
          (add-result 'thunk-out)
          1)))))
@result{} (1 (thunk-in inner-parm thunk-out
       cleanup-in outer-parm cleanup-out))

(with-result
  (returnable
    (parametrise ((parm 'outer-parm))
      (with-unwind-protection
          (lambda (why)
            (add-result 'cleanup-in)
            (add-result (parm))
            (add-result 'cleanup-out))
        (lambda ()
          (parametrise ((parm 'inner-parm))
            (add-result 'thunk-in)
            (add-result (parm))
            (return 2)
            (add-result 'thunk-out)
            1))))))
@result{} (2 (thunk-in inner-parm
       cleanup-in outer-parm cleanup-out))
@end example

@c page
@node iklib unwind-protect problems
@subsection Known problems


The unwind protection mechanism may misbehave in some cases.
Specifically the unwind handler may not be called in the following
cases:

@itemize
@item
An exception is raised by a thunk and, while handling it, a second
exception is raised.

@item
An exception is raised by the in--guard or out--guard thunks of a call
to @func{dynamic-wind}.
@end itemize

@c ------------------------------------------------------------------------

@subsubheading Raising exceptions from an exception handler

In the following example an exception is raised by an exception handler:
the unwind handler is called, but the original exception is lost.

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E (else
             (add-result 'guard-else)
             E))
    (with-exception-handler
        (lambda (E)
          (add-result 'exception-handler)
          (raise 2))
      (lambda ()
        (with-unwind-protection
            (lambda (why)
              (add-result 'unwind-handler))
          (lambda ()
            (dynamic-wind
                (lambda ()
                  (add-result 'in-guard))
                (lambda ()
                  (add-result 'thunk-in)
                  (raise 1)
                  (add-result 'thunk-out))
                (lambda ()
                  (add-result 'out-guard)))))))))
@result{} (2 (in-guard
       thunk-in
       exception-handler
       out-guard
       in-guard out-guard unwind-handler
       guard-else))
@end example

@c ------------------------------------------------------------------------

@subsubheading Raising exceptions from a @syntax{guard}'s test

In the following example an exception is raised from a @syntax{guard}'s
test expression: the unwind handler is @strong{not} called and the
original exception is lost.

@example
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (guard (E (else
             (add-result 'outer-guard-else)
             E))
    (guard (E ((begin
                 (add-result 'inner-guard-test)
                 (raise 2))
               E))
      (with-unwind-protection
          (lambda (why)
            (add-result 'unwind-handler))
        (lambda ()
          (dynamic-wind
              (lambda ()
                (add-result 'in-guard))
              (lambda ()
                (add-result 'thunk-in)
                (raise 1)
                (add-result 'thunk-out))
              (lambda ()
                (add-result 'out-guard))))))))
@result{} (2 (in-guard
       thunk-in
       out-guard
       inner-guard-test
       outer-guard-else))
@end example

@c ------------------------------------------------------------------------

@subsubheading Raising exceptions from @func{dynamic-wind} guards

In the following example an exception is raised from a
@func{dynamic-wind}'s in--guard thunk: the unwind handler is
@strong{not} called and the original exception is lost.

@example
(with-result
  (guard (E (else
             (add-result 'guard-else)
             E))
    (dynamic-wind
        (let ((flag #f))
          (lambda ()
            (cond (flag
                   (add-result 'in-guard/raise)
                   (raise 2))
                  (else
                   (set! flag #t)
                   (add-result 'in-guard)))))
        (lambda ()
          (with-unwind-handler
              (lambda (E)
                (add-result 'unwind-handler))
            (lambda ()
              (add-result 'thunk-in)
              (raise 1))))
        (lambda ()
          (add-result 'out-guard)))))
@result{} (2 (in-guard
       thunk-in
       out-guard
       in-guard/raise
       guard-else))
@end example

@c page
@node iklib unwind-protect call/cc
@subsection Unwinding @func{call/cc}


We have seen that performing a raw escape from an exception handler
skips calling the unwind handlers installed in the body:

@lisp
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (call/cc
      (lambda (escape)
        (with-exception-handler
            (lambda (E)
              (add-result 'exception-handler)
              (escape 2))
          (lambda ()
            (with-unwind-handler
                (lambda (why)
                  (add-result 'unwind-handler))
              (lambda ()
                (add-result 'body-in)
                (raise 1))))))))
@result{} (2 (body-in exception-handler))
@end lisp

@noindent
this problem can be solved by using @func{unwinding-call/cc} rather than
the standard @func{call/cc}.


@defun unwinding-call/cc @var{receiver}
Similar to @func{call/cc}, but calling the escape procedure causes the
invocation of the unwind handlers installed in the dynamic environment
up until the saved continuation is restored.

There are limitations:

@itemize
@item
The escape procedure produced by this primitive @strong{must} be called
only from the dynamic extent of the call to @var{receiver}.  For
example: generating an unwinding escape procedure in a coroutine and
calling it from another coroutine leads to raising an exception of type
@condition{non-reinstatable}.

@item
The escape procedure produced by this primitive @strong{must} be called
only once; an attempt to call it a second time leads to raising an
exception of type @condition{non-reinstatable}.
@end itemize

@quotation
@strong{NOTE} After some development iterations, the implementation of
this primitive has taken a shape quite similar to the function
@func{call/cc-escaping} proposed by Will Clinger in
@url{http:/@//@/www.ccs.neu.edu/@/home/@/will/@/UWESC/@/uwesc.sch}.
@end quotation
@end defun


Usage examples:

@lisp
(import (vicare)
  (only (vicare checks)
        with-result
        add-result))

(with-result
  (unwinding-call/cc
      (lambda (escape)
        (with-unwind-handler
            (lambda (why)
              (add-result 'unwind-handler))
          (lambda ()
            (add-result 'body-in)
            (escape 1))))))
@result{} (1 (body-in unwind-handler))

(with-result
  (unwinding-call/cc
      (lambda (escape)
        (with-exception-handler
            (lambda (E)
              (add-result 'exception-handler)
              (escape 2))
          (lambda ()
            (with-unwind-handler
                (lambda (why)
                  (add-result 'unwind-handler))
              (lambda ()
                (add-result 'body-in)
                (raise 1))))))))
@result{} (2 (body-in exception-handler unwind-handler))

;;Calling unwinding escape procedure from outside the
;;dynamic extent of the call to the receiver.
;;
(let ((escape-proc #f))
  (unwinding-call/cc
      (lambda (escape)
        (set! escape-proc escape)))
  (escape-proc))
@error{} &non-reinstatable

;;Calling unwinding escape procedure twice.
;;
(let ((again-proc #f))
  (unwinding-call/cc
      (lambda (escape)
        (call/cc
            (lambda (again)
              (set! again-proc again)))
        (escape)))
  (again-proc))
@error{} &non-reinstatable
@end lisp

@c page
@node iklib compensations
@section Compensation stacks


@cindex Compensation stacks
@cindex Stacks of compensation thunks
@cindex Releasing asynchronous resources
@cindex Asynchronous resources, releasing


Compensation stacks allow us to write code to allocate resources near
the code that releases them; @ref{resources, Allocating and releasing
resources}, for an overview of resource management under
@value{PRJNAME}.  Compensation stacks are described in:

@quotation
Westley Weimer, George C. Necula.  ``Finding and Preventing Run--Time
Error Handling Mistakes''.  In Proceedings of the @acronym{ACM}
Conference on Object--Oriented Programming, Systems, Languages, and
Applications, 2004.
@end quotation

@value{PRJNAME} implements compensation stacks on top of the unwind
protection mechanism, which allows operations to be performed
synchronously with respect to the dynamic extent of a call to thunk.
@ref{iklib unwind-protect, The unwind--protection mechanism}.


@menu
* iklib compensations usage::   Basic compensations usage.
* iklib compensations api::     Compensations @api{}.
@end menu

@c page
@node iklib compensations usage
@subsection Basic compensations usage


A @dfn{compensation} is a chunk of code that undoes a resource
allocation performed in another chunk, example:

@example
(define port
  (open-file-input-port "/tmp/proof.1"))
@end example

@noindent
must be ''compensated'' by:

@example
(close-port port)
@end example

@noindent
with the compensations stack such code can be written:

@example
(with-compensations
  (letrec
      ((port (compensate
                 (open-file-input-port "/tmp/proof.1")
               (with
                 (close-port port)))))
    (make-use-of port)))
@end example

@noindent
or:

@example
(with-compensations
  (define port
    (compensate
        (open-file-input-port "/tmp/proof.1")
      (with
        (close-port port))))
  (make-use-of port))
@end example

Compensation forms are embedded in a closure and pushed on a stack, so
that, in case of error, it is possible to evaluate them in
allocation--reversed order.

A form that makes use of a compensation stack looks like this:

@example
(with-compensations
  (compensate
      ALLOC-FORMS-1
    (with RELEASE-FORMS-1))
  (compensate
      ALLOC-FORMS-2
    (with RELEASE-FORMS-2))
  BODY-FORMS)
@end example

@noindent
both @func{with-compensations} and @func{compensate} are syntaxes.  If
no error occurs the order of evaluation is:

@example
ALLOC-FORMS-1
ALLOC-FORMS-2
BODY-FORMS
RELEASE-FORMS-2
RELEASE-FORMS-1
@end example

@noindent
if an error occurs in @code{BODY-FORMS}, the order of evaluation is:

@example
ALLOC-FORMS-1
ALLOC-FORMS-2
BODY-FORMS
RELEASE-FORMS-2
RELEASE-FORMS-1
@end example

@noindent
if an error occurs in @code{ALLOC-FORMS-2}, the order of evaluation is:

@example
ALLOC-FORMS-1
ALLOC-FORMS-2
RELEASE-FORMS-1
@end example

@noindent
if an error occurs in @code{ALLOC-FORMS-1}, the order of evaluation is:

@example
ALLOC-FORMS-1
@end example

@noindent
if an error occurs in @code{RELEASE-FORMS-1}, the order of evaluation is:

@example
ALLOC-FORMS-1
ALLOC-FORMS-2
BODY-FORMS
RELEASE-FORMS-2
RELEASE-FORMS-1
@end example

@noindent
if an error occurs in @code{RELEASE-FORMS-2}, the order of evaluation is:

@example
ALLOC-FORMS-1
ALLOC-FORMS-2
BODY-FORMS
RELEASE-FORMS-2
RELEASE-FORMS-1
@end example

So @func{with-compensations} tries to evaluate all the release forms,
despite errors.  Of course if an error occurs in the middle of a set of
forms:

@example
(first-form)   ;evaluated
(raise 'here)
(third-form)   ;not evaluated
@end example

@noindent
the forms before the error are evaluated, while the forms after the
error are not.

A variant of @func{with-compensations} exists to evaluate the
compensation forms only in case of error:

@example
(with-compensations/on-error
  (compensate
      ALLOC-FORMS-1
    (with RELEASE-FORMS-1))
  (compensate
      ALLOC-FORMS-2
    (with RELEASE-FORMS-2))
  BODY-FORMS)
@end example

@noindent
if no error occurs the order of evaluation is:

@example
ALLOC-FORMS-1
ALLOC-FORMS-2
BODY-FORMS
@end example

@noindent
while if an error occurs the evaluation is equal to the cases of
@func{with-compensations}.  The ``on error'' variant is useful in
constructors and initialisation functions, where we want to run the
compensations only if an error occurs; if no error is raised, we just
want the constructor to return.

@c page
@node iklib compensations api
@subsection Compensations @api{}


The compensations mechanism is built on top of the unwind protection
mechanism:

@itemize
@item
All the @meta{alloc} and @meta{body} forms end in the body of a thunk;
the compensations are evaluated when the dynamic extent of the call to
such thunk is terminated, as defined by the unwind protection mechanism.

@item
All the @meta{release} forms end in the body of a clean--up procedure;
such forms are evaluated in the @strong{dynamic environment of the
syntax use that allocates the compensations stack}.
@end itemize


@deffn Syntax with-compensations @metao{body} @meta{body} @dots{}
Allocate a new compensations stack, then evaluate all the @meta{body}
forms in the given order.  If no error occurs: call
@func{run-compensations}, reset the compensations stack to empty,
finally return the result value of the last @meta{body} form.

If the dynamic extent of the evaluation of the @meta{body} forms is
terminated: the accumulated compensations are evaluated in reverse
order.
@end deffn


@deffn Syntax with-compensations/on-error @metao{body} @meta{body} @dots{}
Allocate a new compensations stack, then evaluate all the @meta{body}
forms in the given order.  If no error occurs: reset the compensations
stack to empty, return the result value of the last @meta{body} form.

If the dynamic extent of the evaluation of the @meta{body} forms is
terminated by escaping from the body directly or by escaping from the
body while handling a raised a exception: the accumulated compensations
are evaluated in reverse order.
@end deffn


@defun run-compensations
Evaluate all the compensation thunks in the current stack, in last
in/first out order; compensation thunks are called in the current
dynamic environment.  If a compensation thunk raises an exception: the
exception is blocked and silently discarded.

This function should be called only inside the dynamic environment
prepared by @func{with-compensations} and similar syntaxes.  It can be
called multiple times: every time the compensation thunks are consumed
and removed from the stack.
@end defun


@deffn Syntax with-compensation-handler @meta{release-thunk} @meta{alloc-thunk}
First push @meta{release-thunk} on the current compensations stack,
@strong{then} evaluate @meta{alloc-thunk}.  Return the results of
evaluating @meta{alloc-thunk}.
@end deffn


@deffn Syntax compensate @metao{alloc} @meta{alloc} @dots{} (with @metao{release} @meta{release} @dots{})
@deffnx {Auxiliary Fluid Syntax} with
@deffnx {Auxiliary Fluid Syntax} <>
First evaluate all the @meta{alloc} expressions then, @strong{only} if
they perform a normal return: push one thunk holding all the
@meta{release} forms on the current compensations stack.  Return the
result of the last @meta{alloc} expression.

While expanding the @meta{release} forms: the fluid syntax @syntax{<>}
is bound to an identifier referencing the object returned by the
@meta{alloc} forms; this allows to code:

@lisp
(define (make-compensated-object)
  (compensate
      (make-new-object)
    (with
      (destroy-object <>))))
@end lisp

@noindent
rather than:

@lisp
(define (make-compensated-object)
  (receive-and-return (obj)
    (compensate
        (make-new-object)
      (with
        (destroy-object obj)))))
@end lisp
@end deffn


@deffn Syntax push-compensation @metao{release} @meta{release} @dots{}
Push a thunk holding the @meta{release} forms on the current
compensations stack.
@end deffn


@defun push-compensation-thunk @var{thunk}
Push the given thunk on the current compensations stack.
@end defun

@c page
@node iklib coroutines
@section Running coroutines


@value{PRJNAME} implements coroutines on top of Scheme continuations.
The implementation is a simple queue of escape procedures: whenever
coroutine yields control to the ``next'' coroutine, it enqueues an
escape function to its current continuation and causes the next escape
procedure to be invoked.

For discussions about other implementations of coroutines and
continuations see @vicareref{HFWCoro, references}.

@menu
* iklib coroutines examples::   Usage examples for coroutines.
* iklib coroutines basic::      Basic coroutine operations.
* iklib coroutines uid::        Coroutine unique identifiers.
* iklib coroutines suspend::    Suspending and resuming coroutines.
* iklib coroutines syntaxes::   Utility syntaxes for coroutines.
* iklib coroutines debug::      Debugging utilities for coroutines.
* iklib coroutines parallel::   Running parallel processes.
@end menu

@c page
@node iklib coroutines examples
@subsection Usage examples for coroutines


Coroutines are created by the function @func{coroutine}; a coroutine in
execution can yield control to the next coroutine with the function
@func{yield}.  It is possible to enter a loop that runs all the
coroutines until all of them are finished with the function
@func{finish-coroutines}.

All the examples in this section are to be considered as Scheme programs
after the prelude:

@example
#!r6rs
(import (vicare))

(set-port-buffer-mode! (current-output-port)
                       (buffer-mode line))
@end example

@noindent
which allows the intertwining of coroutines to be seen by displaying
strings on the current output port.

@c ------------------------------------------------------------

@subsubheading Two coroutines

The following example runs two coroutines and waits for them to finish:

@example
(coroutine
    (lambda ()
      (display "one 1\n")
      (yield)
      (display "one 2\n")
      (yield)
      (display "one 3\n")))

(coroutine
    (lambda ()
      (display "two 1\n")
      (yield)
      (display "two 2\n")
      (yield)
      (display "two 3\n")))

(finish-coroutines)
@end example

@noindent
the output is:

@example
one 1
two 1
one 2
two 2
one 3
two 3
@end example

We see that to exit a coroutine we just return from its start function.

@c ------------------------------------------------------------

@subsubheading The main routine and a subroutine

We can always consider the ordinary control flow of a program as a
coroutine, the @dfn{main routine}; so the following program produces
output similar to the one above:

@example
(coroutine
    (lambda ()
      (display "sub 1\n")
      (yield)
      (display "sub 2\n")
      (yield)
      (display "sub 3\n")))

;;This runs in the main routine.
(display "main 1\n")
(yield)
(display "main 2\n")
(yield)
(display "main 3\n")

(finish-coroutines)
@end example

@noindent
the output is:

@example
sub 1
main 1
sub 2
main 2
sub 3
main 3
@end example

@c ------------------------------------------------------------

@subsubheading Main routine alone

It is perfectly all right to call @func{yield} and
@func{finish-coroutines} from the main routine even when there are no
subroutines:

@example
(display "main 1\n")
(yield)
(display "main 2\n")
(yield)
(display "main 3\n")
(finish-coroutines)
@end example

@noindent
the output of this program is just:

@example
main 1
main 2
main 3
@end example

@c ------------------------------------------------------------

@subsubheading Finishing coroutines

It is possible to call @func{finish-coroutines} from any coroutine, but
we must be careful because if we let the main routine exit before all
the routines are finished some computation will not take place.  In the
following program the subroutine has more steps than the main routine:

@example
(coroutine
    (lambda ()
      (display "sub 1\n")
      (yield)
      (display "sub 2\n")
      (yield)
      (display "sub 3\n")
      (yield)
      (display "sub 4\n")
      (yield)
      (display "sub 5\n")
      (finish-coroutines)))

;; This runs in the main routine.
(display "main 1\n")
(yield)
(display "main 2\n")
(yield)
(display "main 3\n")
@end example

@noindent
and its output is:

@example
sub 1
main 1
sub 2
main 2
sub 3
main 3
@end example

@noindent
we see that @samp{sub 4} and @samp{sub 5} are not displayed.

@c ------------------------------------------------------------

@subsubheading Finish coroutines as exit hook

It can be useful to register @func{finish-coroutines} as exit hook, so
that upon exiting the process all the pending coroutines are correctly
terminated.

@example
(coroutine
    (lambda ()
      (display "one 1\n")
      (yield)
      (display "one 2\n")
      (yield)
      (display "one 3\n")))

(coroutine
    (lambda ()
      (display "two 1\n")
      (yield)
      (display "two 2\n")
      (yield)
      (display "two 3\n")))

(exit-hooks (cons finish-coroutines (exit-hooks)))
(exit)
@end example

@c page
@node iklib coroutines basic
@subsection Basic coroutine operations


@defun coroutine @var{thunk}
Create a new coroutine having @var{thunk} as function and enter it;
return unspecified values.
@end defun


@defun yield
Register the current continuation as coroutine, then run the next
coroutine; return unspecified values.
@end defun


@defun finish-coroutines
@defunx finish-coroutines @var{exit-loop?}
Loop running the next coroutine until there are no more; return
unspecified values.

When the argument @var{exit-loop?} is used: it must be a thunk.  Before
entering the next coroutine @var{exit-loop?} is called: if it returns
non-false the loop exits, if it returns @false{} the loop continues.
@end defun

@c page
@node iklib coroutines uid
@subsection Coroutine unique identifiers


@defun coroutine-uid
Return a gensym acting as unique identifier for the current coroutine.
This symbol is bound to an internal data structure.
@end defun


@defun coroutine-uid? @var{obj}
Return @true{} if @var{obj} is a unique coroutine identifier; otherwise
return @false{}.
@end defun

@c page
@node iklib coroutines suspend
@subsection Suspending and resuming coroutines


@defun suspend-coroutine
Suspend the current coroutine by yielding control to the next one.  The
continuation of the current coroutine is @strong{not} enqueued to be
reinstated later.
@end defun


@defun resume-coroutine @var{uid}
Given the unique identifier of a suspended coroutine: resume it by
enqueueing the current continuation and yielding control to the
suspended coroutine.
@end defun


@defun suspended-coroutine? @var{uid}
Return @true{} if @var{uid} is the unique identifier of a suspended
coroutine; otherwise return @false{}.  It is an error if @var{uid} is
not the @uid{} of a coroutine.
@end defun

@c page
@node iklib coroutines syntaxes
@subsection Utility syntaxes for coroutines


@deffn Syntax concurrently @metao{thunk} @meta{thunk} @dots{}
Evaluate the given thunks each in its own coroutine.  Return unspecified
values when all the coroutines are finished.
@end deffn


@deffn Syntax monitor @meta{max-coroutines-count} @meta{thunk}
Allow only a maximum number of coroutines to concurrently enter the
evaluation of @meta{thunk}.

The argument @meta{max-coroutines-count} must be an expression
evaluating to a positive integer representing the maximum number of
coroutines.  It is evaluated only once.

The argument @meta{thunk} must be an expression evaluating to a thunk.
It is evaluated only once.
@end deffn

@c page
@node iklib coroutines debug
@subsection Debugging utilities for coroutines


@defun reset-coroutines!
Reset the internal state of the coroutine mechanism, discarding all the
enqueued coroutines.  This function should not be used.
@end defun


@defun dump-coroutines
Print, on the current error port, a symbolic expression listing the
currently enqueued coroutine continuation procedures.  This is strictly
for debugging purposes.
@end defun

@c page
@node iklib coroutines parallel
@subsection Running parallel processes


@cindex Running parallel processes, coroutines
@cindex Coroutines, running parallel processes
@cindex Processes, running in parallel


The following example program shows how to run a parallel, child process
waiting for its termination in a coroutine; it assumes that
@value{PRJNAME} has been installed with the @posix{} extensions.

@smallexample
#!vicare
(import (vicare)
  (prefix (vicare posix) px.)
  (prefix (vicare platform constants) const.))

(define (parent-proc child-pid child-stdin child-stdout child-stderr)
  (with-unwind-protection
      (lambda (why)
        (close-output-port child-stdin)
        (close-input-port  child-stdout)
        (close-input-port  child-stderr))
    (lambda ()
      (let loop ((status (px.waitpid child-pid const.WNOHANG)))
        (cond ((not status)
               ;;Child still running.
               (yield)
               (loop (px.waitpid child-pid const.WNOHANG)))
              ((px.WIFEXITED status)
               ;;Child exited.
               (values status
                       (read-all child-stdout)
                       (get-string-all child-stderr)))
              (else
               (error #f
                 "child process exited abnormally" status)))))))

(define (child-thunk)
  (guard (E (else
             (print-condition E)
             (exit 1)))
    (px.close-ports-in-close-on-exec-mode)
    (write '(1 2 3) (console-output-port))
    (write '(4 5 6) (console-output-port))
    (flush-output-port (console-output-port))
    (put-string (console-error-port) "done\n")
    (flush-output-port (console-error-port))
    (exit 0)))

(define (read-all port)
  (let ((obj (read port)))
    (if (eof-object? obj)
        '()
      (cons obj (read-all port)))))

(coroutine
    (lambda ()
      (px.flush-ports-in-close-on-exec-mode)
      (receive (status out err)
          (px.fork-with-textual-ports parent-proc child-thunk)
        (printf "out: ~s\n" out)
        (printf "err: ~a\n" err)
        (flush-output-port (current-output-port)))))

(finish-coroutines)
@end smallexample

@c page
@node iklib conditions
@section Additional condition types


@menu
* iklib conditions raising::    Raising conditions.
* iklib conditions preds::      Predicates for condition objects.
* iklib conditions spos::       Scheme source code position.
* iklib conditions eagain::     Reporting @code{EAGAIN} exceptions.
* iklib conditions errno::      Reporting @code{errno} exceptions.
* iklib conditions failexpr::   Failed expression conditions.
* iklib conditions procpre::    Procedure precondition violations.
* iklib conditions procpost::   Procedure postcondition violations.
* iklib conditions procarg::    Procedure argument violations.
* iklib conditions sigarg::     Procedure signature argument violations.
* iklib conditions rvarg::      Procedure signature return value violations.
* iklib conditions proccon::    Procedure argument consistency violations.
* iklib conditions exprret::    Expression return value violations.
* iklib conditions non-reinst:: Non-reinstatable continuations.
* iklib conditions string::     String encoding and decoding.
* iklib conditions misc::       Miscellaneous primitives.
@end menu

@c page
@node iklib conditions raising
@subsection Raising conditions


@defun raise-non-continuable-standard-condition @var{who} @var{message} @var{irritants}
@defunx raise-non-continuable-standard-condition @var{who} @var{message} @var{irritants} @var{cnd}
Raise a non--continuable exception with a compound condition object of
types: @condition{who}, @condition{message}, @condition{irritants}; in
addition, when used, add the condition object @var{cnd} to it.

The argument @var{who} must be a symbol.  The argument @var{message}
must be a string.  The argument @var{irritants} must be null or a list
of objects.  The optional argument @var{cnd} must be a simple or
compound condition object.
@end defun

@c page
@node iklib conditions preds
@subsection Predicates for condition objects


@defun simple-condition? @var{obj}
Return @true{} if @var{obj} is a simple condition object; otherwise
return @false{}.
@end defun


@defun list-of-simple-conditions? @var{obj}
Return @true{} if @var{obj} is a proper list of simple condition
objects; otherwise return @false{}.
@end defun


@defun list-of-conditions? @var{obj}
Return @true{} if @var{obj} is a proper list of simple or compound
condition objects; otherwise return @false{}.
@end defun

@c page
@node iklib conditions spos
@subsection Scheme source code position


The following bindings are exported by the library @library{vicare}.


@deftp {Condition Type} &source-position
Condition type used to represent a position in Scheme source code read
from a textual input port; it is derived from @condition{condition}.  It
has the following fields:

@table @code
@item port-id
A Scheme string representing the port identifier, for example the file
name.

@item byte
An exact non--negative zero--based integer representing the byte offset
of the position in the source.

@item character
An exact non--negative zero--based integer representing the character
offset of the position in the source.

@item line
An exact non--negative one--based integer representing the line offset
of the position in the source.

@item column
An exact non--negative one--based integer representing the column offset
of the position in the source.
@end table
@end deftp


@defun make-source-position-condition @var{port-id} @var{byte} @var{character} @var{line} @var{column}
Build and return a new condition object of type
@condition{source-position}.
@end defun


@defun source-position-condition? @var{obj}
Return true if @var{obj} is a condition object with type
@condition{source-position}.
@end defun


@defun source-position-port-id @var{spos}
@defunx source-position-byte @var{spos}
@defunx source-position-character @var{spos}
@defunx source-position-line @var{spos}
@defunx source-position-column @var{spos}
Accessors for the fields of condition objects of type
@condition{source-position}.
@end defun

@c page
@node iklib conditions eagain
@subsection Reporting @code{EAGAIN} exceptions


The following bindings are exported by the library @library{vicare}.


@deftp {Condition Type} &i/o-eagain
Used to signal that a system call returned with @code{errno} set to
@code{EAGAIN}.  It is derived from @condition{i/o}.
@end deftp


@defun make-i/o-eagain
Return a new condition object of type @condition{i/o-eagain}.
@end defun


@defun i/o-eagain-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{i/o-eagain}.
@end defun

@c page
@node iklib conditions errno
@subsection Reporting @code{errno} exceptions


The following bindings are exported by the library @library{vicare}.


@deftp {Condition Type} &errno
Condition object type representing system errors described by an encoded
@code{errno} value; it is derived from @condition{condition}.
@end deftp


@defun make-errno-condition @var{errno}
Build and return a new @condition{errno} condition object holding the
given encoded @code{errno} value.
@end defun


@defun errno-condition? @var{obj}
Return @true{} if @var{obj} is an instance of @condition{errno}.
@end defun


@defun condition-errno @var{obj}
Accessor for the encoded @code{errno} value in @var{obj}, which must be
an instance of @condition{errno}.
@end defun

@c page
@node iklib conditions failexpr
@subsection Failed expression conditions


@deftp {Condition Type} &failed-expression-condition
Condition type used to describe a failed expression, for example in a
procedure argument validation predicate.  It is derived from
@condition{condition}.  It has the following fields:

@table @code
@item failed-expression
A symbolic expression representing the source code of the failed
expression.
@end table
@end deftp


@defun make-failed-expression-condition @var{sexp}
Build and return a condition object of type
@condition{failed-expression-condition}.
@end defun


@defun failed-expression-condition? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{failed-expression-condition}; otherwise return @false{}.
@end defun


@defun condition-failed-expression @var{cnd}
Given a condition object off type
@condition{failed-expression-condition} return the symbolic expression.
@end defun

@c page
@node iklib conditions procpre
@subsection Procedure precondition violations


@deftp {Condition Type} &procedure-precondition-violation
Base condition object type representing invalid state or argument for a
procedure application; it is derived from @condition{assertion}.
@end deftp


@defun make-procedure-precondition-violation
Build and return a new condition object of type
@condition{procedure-precondition-violation}.
@end defun


@defun procedure-precondition-violation? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{procedure-precondition-violation}; otherwise return
@false{}.
@end defun

@c page
@node iklib conditions procpost
@subsection Procedure postcondition violations


@deftp {Condition Type} &procedure-postcondition-violation
Base condition object type representing invalid state or return values
for a procedure application; it is derived from @condition{assertion}.
@end deftp


@defun make-procedure-postcondition-violation
Build and return a new condition object of type
@condition{procedure-postcondition-violation}.
@end defun


@defun procedure-postcondition-violation? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{procedure-postcondition-violation}; otherwise return
@false{}.
@end defun

@c page
@node iklib conditions procarg
@subsection Procedure argument violations


@deftp {Condition Type} &procedure-argument-violation
Condition object type representing, generically, one or more invalid
values handed as arguments to a procedure application; it is derived
from @condition{procedure-precondition-violation}.
@end deftp


@defun make-procedure-argument-violation
Build and return a new condition object of type
@condition{procedure-argument-violation}.
@end defun


@defun procedure-argument-violation? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{procedure-argument-violation}; otherwise return @false{}.
@end defun


@defun procedure-argument-violation @var{who} @var{message} @var{irritant} @dots{}
Raise a compound condition object as non--continuable exception with
component types: @condition{who}, @condition{message},
@condition{irritants}, @condition{procedure-argument-violation}.
@end defun

@c page
@node iklib conditions sigarg
@subsection Procedure signature argument violations


@deftp {Condition Type} &procedure-signature-argument-violation
Condition object type representing an invalid value handed as argument
to a procedure application; it is derived from
@condition{procedure-argument-violation}.

This condition type has the following fields:

@table @code
@item index
One--base index of the offending operand.  It is @false{} when the index
is unknown.

@item failed-expression
Symbolic expression representing the predicate used to validate the
operand; set to the void object if the expression is not available.
When debugging mode is disabled: some code might avoid putting symbolic
expressions in this field.

@item offending-value
The actual value of the operand.  If there are multiple offending
values: this field can be set to @code{(void)} and an additional
condition object of type @condition{irritants} can be used.
@end table

This condition type is meant to be used to signal a wrong argument given
to a procedure performing signature validation; for example
@syntax{define*} and @syntax{case-define*} use it to signal a violation
of the logic predicate specifications.
@end deftp


@defun make-procedure-signature-argument-violation @var{operand-index} @var{failed-expression} @var{offending-value}
Build and return a new condition object of type
@condition{procedure-signature-argument-violation}.
@end defun


@defun procedure-signature-argument-violation? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{procedure-signature-argument-violation}; otherwise return @false{}.
@end defun


@defun procedure-signature-argument-violation.one-based-argument-index @var{cnd}
@defunx procedure-signature-argument-violation.failed-expression @var{cnd}
@defunx procedure-signature-argument-violation.offending-value @var{cnd}
Accessors for the fields of condition objects of type
@condition{procedure-signature-argument-violation}.
@end defun


@defun procedure-signature-argument-violation @var{who} @var{message} @var{operand-index} @var{failed-expression} @var{offending-value}
Raise a compound condition object as non--continuable exception with
component types: @condition{who}, @condition{message},
@condition{irritants}, @condition{procedure-signature-argument-violation}.
@end defun

@c page
@node iklib conditions rvarg
@subsection Procedure signature return value violations


@deftp {Condition Type} &procedure-signature-return-value-violation
Condition object type representing invalid values returned from an
expression; it is derived from
@condition{procedure-postcondition-violation}.  It has the following
fields:

@table @code
@item index
One--base index of the offending return value in the tuple of values
returned by the expression.  It is @false{} when the index is unknown.

@item failed-expression
Symbolic expression representing the predicate used to validate the
return value.

@item offending-value
The actual value returned by the expression.
@end table
@end deftp


@defun make-procedure-signature-return-value-violation @var{retval-index} @var{failed-expression} @var{offending-value}
Build and return a new condition object of type
@condition{procedure-signature-return-value-violation}.
@end defun


@defun procedure-signature-return-value-violation? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{procedure-signature-return-value-violation}; otherwise return
@false{}.
@end defun


@defun procedure-signature-return-value-violation.one-based-return-value-index @var{cnd}
@defunx procedure-signature-return-value-violation.failed-expression @var{cnd}
@defunx procedure-signature-return-value-violation.offending-value @var{cnd}
Accessors for the fields of condition objects of type
@condition{procedure-signature-return-value-violation}.
@end defun


@defun procedure-signature-return-value-violation @var{who} @var{message} @var{retval-index} @var{failed-expression} @var{offending-value} @var{irritant} @dots{}
Raise a compound condition object as non--continuable exception with
component types: @condition{who}, @condition{message},
@condition{irritants}, @condition{procedure-signature-return-value-violation}.
@end defun

@c page
@node iklib conditions proccon
@subsection Procedure argument consistency violations


@deftp {Condition Type} &procedure-arguments-consistency-violation
Condition object type representing a set of inconsistent arguments to a
procedure application; it is derived from
@condition{procedure-precondition-violation}.
@end deftp


@defun make-procedure-arguments-consistency-violation
Build and return a new condition object of type
@condition{procedure-arguments-consistency-violation}.
@end defun


@defun procedure-arguments-consistency-violation? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{procedure-arguments-consistency-violation}; otherwise return
@false{}.
@end defun


@defun procedure-arguments-consistency-violation @var{who} @var{message} @var{irritant} @dots{}
Raise a non--continuable exception with compound condition object
holding components of type: @condition{who}, @condition{message},
@condition{irritants},
@condition{procedure-arguments-consistency-violation}.
@end defun


@defun procedure-arguments-consistency-violation/failed-expression @var{who} @var{message} @var{failed-expression} @var{irritant} @dots{}
Like @func{procedure-arguments-consistency-violation} and in addition
attach to the raised condition object a component with type
@condition{failed-expression-condition}, using the symbolic
@var{failed-expression} as argument.
@end defun

@c page
@node iklib conditions exprret
@subsection Expression return value violations


@deftp {Condition Type} &expression-return-value-violation
Condition object type representing invalid values returned from an
expression; it is derived from @condition{assertion}.
@end deftp


@defun make-expression-return-value-violation
Build and return a new condition object of type
@condition{expression-return-value-violation}.
@end defun


@defun expression-return-value-violation? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{expression-return-value-violation}; otherwise return
@false{}.
@end defun


@defun expression-return-value-violation @var{who} @var{message} @var{irritant} @dots{}
Raise a compound condition object as non--continuable exception with
component types: @condition{who}, @condition{message},
@condition{irritants}, @condition{expression-return-value-violation}.
@end defun

@c page
@node iklib conditions non-reinst
@subsection Non--reinstatable continuations


@anchor{&non-reinstatable}
@deftp {Condition Type} &non-reinstatable
Condition object type representing an attempt to reinstate a
continuation in an invalid context; it is derived from
@condition{violation}.
@end deftp


@defun make-non-reinstatable-violation
Build and return a new condition object of type
@condition{non-reinstatable}.
@end defun


@defun non-reinstatable-violation? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{non-reinstatable}; otherwise return @false{}.
@end defun


@defun non-reinstatable-violation @var{who} @var{message} @var{irritant} @dots{}
Raise a compound condition object with components: @condition{who},
@condition{message}, @condition{irritants},
@condition{non-reinstatable}.
@end defun

@c page
@node iklib conditions string
@subsection String encoding and decoding


@menu
* iklib conditions string generic::     Generic string encoding condition types.
* iklib conditions string utf8::        @utf{}-8 string encoding condition types.
* iklib conditions string utf16::       @utf{}-16 string encoding condition types.
* iklib conditions string utf32::       @utf{}-32 string encoding condition types.
@end menu

@c page
@node iklib conditions string generic
@subsubsection Generic string encoding condition types


@subsubheading Encoding strings

@deftp {Condition Type} &string-encoding
Condition object type representing an error while encoding a string into
a bytevector; it is derived from @condition{error}.
@end deftp


@defun make-string-encoding-error
Build and return a new condition object of type
@condition{string-encoding}.
@end defun


@defun string-encoding-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{string-encoding}; otherwise return @false{}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Decoding strings

@deftp {Condition Type} &string-decoding
Condition object type representing an error while encoding a bytevector
into a string; it is derived from @condition{error}.
@end deftp


@defun make-string-decoding-error
Build and return a new condition object of type
@condition{string-decoding}.
@end defun


@defun string-decoding-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{string-decoding}; otherwise return @false{}.
@end defun

@c page
@node iklib conditions string utf8
@subsubsection @utf{}-8 string encoding condition types


@subsubheading Encoding strings into @utf{}-8 bytevectors


@deftp {Condition Type} &utf8-string-encoding
Condition object type representing an error while encoding a string into
a @utf{}-8 bytevector; it is derived from @condition{string-encoding}.
@end deftp


@defun make-utf8-string-encoding-error
Build and return a new condition object of type
@condition{utf8-string-encoding}.
@end defun


@defun utf8-string-encoding-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf8-string-encoding}; otherwise return @false{}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Decoding strings from @utf{}-8 bytevectors


@deftp {Condition Type} &utf8-string-decoding
Condition object type representing an error while decoding a @utf{}-8
bytevector into a string; it is derived from
@condition{string-decoding}.
@end deftp


@defun make-utf8-string-decoding-error
Build and return a new condition object of type
@condition{utf8-string-decoding}.
@end defun


@defun utf8-string-decoding-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf8-string-decoding}; otherwise return @false{}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Invalid octet in @utf{}-8 bytevector

@deftp {Condition Type} &utf8-string-decoding-invalid-octet
Condition object type representing an invalid octet in a @utf{}-8
bytevector; it is derived from @condition{utf8-string-decoding}.  It has
the following fields:

@table @code
@item bytevector
The @utf{}-8 bytevector.

@item index
The index in the bytevector of the offending octet.

@item octets
A list holding the offending octet.
@end table
@end deftp


@defun make-utf8-string-decoding-invalid-octet @var{bytevector} @var{index} @var{octets}
Build and return a condition object of type
@condition{utf8-string-decoding-invalid-octet}.
@end defun


@defun utf8-string-decoding-invalid-octet? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf8-string-decoding-invalid-octet}; otherwise return
@false{}.
@end defun


@defun utf8-string-decoding-invalid-octet.bytevector @var{cnd}
@defunx utf8-string-decoding-invalid-octet.index @var{cnd}
@defunx utf8-string-decoding-invalid-octet.octets @var{cnd}
Field accessors for condition objects of type
@condition{utf8-string-decoding-invalid-octet}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Invalid 2-octets sequence in @utf{}-8 bytevector

@deftp {Condition Type} &utf8-string-decoding-invalid-2-tuple
Condition object type representing an invalid 2-octets sequence in a
@utf{}-8 bytevector: the first octet is valid, the second one is
invalid.  It is derived from @condition{utf8-string-decoding}.  It has
the following fields:

@table @code
@item bytevector
The @utf{}-8 bytevector.

@item index
The index in the bytevector of the offending octet.

@item octets
A list holding the offending octets.
@end table
@end deftp


@defun make-utf8-string-decoding-invalid-2-tuple @var{bytevector} @var{index} @var{octets}
Build and return a condition object of type
@condition{utf8-string-decoding-invalid-2-tuple}.
@end defun


@defun utf8-string-decoding-invalid-2-tuple? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf8-string-decoding-invalid-2-tuple}; otherwise return
@false{}.
@end defun


@defun utf8-string-decoding-invalid-2-tuple.bytevector @var{cnd}
@defunx utf8-string-decoding-invalid-2-tuple.index @var{cnd}
@defunx utf8-string-decoding-invalid-2-tuple.octets @var{cnd}
Field accessors for condition objects of type
@condition{utf8-string-decoding-invalid-2-tuple}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Invalid 3-octets sequence in @utf{}-8 bytevector

@deftp {Condition Type} &utf8-string-decoding-invalid-3-tuple
Condition object type representing an invalid 3-octets sequence in a
@utf{}-8 bytevector: the first octet is valid, the second and/or third
ones are invalid.  It is derived from @condition{utf8-string-decoding}.
It has the following fields:

@table @code
@item bytevector
The @utf{}-8 bytevector.

@item index
The index in the bytevector of the offending octet.

@item octets
A list holding the offending octets.
@end table
@end deftp


@defun make-utf8-string-decoding-invalid-3-tuple @var{bytevector} @var{index} @var{octets}
Build and return a condition object of type
@condition{utf8-string-decoding-invalid-3-tuple}.
@end defun


@defun utf8-string-decoding-invalid-3-tuple? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf8-string-decoding-invalid-3-tuple}; otherwise return
@false{}.
@end defun


@defun utf8-string-decoding-invalid-3-tuple.bytevector @var{cnd}
@defunx utf8-string-decoding-invalid-3-tuple.index @var{cnd}
@defunx utf8-string-decoding-invalid-3-tuple.octets @var{cnd}
Field accessors for condition objects of type
@condition{utf8-string-decoding-invalid-3-tuple}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Invalid 4-octets sequence in @utf{}-8 bytevector

@deftp {Condition Type} &utf8-string-decoding-invalid-4-tuple
Condition object type representing an invalid 4-octets sequence in a
@utf{}-8 bytevector: the first octet is valid, one or more among the
second, third and fourth ones are invalid.  It is derived from
@condition{utf8-string-decoding}.  It has the following fields:

@table @code
@item bytevector
The @utf{}-8 bytevector.

@item index
The index in the bytevector of the offending octet.

@item octets
A list holding the offending octets.
@end table
@end deftp


@defun make-utf8-string-decoding-invalid-4-tuple @var{bytevector} @var{index} @var{octets}
Build and return a condition object of type
@condition{utf8-string-decoding-invalid-4-tuple}.
@end defun


@defun utf8-string-decoding-invalid-4-tuple? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf8-string-decoding-invalid-4-tuple}; otherwise return
@false{}.
@end defun


@defun utf8-string-decoding-invalid-4-tuple.bytevector @var{cnd}
@defunx utf8-string-decoding-invalid-4-tuple.index @var{cnd}
@defunx utf8-string-decoding-invalid-4-tuple.octets @var{cnd}
Field accessors for condition objects of type
@condition{utf8-string-decoding-invalid-4-tuple}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Incomplete 2-octets sequence in @utf{}-8 bytevector

@deftp {Condition Type} &utf8-string-decoding-incomplete-2-tuple
Condition object type representing an incomplete 2-octets sequence in a
@utf{}-8 bytevector: the first octet is present, the second one is
missing because we are at the end of the bytevector.  It is derived from
@condition{utf8-string-decoding}.  It has the following fields:

@table @code
@item bytevector
The @utf{}-8 bytevector.

@item index
The index in the bytevector of the first octet in the incomplete
sequence.

@item octets
A list holding the incomplete sequence of octets.
@end table
@end deftp


@defun make-utf8-string-decoding-incomplete-2-tuple @var{bytevector} @var{index} @var{octets}
Build and return a condition object of type
@condition{utf8-string-decoding-incomplete-2-tuple}.
@end defun


@defun utf8-string-decoding-incomplete-2-tuple? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf8-string-decoding-incomplete-2-tuple}; otherwise return
@false{}.
@end defun


@defun utf8-string-decoding-incomplete-2-tuple.bytevector @var{cnd}
@defunx utf8-string-decoding-incomplete-2-tuple.index @var{cnd}
@defunx utf8-string-decoding-incomplete-2-tuple.octets @var{cnd}
Field accessors for condition objects of type
@condition{utf8-string-decoding-incomplete-2-tuple}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Incomplete 3-octets sequence in @utf{}-8 bytevector

@deftp {Condition Type} &utf8-string-decoding-incomplete-3-tuple
Condition object type representing an incomplete 3-octets sequence in a
@utf{}-8 bytevector: the first octet is present, the second and/or third
ones are missing because we are at the end of the bytevector.  It is
derived from @condition{utf8-string-decoding}.  It has the following
fields:

@table @code
@item bytevector
The @utf{}-8 bytevector.

@item index
The index in the bytevector of the first octet in the incomplete
sequence.

@item octets
A list holding the incomplete sequence of octets.
@end table
@end deftp


@defun make-utf8-string-decoding-incomplete-3-tuple @var{bytevector} @var{index} @var{octets}
Build and return a condition object of type
@condition{utf8-string-decoding-incomplete-3-tuple}.
@end defun


@defun utf8-string-decoding-incomplete-3-tuple? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf8-string-decoding-incomplete-3-tuple}; otherwise return
@false{}.
@end defun


@defun utf8-string-decoding-incomplete-3-tuple.bytevector @var{cnd}
@defunx utf8-string-decoding-incomplete-3-tuple.index @var{cnd}
@defunx utf8-string-decoding-incomplete-3-tuple.octets @var{cnd}
Field accessors for condition objects of type
@condition{utf8-string-decoding-incomplete-3-tuple}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Incomplete 4-octets sequence in @utf{}-8 bytevector

@deftp {Condition Type} &utf8-string-decoding-incomplete-4-tuple
Condition object type representing an incomplete 4-octets sequence in a
@utf{}-8 bytevector: the first octet is present, one or more among the
second, third and fourth ones are missing because we are at the end of
the bytevector.  It is derived from @condition{utf8-string-decoding}.
It has the following fields:

@table @code
@item bytevector
The @utf{}-8 bytevector.

@item index
The index in the bytevector of the first octet in the incomplete
sequence.

@item octets
A list holding the incomplete sequence of octets.
@end table
@end deftp


@defun make-utf8-string-decoding-incomplete-4-tuple @var{bytevector} @var{index} @var{octets}
Build and return a condition object of type
@condition{utf8-string-decoding-incomplete-4-tuple}.
@end defun


@defun utf8-string-decoding-incomplete-4-tuple? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf8-string-decoding-incomplete-4-tuple}; otherwise return
@false{}.
@end defun


@defun utf8-string-decoding-incomplete-4-tuple.bytevector @var{cnd}
@defunx utf8-string-decoding-incomplete-4-tuple.index @var{cnd}
@defunx utf8-string-decoding-incomplete-4-tuple.octets @var{cnd}
Field accessors for condition objects of type
@condition{utf8-string-decoding-incomplete-4-tuple}.
@end defun

@c page
@node iklib conditions string utf16
@subsubsection @utf{}-16 string encoding condition types


@subsubheading Encoding strings into @utf{}-16 bytevectors


@deftp {Condition Type} &utf16-string-encoding
Condition object type representing an error while encoding a string into
a @utf{}-16 bytevector; it is derived from @condition{string-encoding}.
@end deftp


@defun make-utf16-string-encoding-error
Build and return a new condition object of type
@condition{utf16-string-encoding}.
@end defun


@defun utf16-string-encoding-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf16-string-encoding}; otherwise return @false{}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Decoding strings from @utf{}-16 bytevectors


@deftp {Condition Type} &utf16-string-decoding
Condition object type representing an error while decoding a @utf{}-16
bytevector into a string; it is derived from
@condition{string-decoding}.
@end deftp


@defun make-utf16-string-decoding-error
Build and return a new condition object of type
@condition{utf16-string-decoding}.
@end defun


@defun utf16-string-decoding-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf16-string-decoding}; otherwise return @false{}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Invalid first word in @utf{}-16 bytevectors

@deftp {Condition Type} &utf16-string-decoding-invalid-first-word
Condition object type representing an invalid 16-bit word in the
position of standalone word or first word of a surrogate pair; it is
derived from @condition{utf16-string-decoding}.  It has the following
fields:

@table @code
@item bytevector
The bytevector object.

@item index
The index of the offending word.

@item word
The offending word.
@end table
@end deftp


@defun make-utf16-string-decoding-invalid-first-word @var{bytevector} @var{index} @var{word}
Build and return a new condition object of type
@condition{utf16-string-decoding-invalid-first-word}.
@end defun


@defun utf16-string-decoding-invalid-first-word? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf16-string-decoding-invalid-first-word}; otherwise return
@false{}.
@end defun


@defun utf16-string-decoding-invalid-first-word.bytevector @var{cnd}
@defunx utf16-string-decoding-invalid-first-word.index @var{cnd}
@defunx utf16-string-decoding-invalid-first-word.word @var{cnd}
Field accessors for condition objects of type
@condition{utf16-string-decoding-invalid-first-word}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Invalid second word in @utf{}-16 bytevectors

@deftp {Condition Type} &utf16-string-decoding-invalid-second-word
Condition object type representing an invalid 16-bit word in the
position of second word of a surrogate pair; it is derived from
@condition{utf16-string-decoding}.  It has the following fields:

@table @code
@item bytevector
The bytevector object.

@item index
The index of the offending second word.

@item first-word
The correct first word.

@item second-word
The offending second word.
@end table
@end deftp


@defun make-utf16-string-decoding-invalid-second-word @var{bytevector} @var{index} @var{first-word} @var{second-word}
Build and return a new condition object of type
@condition{utf16-string-decoding-invalid-second-word}.
@end defun


@defun utf16-string-decoding-invalid-second-word? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf16-string-decoding-invalid-second-word}; otherwise return
@false{}.
@end defun


@defun utf16-string-decoding-invalid-second-word.bytevector @var{cnd}
@defunx utf16-string-decoding-invalid-second-word.index @var{cnd}
@defunx utf16-string-decoding-invalid-second-word.first-word @var{cnd}
@defunx utf16-string-decoding-invalid-second-word.second-word @var{cnd}
Field accessors for condition objects of type
@condition{utf16-string-decoding-invalid-second-word}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Missing second word in @utf{}-16 bytevectors


@deftp {Condition Type} &utf16-string-decoding-missing-second-word
Condition object type representing a missing 16-bit word in the position
of second word of a surrogate pair; it is derived from
@condition{utf16-string-decoding}.  It has the following fields:

@table @code
@item bytevector
The bytevector object.

@item index
The index of the correct first word.

@item word
The correct first word.
@end table
@end deftp


@defun make-utf16-string-decoding-missing-second-word @var{bytevector} @var{index} @var{word}
Build and return a new condition object of type
@condition{utf16-string-decoding-missing-second-word}.
@end defun


@defun utf16-string-decoding-missing-second-word? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf16-string-decoding-missing-second-word}; otherwise return
@false{}.
@end defun


@defun utf16-string-decoding-missing-second-word.bytevector @var{cnd}
@defunx utf16-string-decoding-missing-second-word.index @var{cnd}
@defunx utf16-string-decoding-missing-second-word.word @var{cnd}
Field accessors for condition objects of type
@condition{utf16-string-decoding-missing-second-word}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Standalone octet in @utf{}-16 bytevectors


@deftp {Condition Type} &utf16-string-decoding-standalone-octet
Condition object type representing a standalone octet at the end of the
byte vector; it is derived from @condition{utf16-string-decoding}.  It
has the following fields:

@table @code
@item bytevector
The bytevector object.

@item index
The index of the octet.

@item octet
The offending octet.
@end table
@end deftp


@defun make-utf16-string-decoding-standalone-octet @var{bytevector} @var{index} @var{octet}
Build and return a new condition object of type
@condition{utf16-string-decoding-standalone-octet}.
@end defun


@defun utf16-string-decoding-standalone-octet? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf16-string-decoding-standalone-octet}; otherwise return
@false{}.
@end defun


@defun utf16-string-decoding-standalone-octet.bytevector @var{cnd}
@defunx utf16-string-decoding-standalone-octet.index @var{cnd}
@defunx utf16-string-decoding-standalone-octet.octet @var{cnd}
Field accessors for condition objects of type
@condition{utf16-string-decoding-standalone-octet}.
@end defun

@c page
@node iklib conditions string utf32
@subsubsection @utf{}-32 string encoding condition types


@subsubheading Encoding strings into @utf{}-32 bytevectors


@deftp {Condition Type} &utf32-string-encoding
Condition object type representing an error while encoding a string into
a @utf{}-32 bytevector; it is derived from @condition{string-encoding}.
@end deftp


@defun make-utf32-string-encoding-error
Build and return a new condition object of type
@condition{utf32-string-encoding}.
@end defun


@defun utf32-string-encoding-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf32-string-encoding}; otherwise return @false{}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Decoding strings from @utf{}-32 bytevectors


@deftp {Condition Type} &utf32-string-decoding
Condition object type representing an error while decoding a @utf{}-32
bytevector into a string; it is derived from
@condition{string-decoding}.
@end deftp


@defun make-utf32-string-decoding-error
Build and return a new condition object of type
@condition{utf32-string-decoding}.
@end defun


@defun utf32-string-decoding-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf32-string-decoding}; otherwise return @false{}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Invalid 32-bit word in @utf{}-32 bytevectors


@deftp {Condition Type} &utf32-string-decoding-invalid-word
Condition object type representing an invalid 32-bit word; it is derived
from @condition{utf32-string-decoding}.  It has the following fields:

@table @code
@item bytevector
The bytevector object.

@item index
The index of the offending word.

@item word
The offending word.
@end table
@end deftp


@defun make-utf32-string-decoding-invalid-word @var{bytevector} @var{index} @var{word}
Build and return a new condition object of type
@condition{utf32-string-decoding-invalid-word}.
@end defun


@defun utf32-string-decoding-invalid-word? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf32-string-decoding-invalid-word}; otherwise return
@false{}.
@end defun


@defun utf32-string-decoding-invalid-word.bytevector @var{cnd}
@defunx utf32-string-decoding-invalid-word.index @var{cnd}
@defunx utf32-string-decoding-invalid-word.word @var{cnd}
Field accessors for condition objects of type
@condition{utf32-string-decoding-invalid-word}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Orphan octets at end of @utf{}-32 bytevectors


@deftp {Condition Type} &utf32-string-decoding-orphan-octets
Condition object type representing the presence of 1, 2 or 3 orphan
octets at the end of the @utf{}-32 bytevector; it is derived from
@condition{utf32-string-decoding}.  It has the following fields:

@table @code
@item bytevector
The bytevector object.

@item index
The index of the first octet.

@item octets
A list of fixnums representing the octets.
@end table
@end deftp


@defun make-utf32-string-decoding-orphan-octets @var{bytevector} @var{index} @var{octets}
Build and return a new condition object of type
@condition{utf32-string-decoding-orphan-octets}.
@end defun


@defun utf32-string-decoding-orphan-octets? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{utf32-string-decoding-orphan-octets}; otherwise return
@false{}.
@end defun


@defun utf32-string-decoding-orphan-octets.bytevector @var{cnd}
@defunx utf32-string-decoding-orphan-octets.index @var{cnd}
@defunx utf32-string-decoding-orphan-octets.octets @var{cnd}
@end defun

@c page
@node iklib conditions misc
@subsection Miscellaneous primitives


@defun compound-condition? @var{obj}
Return @true{} if @var{obj} is a compound condition object; otherwise
return @false{}.

@lisp
(compound-condition? (make-error))
@result{} #f

(compound-condition? (condition (make-error)
                                (make-warning)))
@result{} #t

(compound-condition? "ciao")
@result{} #f
@end lisp
@end defun


@defun condition-and-rtd? @var{obj} @var{rtd}
Return @true{} if @var{obj} is either a simple condition object of type
@var{rtd} or a compound condition object containing a simple condition
object of type @var{rtd}; otherwise return @false{}.  @var{rtd} must be
the record--type descriptor of a condition object type.

@example
(condition-and-rtd? (make-error)
                    (record-type-descriptor &error))
@result{} #t

(condition-and-rtd? (condition (make-error)
                               (make-warning))
                    (record-type-descriptor &error))
@result{} #t

(condition-and-rtd? "ciao"
                    (record-type-descriptor &error))
@result{} #f
@end example
@end defun


@defun print-condition @var{cnd}
@defunx print-condition @var{cnd} @var{port}
Print a human readable serialisation of a condition object to the given
@var{port}, which must be a textual output port.  When not given:
@var{port} defaults to the return value of @code{(console-error-port)}.
@end defun

@c page
@node iklib reader
@section Reader


@menu
* iklib reader mode::           Textual input port modes.
* iklib reader bv::             Additional bytevector syntaxes.
* iklib reader chars::          Custom named characters.
* iklib reader stx::            Miscellaneous additional syntaxes.
* iklib reader fun::            Additional reader functions.
@end menu

@c page
@node iklib reader mode
@subsection Textual input port modes


@deffn {Reader Syntax} {#!vicare}
@deffnx {Reader Syntax} {#!ikarus}
@value{PRJNAME} extends Scheme's lexical syntax (@rnrs{6} Chapter 4) in
a variety of ways including:

@itemize
@item
@cindex @code{#!eof}
End--of--file marker, @code{#!eof}.

@item
@cindex @code{#!void}
Void object, @code{#!void}.

@item
@cindex @code{#!would-block}
Would--block object, @code{#!would-block}.

@item
@cindex @code{#!unbound}
Unbound object, @code{#!unbound}.

@item
@cindex @code{#!bwp}
@acronym{BWP} object, @code{#!bwp}.

@item
Gensym syntax, @code{#@{gensym@}}.

@item
Shared structures graph notation: @code{#nn=}, @code{#nn#}.

@item
Special symbols: @code{++}, @code{--}.

@item
Special symbol @code{|}, which is a standalone vertical bar.

@item
Special symbols beginning with @code{+g} and @code{-g}, to allow reading
symbols starting with @code{+greek-pi} and @code{-greek-pi}.

@item
Brace lists @code{@{ ... @}} are read as @code{(brace ...)}, @ref{iklib
syntaxes misc, brace}.
@end itemize

The syntax extensions are made available by default on all input ports,
until the token @code{#!r6rs} is read; thus, reading the token
@code{#!r6rs} disables all extensions to the lexical syntax on the
specific port, and the token @code{#!vicare} enables them again.

When writing code that is intended to be portable across different
Scheme implementations, we should add the token @code{#!r6rs} to the top
of every script and library that we write; this allows @value{PRJNAME}
to alert us when using non--portable features.  When writing code that's
intended to be @value{PRJNAME}--specific, we should add the token
@code{#!vicare} in order to get an immediate error when the code is run
under other implementations.

The comment @code{#!ikarus} is accepted for backwards compatibility with
Ikarus Scheme.
@end deffn


@deffn Procedure port-mode @var{input-port}
Accept an input port as argument and return a symbol among: @code{r6rs},
@code{vicare}.  All input ports start under @code{vicare} mode and thus
accept @value{PRJNAME}--specific reader extensions.  When the token
@code{#!r6rs} is read from a port: its mode changes to @code{r6rs}.

@example
> (port-mode (current-input-port))
vicare
> #!r6rs (port-mode (current-input-port))
r6rs
> #!vicare (port-mode (current-input-port))
vicare
@end example
@end deffn


@deffn Procedure set-port-mode! @var{input-port} @var{mode}
Modifiy the lexical syntax accepted by subsequent calls to @func{read}
on the input port.  The mode is a symbol among @code{r6rs} and
@code{vicare}.  The effect of setting the port mode is similar to that
of reading the token @code{#!r6rs} or @code{#!vicare} from that port.

@example
> (set-port-mode! (current-input-port) 'r6rs)
> (port-mode (current-input-port))
r6rs
@end example
@end deffn

@c page
@node iklib reader bv
@subsection Additional bytevector syntaxes


The following syntaxes are available only when the input port mode is
set to @code{vicare}.


@deffn {Reader Syntax} {#vs8(@var{byte} ...)}
Read a bytevector as @code{#vu8(@var{octect} ...)} would do, but allow
@var{byte} to be in the range @math{[-128, 127]}.
@end deffn


@deffn {Reader Syntax} {#vu16l(@var{word} ...)}
@deffnx {Reader Syntax} {#vu16b(@var{word} ...)}
@deffnx {Reader Syntax} {#vu16n(@var{word} ...)}
Read a bytevector of 16-bit unsigned words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vs16l(@var{word} ...)}
@deffnx {Reader Syntax} {#vs16b(@var{word} ...)}
@deffnx {Reader Syntax} {#vs16n(@var{word} ...)}
Read a bytevector of 16-bit signed words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vu32l(@var{word} ...)}
@deffnx {Reader Syntax} {#vu32b(@var{word} ...)}
@deffnx {Reader Syntax} {#vu32n(@var{word} ...)}
Read a bytevector of 32-bit unsigned words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vs32l(@var{word} ...)}
@deffnx {Reader Syntax} {#vs32b(@var{word} ...)}
@deffnx {Reader Syntax} {#vs32n(@var{word} ...)}
Read a bytevector of 32-bit signed words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vu64l(@var{word} ...)}
@deffnx {Reader Syntax} {#vu64b(@var{word} ...)}
@deffnx {Reader Syntax} {#vu64n(@var{word} ...)}
Read a bytevector of 64-bit unsigned words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vs64l(@var{word} ...)}
@deffnx {Reader Syntax} {#vs64b(@var{word} ...)}
@deffnx {Reader Syntax} {#vs64n(@var{word} ...)}
Read a bytevector of 64-bit signed words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vf4l(@var{flonum} ...)}
@deffnx {Reader Syntax} {#vf4b(@var{flonum} ...)}
@deffnx {Reader Syntax} {#vf4n(@var{flonum} ...)}
Read a bytevector of single--precision flonums stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vf8l(@var{flonum} ...)}
@deffnx {Reader Syntax} {#vf8b(@var{flonum} ...)}
@deffnx {Reader Syntax} {#vf8n(@var{flonum} ...)}
Read a bytevector of double--precision flonums stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vc4l(@var{cflonum} ...)}
@deffnx {Reader Syntax} {#vc4b(@var{cflonum} ...)}
@deffnx {Reader Syntax} {#vc4n(@var{cflonum} ...)}
Read a bytevector of single--precision cflonums stored in little, big
and native endianness, real part first.
@end deffn


@deffn {Reader Syntax} {#vc8l(@var{cflonum} ...)}
@deffnx {Reader Syntax} {#vc8b(@var{cflonum} ...)}
@deffnx {Reader Syntax} {#vc8n(@var{cflonum} ...)}
Read a bytevector of double--precision cflonums stored in little, big
and native endianness, real part first.
@end deffn


@deffn {Reader Syntax} {#ve(@var{encoding} @var{data})}
Read a bytevector in some encoding which is supposed to be easy to type
for human beings.  @var{encoding} is a symbol representing the encoding
format, @var{data} is a datum to convert to bytevector.  At present the
following encodings are supported:

@table @code
@item ascii
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->ascii}.

@item latin1
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->latin1}.

@item utf8
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->utf8}.

@item utf16be
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->utf16be}.

@item utf16le
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->utf16le}.

@item utf16n
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->utf16n}.

@item hex
Convert the Scheme string @var{data} to a bytevector using the function
@func{string-hex->bytevector}.

@item base64
Convert the Scheme string @var{data} to a bytevector using the function
@func{string-base64->bytevector}.

@item percent-encoding
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->percent-encoding}.
@end table
@end deffn

@c page
@node iklib reader chars
@subsection Custom named characters


The following syntaxes are available only when the input port mode is
set to @code{vicare}.


@deffn {Reader Syntax} {#!(char-names (@meta{name} . @meta{char}) ...)}
Add new custom named characters to the internal table for the current
reading operation.  Each @meta{name} must be a Scheme identifier
starting with a @meta{constituent} character as defined by @rnrs{6};
each @meta{char} must be a Scheme character.

@example
#!(char-names
    (lambda . #\x0EBB))
@end example
@end deffn


@deffn {Reader Syntax} {#\@{@meta{name}@}}
Reader syntax for standalone custom named characters.  @meta{name} must
be an identifier previously defined with the @code{char-names} comment
list defined above.

@example
#\@{lambda@}            @result{} #\xEBB
@end example
@end deffn


@deffn {Reader Syntax} {\@{@meta{name}@}}
Reader syntax for custom named characters embedded in strings.
@meta{name} must be an identifier previously defined with the
@code{char-names} comment list defined above.

@example
"\@{lambda@}"           @result{} "\xEBB;"
@end example
@end deffn

@c page
@node iklib reader stx
@subsection Miscellaneous additional syntaxes


The following syntaxes are available only when the input port mode is
set to @code{vicare}.


@deffn {Reader Syntax} {|@var{symbol}|}
The vertical bars can be used to specify symbols whose name does not
comply with the @rnrs{6} specifications; this syntax is available only
when the port mode is @code{#!vicare}.  Examples:

@example
(define port (open-string-input-port "|123|"))
(set-port-mode! port 'vicare)
(define sym (read port))

(symbol? sym)           @result{} #t
(symbol->string sym)    @result{} "123"
@end example

@noindent
backslash sequences are allowed in bar symbols:

@example
(define port (open-string-input-port "|123-\x41;\x42;\x43;|"))
(set-port-mode! port 'vicare)
(define sym (read port))

(symbol? sym)           @result{} #t
(symbol->string sym)    @result{} "123-\x41;\x42;\x43;"
@end example

@noindent
notice that the sequence of characters @code{|ciao|hello|} is split into
@code{ciao}, @code{hello}, @code{|} and the ending vertical bar would
cause an error if read:

@example
(define port (open-string-input-port "|ciao|hello|"))
(set-port-mode! port 'vicare)

(read port)             @result{} ciao
(read port)             @result{} hello
(port-eof? port)        @result{} #f
(get-char port)         @result{} #\|
(port-eof? port)        @result{} #t
@end example
@end deffn


@deffn {Reader Syntax} {#@{unique-name@}}
@deffnx {Reader Syntax} {#@{pretty-name unique-name@}}
@c @deffnx {Reader Syntax} {#:pretty-name}
@value{PRJNAME}'s @func{read} and @func{write} procedures extend the lexical
syntax of Scheme by the ability to read and write gensyms using one of
these three forms.

@code{#@{unique-name@}} constructs, at read time, a gensym whose unique
name is the one specified.  If a gensym with the same unique name
already exists in the system's symbol table, that gensym is returned.

@example
> '#@{some-long-name@}
#@{g0 |some-long-name|@}
> (gensym? '#@{some-long-unique-name@})
#t
> (eq? '#@{another-unique-name@} '#@{another-unique-name@})
#t
@end example

The two--part @code{#@{pretty-name unique-name@}} gensym syntax is
similar to the syntax shown above with the exception that if a new
gensym is constructed (that is, if the gensym did not already exist in
the symbol table), the pretty name of the constructed gensym is set to
@code{pretty-name}.

@example
> '#@{foo unique-identifier@}
#@{foo |unique-identifier|@}
> '#@{unique-identifier@}
#@{foo |unique-identifier|@}
> '#@{bar unique-identifier@}
#@{foo |unique-identifier|@}
@end example

@ignore
The @code{#:pretty-name} form constructs, at read time, a gensym whose
pretty name is @code{pretty-name} and whose unique name is fresh.  This
form guarantees that the resulting gensym is not @func{eq?} to any other
symbol in the system.

@example
> '#:foo
#@{foo |j=qTGlEwS/Zlp2Dj|@}
> (eq? '#:foo '#:foo)
#f
@end example
@end ignore
@end deffn


@deffn {Reader Syntax} {#:@var{symbol}}
Read a keyword object using @var{symbol} as symbol.  @var{symbol} must
be a symbol object as defined by @rnrs{6}.  @ref{iklib keywords, Keyword
objects}.
@end deffn


@deffn {Reader Syntax} {#!eof}
The end--of--file marker, @code{#!eof}, is an extension to the @rnrs{6}
syntax.  The primary utility of the @code{#!eof} marker is to stop the
reader (e.g. @func{read} and @func{get-datum}) from reading the rest of
the file.

@example
(import (vicare))
<some code>
(display "goodbye\n")

#!eof
<some junk>
@end example

The @code{#!eof} marker also serves as a datum in @value{PRJNAME}, much
like @true{} and @false{}, when it is found inside other expressions.

@example
> (eof-object)
#!eof
> (read (open-input-string ""))
#!eof
> (read (open-input-string "#!eof"))
#!eof
> (quote #!eof)
#!eof
> (eof-object? '#!eof)
#t
> #!r6rs #!eof
Unhandled exception
Condition components:
  1. &error
  2. &who: tokenize
  3. &message: "invalid syntax: #!e"
> #!vicare #!eof
$
@end example
@end deffn


@deffn {Reader Syntax} #ci @var{form}
@deffnx {Reader Syntax} #cs @var{form}
Switch between case sensitive and case insensitive identifiers; the
default for @rnrs{6} source code is case sensitive.  When @code{#ci} is
read: the next form read has case insensitive identifiers.  When
@code{#cs} is read: the next form read has case sensitive identifiers.

@example
#ci(1 2 3)              @result{} (1 2 3)
#cs(1 2 3)              @result{} (1 2 3)

#ci(1 A 3)              @result{} (1 a 3)
#cs(1 A 3)              @result{} (1 A 3)

#ci CIAO #cs CIAO       @result{} ciao CIAO
#ci CIAO CIAO           @result{} ciao CIAO

#ci(A #csB C)           @result{} (a B c)
#ci(A #cs B C)          @result{} (a B c)
@end example
@end deffn

@c page
@node iklib reader fun
@subsection Additional reader functions


The Scheme source code reader allows us to annotate source code read
from a textual input with informations about the position of an
expression in the input.  For example:

@lisp
(import (vicare))

(define port  (open-string-input-port "(list var)"))
(define datum (get-annotated-datum port))
(pretty-print datum)
@print{} #[annotation
        expression=#<omitted>
        stripped=(list var)
        textual-position=#[r6rs-record: &source-position
                              port-id="*string-input-port*"
                              byte=0
                              character=0
                              line=1
                              column=1]]
@end lisp

The following bindings are exported by the library @library{vicare}.


@deftp {Object type} annotation
Disjoint object type representing source code read from a textual input
port.  The source code expression is annotated with informations from
its textual input.
@end deftp


@defun annotation? @var{obj}
Return @true{} if @var{obj} is an @objtype{annotation} object, else return
@false{}.
@end defun


@defop {Field accessor} @objtype{annotation} annotation-expression @var{ann}
Return a list, vector, identifier, what--have--you that may contain
further annotations.
@end defop


@defop {Field accessor} @objtype{annotation} annotation-stripped @var{ann}
Return the same symbolic expression of the @code{expression} field with
no annotations.
@end defop


@defop {Field accessor} @objtype{annotation} annotation-textual-position @var{ann}
Return a condition object of type @condition{source-position}
representing the position of the expression in the source code.
@end defop


@defop {Field accessor} @objtype{annotation} annotation-source @var{ann}
Return a pair whose car is the port identifier and whose cdr is the
offset of the first character of the source expression in the textual
input.
@end defop


@defun get-annotated-datum @var{port}
Like @func{get-datum}, but rather than returning a datum return a
hierarchy of @objtype{annotation} objects with the same hierarchy of the
datum and embedding the datum itself.
@end defun

@c page
@node iklib expander
@section Interface to the expander


@menu
* iklib expander transformers::     Syntax transformers facilities.
* iklib expander export specs::     Additional export specifications.
* iklib expander import specs::     Additional import specifications.
* iklib expander local import::     Local library imports.
* iklib expander extended export::  Extended library exports.
* iklib expander fluids::           Fluid syntaxes.
* iklib expander utils::            Utilities for macro writers.
* iklib expander clauses::          Syntax clauses helpers.
* iklib expander etv::              Expand-time values.
* iklib expander parameters::       Expand-time parameters.
* iklib expander synonym::          Synonym transformers.
@end menu

@c page
@node iklib expander transformers
@subsection Syntax transformers facilities


The following bindings are exported by the library @library{vicare}.


@defun make-variable-transformer @var{func}
Defined by @rnrs{6}.  Build and return a ``special'' value that, when
used as right--hand side of a syntax definition, is recognised by the
expander as a variable transformer as opposed to a normal transformer or
a compile-time value.

@func{func} must be the transformer function.
@end defun


@defun variable-transformer? @var{obj}
Return @true{} if @var{obj} is recognised by the expander as a variable
transformer as opposed to a normal transformer or a compile--time value;
otherwise return @false{}.
@end defun


@defun variable-transformer-procedure @var{var-trasf}
If @var{var-trasf} is recognised by the expander as a variable
transformer: return the actual transformer function, otherwise raise an
assertion violation.
@end defun

@c page
@node iklib expander export specs
@subsection Additional export specifications


@deffn {Export Spec} prefix (@meta{internal} ...) @meta{prefix}
Prepend the specified prefix to the selected internal symbols and add
the result to the export list.  This clause is forbidden when running
with the command line option @option{--strict-r6rs}.

@example
(library (demo)
  (export
    (prefix (these those) yeah.))
  (import (rnrs))
  (define (these) "these")
  (define (those) "those"))
@end example
@end deffn


@deffn {Export Spec} deprefix (@meta{internal} ...) @meta{prefix}
Remove the specified prefix from the selected internal symbols and add
the result to the export list.  This clause is forbidden when running
with the command line option @option{--strict-r6rs}.

@example
(library (demo)
  (export
    (deprefix (yeah.this yeah.that) yeah.))
  (import (rnrs))
  (define (yeah.this) "this")
  (define (yeah.that) "that"))
@end example
@end deffn


@deffn {Export Spec} suffix (@meta{internal} ...) @meta{suffix}
Append the specified suffix to the selected internal symbols and add the
result to the export list.  This clause is forbidden when running with
the command line option @option{--strict-r6rs}.

@example
(library (demo)
  (export
    (suffix (these those) _yeah))
  (import (rnrs))
  (define (these) "these")
  (define (those) "those"))
@end example
@end deffn


@deffn {Export Spec} desuffix (@meta{internal} ...) @meta{suffix}
Remove the specified suffix from the selected internal symbols and add
the result to the export list.  This clause is forbidden when running
with the command line option @option{--strict-r6rs}.

@example
(library (demo)
  (export
    (desuffix (this_yeah that_yeah) _yeah))
  (import (rnrs))
  (define (this_yeah) "this")
  (define (that_yeah) "that"))
@end example
@end deffn

@c page
@node iklib expander import specs
@subsection Additional import specifications


@deffn {Import Spec} deprefix @meta{import-spec} @meta{prefix}
Similar to the import specification @code{prefix}, but remove a prefix
rather than add it.  This clause is forbidden when running with the
command line option @option{--strict-r6rs}.

@example
(import (rnrs)
  (rnrs eval))

(eval '(str.length "ciao")
      (environment
       '(prefix
         (deprefix (only (rnrs)
                         string-length
                         string-append)
                   string-)
         str.)))
@result{} 4
@end example
@end deffn


@deffn {Import Spec} suffix @meta{import-spec} @meta{suffix}
Similar to the import specification @code{prefix}, but append a suffix
rather than a prefix.  This clause is forbidden when running with the
command line option @option{--strict-r6rs}.
@end deffn


@deffn {Import Spec} desuffix @meta{import-spec} @meta{suffix}
Similar to the import specification @code{deprefix}, but remove a suffix
rather than a prefix.  This clause is forbidden when running with the
command line option @option{--strict-r6rs}.
@end deffn

@c page
@node iklib expander local import
@subsection Local library imports


@cindex @clause{import}, local library imports
@cindex Local library imports, @clause{import}
@cindex Importing alternative libraries, @clause{import}
@cindex @clause{import}, importing alternative libraries
@cindex Conditionally importing libraries, @clause{import}
@cindex @clause{import}, conditionally importing libraries


Local @func{import} forms are useful for the following reasons:

@enumerate
@item
They minimize the namespace clutter that usually occurs when many
libraries are imported at the top level.

@item
They limit the scope of the import and thus help modularize a library's
dependencies.

@item
They allow conditional importing of libraries, and so importing
alternative libraries according to some expand--time test.
@end enumerate

Let's suppose we are constructing a large library and at some point we
realize that a procedure needs to make use of some other library to
performing a specific task; importing that library at top level makes it
available for the entire library.  Consequently, even if that library is
no longer used anywhere in the code (say when the code that uses it is
deleted), it becomes very hard to delete the import without first
examiniming the entire library body for potential usage leaks.  By
locally importing a library into the appropriate scope, we gain the
ability to delete the @func{import} form when the procedure that was
using it is deleted.


@deffn Syntax import @meta{import-spec} ...
This syntax can be used anywhere definitions can occur:

@enumerate
@item
In a script body.

@item
At library's top--level.

@item
In internal definitions context.
@end enumerate

The syntax of the local @func{import} form is similar to the
@func{import} that appears at the top of a library or a script form, and
carries with it the same restrictions:

@itemize
@item
No identifier name may be imported twice unless it denotes the same
identifier.

@item
No identifier may be both imported and defined.

@item
Imported identifiers are immutable.
@end itemize

Each @meta{import-spec} can be as defined by @rnrs{6} or a symbol
representing the name of a module; notice that module import
specifications can be only symbols, @strong{without} prefixes, renaming
and the features allowed for libraries.
@end deffn


In the following example we import a library in the body of a function:

@example
;;; file "alpha.sls"
(library (alpha)
  (export doit)
  (import (vicare))
  (define (doit)
    (fprintf (current-error-port) "From alpha!\n")))

;;; file "beta.sls"
(library (beta)
  (export doit)
  (import (vicare))
  (define (doit)
    (fprintf (current-error-port) "From beta!\n")))

;;; file "program.sps"
(import (vicare)
  (alpha))
(define (do-that)
  (import (beta))
  (doit))
(doit)
(do-that)
@print{} From alpha!
@print{} From beta!
@end example

In the following example we import bindings from a module in the body of
a function:

@example
(import (vicare))

(define (doit)
  (fprintf (current-error-port) "From body!\n"))

(module do-stuff
  (doit)
  (define (doit)
    (fprintf (current-error-port) "From module!\n")))

(define (do-that)
  (import do-stuff)
  (doit))

(doit)
(do-that)
@print{} From body!
@print{} From module!
@end example

In the following example: if @ansrfi{13} is available, import
@func{string-concatenate} from it; otherwise define a custom version of
the function.

@example
#!r6rs
(import (vicare)
  (srfi :0))

(cond-expand
 ((srfi :13)
  (import (only (srfi :13)
                string-concatenate)))
 (else
  (define (string-concatenate strs)
    (receive (port getter)
        (open-string-output-port)
      (for-each-in-order (lambda (str)
                           (display str port))
        strs)
      (getter)))))

(display (string-concatenate '("a" "b" "c")))
(newline)
(flush-output-port (current-output-port))
@end example

@c page
@node iklib expander extended export
@subsection Extended library exports


@value{PRJNAME} allows the @func{export} syntax to appear at the top
level of a library among the definitions, not only as third form of a
@syntax{library} form.


@deffn Syntax export @meta{export-spec} ...
Export the specified bidings from the current library or module.  When
@func{export} appears at the top level of a library: it exports the
specified bindings from the library.  When @func{export} appears in the
body of a module: it exports the specified bindings from the module
(@strong{not} from the enclosing library).
@end deffn


Here is an example of library exporting a binding with a @func{export}
at the end:

@example
;;; file "alpha.sls"
(library (alpha)
  (export red)
  (import (vicare))
  (define (blue)
    'blue)
  (define (red)
    'red)
  (export blue))

;;; file "program.sps"
(import (vicare)
  (alpha))
(pretty-print (red)  (current-error-port))
(pretty-print (blue) (current-error-port))
@end example

Here is an example of module exporting a binding with @func{export}:

@example
(import (vicare))

(module (green)
  (define (green) 'green)
  (define (yellow) 'yellow)
  (export yellow))

(list (green) (yellow)) @result{} (green yellow)
@end example

@c page
@node iklib expander fluids
@subsection Fluid syntaxes


Fluid syntaxes are macro bindings that can be temporarily redefined
while expanding a sequence of forms:

@example
(import (vicare))

(define-fluid-syntax ciao
  (identifier-syntax "ciao"))

ciao    @result{} "ciao"

(fluid-let-syntax ((ciao (identifier-syntax "hello")))
  ciao) @result{} "hello"

(fluid-let-syntax ((ciao (identifier-syntax "ohayo")))
  ciao) @result{} "ohayo"

ciao    @result{} "ciao"
@end example


@deffn Syntax define-fluid-syntax @meta{keyword} @meta{expr}
Like @func{define-syntax} define a new syntax binding the transformer to
@meta{keyword}, but mark @meta{keyword} as fluid so that later it can be
rebound by @func{fluid-let-syntax}.
@end deffn


@deffn Syntax fluid-let-syntax ((@meta{keyword} @meta{expr}) ...) @metao{body} @meta{body}
Similar, but not equal, to @func{let-syntax}; rather than defining new
@meta{keyword} bindings, temporarily rebind the keywords to new
transformers while expanding the @meta{body} forms.  The given
@meta{keyword} must be already bound to fluid syntaxes defined by
@func{define-fluid-syntax}.

There are two differences between @func{fluid-let-syntax} and
@func{let-syntax}: @func{fluid-let-syntax} must appear in expression
context only; the internal @meta{body} forms are @strong{not} spliced in
the enclosing body.
@end deffn

@c page
@node iklib expander utils
@subsection Utilities for macro writers


@menu
* iklib expander utils intro::    Introduction to utility functions.
* iklib expander utils id::       Identifiers processing: generic functions.
* iklib expander utils records::  Generating identifiers for records @api{}.
* iklib expander utils structs::  Generating identifiers for structs @api{}.
* iklib expander utils pairs::    Pairs processing.
* iklib expander utils vectors::  Vectors processing.
* iklib expander utils special::  Special processors.
* iklib expander utils unwrap::   Unwrapping syntax objects.
* iklib expander utils inspect::  Inspecting syntax objects.
* iklib expander utils compar::   Comparing syntax objects.
@end menu

@c page
@node iklib expander utils intro
@subsubsection Introduction to utility functions


Some functions accept an optional argument @var{synner}: when used, it
must be a function accepting 1 or 2 arguments, the first argument being
a string error message and the optional second argument being a subform;
@var{synner} must raise a compound condition object with components:
@condition{who}, @condition{message}, @condition{syntax}.  The
@var{synner} argument is meant to be used as follows:

@example
(define-syntax (my-macro stx)
  (case-define synner
    ((message)
     (synner message #f))
    ((message subform)
     (syntax-violation 'my-macro message stx subform)))
  (syntax-case stx ()
    (pattern body)
    (_
     (synner "invalid syntax"))))
@end example

@c page
@node iklib expander utils id
@subsubsection Identifiers processing: generic functions


@defun identifier-bound? @var{id}
Return @true{} if the identifier @var{id} is lexically bound; otherwise
return @false{}.

@example
(import (vicare))

(identifier-bound? #'woppa-woppa-woppa)
@result{} #f

(let ((ciao 123))
  (define-syntax (doit stx)
    (identifier-bound? #'ciao))
  (doit))
@result{} #t

(let ((ciao 123))
  (define-syntax (doit stx)
    (syntax-case stx ()
      ((_ ?id)
       (identifier-bound? #'?id))))
  (doit ciao))
@result{} #t

(let ()
  (define ciao 123)
  (define-syntax (doit stx)
    (syntax-case stx ()
      ((_ ?id)
       (identifier-bound? #'?id))))
  (doit ciao))
@result{} #t

(let ()
  (let-syntax ((ciao (identifier-syntax 123)))
    (define-syntax (doit stx)
      (syntax-case stx ()
        ((_ ?id)
         (identifier-bound? #'?id))))
    (doit ciao)))
@result{} #t
@end example
@end defun


@defun identifier->string @var{id}
Return a string representing the name of the identifier @var{id}.
@end defun


@defun string->identifier @var{ctx} @var{str}
Build and return a new identifier, in the same lexical context of
@var{ctx}, having the string @var{str} as name.
@end defun


@defun identifier-prefix @var{prefix} @var{id}
Build and return a new identifier, in the same lexical context of the
identifier @var{id}, whose string name is the concatenation of
@var{prefix} and @var{id}.  @var{prefix} can be a string, symbol or
identifier.

@example
(import (vicare))

(bound-identifier=? (identifier-prefix "this-" #'that)
                    #'this-that)
@result{} #t
@end example
@end defun


@defun identifier-suffix @var{id} @var{suffix}
Build and return a new identifier, in the same lexical context of the
identifier @var{id}, whose string name is the concatenation of @var{id}
and @var{suffix}.  @var{suffix} can be a string, symbol or identifier.

@example
(import (vicare))

(bound-identifier=? (identifier-suffix #'this "-that")
                    #'this-that)
@result{} #t
@end example
@end defun


@defun identifier-append @var{ctx} @var{item} @dots{}
Build and return a new identifier, in the same lexical context of the
identifier @var{ctx}, whose string name is the concatenation of the
arguments @var{item}.  Each @var{item} can be a string, symbol or
identifier.

@example
(import (vicare))

(bound-identifier=? (identifier-append #'this "-that" '-those)
                    #'this-that-those)
@result{} #t
@end example
@end defun


@defun identifier-format @var{ctx} @var{template} @var{item} @dots{}
Build and return a new identifier, in the same lexical context of the
identifier @var{ctx}, whose string name is the result of formatting the
string @var{template} with the arguments @var{item}.  @var{template} can
be a string including the same escape sequences of @func{format} from
@library{vicare} (@pxref{iklib printing, format}).  Each @var{item} can
be a string, symbol or identifier.

@example
(import (vicare))

(bound-identifier=?
 (identifier-format #'here "~a-~a-~a" #'this "that" 'those)
 #'this-that-those)
@result{} #t
@end example
@end defun


@defun duplicate-identifiers? @var{ids}
@defunx duplicate-identifiers? @var{ids} @var{identifier=}
Search the list of identifiers @var{ids} for duplicate identifiers; at
the first duplicate found, return it; return @false{} if no duplications
are found.

The optional argument @var{identifier=} must be the predicate function
used to compare identifiers; when not given it defaults to
@func{free-identifier=?}.
@end defun


@defun delete-duplicate-identifiers @var{ids}
@defunx delete-duplicate-identifiers @var{ids} @var{identifier=}
Given the list of identifiers @var{ids} remove the duplicate identifiers
and return a proper list of unique identifiers.

The optional argument @var{identifier=} must be the predicate function
used to compare identifiers; when not given it defaults to
@func{free-identifier=?}.
@end defun


@defun identifier-memq @var{id} @var{ids}
@defunx identifier-memq @var{id} @var{ids} @var{identifier=}
Search the list of identifiers @var{ids} for one that matches @var{id}
and return the sublist starting with it; return @false{} if @var{id} is
not present.

The optional argument @var{identifier=} must be the predicate function
used to compare identifiers; when not given it defaults to
@func{free-identifier=?}.
@end defun


@deffn Syntax with-implicits ((@meta{ctx} @meta{symbol} ...) ...) . @meta{body}
Wrapper for @func{with-syntax} which defines the identifiers
@meta{symbol} with the same context of @meta{ctx}.  @meta{ctx} must be
an expression evaluating to an identifier; it is evaluated only once.
@meta{symbol} must be Scheme symbols.

For example:

@example
(syntax-case stx ()
  ((id)
   (identifier? #'id)
   (with-implicits ((#'id x y))
     #'(list x y))))
@end example

@noindent
is equivalent to:

@example
(syntax-case stx ()
  ((id)
   (identifier? #'id)
   (with-syntax ((x (datum->syntax #'id 'x))
                 (y (datum->syntax #'id 'y)))
     #'(list x y))))
@end example

@quotation
@strong{NOTE} This macro is derived from the one documented in the Chez
Scheme User's Guide.
@end quotation
@end deffn

@c page
@node iklib expander utils records
@subsubsection Generating identifiers for records @api{}


@defun identifier-record-constructor @var{type-id}
Assume @var{type-id} is an identifier representing the name of a
@rnrs{6} record type: build and return a new identifer, in the same
lexical context of @var{type-id}, representing the default constructor
name for such record type.

@example
(import (vicare))

(bound-identifier=?
 (identifier-record-constructor #'alpha)
 #'make-alpha)
@result{} #t
@end example
@end defun


@defun identifier-record-predicate @var{type-id}
Assume @var{type-id} is an identifier representing the name of a
@rnrs{6} record type: build and return a new identifer, in the same
lexical context of @var{type-id}, representing the default predicate
name for such record type.

@example
(import (vicare))

(bound-identifier=?
 (identifier-record-predicate #'alpha)
 #'alpha?)
@result{} #t
@end example
@end defun


@defun identifier-record-field-accessor @var{type-id} @var{field-name}
Assume @var{type-id} is an identifier representing the name of a
@rnrs{6} record type: build and return a new identifer, in the same
lexical context of @var{type-id}, representing the default accessor name
for the field @var{field-name} of such record type.  @var{field-name}
can be a string, symbol or identifier.

@example
(import (vicare))

(bound-identifier=?
 (identifier-record-field-accessor #'alpha "one")
 #'alpha-one)
@result{} #t
@end example
@end defun


@defun identifier-record-field-mutator @var{type-id} @var{field-name}
Assume @var{type-id} is an identifier representing the name of a
@rnrs{6} record type: build and return a new identifer, in the same
lexical context of @var{type-id}, representing the default mutator name
for the field @var{field-name} of such record type.  @var{field-name}
can be a string, symbol or identifier.

@example
(import (vicare))

(bound-identifier=?
 (identifier-record-field-mutator #'alpha "one")
 #'alpha-one-set!)
@result{} #t
@end example
@end defun

@c page
@node iklib expander utils structs
@subsubsection Generating identifiers for structs @api{}


@defun identifier-struct-constructor @var{type-id}
Assume @var{type-id} is an identifier representing the name of a Vicare
struct type: build and return a new identifer, in the same lexical
context of @var{type-id}, representing the default constructor name for
such struct type.

@example
(import (vicare))

(bound-identifier=?
 (identifier-struct-constructor #'alpha)
 #'make-alpha)
@result{} #t
@end example
@end defun


@defun identifier-struct-predicate @var{type-id}
Assume @var{type-id} is an identifier representing the name of a Vicare
struct type: build and return a new identifer, in the same lexical
context of @var{type-id}, representing the default predicate name for
such struct type.

@example
(import (vicare))

(bound-identifier=?
 (identifier-struct-predicate #'alpha)
 #'alpha?)
@result{} #t
@end example
@end defun


@defun identifier-struct-field-accessor @var{type-id} @var{field-name}
Assume @var{type-id} is an identifier representing the name of a Vicare
struct type: build and return a new identifer, in the same lexical
context of @var{type-id}, representing the default accessor name for the
field @var{field-name} of such struct type.  @var{field-name} can be a
string, symbol or identifier.

@example
(import (vicare))

(bound-identifier=?
 (identifier-struct-field-accessor #'alpha "one")
 #'alpha-one)
@result{} #t
@end example
@end defun


@defun identifier-struct-field-mutator @var{type-id} @var{field-name}
Assume @var{type-id} is an identifier representing the name of a Vicare
struct type: build and return a new identifer, in the same lexical
context of @var{type-id}, representing the default mutator name for the
field @var{field-name} of such struct type.  @var{field-name} can be a
string, symbol or identifier.

@example
(import (vicare))

(bound-identifier=?
 (identifier-struct-field-mutator #'alpha "one")
 #'set-alpha-one!)
@result{} #t
@end example
@end defun

@c page
@node iklib expander utils pairs
@subsubsection Pairs processing


@defun syntax-car @var{stx}
@defunx syntax-car @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding pair; return a syntax
object representing the car of @var{stx}.

@example
(import (vicare))

(bound-identifier=? (syntax-car #'(display . write))
                    #'display)
@result{} #t
@end example
@end defun


@defun syntax-cdr @var{stx}
@defunx syntax-cdr @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding pair; return a syntax
object representing the cdr of @var{stx}.

@example
(import (vicare))

(bound-identifier=? (syntax-cdr #'(display . write))
                    #'write)
@result{} #t
@end example
@end defun


@defun syntax->list @var{stx}
@defunx syntax->list @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding a proper list of items;
return a proper list holding the individual item syntax objects.

@example
(import (vicare))

(for-all (lambda (obj1 obj2)
           (if (identifier? obj2)
               (bound-identifier=? obj1 obj2)
             (equal? obj1 obj2)))
  (syntax->list #'(display 123 write))
  (list #'display 123 #'write))
@result{} #t
@end example
@end defun


@defun identifiers->list @var{stx}
@defunx identifiers->list @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding a proper list of
identifiers; return a proper list holding the individual identifiers.

@example
(import (vicare))

(for-all bound-identifier=?
  (identifiers->list #'(display write))
  (list #'display #'write))
@result{} #t
@end example
@end defun


@defun all-identifiers? @var{stx}
Return @true{} if @var{stx} is a syntax object representing the empty
list or a proper list of identifiers, otherwise return @false{}.
@end defun

@c page
@node iklib expander utils vectors
@subsubsection Vectors processing


@defun syntax->vector @var{stx}
@defunx syntax->vector @var{stx} @var{synner}
Expect @var{stx} to be a syntax object holding a vector of items; return
a proper list holding the individual item syntax objects.

@example
(import (vicare))

(vector-for-all
    (lambda (obj1 obj2)
      (if (identifier? obj2)
          (bound-identifier=? obj1 obj2)
        (equal? obj1 obj2)))
  (syntax->vector #'#(display 123 write))
  (vector #'display 123 #'write))
@result{} #t
@end example
@end defun

@c page
@node iklib expander utils special
@subsubsection Special processors


@defun parse-logic-predicate-syntax @var{stx}
@defunx parse-logic-predicate-syntax @var{stx} @var{tail-proc}
Given a syntax object @var{stx} parse it as logic predicate expression
with expected format:

@example
@var{stx} = (and @metao{expr} @meta{expr} ...)
    | (or  @metao{expr} @meta{expr} ...)
    | (xor @metao{expr} @meta{expr} ...)
    | (not @meta{expr})
    | @meta{expr}
@end example

@noindent
where @syntax{and}, @syntax{or}, @syntax{xor}, @syntax{not} are the
identifiers exported by @library{vicare}.  If a standalone @meta{expr}
is found: apply the procedure @var{tail-proc} to it gather its single
return value; @var{tail-proc} defaults to the identity function.

Return a syntax object representing the logic predicate with the
standalone expressions replaced by the return values of @var{tail-proc}.

@lisp
(define (tail-proc stx)
  (syntax-case stx ()
    ((?expr0 ?expr ...)
     #`(or #,@@(map (lambda (expr)
                     (parse-logic-predicate-syntax
                        expr tail-proc))
                (syntax->list #'(?expr0 ?expr ...)))))
    (_
     (list #'here stx))))

(define-syntax-rule (doit ?input)
  (parse-logic-predicate-syntax (syntax ?input) tail-proc))

(doit (and 1 2))
@result{} #'(and (here 1) (here 2))

(doit (or 1 2))
@result{} #'(or (here 1) (here 2))

(doit (xor 1 2)
@result{} #'(xor (here 1) (here 2))

(doit (not 1))
@result{} (not (here 1))

(doit (and (xor (not 1) 2)
           (or  (not 3) 4)))
@result{} #'(and (xor (not (here 1)) (here 2))
          (or  (not (here 3)) (here 4)))

(doit (1 2))
@result{} #'(or (here 1) (here 2))
@end lisp
@end defun

@c page
@node iklib expander utils unwrap
@subsubsection Unwrapping syntax objects


@defun syntax-unwrap @var{stx}
Given a syntax object @var{stx} decompose it and return the
corresponding symbolic expression holding datums and identifiers.  Take
care of returning a proper list when the input is a syntax object
holding a proper list.
@end defun

@c page
@node iklib expander utils inspect
@subsubsection Inspecting syntax objects


@c @defun quoted-syntax-object? @var{stx}
@c Given a syntax object: return @true{} if it is a list whose car is one
@c among the identifiers @func{quote}, @func{quasiquote}, @func{syntax},
@c @func{quasisyntax}; return @false{} otherwise.
@c @end defun

@c page
@node iklib expander utils compar
@subsubsection Comparing syntax objects


@defun syntax=? @vari{stx} @varii{stx}
Recursively visit the internals of the given syntax objects and return
@true{} if they are equal; return @false{} otherwise.  Identifiers are
compared with @func{free-identifier=?}.
@end defun


@defun {identifier=symbol?} @var{id} @var{sym}
Return true if the symbol @var{sym} is equal to the symbol name of the
identifier @var{id}.
@end defun

@c page
@node iklib expander clauses
@subsection Syntax clauses helpers


When writing definition macros similar to @func{define-record-type} it
is quite useful to include in the syntax ``clauses'' that optionally
specify the behaviour of the defined thing.  A list of clauses is a
syntax object with the format:

@example
((@meta{identifier} @meta{thing} ...) ...)
@end example

@noindent
in which @meta{identifier} is meant to be an auxiliary syntax (as
defined by @func{define-auxiliary-syntaxes} or @func{define-syntax}) and
the optional @meta{thing} arguments can represent any symbolic
expression.  The functions documented in this section help in validating
and processing such clauses.

@menu
* iklib expander clauses intro::    Introduction to clauses functions.
* iklib expander clauses utils::    Syntax clauses utilities.
* iklib expander clauses constr::   Syntax clauses constraints.
* iklib expander clauses objects::  Clause specification objects.
@end menu

@c page
@node iklib expander clauses intro
@subsubsection Introduction to clauses functions


Some functions accept an optional argument @var{synner}: when used, it
must be a function accepting 1 or 2 arguments, the first argument being
a string error message and the optional second argument being a subform;
@var{synner} must raise a compound condition object with components:
@condition{who}, @condition{message}, @condition{syntax}.  The
@var{synner} argument is meant to be used as follows:

@example
(define-syntax (my-macro stx)
  (case-define synner
    ((message)
     (synner message #f))
    ((message subform)
     (syntax-violation 'my-macro message stx subform)))
  (syntax-case stx ()
    (pattern body)
    (_
     (synner "invalid syntax"))))
@end example

@c page
@node iklib expander clauses utils
@subsubsection Syntax clauses utilities


@defun syntax-clauses-unwrap @var{clauses}
@defunx syntax-clauses-unwrap @var{clauses} @var{synner}
Scan the syntax object @var{clauses} expecting it to represent a list of
clauses; return a new syntax object representing @var{clauses} fully
unwrapped.  The function @var{synner} is invoked if the structure of
@var{clauses} is invalid.
@end defun


@defun syntax-clauses-filter @var{keywords} @var{unwrapped-clauses}
Given a fully unwrapped syntax object @var{unwrapped-clauses} holding a
list of clauses (for example the return value of
@func{syntax-clauses-unwrap}) select the ones having @meta{identifier}
being @func{free-identifier=?} to an identifier in the list
@var{keywords} and return the selected clauses in a fully unwrapped
syntax object holding the list of them; return null if no matching
clause is found.
@end defun


@defun syntax-clauses-remove @var{keywords} @var{unwrapped-clauses}
Given a fully unwrapped syntax object @var{unwrapped-clauses} holding a
list of clauses (for example the return value of
@func{syntax-clauses-unwrap}) remove the ones having @meta{identifier}
being @func{free-identifier=?} to an identifier in the list
@var{keywords} and return the selected clauses in a fully unwrapped
syntax object holding the list of them; return null if no matching
clause is found.
@end defun


@defun syntax-clauses-partition @var{keywords} @var{unwrapped-clauses}
Given a fully unwrapped syntax object @var{unwrapped-clauses} holding a
list of clauses (for example the return value of
@func{syntax-clauses-unwrap}) partition it into: a list of clauses
having @meta{identifier} being @func{free-identifier=?} to an identifier
in the list @var{keywords}, a list of non--matching clauses.  Return the
two lists.

This function can be used to check that a list of clauses only contains
clauses with selected identifiers.
@end defun


@defun syntax-clauses-collapse @var{unwrapped-clauses}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}): collapse the
clauses having equal @meta{identifier} into a single clause and return
the resulting unwrapped syntax object.  Example:

@example
(syntax-clauses-collapse ((#'fields #'a #'b #'c)
                          (#'fields #'d #'e #'f)))
@result{} ((#'fields #'a #'b #'c #'d #'e #'f))
@end example
@end defun

@c page
@node iklib expander clauses constr
@subsubsection Syntax clauses constraints


@defun syntax-clauses-verify-at-least-once @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-at-least-once @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that
all the identifiers in the list @var{keywords} are present at least once
as clause identifiers.  If successful return unspecified values, else
call @var{synner} or raise a @condition{syntax} violation exception.
@end defun


@defun syntax-clauses-verify-at-most-once @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-at-most-once @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that
all the identifiers in the list @var{keywords} are present at most once
as clause identifiers.  If successful return unspecified values, else
call @var{synner} or raise a @condition{syntax} violation exception.
@end defun


@defun syntax-clauses-verify-exactly-once @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-exactly-once @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that
all the identifiers in the list @var{keywords} are present exactly once
as clause identifiers.  If successful return unspecified values, else
call @var{synner} or raise a @condition{syntax} violation exception.
@end defun


@defun syntax-clauses-verify-mutually-inclusive @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-mutually-inclusive @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that if
one of the identifiers in the list @var{keywords} is present at least
once as clause identifier, then all the others are present too.  If
successful return unspecified values, else call @var{synner} or raise a
@condition{syntax} violation exception.
@end defun


@defun syntax-clauses-verify-mutually-exclusive @var{keywords} @var{unwrapped-clauses}
@defunx syntax-clauses-verify-mutually-exclusive @var{keywords} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that if
one of the identifiers in the list @var{keywords} is present at least
once as clause identifier, then all the others are @strong{not} present.
If successful return unspecified values, else call @var{synner} or raise
a @condition{syntax} violation exception.
@end defun

@c page
@node iklib expander clauses objects
@subsubsection Clause specification objects


Clause specification objects are opaque objects, disjoint from all the
other Scheme object types, representing the constraints enforceable on a
syntax clause.


@defun make-syntax-clause-spec @var{keyword} @var{min-occur} @var{max-occur} @var{min-args} @var{max-args} @var{mutually-inclusive} @var{mutually-exclusive}
@defunx make-syntax-clause-spec @var{keyword} @var{min-occur} @var{max-occur} @var{min-args} @var{max-args} @var{mutually-inclusive} @var{mutually-exclusive} @var{custom-data}
Build and return a new syntax clause specification object.  The
arguments are:

@table @var
@item keyword
An identifier representing the keyword for this clause.

@item min-occur
A non--negative real number representing the allowed minimum number of
occurrences for this clause.  @samp{0} means the clause is optional;
@samp{1} means the clause is mandatory.

@item max-occur
A non--negative real number representing the allowed maximum number of
occurrences for this clause.  @samp{0} means the clause is forbidden;
@samp{1} means the clause must appear at most once; @samp{+inf.0} means
the clause can appear any number of times.

@item min-args
A non--negative real number representing the allowed minimum number of
arguments for this clause.  @samp{0} means the clause can have no
arguments; @samp{1} means the clause must have at least one argument.

@item max-args
A non--negative real number representing the allowed maximum number of
arguments for this clause.  @samp{0} means the clause has no arguments;
@samp{1} means the clause must have at most one arguments; @samp{+inf.0}
means the clause can have any number of arguments.

@item mutually-inclusive
A list identifiers representing clauses keywords that must appear along
with this one.

@item mutually-exclusive
A list identifiers representing clauses keywords that must not appear
along with this one.

@item custom-data
Optional free value available for the user.  It is initialised to
@false{}.
@end table
@end defun


@defun syntax-clause-spec? @var{obj}
Return @true{} if @var{obj} is a syntax clause specification object,
otherwise return @false{}.
@end defun


@defun syntax-clause-spec-keyword @var{spec}
@defunx syntax-clause-spec-min-number-of-occurrences @var{spec}
@defunx syntax-clause-spec-max-number-of-occurrences @var{spec}
@defunx syntax-clause-spec-min-number-of-arguments @var{spec}
@defunx syntax-clause-spec-max-number-of-arguments @var{spec}
@defunx syntax-clause-spec-mutually-inclusive @var{spec}
@defunx syntax-clause-spec-mutually-exclusive @var{spec}
@defunx syntax-clause-spec-custom-data @var{spec}
Accessors for the fields of syntax clause specification objects.
@end defun


@defun syntax-clauses-single-spec @var{spec} @var{unwrapped-clauses}
@defunx syntax-clauses-single-spec @var{spec} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify if
there are clauses conforming to the given specification @var{spec}.

If successful return a (possibly empty) vector of vectors of syntax
objects; else call @var{synner} or raise a @condition{syntax} exception.
The length of the returned vector is the number of clauses from
@var{unwrapped-clauses} conforming to @var{spec}.  Each nested vector
represents the cdr of a clause matching @var{spec}:

@itemize
@item
If a clause has no arguments: the corresponding nested vector is empty.

@item
If a clause has @math{1} argument: the corresponding nested vector has
@math{1} item being the syntax object representing the argument.

@item
If a clause has @math{N} arguments: the corresponding nested vector has
@math{N} items being the syntax objects representing the arguments.
@end itemize

Examples:

@example
(import (vicare))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 1 1 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 456)
                             (d 789))))
@result{} #(#(456))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b)
                             (d 789))))
@result{} #(#())

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 4 5 6)
                             (d 789))))
@result{} #(#(4 5 6))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 4)
                             (b 5)
                             (b 6)
                             (d 789))))
@result{} #(#(4) #(5) #(6))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 4 4.1)
                             (b 5 5.1)
                             (d 789))))
@result{} #(#(4 4.1) #(5 5.1))

(syntax-clauses-single-spec
   (make-syntax-clause-spec #'b 1 1 0 +inf.0 '() '())
   (syntax-clauses-unwrap #'((a 123)
                             (b 4 ciao 6)
                             (d 789))))
@result{} #(#(4 #<syntax-object expr=ciao> 6))
@end example
@end defun


@defun syntax-clauses-fold-specs @var{combine} @var{knil} @var{specs} @var{unwrapped-clauses}
@defunx syntax-clauses-fold-specs @var{combine} @var{knil} @var{specs} @var{unwrapped-clauses} @var{synner}
Given a fully unwrapped syntax object holding a list of clauses (for
example the return value of @func{syntax-clauses-unwrap}) verify that
the clauses conform to the given @var{specs}, which must be a list of
syntax clause specification objects.

Combine the clause arguments with the given @var{knil} in a
@func{fold-left} fashion, if successful return the resulting @var{knil};
if an invalid clause is found call @var{synner} or raise a
@condition{syntax} object.

The operation is conceptually as follows:

@example
(fold-left
    (lambda (knil spec)
      (let ((args (syntax-clauses-single-spec spec
                     @var{unwrapped-clauses} @var{synner})))
        (if (fxzero? (vector-length args))
            knil
          (@var{combine} knil spec args))))
  @var{knil}
  @var{specs})
@end example

@noindent
notice that @var{combine} is called only if a clause from @var{specs} is
present in @var{unwrapped-clauses}; @var{combine} must return the new
value for @var{knil}.
@end defun


@defun syntax-clauses-validate-specs @var{list-of-specs}
Given a list of @objtype{syntax-clause-spec} objects: perform some
validations among them.  If successful return @var{list-of-specs}
itself, otherwise raise an assertion violation.

The following checks are performed:

@itemize
@item
For every identifier listed in the @code{mutually-inclusive} field of
every @objtype{syntax-clause-spec}: check that such identifier is equal,
according to @func{free-identifier=?}, to an identifier in the
@code{keyword} field of another @objtype{syntax-clause-spec} object.

@item
For every identifier listed in the @code{mutually-exclusive} field of
every @objtype{syntax-clause-spec}: check that such identifier is equal,
according to @func{free-identifier=?}, to an identifier in the
@code{keyword} field of another @objtype{syntax-clause-spec} object.
@end itemize
@end defun

@c page
@node iklib expander etv
@subsection expand--time values


It is sometimes useful to precompute a value at expand--time and push it
on the lexical environment to be later retrieved.  Here is an example of
simple expand--time value computation, retrieval and insertion in which
the value is a self--evaluating fixnum:

@example
(import (vicare))

(define-syntax obj1
  (make-expand-time-value (+ 1 2 3)))

(define-syntax get-obj1
  (lambda (stx)
    (retrieve-expand-time-value #'obj1)))

(get-obj1) @expansion{} 6
@end example

@noindent
here is an example of simple expand--time value computation, retrieval
and insertion in which the value is a non--self--evaluating vector:

@example
(import (vicare))

(define-syntax obj2
  (make-expand-time-value (vector 1 2 3)))

(define-syntax get-obj2
  (lambda (stx)
    #`(quote #,(retrieve-expand-time-value #'obj2))))

(get-obj2) @expansion{} (quote #(1 2 3))
@end example

@noindent
we see that to produce an expand--time value we define a syntax keyword
bound to the result of @func{make-expand-time-value}.


@defun make-expand-time-value @var{obj}
Build and return a ``special'' object that is recognised by the expander
as holding @var{obj} as a precomputed expand--time object.
@end defun


@defun expand-time-value? @var{obj}
Return @true{} if @var{obj} is a ``special'' object that is recognised
by the expander as holding a precomputed expand--time object.
@end defun


@defun expand-time-value-object @var{etv}
Given a ``special'' object that is recognised by the expander as holding
a precomputed expand--time object: return the actual value.
@end defun


@defun retrieve-expand-time-value @var{id}
Given a syntactic identifier return its associated expand--time value;
if @var{id} is not associated to a expand--time value: return @false{}.
@end defun

@c ------------------------------------------------------------

@subsubheading What expand--time values are @strong{not} for


We have to understand that the real use of expand--time values is not
actually to precompute values and put them in compiled code; for this we
can just use @func{define-inline-constant}, which in the end defines a
``normal'' syntax transformer as the following:

@example
(import (vicare))

(define-syntax obj1
  (let ((const (vector 1 2 3)))
    (lambda (stx)
      (syntax-case stx ()
        (?id
         (identifier? #'?id)
         #`(quote #,const))))))

obj1    @expansion{} (quote #(1 2 3))
@end example

@c ------------------------------------------------------------

@subsubheading What expand--time values are for

Let's say we define a record type in a library (it must go in a library
so that we can import it and use it at expand--time in the body of
transformers):

@example
(library (etv-demo)
  (export that make-that)
  (import (vicare))
  (define-record-type that
    (fields a b c)))
@end example

@noindent
now we can instantiate a struct @code{that} and push the instance on the
lexical environment, bound to the identifier @code{it}:

@example
(import (vicare)
  (for (etv-demo) expand))

(define-syntax it
  (make-expand-time-value
    (make-that 1 2 3)))
@end example

@noindent
later we retrieve the struct instance, through the identifier @code{it},
and use its fields to produce the output of a syntax use:

@example
(define-syntax get-it
  (lambda (stx)
    (let ((S (retrieve-expand-time-value #'it)))
      (with-syntax
          ((A (slot-ref S a that))
           (B (slot-ref S b that))
           (C (slot-ref S c that)))
        #'(quote #(A B C))))))

(get-it)        @expansion{} (quote #(1 2 3))
@end example

@c page
@node iklib expander parameters
@subsection Expand--time parameters


Fluid syntaxes and expand--time values can be used to implement a sort
of expand--time parameters, @ref{iklib parameters, Parameters}.  The
following example shows the mechanism by defining a ``parameter''
@samp{parm}:

@example
(import (vicare))

(define-syntax (show-it stx)
  (fprintf (current-error-port)
           "parm ~a: ~a\n"
           (cadr (syntax->datum stx))
           (retrieve-expand-time-value #'parm))
  #f)

(define-fluid-syntax parm
  (make-expand-time-value #f))

(show-it "1, expect #f")
(fluid-let-syntax ((parm (make-expand-time-value #t)))
  (show-it "2, expect #t")
  (fluid-let-syntax ((parm (make-expand-time-value #f)))
    (show-it "3, expect #f"))
  (show-it "4, expect #t"))
(show-it "5, expect #f")
@end example

@noindent
the output of the program is:

@example
parm 1, expect #f: #f
parm 5, expect #f: #f
parm 2, expect #t: #t
parm 3, expect #f: #f
parm 4, expect #t: #t
@end example

@noindent
Using the @api{} described here, the example can be rewritten:

@example
(import (vicare))

(define-syntax (show-it stx)
  (fprintf (current-error-port)
           "parm ~a: ~a\n"
           (cadr (syntax->datum stx))
           (syntax-parameter-value #'parm))
  #f)

(define-syntax-parameter parm #f)

(show-it "1, expect #f")
(syntax-parametrise ((parm #t))
  (show-it "2, expect #t")
  (syntax-parametrise ((parm #f))
    (show-it "3, expect #f"))
  (show-it "4, expect #t"))
(show-it "5, expect #f")
@end example


@deffn Syntax define-syntax-parameter @meta{parm-id} @meta{expr}
Define a new syntax parameter bound to the identifier @meta{parm-id}.
The parameter is initialised to the result of evaluating the
expand--time expression @meta{expr}.
@end deffn


@deffn Syntax syntax-parametrise ((@meta{parm-id} @meta{expr}) @dots{}) @metao{body} @meta{body} @dots{}
Bind one or more syntax parameters to new expand--time values and while
the body forms are expanded.  The arguments @meta{parm-id} must be
identifiers previously bound to expand--time values by
@func{define-syntax-parameter}.  The arguments @meta{expr} must be
expressions.
@end deffn


@defun syntax-parameter-value @var{parm-id}
Return the syntax parameter value bound to @var{parm-id}, which must be
an identifier previously bound by @func{define-syntax-parameter}.  This
function must be called only from the extent of a macro expansion; in
practice: only by a macro transformer.
@end defun

@c page
@node iklib expander synonym
@subsection Synonym transformers


Synonym transformers allow the creation of multiple identifiers which
resolve to the same syntactic binding.  Usage examples:

@example
(import (vicare))

(define a 1)

(define-syntax b
  (make-synonym-transformer #'a))

(list a b)      @result{} (1 1)

(define-syntax c
  (make-synonym-transformer #'b))

(list a b c)    @result{} (1 1 1)

(define-syntax d
  (make-synonym-transformer #'b))

(set! c 2)

(list a b c d)  @result{} (2 2 2 2)
@end example

Circular references are detected and cause a syntax violation to be
raised.

If the identifier @vari{id} is bound to a synonym transformer with
source identifier @varii{id}: the two identifiers resolve to the same
syntactic binding but are @strong{not} @func{free-identifier=?}.  To
create an identifier that is @func{free-identifier=?} to another we have
to use @func{define-alias}.


@defun make-synonym-transformer @var{id}
Build and return a ``special'' value that, when used as right--hand side
of a syntax definition, is recognised by the expander as a synonym
transformer as opposed to a normal transformer, variable transformer or
a compile--time value.  @var{id} must be the source identifier.
@end defun


@defun synonym-transformer? @var{obj}
Return @true{} if @var{obj} is recognised by the expander as a synonym
transformer as opposed to a normal transformer, variable transformer or
a compile--time value; otherwise return @false{}.
@end defun


@defun synonym-transformer-identifier @var{obj}
If @var{obj} is recognised by the expander as a synonym transformer:
return the source identifier, otherwise raise an exception.
@end defun

@c page
@node iklib shared
@section Shared structures graph notation


This feature of the reader is derived from the @srfi{} 38 ``External
Representation for Data With Shared Structure'':

@center @url{http://srfi.schemers.org/srfi-38/srfi-38.html}

This graph notation allows the reader to build symbolic expressions with
graph structure including cycles.  @strong{Shared structures must always
be used inside quoted datums}; if we create a cycle in a symbolic
expression passed as code to the expander: the result will be an
infinite loop.  Graph notation is available only when the textual input
port is configured in @code{#!vicare} mode.

Graph notation extends the @rnrs{6} syntax with these additional cases:

@example
<lexeme>                -> <r6rs lexeme>
                         | <defining datum>
                         | <defined datum>
<defining datum>        -> #<indexnum>=<r6rs lexeme>
<defined datum>         -> #<indexnum>#
<indexnum>              -> <digit>+
@end example

@noindent
where @code{<r6rs lexeme>} is the lexeme definition in @rnrs{6}.


@deffn Parameter print-graph
@deffnx Parameter print-graph #t
@deffnx Parameter print-graph #f
@cindex Parameter @func{print-graph}
The graph notation is a way of marking and referencing parts of a data
structure and, consequently, creating shared and cyclic data structures
at read time instead of resorting to explicit mutation at run time.

In a string generated by the Scheme objects writer: the prefix
@code{#N=} marks the subsequent data structure with mark @math{N}, where
@math{N} is a non--negative integer.  The string @code{#N#} references
the data structure marked @math{N}.  Marks can be assigned and
referenced in any order but each mark must be assigned to exactly once
in an expression.

@example
> (let ([x '#0=(1 2 3)])
    (eq? x '#0#))
#t
> (let ([x '#0#] [y '#0=(1 2 3)])
    (eq? x y))
#t
> (eq? (cdr '(12 . #1#)) '#1=(1 2 3))
#t
> (let ([x '#1=(#1# . #1#)])
    (and (eq? x (car x))
         (eq? x (cdr x))))
#t
@end example

The @func{print-graph} parameter controls how the writers (e.g.
@func{pretty-print} and @func{write}) handle shared and cyclic data
structures.  In @value{PRJNAME}, all writers detect cyclic data structures and
they all terminate on all input, cyclic or otherwise.

If the value of @func{print-graph} is set to @false{}, then the writers
do not attempt to detect shared data structures.  Any part of the input
that is shared is printed as if no sharing is present.  If the value of
@func{print-graph} is set to @true{} (the default), all sharing of data
structures is marked using the @code{#n=} and @code{#n#} notation.

@example
> (parameterize ((print-graph #f))
    (let ((x (list 1 2 3 4)))
      (pretty-print (list x x x))))
((1 2 3 4) (1 2 3 4) (1 2 3 4))

> (parameterize ((print-graph #t))
    (let ((x (list 1 2 3 4)))
      (pretty-print (list x x x))))
(#0=(1 2 3 4) #0# #0#)

> (parameterize ((print-graph #f))
    (let ((x (list 1 2)))
      (let ((y (list x x x x)))
        (set-car! (last-pair y) y)
        (pretty-print (list y y)))))
(#0=((1 2) (1 2) (1 2) #0#) #0#)

> (parameterize ((print-graph #t))
    (let ((x (list 1 2)))
      (let ((y (list x x x x)))
        (set-car! (last-pair y) y)
        (pretty-print (list y y)))))
(#0=(#1=(1 2) #1# #1# #0#) #0#)
@end example
@end deffn

@c page
@node iklib environment
@section Environments


@cindex Environment, interaction


The following bindings are exported by the library @library{vicare}.


@defun environment? @var{env}
Return @true{} if @var{env} is an environment object.
@end defun


@defun interaction-environment
@defunx interaction-environment @var{env}
When called with no arguments: return an environment object representing
the environment active at the @repl{}; to be used as argument for
@func{eval}.

When called with the argument @var{env}, which must be an environment
object: set @var{env} as interaction environment.
@end defun


@defun new-interaction-environment
@defunx new-interaction-environment @var{libname}
Build and return a new interaction environment object.  When no argument
is given: the returned environment is initialised by importing the
library @library{vicare}.  When @var{libname} is used it must be a
library name specification: the returned environment is initialised with
the specified library.
@end defun


Notice that it is possible to use interaction environments to have
persistent bindings:

@example
(begin
  (eval '(define c 3)
        (interaction-environment))
  (eval 'c
        (interaction-environment)))
@result{} 3

(begin
  (eval '(begin
           (define a 1)
           (define b 2))
        (interaction-environment))
  (eval '(list a b)
        (interaction-environment)))
@result{} (1 2)

(let ((env (new-interaction-environment)))
  (eval '(begin
           (define a 1)
           (define b 2))
        env)
  (eval '(list a b)
        env))
@result{} (1 2)
@end example

@noindent
and it is also possible to import additional libraries:

@example
(eval '(import (nausicaa))
       (interaction-environment))
@end example

At the top--level of an interaction environment, it is possible to
redefine syntactic bindings:

@lisp
(let ((env (new-interaction-environment '(rnrs base))))
  (eval '(define d 3) env)
  (eval '(define d 4) env)
  (eval 'd env))
@result{} 4

(let ((env (new-interaction-environment '(rnrs base))))
  (eval '(begin
           (define x 1)
           (define y 2)
           (define z 3))
        env)
  (eval '(begin
           (define x 10)
           (define y 20)
           (define z 30))
        env)
  (eval '(list x y z)
        env))
@result{} (10 20 30)

(let ((env (new-interaction-environment '(rnrs base))))
  (eval '(begin
           (define-syntax x (identifier-syntax 1))
           (define-syntax y (identifier-syntax 2))
           (define-syntax z (identifier-syntax 3)))
        env)
  (eval '(begin
           (define-syntax x (identifier-syntax 10))
           (define-syntax y (identifier-syntax 20))
           (define-syntax z (identifier-syntax 30)))
        env)
  (eval '(list x y z)
        env))
@result{} (10 20 30)

(let ((env (new-interaction-environment '(vicare))))
  (eval '(begin
           (define-fluid-syntax x (identifier-syntax 1))
           (define-fluid-syntax y (identifier-syntax 2))
           (define-fluid-syntax z (identifier-syntax 3)))
        env)
  (eval '(begin
           (define-fluid-syntax x (identifier-syntax 10))
           (define-fluid-syntax y (identifier-syntax 20))
           (define-fluid-syntax z (identifier-syntax 30)))
        env)
  (eval '(list x y z)
        env))
@result{} (10 20 30)

(let ((env (new-interaction-environment '(vicare))))
  (eval '(begin
           (begin-for-syntax
             (define a 1)
             (define a 2))
           (define-syntax doit
             (lambda (stx) a)))
        env)
  (eval '(doit) env))
@result{} 2
@end lisp

At the top--level of an interaction environment, it is possible to
shadow syntactic bindings imported from a library:

@lisp
(let ((env (new-interaction-environment '(vicare))))
  (eval '(define display 123) env)
  (eval 'display env))
@result{} 123

(let ((env (new-interaction-environment '(vicare))))
  (eval '(begin
           (begin-for-syntax
             (define display 123))
           (define-syntax doit
             (lambda (stx) display)))
        env)
  (eval '(doit) env))
@result{} 123
@end lisp


@defun environment-symbols @var{env}
Return a list of symbols representing the names of the bindings from
@var{env}, which must be an environment.  The name in position @math{i}
in the returned list is associated to the label in position @math{i} in
the list returned by @func{environment-labels}.

For example, the following program prints all the bindings in the
library @library{vicare language-extensions}:

@example
#!r6rs
(import (vicare))
(for-each pretty-print
  (environment-symbols
   (environment '(vicare language-extensions))))
(flush-output-port (current-output-port))
@end example
@end defun


@defun environment-labels @var{env}
Return a list of symbols representing the labels of the bindings from
the given non--interaction environment.  The label in position @math{i}
in the returned list is associated to the name in position @math{i} in
the list returned by @func{environment-symbols}.
@end defun


@defun environment-libraries @var{env}
Return the list of @objtype{library} records representing the libraries
forming the non--interaction environment @var{env}.
@end defun


@defun environment-binding @var{sym} @var{env}
Search the symbol @var{sym} in the non--interaction environment
@var{env}; if @var{sym} is the public name of a binding in @var{env}
return 2 values: the label associated to the binding, the list of values
representing the binding.  If @var{sym} is not present in @var{env}
return false and false.

@example
(environment-binding 'display (environment '(vicare)))
@result{} #@{g870 |/1tY778AJ%G&f2UX|@} (core-prim . display)
@end example
@end defun

@c page
@node iklib eval
@section Extended code evaluation


The following bindings are exported by the library @library{vicare}.


@defun eval @var{sexp} @var{environment}
@defunx eval @var{sexp} @var{environment} @var{expander-options} @var{compiler-options}
Extension of @func{eval} as defined by @rnrs{6}.  The arguments
@var{expander-options} and @var{compiler-options} must be @false{} or
enumeration sets as returned by @func{expander-options} and
@func{compiler-options}.
@end defun


@deffn Syntax expander-options @meta{symbol} @dots{}
Return an enumeration set to be used as argument to @func{eval}.
Supported @meta{symbol} options are:

@table @code
@item strict-r6rs
Adhere more strictly to the behaviour defined by @rnrs{6}.  For example:
report errors at run--time, rather than at expand--time.

@item typed-language
Turn on the tagged language extensions (@pxref{types, The typed
language}).
@end table
@end deffn


@deffn Syntax compiler-options @meta{symbol} @dots{}
Return an enumeration set to be used as argument to @func{eval}.
Supported @meta{symbol} options are:

@table @code
@item strict-r6rs
Adhere more strictly to the behaviour defined by @rnrs{6}.  For example:
report errors at run--time, rather than at compile--time.
@end table
@end deffn


@defun make-expander-options @var{symbol} @dots{}
Return an enumeration set as defined by @func{expander-options}.
@end defun


@defun make-compiler-options @var{symbol} @dots{}
Return an enumeration set as defined by @func{compiler-options}.
@end defun

@c page
@node iklib cafe
@section Cafe


The following bindings are exported by the library @library{vicare}.


@defun new-cafe
@defunx new-cafe @var{eval}
Start a new read--eval--print loop (@repl{}) inside the current cafe (if
one exists).  It prompts the user for an expression, evaluates it,
prints the result back, and repeats the process.  If @func{new-cafe} is
called with an argument, @var{eval}, then that argument must be a
procedure that takes a single argument; the @var{eval} procedure will be
used to evaluate the expressions.

Every time a new cafe is started, the prompt is changed to reflect the
depth of the current cafe (i.e. how many eof objects is takes to exit
the outermost cafe).

When the readline interface is @strong{not} used: input is performed
from the port returned by @func{console-input-port}; output is performed
through the port returned by @func{console-output-port)}.  When readline
support is available and used: the @repl{} input is performed through a
readline input port.

If an error occurs during reading, evaluating, or printing an
expression, then the error message is printed to the error--port and the
operations of the cafe resume as normal.

To exit from a cafe we can write the @eof{} object.
@end defun


@deffn Parameter waiter-prompt-string
@cindex Parameter @func{waiter-prompt-string}
The string used as prompt for cafe.
@end deffn


@deffn Parameter cafe-input-port
@cindex Parameter @func{cafe-input-port}
A textual input port used by the cafe.
@end deffn

@c page
@node iklib procedures
@section Procedures


@defun procedure-annotation @var{proc}
Return the annotation of the procedure @var{proc}; return @false{} if
@var{proc} has no annotation.

@example
(define (a) 1)
(procedure-annotation a)
@result{} (#@{a |w$qfI9a4N>aIi$P5|@} . #f)
@end example
@end defun

@c page
@node iklib structs
@section @value{PRJNAME}'s structs


A @value{PRJNAME}'s struct is a record object, lighter than records as
defined by @rnrs{6}.  @ref{objects structs} for more informations on the
internals of structs.

@menu
* iklib structs define::        Defining struct types.
* iklib structs types::         Inspection and configuration of
                                struct types.
* iklib structs inspect::       Inspecting structs.
@end menu

@c page
@node iklib structs define
@subsection Defining structure types


@deffn Syntax define-struct @meta{type-name} (@meta{field} @dots{})
@deffnx Syntax define-struct @meta{type-name} (@meta{field} @dots{}) (nongenerative @meta{uid})
@deffnx Syntax define-struct (@meta{type-name} @meta{constructor} @meta{predicate}) (@meta{field} @dots{})
@deffnx Syntax define-struct (@meta{type-name} @meta{constructor} @meta{predicate}) (@meta{field} @dots{}) (nongenerative @meta{uid})
@deffnx {Auxiliary Syntax} nongenerative
Define a new struct type.  This macro is embedded in the expander.

@meta{type-name} must be a symbol representing the name of the structure; it
is used to build names for the constructor, predicate, field accessors
and mutators.  When @meta{constructor} is used: it must be an identifier
representing the name of the constructor.  When @meta{predicate} is
used: it must be an identifier representing the name of the predicate.

The @meta{field} values must be either symbols representing the names of
the fields or @syntax{brace} forms representing the name and type of
fields:

@lisp
(brace @meta{field-name} @meta{tag})
@end lisp

@noindent
they are used to build names for the accessors and mutators.

When the @clause{nongenerative} clause is used: @meta{uid} must be a
symbol uniquely identifying the struct type.  Multiple definitions of
struct type using the same @meta{uid} must have the same type name and
field names, and represent the same type definition.  See
@func{make-struct-type} for more details.

The following definition:

@example
(define-struct color
  (red green blue))
@end example

@noindent
expands to the definition of the following syntactic bindings:

@table @code
@item color
A syntactic identifier representing the type name.  When the tagged
language is enabled, we can use this identifier to tag a variable
syntactic binding:

@lisp
(define @{O color@}
  (make-color 1 2 3))

(O red)         @result{} 1
(O green)       @result{} 2
(O blue)        @result{} 3
@end lisp

We can use the identifier as argument for the @syntax{is-a?} syntax:

@lisp
(is-a? (make-color 1 2 3) color)        @result{} #t
(is-a? "ciao" color)                    @result{} #f
@end lisp

When the identifier is used in macro keyword position with the syntax:

@example
(@meta{type-name} (@meta{expr} ...))
@end example

@noindent
the form is expanded to the application of the constructor to the
results of evaluating the @meta{expr} arguments:

@example
(color (1 2 3)) @result{} #["color" red=1 green=2 blue=3]
@end example

@item make-color @var{red} @var{green} @var{blue}
A structure constructor accepting as much arguments as there are fields.
The constructor makes use of the @func{$struct} low level operation.

@item color? @var{obj}
A predicate to distinguish between references to @code{color} structures
and other values.  This predicate makes use of the @func{$struct/rtd?}
low level operation.

@item color-red @var{stru}
@itemx color-green @var{stru}
@itemx color-blue @var{stru}
Accessor functions for the fields of the structure.  These accessors
make use of the @func{$struct/rtd?} low level operation to validate the
argument and if successful they use @func{$struct-ref} to extract the
value; if the argument is of invalid type: an assertion violation is
raised.

@item set-color-red! @var{stru} @var{red}
@itemx set-color-green! @var{stru} @var{green}
@itemx set-color-blue! @var{stru} @var{blue}
Mutator functions for the fields of the structure.  These mutators make
use of the @func{$struct/rtd?} low level operation to validate the
argument @var{stru} and if successful they use @func{$struct-set!} to
set the value; if the argument @var{stru} is of invalid type: an
assertion violation is raised.

@item $color-red @var{stru}
@itemx $color-green @var{stru}
@itemx $color-blue @var{stru}
Unsafe accessor syntaxes for the fields of the structure.  These
accessors do not validate the arguments and expand directly to a use of
@func{$struct-ref} to extract the value; if the argument is invalid: the
behaviour is undefined.

@item $set-color-red! @var{stru} @var{red}
@itemx $set-color-green! @var{stru} @var{green}
@itemx $set-color-blue! @var{stru} @var{blue}
Unsafe mutator syntaxes for the fields of the structure.  These mutators
do not validate the arguments and expand directly to a use of
@func{$struct-set!} to set the value; if the argument @var{stru} is
invalid: the behaviour is undefined.
@end table
@end deffn


@defun make-struct-type @var{type-name} @var{fields}
@defunx make-struct-type @var{type-name} @var{fields} @var{uid}
Build and return a new struct--type descriptor.  @var{type-name} must be
a string representing the type name.  @var{fields} must be a list of
symbols representing the field names.

The optional @var{uid} argument must be a symbol uniquely identifying
this type; when not supplied, a symbol is automatically generated.  The
@code{value} field of the symbol object @var{uid} is set to the newly
created @rtd{}; if @var{uid} already has a symbol value: such value must
be a struct descriptor equal to the newly created @rtd{}.

The use of a @var{uid} allows us to define a unique struct type in
different libraries without sharing the definition by importing
syntactic bindings.  For example, we can define a struct type in a
library and import the definition in other libraries:

@example
(library (one)
  (export
    make-color color?
    color-red color-green color-blue)
  (import (vicare))
  (define-struct color
    (red green blue)))

(library (two)
  (export C)
  (import (vicare) (one))
  (define C (make-color 1 2 3)))

(library (three)
  (export)
  (import (vicare) (one) (two))
  (display (color-red C)))
@end example

@noindent
but, by specifying a @var{uid}, we can also do:

@example
(library (two)
  (export C)
  (import (vicare))
  (define-struct color
    (red green blue)
    (nongenerative the-color))
  (define C
    (make-color 1 2 3)))

(library (three)
  (export)
  (import (vicare))
  (define-struct color
    (red green blue)
    (nongenerative the-color))
  (display (color-red C)))
@end example

@noindent
and everything will work as before.
@end defun

@c page
@node iklib structs types
@subsection Inspection and configuration of structure types


@menu
* iklib structs types using::   Using struct types.
* iklib structs types inspect:: Inspecting struct types.
* iklib structs types printer:: Struct printer customisation.
* iklib structs types final::   Finalisation of structs.
@end menu

@c page
@node iklib structs types using
@subsubsection Using structure types


@deffn Syntax struct-type-descriptor @meta{type-name}
Evaluate to the type descriptor of the data structure @meta{type-name}, which
must be the first argument to a previous use of @func{define-struct}.
@end deffn


@defun struct-type-descriptor? @var{obj}
Return @true{} if @var{obj} is a struct--type descriptor, otherwise
return @false{}.  This predicate returns @false{} when applied to
@rnrs{6} record--type descriptors.
@end defun


@defun struct-constructor @var{std}
Return a constructor function for struct of type defined by the type
descriptor @var{std}.  The returned constructor accepts as many
arguments as there are fields specified by @var{std} and it returns a
new struct instance.

@lisp
(define duo-std
  (make-struct-type "duo" '(one two)))

(define make-duo
  (struct-constructor duo-std))

(make-duo 1 2)  @result{} #[struct duo one=1 two=2]
@end lisp
@end defun


@defun struct-predicate @var{std}
Return a predicate function for structs of type defined by the type
descriptor @var{std}.

@lisp
(define duo-std
  (make-struct-type "duo" '(one two)))

(define make-duo
  (struct-constructor duo-std))

(define duo?
  (struct-predicate duo-std))

(duo? (make-duo 1 2))   @result{} #t
@end lisp
@end defun


@defun struct-field-accessor @var{std} @var{index/name}
@defunx struct-field-mutator @var{std} @var{index/name}
Return an accessor or mutator function for the field at @var{index/name}
of structs of type defined by the type descriptor @var{std}.
@var{index/name} can be a field index or a symbol representing a field
name.

@example
(define-struct color
  (red green blue))

(define stru
  (make-color 1 2 3))

((struct-field-accessor (struct-type-descriptor color) 'red)
 stru)
@result{} 1

((struct-field-accessor (struct-type-descriptor color) 0)
 stru)
@result{} 1
@end example
@end defun


@defun struct-field-method @var{std} @var{index/name}
Return a ``method'' function for the field at @var{index/name} of
structs of type defined by the type descriptor @var{std}.
@var{index/name} can be a field index or a symbol representing a field
name.  When the method function is applied to @math{1} argument: it
behaves like a field accessor.  When the method function is applied to
@math{2} arguments: it behaves like a field mutator.

@example
(define-struct color
  (red green blue))

(define stru
  (make-color 1 2 3))

(define red-method
  (struct-field-method (struct-type-descriptor color) 'red))

(red-method stru)       @result{} 1
(red-method stru 11)
(red-method stru)       @result{} 11
@end example
@end defun

@c page
@node iklib structs types inspect
@subsubsection Inspecting struct types


@defun struct-type-name @var{std}
Return a string representing the name of structs of type @var{std}.
@end defun


@defun struct-type-symbol @var{std}
Return a symbol uniquely identifying the struct type @var{std}.
@end defun


@defun struct-type-field-names @var{std}
Return a list of symbols representing the names of fields in structs of
type @var{std}.
@end defun

@c page
@node iklib structs types printer
@subsubsection Structs printer customisation


@value{PRJNAME}'s built--in Scheme objects writer can print structs just
fine, handling cyclic references and shared objects:

@lisp
(import (vicare))
(print-graph #t)
(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))

(define-struct duo (one two))

;; simple struct
(display (make-duo 1 2))
@print{} #[struct duo one=1 two=2]

;; struct with shared object
(let* ((A (make-duo 1 2))
       (B (make-duo A A)))
  (display B))
@print{} #[struct duo one=#0=#[struct duo one=1 two=2] two=#0#]

;; struct with cyclic reference to itself
(let ((A (make-duo 1 (void))))
  (set-duo-two! A A)
  (display A))
@print{} #0=#[struct duo one=1 two=#0#]
@end lisp

The Scheme objects writer is able to differentiate between
@func{display}, @func{write} and @func{pretty-print} printing.  When
printing structs, the built--in writer makes @strong{no} difference
between printing with @func{display} and @func{write}; it does it
differently when printing with @func{pretty-print}:

@lisp
(import (vicare))
(print-graph #t)
(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))

(define-struct duo (one two))

;; simple struct
(pretty-print (make-duo 1 2))
@print{} (struct duo (one 1) (two 2))

;; struct with shared object
(let* ((A (make-duo 1 2))
       (B (make-duo A A)))
  (pretty-print B))
@print{} (struct duo (one #0=(struct duo (one 1) (two 2))) (two #0#))

;; struct with cyclic reference to itself
(let ((A (make-duo 1 (void))))
  (set-duo-two! A A)
  (pretty-print A))
@print{} #0=(struct duo (one 1) (two #0#))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Custom printers

Sometimes, we need to print a struct with a customised representation.
For example keyword objects (@pxref{iklib keywords, Keyword objects})
are structs with a custom printer function:

@lisp
(display #:ciao)        @result{} #:ciao
@end lisp

For every struct type it is possible to set a custom printer function;
it accepts @math{3} arguments: the struct to be printed; a textual
output port into which to write a string representation of the struct in
the style of @func{display}, @func{write} or @func{pretty-print}; a
sub--printer function to be optionally used to print component objects.
The sub--printer function accepts as single argument the object to
print; it allows us to interface with the shared objects printer that
handles shared and cyclic references.

As example, the following code defines a custom printer, making use of
the parameter @func{printer-printing-style} to differentiate the style:

@lisp
(import (vicare))
(print-graph #t)
(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))

(define-struct duo (one two))

(define (duo-printer stru port sub-printer)
  (case (printer-printing-style)
    ((display)
     (display "#@{duo " port)
     (sub-printer (duo-one stru))
     (display " " port)
     (sub-printer (duo-two stru))
     (display "@}" port))
    ((write)
     (display "(" port)
     ;;By using the sub-printer: we make this sexp shared too.
     (sub-printer '(struct-constructor
                      (struct-type-descriptor duo)))
     (display " " port)
     (sub-printer (duo-one stru))
     (display " " port)
     (sub-printer (duo-two stru))
     (display ")" port))
    ((pretty-print)
     (sub-printer `(struct duo
                           #:one ,(duo-one stru)
                           #:two ,(duo-two stru))))))

(set-struct-type-printer! (struct-type-descriptor duo)
                          duo-printer)

(define O
  (make-duo 1 2))

(display O)
@print{} #@{duo 1 2@}"

(write O)
@print{} ((struct-constructor (struct-type-descriptor duo)) 1 2)

(pretty-print O)
@print{} (struct duo #:one 1 #:two 2)

;; shared object, display
(let* ((A (make-duo 1 2))
       (B (make-duo A A)))
  (display B))
@print{} #@{duo #0=#@{duo 1 2@} #0#@}

;; shared object, write
(let* ((A (make-duo 1 2))
       (B (make-duo A A)))
  (write B))
@print{} (#0=(struct-constructor (struct-type-descriptor duo)) \
  #1=(#0# 1 2) #1#)
@end lisp


@defun set-struct-type-printer! @var{std} @var{printer}
@defunx set-rtd-printer! @var{std} @var{printer}
Select the procedure @var{printer} as printer for structs of type
@var{std}; if @var{printer} is @false{}, instances of type @var{std}
make use of the built--in Scheme objects printer.  Return the old
printer function or @false{} if no printer function was set for this
@var{std}.
@end defun


@defun struct-type-printer @var{std}
Return @false{} or a function previously set as custom struct printer
for instances of struct type @var{std}.  When the return value is
@false{}: instances of type @var{std} make use of the built--in Scheme
objects printer.
@end defun

@c page
@node iklib structs types final
@subsubsection Finalisation of structs


@cindex Automatic finalisation of structs
@cindex Structs, automatic finalisation
@cindex Structs, destructors
@cindex Finalisation of structs
@cindex Destructors for structs


@value{PRJNAME} allows structs to be finalised either explicitly or
automatically by the garbage collector, by applying a destructor
function to them; here is how automatic finalisation works:

@example
vicare> (define-struct duo (one two))
vicare> (set-struct-type-destructor! (struct-type-descriptor duo)
   (lambda (stru)
     (printf "destroying ~s\n" stru)))
vicare> (make-duo 1 2)
$1 = (struct duo (one 1) (two 2))
vicare> (collect)
destroying #[struct duo one=1 two=2]
vicare>
@end example

A destructor function is associated to a struct--type by registering it
in the struct--type descriptor.  After a destructor is set in the
descriptor: new instances of the struct--type are registered, upon
creation, into an internal guardian, @ref{iklib guardians} for details;
whenever such structs are garbage collected: the guardian applies the
destructor to them.

When the destructor is called by the garbage collector: exceptions
raised by it are catched with @syntax{guard} and discarded; destructor
functions should take care of exceptions by themselves.

It is possible for a destructor function to be applied multiple times to
the same struct: once a destructor is set in the descriptor, it can be
explicitly applied to structs and later applied again by the garbage
collector.  Destructor functions must be written in such a way that
multiple applications are not a problem.  For example, it is usually
possible, upon destruction, to reset some struct fields to the void
object: when the destructor detects a field set to void, it knows that
the struct has already been finalised.


@defun set-struct-type-destructor! @var{std} @var{destructor}
@defunx set-rtd-destructor! @var{std} @var{destructor}
Select the procedure @var{destructor} as destructor for data structs of
type @var{std}; return the old destructor function or @false{} if no
destructor was set for @var{std}.  The destructor accepts a single
argument being the struct instance to finalise; the destructor can
return unspecified values.
@end defun


@defun struct-type-destructor @var{std}
Return @false{} or a procedure being the destructor for instances of
@var{std}.
@end defun


@deffn Parameter struct-guardian-logger
@cindex Parameter @func{struct-guardian-logger}
Select data structs destruction logging mode for debugging purposes.
When a struct is finalised by the garbage collector, using the
destructor registered in the @rtd{}:

@itemize
@item
If this parameter is set to @false{}: no additional actions are
performed.

@item
If this parameter is set to @true{}: the function
@func{struct-guardian-log} is used to log the operations to the textual
output port returned by @code{current-error-port}.

@item
If this parameter is set to a procedure: such procedure is used to log
the operations in a user selected way.
@end itemize

See the documentation of @func{struct-guardian-log} for the calling
protocol of the logger functions.
@end deffn


@defun struct-guardian-log @var{struct} @var{exception} @var{action}
Built in logger function to be used to log struct finalisation
operations by the garbage collector.  @var{struct} is the instance to be
finalised; @var{exception} is @false{} or an object raised by the struct
destructor; @var{action} is one of the symbols:
@code{before-destruction}, @code{after-destruction}, @code{exception}.

When this function is used as value for the parameter
@func{struct-guardian-logger}:

@itemize
@item
The function is called whenever a struct is registered for destruction
with @var{action} set to the symbol @code{registration} and
@var{exception} set to @false{}.

@item
The function is called just before the struct is finalised with
@var{action} set to the symbol @code{before-destruction} and
@var{exception} set to @false{}.

@item
The function is called right after the struct has been finalised with
@var{action} set to the symbol @code{after-destruction} and
@var{exception} set to @false{}.

@item
If an exception is raised by the destructor: such exception is catched
and this function is called with @var{action} set to @code{exception}
and @var{exception} set to the raised object.
@end itemize

The current implementation is the following:

@smallexample
(define (struct-guardian-log S E action)
  (case action
    ((registration)
     (fprintf (current-error-port)
              "*** Vicare debug: struct guardian: registered struct:\n\
               ***\t~s\n" S))
    ((before-destruction)
     (fprintf (current-error-port)
       "*** Vicare debug: struct guardian: before destruction:\n\
        ***\t~s\n" S))
    ((after-destruction)
     (fprintf (current-error-port)
       "*** Vicare debug: struct guardian: after destruction:\n\
        ***\t~s\n" S))
    ((exception)
     (fprintf (current-error-port)
       "*** Vicare debug: struct guardian: exception:\n\
        ***\t~s\n\
        ***\t~s\n" S E))
    (else
     (assertion-violation 'struct-guardian-log
       "invalid action in struct destruction process" S action))))
@end smallexample
@end defun

@c page
@node iklib structs inspect
@subsection Inspecting data structures


@defun struct? @var{stru}
@defunx struct? @var{stru} @var{std}
When no @var{std} argument is given: return true if @var{stru} is a data
structure.  When @var{std} is given: return true if @var{stru} is a data
structure and it is of type @var{std}, which must be a struct type
descriptor.
@end defun


@defun struct-and-std? @var{stru} @var{std}
Return @true{} if @var{stru} is a struct with struct--type descriptor
equal to @var{std}; otherwise return @false{}.  Raise an error if
@var{std} is not a struct--type descriptor.
@end defun


@defun struct-std @var{stru}
@defunx struct-rtd @var{stru}
Return the struct--type descriptor of the data structure @var{stru}.
Notice that this function works with both Vicare's structs and @rnrs{6}
records.
@end defun


@defun struct-length @var{stru}
Return the number of fields in the data structure @var{stru}.  Notice
that this function works with both Vicare's structs and @rnrs{6}
records.
@end defun


@defun struct-field-names @var{stru}
Return a list of symbols representing the field names of the structure
@var{stru}.
@end defun


@defun struct-name @var{stru}
Return a string representing the name of the data structure @var{stru}.
Notice that this function works with both Vicare's structs and @rnrs{6}
records.
@end defun


@defun struct-printer @var{stru}
Return @false{} or the procedure being the printer function for the data
structure @var{stru}.
@end defun


@defun struct-destructor @var{stru}
Return @false{} or the procedure being the destructor function for the
data structure @var{stru}.
@end defun


@defun struct-ref @var{stru} @var{index}
Return the value of field at @var{index} in the data structure
@var{stru}.
@end defun


@defun struct-set! @var{stru} @var{index} @var{value}
Store @var{value} in the field at @var{index} in the data structure
@var{stru}.
@end defun


@defun struct-and-std-ref @var{stru} @var{index} @var{std}
Check that @var{stru} is a struct of type @var{std}, then return the
value of field at @var{index} in the data structure @var{stru}.
@end defun


@defun struct-and-std-set! @var{stru} @var{index} @var{std} @var{value}
Check that @var{stru} is a struct of type @var{std}, store @var{value}
in the field at @var{index} in the data structure @var{stru}.
@end defun


@defun struct=? @vari{obj} @varii{obj}
Return true if @vari{obj} and @varii{obj} are two structures having the
same @rtd{} and equal field values according to @func{eqv?}.  Note that
this function also works when applied to @rnrs{6} records.
@end defun


@defun struct-reset @var{stru}
Reset to void all the fields of a structure.
@end defun

@c page
@node iklib records
@section Extensions to @rnrs{6} records


@menu
* iklib records defs::          Defining record types.
* iklib records predicates::    Record predicates.
* iklib records fields::        Accessing and mutating fields.
* iklib records final::         Automatic finalisation of records.
* iklib records printer::       Custom record printers.
* iklib records rcd::           Record-constructor descriptors.
* iklib records misc::          Miscellaneous functions.
@end menu

@c page
@node iklib records defs
@subsection Defining record types


@deffn Syntax define-record-type @meta{name-spec} @meta{record-clause} @dots{}
@deffnx {Auxiliary Syntax} fields @meta{field-spec} @dots{}
@deffnx {Auxiliary Syntax} method
@deffnx {Auxiliary Syntax} case-method
@deffnx {Auxiliary Syntax} super-protocol @meta{expr}
@deffnx {Auxiliary Syntax} destructor-protocol @meta{expr}
@deffnx {Auxiliary Syntax} custom-printer @meta{expr}
Defined by @rnrs{6}.  Define a new @rnrs{6} record type; @ref{stdlib
records syntactic layer, define-record-type}.  This syntax supports some
@value{PRJNAME} extensions, when the selected language is not strict
@rnrs{6}.

When the selected language is non--strict @rnrs{6}: multiple
@clause{fields} clauses are accepted and the field specifications
concatenated in the order in which they are given.  Example:

@lisp
(define-record-type alpha
  (fields a)
  (fields b)
  (fields c))

(define O
  (make-alpha 1 2 3))

(alpha-a O)     @result{} 1
(alpha-b O)     @result{} 2
(alpha-c O)     @result{} 3
@end lisp
@end deffn


@menu
* iklib records defs super-proto:: The super-type protocol.
* iklib records defs methods::     Record-type methods.
* iklib records defs destructor::  The destructor protocol.
* iklib records defs printer::     The custom printer.
@end menu

@c page
@node iklib records defs super-proto
@subsubsection The super--type protocol


In a use of the syntax @syntax{define-record-type}, the definition
clause:

@lisp
(super-protocol @meta{expr})
@end lisp

@noindent
allows the specification of a constructor protocol to be used by
sub--types of a record--type.  Usually a sub--type make use of the
protocol function built from the constructor protocol specified by the
clause @clause{protocol}, but the clause @clause{super-protocol}
overrides it.

The @clause{super-protocol} works like @clause{protocol}, its
@meta{expr} argument must be an expression evaluating to a protocol
function; the protocol function accepts as single argument the
constructor function of its super--type and it must return the record
instance.

Here is an example in which the record--type @objtype{alpha} is the
super--type of the record--type @objtype{beta}:

@lisp
(define-record-type alpha
  (fields a b)
  (super-protocol
    (lambda (make-record)
      (lambda (a b)
        (make-record (+ 10 a) (+ 20 b))))))

(define-record-type beta
  (parent alpha)
  (fields c d))

(let ((R (make-alpha 1 2)))
  (values (alpha-a R)
          (alpha-b R)))
@result{} 1 2

(let ((R (make-beta 1 2 3 4)))
  (values (alpha-a R)
          (alpha-b R)
          (beta-c  R)
          (beta-d  R)))
@result{} 11 22 3 4
@end lisp

@noindent
the default constructor function @func{make-alpha} builds instances of
@objtype{alpha} with the default constructor; the constructor of
@objtype{beta} receives as constructor function the result of calling
the @clause{super-protocol} of @objtype{alpha}.

@c page
@node iklib records defs methods
@subsubsection Record--type methods


The syntactic bindings @clause{method} and @clause{case-method} are used
as clause keywords in @syntax{define-record-type} to define methods for
a record type; each can be used any number of times in the same
@syntax{define-record-type} macro use.  These clauses are accepted by
@syntax{define-record-type} only when the language is non--strict
@rnrs{6}.

We can think of @clause{method} as acting like @syntax{define} with
regard to the syntax of arguments to function; the first argument to a
method is the record itself: we have to write it explicitly.  For
example:

@lisp
(define-record-type duo
  (fields one two)
  (method (sum-them this)
    (+ (duo-one this)
       (duo-two this)))
  (method (mul-them this)
    (* (duo-one this)
       (duo-two this))))

(define @{O duo@}
  (make-duo 1 2))

(method-call sum-them O)        @result{} 3
@end lisp

The clause @clause{case-method} is similar, we can think of it as acting
like @syntax{case-define}:

@lisp
(define-record-type alpha
  (fields (mutable a))
  (case-method on-a
    ((this)
     (alpha-a this))
    ((this new-val)
     (alpha-a-set! this new-val))))

(define @{O alpha@}
  (new alpha 1))

(method-call on-a O)            @result{} 1
(method-call on-a O 2)
(method-call on-a O)            @result{} 2
@end lisp

The syntax @syntax{method-call} searches for a record--type's methods by
comparing the symbols with @func{eq?} (@strong{not} the syntactic
identifiers with @func{free-identifier=?}).  @ref{types syntaxes
methods, Calling object--type methods}.

When used with records: if a method with the given name is not found,
@syntax{method-call} searches for a field with the given name, but only
if the number of arguments is right; field accessors and mutators are
methods automatically.  The syntax of @syntax{method-call} is:

@example
(method-call @meta{name} @meta{subject-expr} @meta{arg} ...)
@end example

@noindent
and this is what it does for records when no matching method is found:

@itemize
@item
If there are @strong{no} arguments @meta{arg}, then a field with name
@meta{name} is searched and, if found, the form is expanded to an
application of the field's accessor:

@example
(@meta{accessor} @meta{subject-expr})
@end example

@item
If there is @strong{only one} argument @meta{arg}, then a field with
name @meta{name} is searched and, if the field is found and it is
mutable, the form is expanded to an application of the field's mutator:

@example
(@meta{mutator} @meta{subject-expr} @meta{arg})
@end example
@end itemize

So the above @clause{case-method} example can just be rewritten as:

@lisp
(define-record-type alpha
  (fields (mutable a)))

(define @{O alpha@}
  (new alpha 1))

(method-call a O)            @result{} 1
(method-call a O 2)
(method-call a O)            @result{} 2
@end lisp

@noindent
and with dot notation (@pxref{types syntaxes methods, Dot notation}):

@lisp
(define-record-type alpha
  (fields (mutable a)))

(define @{O alpha@}
  (new alpha 1))

(.a O)          @result{} 1
(.a O 2)
(.a O)          @result{} 2
@end lisp

@c page
@node iklib records defs destructor
@subsubsection The destructor protocol


In a use of the syntax @syntax{define-record-type}, the definition
clause:

@lisp
(destructor-protocol @meta{expr})
@end lisp

@noindent
allows the specification of an expression @meta{expr} which must
evaluate to the destructor protocol function; this function is used as
explained below to construct a destructor function to be called:

@itemize
@item
Implicitly by the garbage collector when a record of this type is
collected.

@item
Explicitly with the @syntax{delete} syntax.
@end itemize

@noindent
@ref{iklib records final} for further details.

Here is how the destructor function is built:

@itemize
@item
If this type has a @syntax{destructor-protocol} clause and no parent:
@meta{expr} must evaluate to a closure object accepting no arguments and
returning a closure object acting as destructor function for records of
this type.  For example:

@lisp
(define-record-type <port>
  (fields port)
  (destructor-protocol
    (lambda ()
      (lambda (record)
        (close-port (<port>-port record))))))
@end lisp

@item
If this type has a @syntax{destructor-protocol} clause and a parent
specified with the @clause{parent} or @clause{parent-rtd} clauses:
@meta{expr} must evaluate to a closure object accepting as single
argument the parent's destructor function and returning as single value
a closure object acting as destructor function for records of this type.
For example:

@lisp
(define-record-type <port>
  (fields port)
  (destructor-protocol
    (lambda ()
      (lambda (record)
        (close-port (<port>-port record))))))

(define-record-type <file>
  (parent <port>)
  (fields filename)
  (destructor-protocol
    (lambda (destroy-<port>)
      (lambda (record)
        (destroy-<port> record)))))
@end lisp

@noindent
notice that the destructor of @samp{<file>} is meant to call the
destructor of its supertype @samp{<port>} at some point; however calling
the supertype's destructor is optional.

@item
If this type has no @clause{destructor-protocol} clause, it has a parent
and the parent has a destructor function: the parent's destructor
function becomes this type's destructor function.
@end itemize

@c page
@node iklib records defs printer
@subsubsection The custom printer


In a use of the syntax @syntax{define-record-type}, the definition
clause:

@lisp
(custom-printer @meta{expr})
@end lisp

@noindent
allows the specification of an expression @meta{expr} which must
evaluate to a custom printer function for instances of the record type;
@ref{iklib records printer}, for details on record's custom printers.

Usage example:

@lisp
(define-record-type duo
  (fields one two)
  (custom-printer
    (lambda (record port sub-printer)
      (display "#@{record duo one=" port)
      (display (duo-one record) port)
      (display " two=" port)
      (display (duo-two record) port)
      (display "@}" port))))

(display (make-duo 1 2))
@print{} #@{record duo one=1 two=2@}
@end lisp

@c page
@node iklib records predicates
@subsection Record predicates


@defun record-and-rtd? @var{record} @var{rtd}
Return @true{} if @var{record} is a record instance of the type
described by @var{rtd} or a record instance of a subtype of @var{rtd};
otherwise return @false{}.  This procedure does @strong{not} care if
@var{rtd} is an opaque record type.
@end defun


@deffn Syntax record-type-and-record? @meta{type-name} @meta{record}
Return @true{} if @meta{record} is an expression evaluating to a record
instance of type @meta{type-name} or a record instance of a subtype of
@meta{type-name}; otherwise return @false{}.  This syntax does
@strong{not} care if @meta{type-name} is an opaque record type.

This syntax allows to test the type of a record instance through the
type name identifier, without the need to export the predicate
identifier out of libraries.  It performs the same operation of the more
generic @syntax{is-a?}, but will raise an exception if @meta{type-name}
is not the identifier of a record type.
@end deffn

@c page
@node iklib records fields
@subsection Accessing and mutating fields


@defun record-accessor @var{rtd} @var{index/name}
@defunx record-accessor @var{rtd} @var{index/name} @var{accessor-who}
As defined by @rnrs{6}, this function accepts only two arguments and the
second is a relative field index; @ref{stdlib records procedural layer,
record-accessor}.  @value{PRJNAME} extends this function.

The argument @var{index/name} can be either a relative field index, as
specified by @rnrs{6}, or a symbol representing a field name.  In the
second case @var{rtd} and its parents are searched for the first
matching field specification, so fields of the sub--types take
precedence.

The optional third argument @var{accessor-who} must be a symbol
representing the name of the returned accessor function; it is used for
descriptive error reporting.

Here is an example with the field name argument being a symbol:

@example
(import (vicare))
(define-record-type alpha
  (fields a b c))
(define alpha-rtd
  (record-type-descriptor alpha))
(define R
  (make-alpha 1 2 3))
((record-accessor alpha-rtd 'a) R)      @result{} 1
((record-accessor alpha-rtd 'b) R)      @result{} 2
((record-accessor alpha-rtd 'c) R)      @result{} 3
@end example

Below is another example with record type inheritance; notice that both
the record types have a field named @samp{C} and the sub--type takes
precedence:

@example
(import (vicare))
(define-record-type alpha
  (fields a b C))
(define-record-type beta
  (parent alpha)
  (fields C d e))
(define beta-rtd
  (record-type-descriptor beta))
(define R
  (make-beta 1 2 3 4 5 6))
((record-accessor beta-rtd 'a) R)       @result{} 1
((record-accessor beta-rtd 'b) R)       @result{} 2
((record-accessor beta-rtd 'C) R)       @result{} 4
((record-accessor beta-rtd 'd) R)       @result{} 5
((record-accessor beta-rtd 'e) R)       @result{} 6
@end example
@end defun


@defun record-mutator @var{rtd} @var{index/name}
@defunx record-mutator @var{rtd} @var{index/name} @var{mutator-who}
As defined by @rnrs{6}, this function accepts only two arguments and the
second is a relative field index; @ref{stdlib records procedural layer,
record-mutator}.  @value{PRJNAME} extends this function.

The argument @var{index/name} can be either a relative field index, as
specified by @rnrs{6}, or a symbol representing a field name.  In the
second case @var{rtd} and its parents are searched for the first
matching field specification, so fields of the sub--types take
precedence.

The optional third argument @var{mutator-who} must be a symbol
representing the name of the returned mutator function; it is used for
descriptive error reporting.

Here is an example with the field name argument being a symbol:

@example
(import (vicare))
(define-record-type alpha
  (fields a b c))
(define alpha-rtd
  (record-type-descriptor alpha))
(define R
  (make-alpha 1 2 3))
((record-mutator alpha-rtd 'a) R 19)
((record-mutator alpha-rtd 'b) R 29)
((record-mutator alpha-rtd 'c) R 39)
((record-accessor alpha-rtd 'a) R)      @result{} 1
((record-accessor alpha-rtd 'b) R)      @result{} 2
((record-accessor alpha-rtd 'c) R)      @result{} 3
@end example

@noindent
and another example with record type inheritance; notice that both the
record types have a field named @samp{C} and the sub--type takes
precedence:

@example
(import (vicare))
(define-record-type alpha
  (fields a b C))
(define-record-type beta
  (parent alpha)
  (fields C d e))
(define beta-rtd
  (record-type-descriptor beta))
(define R
  (make-beta 1 2 3 4 5 6))
((record-mutator beta-rtd 'a) R 19)
((record-mutator beta-rtd 'b) R 29)
((record-mutator beta-rtd 'C) R 49)
((record-mutator beta-rtd 'd) R 59)
((record-mutator beta-rtd 'e) R 69)
((record-accessor beta-rtd 'a) R)       @result{} 19
((record-accessor beta-rtd 'b) R)       @result{} 29
((record-accessor beta-rtd 'C) R)       @result{} 49
((record-accessor beta-rtd 'd) R)       @result{} 59
((record-accessor beta-rtd 'e) R)       @result{} 69
@end example
@end defun


@defun unsafe-record-accessor @var{rtd} @var{index/name}
@defunx unsafe-record-accessor @var{rtd} @var{index/name} @var{accessor-who}
Like @func{record-accessor}, but return an unsafe field accessor that
will not validate its arguments.
@end defun


@defun unsafe-record-mutator @var{rtd} @var{index/name}
@defunx unsafe-record-mutator @var{rtd} @var{index/name} @var{mutator-who}
Like @func{record-mutator}, but return an unsafe field mutator that will
not validate its arguments.
@end defun


@defun record-ref @var{reco} @var{index}
Return the value of the field at absolute index @var{index} for the
record @var{reco}.
@end defun

@c page
@node iklib records final
@subsection Automatic finalisation of records


@cindex Automatic finalisation of records
@cindex Records, automatic finalisation
@cindex Records, destructors
@cindex Data records, automatic finalisation
@cindex Data records, destructors
@cindex Finalisation of data records
@cindex Destructors for data records


@value{PRJNAME} allows records to be finalised either explicitly or
automatically by the garbage collector, by applying a destruction
function to them; here is how automatic finalisation works:

@example
#!r6rs
(import (vicare))

(define-record-type <alpha>
  (fields a b c))

(define (<alpha>-destructor rec)
  (fprintf (current-error-port) "finalising ~s\n" rec))

(record-type-destructor-set! (record-type-descriptor <alpha>)
                             <alpha>-destructor)

(pretty-print (make-<alpha> 1 2 3) (current-error-port))
@print{} (record <alpha> (a 1) (b 2) (c 3))

(collect)
@print{} finalising #[record <alpha> a=1 b=2 c=3]
@end example

A destructor function is associated to a record--type by registering it
in the record--type descriptor.  After a destructor is set in the
descriptor: new instances of the record--type are registered, upon
creation, into an internal guardian, @ref{iklib guardians} for details;
whenever such records are garbage collected: the guardian applies the
destructor to them.

When the destructor is called by the garbage collector: exceptions
raised by it are catched with @syntax{guard} and discarded; destructor
functions should take care of exceptions by themselves.

It is possible for a destructor function to be applied multiple times to
the same record: once a destructor is set in the descriptor, it can be
explicitly applied to records and later applied again by the garbage
collector.  Destructor functions must be written in such a way that
multiple applications are not a problem.  For example, it is usually
possible, upon destruction, to reset some record fields to the void
object: when the destructor detects a field set to void, it knows that
the record has already been finalised.


@defun record-type-destructor-set! @var{rtd} @var{destructor}
Select the procedure @var{destructor} as destructor for @rnrs{6} records
of type @var{rtd}; return unspecified values.  The destructor accepts a
single argument being the record to finalise; the destructor can return
unspecified values.
@end defun


@defun record-type-destructor @var{rtd}
Return the function set in @var{rtd} as instance destructor; return
@false{} if no destructor is set in @var{rtd}.
@end defun


@defun record-destructor @var{record}
Return the current destructor for the record @var{record}: @false{} or a
function.
@end defun


@deffn Parameter record-guardian-logger
@cindex Parameter @func{record-guardian-logger}
Select a record destruction logging mode for debugging purposes.  When a
record is finalised by the garbage collector, using the destructor
registered in the @rtd{}:

@itemize
@item
If this parameter is set to @false{}: no additional actions are
performed.

@item
If this parameter is set to @true{}: the function
@func{record-guardian-log} is used to log the operations to the textual
output port returned by @code{current-error-port}.

@item
If this parameter is set to a procedure: such procedure is used to log
the operations in a user selected way.
@end itemize

See the documentation of @func{record-guardian-log} for the calling
protocol of the logger functions.
@end deffn


@defun record-guardian-log @var{record} @var{exception} @var{action}
Built in logger function to be used to log record finalisation
operations by the garbage collector.  @var{record} is the record to be
finalised; @var{exception} is @false{} or an object raised by the record
destructor; @var{action} is one of the symbols:
@code{before-destruction}, @code{after-destruction}, @code{exception}.

When this function is used as value for the parameter
@func{record-guardian-logger}:

@itemize
@item
The function is called whenever a record is registered for destruction
with @var{action} set to the symbol @code{registration} and
@var{exception} set to @false{}.

@item
The function is called just before the record is finalised with
@var{action} set to the symbol @code{before-destruction} and
@var{exception} set to @false{}.

@item
The function is called right after the record has been finalised with
@var{action} set to the symbol @code{after-destruction} and
@var{exception} set to @false{}.

@item
If an exception is raised by the destructor: such exception is catched
and this function is called with @var{action} set to @code{exception}
and @var{exception} set to the raised object.
@end itemize

The current implementation is the following:

@smallexample
(define (record-guardian-log S E action)
  (case action
    ((registration)
     (fprintf (current-error-port)
       "*** Vicare debug: record guardian: registered record:\n\
        ***\t~s\n" S))
    ((before-destruction)
     (fprintf (current-error-port)
       "*** Vicare debug: record guardian: before destruction:\n\
        ***\t~s\n" S))
    ((after-destruction)
     (fprintf (current-error-port)
       "*** Vicare debug: record guardian: after destruction:\n\
        ***\t~s\n" S))
    ((exception)
     (fprintf (current-error-port)
       "*** Vicare debug: record guardian: exception:\n\
        ***\t~s\n\
        ***\t~s\n" S E))
    (else
     (assertion-violation 'record-guardian-log
       "invalid action in record destruction process" S action))))
@end smallexample
@end defun

@c page
@node iklib records printer
@subsection Custom record printers


@value{PRJNAME}'s built--in Scheme objects writer can print records just
fine, handling cyclic references and shared objects:

@lisp
(import (vicare))
(print-graph #t)
(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))

(define-record-type duo
  (fields one two))

;; simple record
(display (make-duo 1 2))
@print{} #[record duo one=1 two=2]

;; record with shared object
(let* ((A (make-duo 1 2))
       (B (make-duo A A)))
  (display B))
@print{} #[record duo one=#0=#[record duo one=1 two=2] two=#0#]

;; record with cyclic reference to itself
(let ((A (make-duo 1 (void))))
  (duo-two-set! A A)
  (display A))
@print{} #0=#[record duo one=1 two=#0#]
@end lisp

The Scheme objects writer is able to differentiate between
@func{display}, @func{write} and @func{pretty-print} printing.  When
printing records, the built--in writer makes @strong{no} difference
between printing with @func{display} and @func{write}; it does it
differently when printing with @func{pretty-print}:

@lisp
(import (vicare))
(print-graph #t)
(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))

(define-record-type duo
  (fields one two))

;; simple record
(pretty-print (make-duo 1 2))
@print{} (record duo (one 1) (two 2))

;; record with shared object
(let* ((A (make-duo 1 2))
       (B (make-duo A A)))
  (pretty-print B))
@print{} (record duo (one #0=(record duo (one 1) (two 2))) (two #0#))

;; record with cyclic reference to itself
(let ((A (make-duo 1 (void))))
  (duo-two-set! A A)
  (pretty-print A))
@print{} #0=(record duo (one 1) (two #0#))
@end lisp

@c ------------------------------------------------------------------------

@subsubheading Custom printers

Sometimes, we need to print a record with a customised representation.
For every record type it is possible to set a custom printer function;
it accepts @math{3} arguments: the record to be printed; a textual
output port into which to write a string representation of the record in
the style of @func{display}, @func{write} or @func{pretty-print}; a
sub--printer function to be optionally used to print component objects.
The sub--printer function accepts as single argument the object to
print; it allows us to interface with the shared objects printer that
handles shared and cyclic references.

As example, the following code defines a custom printer, making use of
the parameter @func{printer-printing-style} to differentiate the style:

@lisp
(import (vicare))
(print-graph #t)
(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))

(define-record-type duo
  (fields one two))

(define (duo-printer stru port sub-printer)
  (case (printer-printing-style)
    ((display)
     (display "#@{duo " port)
     (sub-printer (duo-one stru))
     (display " " port)
     (sub-printer (duo-two stru))
     (display "@}" port))
    ((write)
     (display "(" port)
     ;;By using the sub-printer: we make this sexp shared too.
     (sub-printer '(record-constructor
                      (record-constructor-descriptor duo)))
     (display " " port)
     (sub-printer (duo-one stru))
     (display " " port)
     (sub-printer (duo-two stru))
     (display ")" port))
    ((pretty-print)
     (sub-printer `(record duo
                           #:one ,(duo-one stru)
                           #:two ,(duo-two stru))))))

(record-type-printer-set! (record-type-descriptor duo)
                          duo-printer)

(define O
  (make-duo 1 2))

(display O)
@print{} #@{duo 1 2@}"

(write O)
@print{} ((record-constructor (record-constructor-descriptor duo)) 1 2)

(pretty-print O)
@print{} (record duo #:one 1 #:two 2)

;; shared object, display
(let* ((A (make-duo 1 2))
       (B (make-duo A A)))
  (display B))
@print{} #@{duo #0=#@{duo 1 2@} #0#@}

;; shared object, write
(let* ((A (make-duo 1 2))
       (B (make-duo A A)))
  (write B))
@print{} (#0=(record-constructor (record-constructor-descriptor duo)) \
  #1=(#0# 1 2) #1#)
@end lisp


@defun record-type-printer-set! @var{rtd} @var{printer}
Select the procedure @var{printer} as printer for reocrds of type
@var{rtd}; if @var{printer} is @false{}, instances of type @var{rtd}
make use of the built--in Scheme objects printer.  Return the old
printer function or @false{} if no printer function was set for this
@var{rtd}.
@end defun


@defun record-type-printer @var{rtd}
Return the function set as custom printer for records of type @var{rtd};
return @false{} if @var{rtd} has no custom printer.
@end defun


@defun record-printer @var{record}
Return @false{} or the function being the custom record printer for the
record @var{record}.
@end defun

@c page
@node iklib records rcd
@subsection Record--constructor descriptors


@defun record-constructor-descriptor? @var{obj}
Return @true{} if @var{obj} is a record--constructor descriptor;
otherwise return @false{}.
@end defun


@defun rcd-rtd @var{rcd}
Given a record--constructor descriptor return its record--type
descriptor.
@end defun


@defun rcd-parent-rcd @var{rcd}
Given a record--constructor descriptor return its parent
record--constructor descriptor or @false{} if @var{rcd} has no parent.
@end defun

@c page
@node iklib records misc
@subsection Miscellaneous functions


The following bindings are exported by the library @library{vicare}.


@defun record=? @vari{record} @varii{record}
Return true if @vari{record} and @varii{record} are two @rnrs{6} records
having the same @rtd{} and equal field values according to @func{eqv?}.
@end defun


@defun record-reset @var{record}
Reset to void all the fields of a record, whatever its type.
@end defun


@defun record-object? @var{obj}
Return @true{} if @var{obj} is an @rnrs{6} record, otherwise return
@false{}.  This procedure does @strong{not} care if the associated
record--type is opaque.
@end defun


@defun record-type-all-field-names @var{rtd}
Return a vector holding one Scheme symbol for each field of @var{rtd},
including fields of the parents; the order of the symbols is the same of
the order of the fields in the @var{rtd} definition.

If we need to couple the field names to the field values, we can do it
as follows:

@lisp
(import (vicare))

(define-record-type alpha
  (fields a b c))

(define-record-type beta
  (parent alpha)
  (fields d e f))

(define-record-type gamma
  (parent beta)
  (fields g h i))

(define fields
  (record-type-all-field-names (record-type-descriptor gamma)))

(define O
  (make-gamma 1 2 3 4 5 6 7 8 9))

(let recur ((len (vector-length fields))
            (i   0))
  (if (fx<? i len)
      (cons (list (vector-ref fields i)
                  (struct-ref O i))
            (recur len (fxadd1 i)))
    '())))
@result{} ((a 1) (b 2) (c 3) (d 4) (e 5) (f 6) (g 7) (h 8) (i 9))
@end lisp
@end defun

@c page
@node iklib promises
@section Delay, force and promises


The following bindings are exported by the library @library{vicare}.


@defun promise? @var{obj}
Return @true{} if @var{obj} is a promise object returned by
@func{delay}, else return @false{}.
@end defun

@c page
@node iklib booleans
@section Additional boolean functions


The following bindings are exported by the library @library{vicare}.

@c ------------------------------------------------------------------------

@subsubheading Predicates

@defun list-of-booleans? @var{obj}
Return @true{} if @var{obj} is null or a proper list of booleans;
otherwise return @false{}.
@end defun

@c ------------------------------------------------------------------------

@subsubheading Comparison

@defun {boolean!=?} @varo{bool} @var{bool} @dots{}
The arguments must be booleans.  Return @true{} if the arguments are all
different; otherwise return @false{}.
@end defun


@deffn Procedure {boolean<?} @varo{bool} @dots{}
@deffnx Procedure {boolean>?} @varo{bool} @dots{}
@deffnx Procedure {boolean<=?} @varo{bool} @dots{}
@deffnx Procedure {boolean>=?} @varo{bool} @dots{}
Compare the boolean arguments according to the artificial comparison
definition:

@example
#t == #t
#f == #f
#f <  #t
@end example
@end deffn


@defun boolean-min @varo{bool} @var{bool} @dots{}
@defunx boolean-max @varo{bool} @var{bool} @dots{}
Return the minimal or maximal boolean among the arguments.
@end defun

@c page
@node iklib chars
@section Additional character functions


@menu
* iklib chars predicates::      Additional character predicates.
* iklib chars comparison::      Additional character comparisons.
* iklib chars unicode::         Unicode characters handling.
@end menu

@c page
@node iklib chars predicates
@subsection Additional character predicates


The following bindings are exported by the library @library{vicare}.


@defun list-of-chars? @var{obj}
Return @true{} if @var{obj} is null or a proper list of chars; otherwise
return @false{}.
@end defun


@defun char-in-ascii-range? @var{obj}
Evaluate to @true{} if @meta{obj} is a character and its Unicode code
point is in the range @math{[0, 127]}.
@end defun


@defun fixnum-in-character-range? @var{obj}
Return @true{} if @var{obj} is a fixnum and its value is in one of the
ranges acceptable by Unicode code points; otherwise return @false{}.
@end defun


@defun unicode-printable-char? @var{ch}
Return @true{} if @var{ch} is a character and it is printable; if
@var{ch} is not printable: return @false{}; if @var{ch} is not a
character: raise an exception.
@end defun

@c page
@node iklib chars comparison
@subsection Additional character comparisons


The following bindings are exported by the library @library{vicare}.


@deffn Procedure {char!=?} @varo{char} @var{char} @dots{}
The arguments must be characters.  Return @true{} if the arguments are
all different; otherwise return @false{}.
@end deffn


@deffn Procedure {char-ci!=?} @varo{char} @dots{}
Like @func{char!=?} but operate on the case--folded versions of the
arguments.
@end deffn


@defun chmin @varo{ch} @var{ch} @dots{}
@defunx chmax @varo{ch} @var{ch} @dots{}
Return the minimum or maximum character among the arguments.
@end defun

@c page
@node iklib chars unicode
@subsection Unicode characters handling


@cindex Library @library{vicare unsafe unicode}
@cindex @library{vicare unsafe unicode}, library


The library @library{vicare unsafe unicode} exports macros to handle:
Unicode's code points; the encodings @utf{}-8, @utf{}-16, @utf{}-32; the
Latin-1 encoding; the @ascii{} encoding.

@menu
* iklib chars unicode intro::   Introduction to Unicode.
* iklib chars unicode utf8::    Unicode's @utf{}-8 encoding.
* iklib chars unicode utf16::   Unicode's @utf{}-16 encoding.
* iklib chars unicode utf32::   Unicode's @utf{}-32 encoding.
* iklib chars unicode ascii::   @ascii{} encoding.
* iklib chars unicode latin1::  Latin-1 encoding.
@end menu

@c page
@node iklib chars unicode intro
@subsubsection Introduction to Unicode


The mandatory starting points to learn about Unicode are the following
@aurl{}s:

@center @url{http://www.unicode.org/faq/utf_bom.html}
@center @url{http://en.wikipedia.org/wiki/Universal_Character_Set}
@center @url{http://en.wikipedia.org/wiki/Unicode}
@center @url{http://en.wikipedia.org/wiki/Byte_order_mark}
@center @url{http://en.wikipedia.org/wiki/UTF-8}
@center @url{http://en.wikipedia.org/wiki/UTF-16}
@center @url{http://en.wikipedia.org/wiki/UTF-32}


@noindent
here we give only a brief overview of the main definitions, drawing text
from those pages.  Let's not forget the main source:

@center @url{http://www.unicode.org/}

The @dfn{Universal Character Set} (@acronym{UCS}) is a standard set of
characters upon which many character encodings are based; it contains
abstract characters, each identified by an unambiguous name and an
integer number called its @dfn{code point}.

@dfn{Unicode} is a computing industry standard for the consistent
encoding, representation and handling of text expressed in most of the
world's writing systems.

@acronym{UCS} and Unicode have an identical repertoire and numbers: the
same characters with the same numbers exist in both standards.
@acronym{UCS} is a simple character map, Unicode adds rules for
collation, normalization of forms, and the bidirectional algorithm for
scripts.

The Unicode Consortium, the non--profit organization that coordinates
Unicode's development, has the goal of eventually replacing existing
character encoding schemes with Unicode and its standard ``Unicode
Transformation Format'' alias ``@acronym{UCS} Transformation Format''
(@utf{}) schemes.

By convention a Unicode code point is referred to by writing @samp{U+}
followed by its hexadecimal number with at least @math{4} digits
(@samp{U+0044} is fine, @samp{U+12} is not).

In practice, Unicode code points are exact integers in the range
@samp{[0, #x10FFFF]}, but outside the range @samp{[#xD800, #xDFFF]}
which has special meaning in @utf{} schemes.  A code point can be stored
in @math{21} bits:

@lisp
(string-length (number->string #x10FFFF 2)) @result{} 21
@end lisp

@noindent
@rnrs{6} defines fixnums to have at least @math{24} bits, so a fixnum is
wide enough to hold a code point:

@lisp
(fixnum? #x10FFFF) @result{} #t
@end lisp

@noindent
and indeed Scheme characters are a disjoint type of value holding such
fixnums:

@lisp
(integer->char #x10FFFF) @result{} #\x10FFFF
@end lisp

@c page
@node iklib chars unicode utf8
@subsubsection Unicode's @utf{}-8 encoding


@utf{}-8 is a multioctet character encoding for Unicode which can
represent every character in the Unicode set: it can represent every
code point in the ranges @samp{[0, #xD800)} and @samp{(#xDFFF,
#x10FFFF]}.

A stream of @utf{}-8 encoded characters is meant to be stored octet by
octet in fixed order (and so without the need to specify the endianness
of words).

The encoding scheme uses sequences of 1, 2, 3 or 4 octets to encode each
code point as shown in the following table; the first octet in a
sequence has a unique bit pattern in the most significant bits and so it
allows the determination of the sequence length; every octet contains a
number of payload bits which must be concatenated (bitwise inclusive OR)
to reconstruct the integer representation of a code point:

@example
# of octets | 1st octet  | 2nd octet  | 3rd octet  | 4th octet  |
------------+------------+------------+------------+------------|
     1        #b0xxxxxxx
     2        #b110xxxxx   #b10xxxxxx
     3        #b1110xxxx   #b10xxxxxx   #b10xxxxxx
     4        #b11110xxx   #b10xxxxxx   #b10xxxxxx   #b10xxxxxx
@end example

@example
 # of octets | # of payload bits  |       hex range
-------------+--------------------+----------------------
     1                          7     [#x0000,   #x007F]
     2                 5 + 6 = 11     [#x0080,   #x07FF]
     3             4 + 6 + 6 = 16     [#x0800,   #xFFFF]
     4         3 + 6 + 6 + 6 = 21   [#x010000, #x10FFFF]
@end example

Note that octets @samp{#xFE} (@samp{#b11111110}) and @samp{#xFF}
(@samp{#b11111111}) cannot appear in a valid stream of @utf{}-8 encoded
characters.

The sequence of 3 octets is the one that could encode (but must not) the
forbidden range @samp{[#xD800, #xDFFF]} which are not Unicode code
points.  So the table of valid encoded code points is:

@example
 # of octets |  # of payload bits |    code point range
-------------+--------------------+----------------------
     1       |                  7 |   [#x0000,   #x007F]
     2       |        5 + 6 = 11  |   [#x0080,   #x07FF]
     3       |     4 + 6 + 6 = 16 |   [#x0800,   #xD7FF]
     3       |     4 + 6 + 6 = 16 |   [#xE000,   #xFFFF]
     4       | 3 + 6 + 6 + 6 = 21 | [#x010000, #x10FFFF]
@end example

The first 128 characters of the Unicode character set correspond
one--to--one with @ascii{} and are encoded using a single octet with the
same binary value as the corresponding @ascii{} character, making valid
@ascii{} text valid @utf{}-8 encoded Unicode text as well.  Such encoded
octets have the Most Significant Bit (@acronym{MSB}) set to zero.

Although the standard does not define it, many programs start a @utf{}-8
stream with a Byte Order Mark (@bom{}) composed of the 3 octets:
@samp{#xEF}, @samp{#xBB}, @samp{#xBF}.

The following syntactic bindings are exported by the library
@library{vicare unsafe unicode}.  All the macros are unsafe: no
validation on the type of the arguments is performed.  For all the
macros: the argument @var{octet} is meant to be a fixnum representing 1
octet (in the range @samp{[0, 255]}); the argument @var{code-point} is
meant to be a fixnum representing a Unicode code point (in the range
@samp{[0, #x10FFFF]}, but outside the range @samp{[#xD800, #xDFFF]}).


@deffn Syntax utf-8-invalid-octet? @var{octet}
Evaluate to @true{} if @var{octet} has a value that must never appear in
a valid @utf{}-8 stream; otherwise evaluate to @false{}.
@end deffn


@c ------------------------------------------------------------------------

@subsubheading Decoding 1-octet UTF-8 to code points


@deffn Syntax utf-8-single-octet? @var{octet}
Evaluate to @true{} if @var{octet} is valid as 1-octet @utf{}-8 encoding
of a Unicode character; otherwise evaluate to @false{}.
@end deffn


@deffn Syntax utf-8-decode-single-octet @var{octet}
Decode the code point of a Unicode character from a 1-octet @utf{}-8
encoding.
@end deffn


@deffn Syntax utf-8-valid-code-point-from-1-octet? @var{code-point}
Evaluate to true if @var{code-point} is a valid fixnum representation
for a code point decoded from a 2-octets @utf{}-8 sequence.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Decoding 2-octets @utf{}-8 to code points


@deffn Syntax utf-8-first-of-two-octets? @varo{octet}
Evaluate to @true{} if @varo{octet} is valid as first of 2-octets
@utf{}-8 encoding of a Unicode character.
@end deffn


@deffn Syntax utf-8-second-of-two-octets? @vari{octet}
Evaluate to true if @vari{octet} is valid as second of 2-octets @utf{}-8
encoding of a Unicode character.
@end deffn


@deffn Syntax utf-8-decode-two-octets @varo{octet} @vari{octet}
Decode the code point of a Unicode character from a 2-octets @utf{}-8
encoding.
@end deffn


@deffn Syntax utf-8-valid-code-point-from-2-octets? @var{code-point}
Evaluate to @true{} if @var{code-point} is a valid fixnum representation
for a code point decoded from a 2-octets @utf{}-8 sequence.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Decoding 3-octets @utf{}-8 to code points


@deffn Syntax utf-8-first-of-three-octets? @varo{octet}
Evaluate to @true{} if @varo{octet} is valid as first of 3-octets
@utf{}-8 encoding of a Unicode character; otherwise evaluate to
@false{}.
@end deffn


@deffn Syntax utf-8-second-and-third-of-three-octets? @vari{octet} @varii{octet}
Evaluate to @true{} if @vari{octet} and @varii{octet} are valid as
second and third of 3-octets @utf{}-8 encoding of a Unicode character.
@end deffn


@deffn Syntax utf-8-decode-three-octets @varo{octet} @vari{octet} @varii{octet}
Decode the code point of a Unicode character from a 3-octets @utf{}-8
encoding.
@end deffn


@deffn Syntax utf-8-valid-code-point-from-3-octets? @var{code-point}
Evaluate to @true{} if @var{code-point} is a valid integer
representation for a code point decoded from a 3-octets @utf{}-8
sequence.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Decoding 4-octets @utf{}-8 to code points


@deffn Syntax utf-8-first-of-four-octets? @varo{octet}
Evaluate to @true{} if @varo{octet} is valid as first of 4-octets
@utf{}-8 encoding of a Unicode character.
@end deffn


@deffn Syntax utf-8-second-third-and-fourth-of-four-octets? @vari{octet} @varii{octet} @variii{octet}
Evaluate to true if @vari{octet}, @varii{octet} and @variii{octet} are
valid as second, third and fourth of 4-octets @utf{}-8 encoding of a
Unicode character.
@end deffn


@deffn Syntax utf-8-decode-four-octets @varo{octet} @vari{octet} @varii{octet} @variii{octet}
Decode the code point of a Unicode character from a 4-octets UTF-8 encoding.
@end deffn


@deffn Syntax utf-8-valid-code-point-from-4-octets? @var{code-point}
Evaluate to @true{} if @var{code-point} is a valid integer
representation for a code point decoded from a 4-octets @utf{}-8
sequence.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Encoding code points to 1-octet @utf{}-8


@deffn Syntax utf-8-single-octet-code-point? @var{code-point}
Evaluate to @true{} if @var{code-point} is a Unicode code point
representable as 1-octet @utf{}-8 encoding; otherwise evaluate to
@false{}.
@end deffn


@deffn Syntax utf-8-encode-single-octet @var{code-point}
Encode the code point of a Unicode character to a 1-octet @utf{}-8
encoding.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Encoding code points to 2-octet @utf{}-8


@deffn Syntax utf-8-two-octets-code-point? @var{code-point}
Evaluate to @true{} if @var{code-point} is a Unicode code point
representable as 2-octet @utf{}-8 encoding; otherwise evaluate to
@false{}.
@end deffn


@deffn Syntax utf-8-encode-first-of-two-octets @var{code-point}
Encode the code point of a Unicode character to the first octet in a
2-octet @utf{}-8 encoding.
@end deffn


@deffn Syntax utf-8-encode-second-of-two-octets @var{code-point}
Encode the code point of a Unicode character to the second octet in a
2-octet @utf{}-8 encoding.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Encoding code points to 3-octet @utf{}-8


@deffn Syntax utf-8-three-octets-code-point? @var{code-point}
Evaluate to @true{} if @var{code-point} is a Unicode code point
representable as 3-octet @utf{}-8 encoding; otherwise evaluate to
@false{}.
@end deffn


@deffn Syntax utf-8-encode-first-of-three-octets @var{code-point}
Encode the code point of a Unicode character to the first octet in a
3-octet @utf{}-8 encoding.
@end deffn


@deffn Syntax utf-8-encode-second-of-three-octets @var{code-point}
Encode the code point of a Unicode character to the second octet in a
3-octet @utf{}-8 encoding.
@end deffn


@deffn Syntax utf-8-encode-third-of-three-octets @var{code-point}
Encode the code point of a Unicode character to the fourth octet in a
3-octet @utf{}-8 encoding.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Encoding code points to 4-octet @utf{}-8


@deffn Syntax utf-8-four-octets-code-point? @var{code-point}
Evaluate to @true{} if @var{code-point} is a Unicode code point
representable as 4-octet @utf{}-8 encoding; otherwise evaluate to
@false{}.
@end deffn


@deffn Syntax utf-8-encode-first-of-four-octets @var{code-point}
Encode the code point of a Unicode character to the first octet in a
4-octet @utf{}-8 encoding.
@end deffn


@deffn Syntax utf-8-encode-second-of-four-octets @var{code-point}
Encode the code point of a Unicode character to the second octet in a
4-octet @utf{}-8 encoding.
@end deffn


@deffn Syntax utf-8-encode-third-of-four-octets @var{code-point}
Encode the code point of a Unicode character to the third octet in a
4-octet @utf{}-8 encoding.
@end deffn


@deffn Syntax utf-8-encode-fourth-of-four-octets @var{code-point}
Encode the code point of a Unicode character to the fourth octet in a
4-octet @utf{}-8 encoding.
@end deffn

@c page
@node iklib chars unicode utf16
@subsubsection Unicode's @utf{}-16 encoding


@utf{}-16 is a multioctet character encoding for Unicode which can
represent every character in the Unicode set: it can represent every
code point in the ranges @samp{[0, #xD800)} and @samp{(#xDFFF,
#x10FFFF]}.

Code points in the range @samp{[0, #x10000)} are encoded with a single
@utf{}-16 16-bit word; code points in the range @samp{[#x10000,
#x10FFFF]} are encoded in a surrogate pair of 2 16-bit words.

Given a 16-bit word in a @utf{}-16 stream, represented in Scheme as a
fixnum in the range @samp{[#x0000, #xFFFF]}, we can classify it on the
following axis:

@example
0000        D7FF D800    DBFF DC00      DFFF E000       FFFF
 |-------------||-----------||-------------||------------|
  single word    first in     second in      single word
  character      pair         pair           character
@end example

@noindent
or the following logic:

@example
word in [#x0000, #xD7FF] => single word character
word in [#xD800, #xDBFF] => first in surrogate pair
word in [#xDC00, #xDFFF] => second in surrogate pair
word in [#xE000, #xFFFF] => single word character
@end example

A @utf{}-16 stream may start with a Byte Order Mark (@bom{}).  A
@utf{}-16 @bom{} is either:

@itemize
@item
A sequence of bytes @samp{#xFE}, @samp{#xFF} specifying ``big
endianness'' and @utf{}-16BE encoding.

@item
A sequence of bytes @samp{#xFF}, @samp{#xFE} specifying ``little
endianness'' and @utf{}-16LE encoding.
@end itemize


The following syntactic bindings are exported by the library
@library{vicare unsafe unicode}.  The following macros assume the
@var{word} arguments are fixnums representing 16-bit words: they must be
in the range @samp{[0, #xFFFF]}; while the @var{code-point} arguments
are fixnums representing Unicode code points (they are in the range
@samp{[0, #x10FFFF]}, but outside the range @samp{[#xD800, #xDFFF]}).

@c ------------------------------------------------------------------------

@subsubheading 1-word decoding


@deffn Syntax utf-16-single-word? @varo{word}
Evaluate to @true{} if @varo{word} is valid as single 16-bit word
@utf{}-16 encoding of a Unicode character; otherwise evaluate to
@false{}.
@end deffn


@deffn Syntax utf-16-decode-single-word @varo{word}
Decode the integer representation of a Unicode character from a 16-bit
single word @utf{}-16 encoding.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading 2-words decoding


@deffn Syntax utf-16-first-of-two-words? @varo{word}
Evaluate to @true{} if @varo{word} is valid as first 16-bit word in a
surrogate pair @utf{}-16 encoding of a Unicode character; otherwise
evaluate to @false{}.
@end deffn


@deffn Syntax utf-16-second-of-two-words? @vari{word}
Evaluate to @true{} if @vari{word} is valid as second 16-bit word in a
surrogate pair @utf{}-16 encoding of a Unicode character; otherwise
evaluate to @false{}.
@end deffn


@deffn Syntax utf-16-decode-surrogate-pair @varo{word} @varii{word}
Decode the integer representation of a Unicode character from a
surrogate pair @utf{}-16 encoding.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading 1-word encoding


@deffn Syntax utf-16-single-word-code-point? @var{code-point}
Evaluate to @true{} if @var{code-point} is the fixnum representation of
a Unicode code point representable as single 16-bit word @utf{}-16
encoding; otherwise evaluate to @false{}.
@end deffn


@deffn Syntax utf-16-encode-single-word @var{code-point}
Encode @var{code-point} as single 16-bit word @utf{}-16 encoding.
@end deffn


@c ------------------------------------------------------------------------

@subsubheading 2-word encoding

@deffn Syntax utf-16-two-words-code-point? @var{code-point}
Evaluate to @true{} if @var{code-point} is the fixnum representation of
a Unicode code point representable as surrogate pair of two 16-bit words
@utf{}-16 encoding; otherwise evaluate to @false{}.
@end deffn


@deffn Syntax utf-16-encode-first-of-two-words @var{code-point}
Encode @var{code-point} as first 16-bit word in a surrogate pair
@utf{}-16 encoding.
@end deffn


@deffn Syntax utf-16-encode-second-of-two-words @var{code-point}
Encode @var{code-point} as second 16-bit word in a surrogate pair
@utf{}-16 encoding.
@end deffn

@c page
@node iklib chars unicode utf32
@subsubsection Unicode's @utf{}-32 encoding


@utf{}-32, also called @acronym{UCS} 4, is a multioctet character
encoding for Unicode which can represent every character in the Unicode
set: it can represent every code point in the ranges @samp{[0, #xD800)}
and @samp{(#xDFFF, #x10FFFF]}.  It uses exactly 32 bits per Unicode code
point.

This makes @utf{}-32 a fixed-length encoding, in contrast to all other
Unicode Transformation Formats which are variable--length encodings.
The @utf{}-32 form of a character is a direct representation of its code
point.

The following syntactic bindings are exported by the library
@library{vicare unsafe unicode}.  The following macros assume the
@var{word} arguments are fixnums representing 32-bit words: they must be
in the range @samp{[0, #xFFFFFFFF]}; while the @var{code-point}
arguments are fixnums representing Unicode code points (they are in the
range @samp{[0, #x10FFFF]}, but outside the range @samp{[#xD800,
#xDFFF]}).

@c ------------------------------------------------------------------------

@subsubheading Encoding


@deffn Syntax utf-32-code-point? @var{code-point}
Evaluate to @true{} if @var{code-point} is a Unicode code point
representable in @utf{}-32 encoding.
@end deffn


@deffn Syntax utf-32-encode @var{code-point}
Encode a Unicode code point as @utf{}-32 encoding.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Decoding


@deffn Syntax utf-32-word? @var{word}
Evaluate to @true{} if @var{word} is valid as 32-bit word @utf{}-32
encoding of a Unicode character; otherwise evaluate to @false{}.
@end deffn


@deffn Syntax utf-32-decode @var{word}
Encode a valid @utf{}-32 encoding word into the corresponding Unicode
code point.
@end deffn

@c page
@node iklib chars unicode ascii
@subsubsection @ascii{} encoding


The following syntactic bindings are exported by the library
@library{vicare unsafe unicode}.  In the following macros the argument
@var{octet} is meant to be a fixnum representing an @ascii{} code point;
while the argument @var{code-point} is meant to be a fixnum representing
a Unicode code point.

@c ------------------------------------------------------------------------

@subsubheading Encoding


@deffn Syntax ascii-code-point? @var{code-point}
Assume @var{code-point} is a fixnum representation of a Unicode code
point.  Return @true{} if @var{code-point} is in the range accepted by
the @ascii{} encoding.
@end deffn


@deffn Syntax ascii-encode @var{code-point}
Assume @var{code-point} is a fixnum representation of a Unicode code
point in the range representable with @ascii{} encoding.  Return its
encoding in @ascii{} format.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Decoding


@deffn Syntax ascii-octet? @var{octet}
Assume @var{octet} is a fixnum representing an octet.  Return @true{} if
@var{octet} is in the range accepted by the @ascii{} encoding; otherwise
return @false{}.
@end deffn


@deffn Syntax ascii-decode @var{octet}
Assume @var{octet} is the fixnum representation of an @ascii{} encoded
character.  Return its associated Unicode code point.
@end deffn

@c page
@node iklib chars unicode latin1
@subsubsection @acronym{ISO}/@acronym{IEC} 8859-1 also known as Latin-1 encoding


Latin-1 encoding uses 1 octet per character.  For an itroduction to
Latin-1 see:

@center @url{http://en.wikipedia.org/wiki/ISO/IEC_8859-1}

@noindent
and for Unicode's ``C1 Controls and Latin-1 Supplement'' see:

@center @url{https://en.wikipedia.org/wiki/Latin-1_Supplement_%28Unicode_block%29}
@center @url{http://www.unicode.org/charts/PDF/U0080.pdf}

Strictly speaking, the Latin-1 encoding only defines code points in the
ranges @samp{[#x20, #x7E]} and @samp{[#xA0, #xFF]}; notice that the
control characters are excluded.

In the range @samp{[#x20, #x7E]} the Latin-1 code points are equal to
the corresponding @ascii{} code points.

In both the ranges @samp{[#x20, #x7E]} and @samp{[#xA0, #xFF]}:
Latin-1's code points are equal to Unicode's code points, when we take
into account Unicode's ``C1 Controls and Latin-1 Supplement''.

Notice that:

@itemize
@item
Unicode's ``C0 Controls and Basic Latin'' specifies the code points in
the range @samp{[#x00, #x7F]} so that they are equal to @ascii{}'s
control characters in the same range.  This Unicode block includes the
range of control characters @samp{[#x00, #x1F]} which is left undefined
by Latin-1.

@item
Unicode's ``C1 Controls and Latin-1 Supplement'' specifies code points
in the range @samp{[#x80, #x9F]}.  This range is left undefined by
Latin-1.
@end itemize

This library defines an @strong{extended} Latin-1 encoding spanning the
whole @samp{[#x00, #xFF]} range with the following blocks:

@example
[#x00, #x1F]    C0 Controls
[#x20, #x7E]    Latin-1 code points
#x7F            C0 Controls
[#x80, #x9F]    C1 Controls
[#xA0, #xFF]    Latin-1 code points
@end example

The following syntactic bindings are exported by the library
@library{vicare unsafe unicode}.  In the following macros the argument
@var{latin-1-code-point} is meant to be a fixnum representing a Latin-1
code point; while the argument @var{unicode-code-point} is meant to be a
fixnum representing a Unicode code point.

@c ------------------------------------------------------------------------

@subsubheading Encoding Unicode code points as Latin-1 code points

@deffn Syntax unicode-code-point-representable-as-latin-1-code-point? @var{unicode-code-point}
Evaluate to @true{} if @var{unicode-code-point} is a Unicode code point
in a range that can be encoded in Latin-1; otherwise evaluate to
@false{}.
@end deffn


@deffn Syntax latin-1-encode @var{unicode-code-point}
Encode a Unicode code point into a Latin-1 code point.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Decoding Unicode code points from Latin-1 code points


@deffn Syntax latin-1-code-point? @var{octet}
Assum @var{octet} is the fixnum representation of an octet.  Evaluate to
@true{} if @var{octet} a valid Latin-1 code point; otherwise evaluate to
@false{}.
@end deffn


@deffn Syntax latin-1-decode @var{latin-1-code-point}
Decode a Latin-1 code point to a Unicode code point.
@end deffn

@c ------------------------------------------------------------------------

@subsubheading Classification


@deffn Syntax latin-1-C0-control? @var{latin-1-code-point}
Evaluate to @true{} if the argument is a Latin-1 code point in the range
of C0 Control characters.
@end deffn


@deffn Syntax latin-1-C1-control? @var{latin-1-code-point}
Evaluate to @true{} if the argument is a Latin-1 code point in the range
of C1 Control characters.
@end deffn


@deffn Syntax latin-1-control? @var{latin-1-code-point}
Evaluate to @true{} if the argument is a Latin-1 code point in the range
of C0 Control or C1 Control characters.
@end deffn


@deffn Syntax latin-1-graphic? @var{latin-1-code-point}
Evaluate to @true{} if the argument is a Latin-1 code point in the range
of graphics (non--control) characters.
@end deffn

@c page
@node iklib keywords
@section Keyword objects


Keyword objects are struct instances embedding a Scheme symbol; keyword
objects are a disjoint type; keyword objects are @strong{not} interned.

Keyword objects can be compared with @func{eq?}, @func{eqv?} and
@func{equal?}; a keyword object is @func{eq?} only to itself.  Keyword
objects can also be compared with the @func{keyword=?} predicate which
is faster than @func{eqv?} and @func{equal?} and slower than @func{eq?}
for symbols.

The reader supports a special syntax to read keyword objects, @ref{iklib
reader stx, Miscellaneous additional syntaxes}.

The following bindings are exported by the library @library{vicare}.


@defun symbol->keyword @var{symbol}
@defunx keyword->symbol @var{keyword}
Convert between a symbol and a keyword.
@end defun


@defun keyword->string @var{keyword}
Return the string representation of a keyword.
@end defun


@defun keyword? @var{obj}
Return @true{} if @var{obj} is a keyword object, else return @false{}.
@end defun


@defun keyword=? @vari{keyword} @varii{keyword}
The arguments @vari{keyword} and @varii{keyword} must be keyword
objects, otherwise an exception is raised.  Return @true{} if the
arguments are equal.  A keyword object is equal to itself; two distinct
keyword objects are equal if they have the same symbol.
@end defun


@defun keyword-hash @var{keyword}
Return an exact integer suitable to be used as hash value for
@var{keyword} used as key for hash tables.
@end defun

@c page
@node iklib ipairs
@section Immutable pairs


@value{PRJNAME} defines immutable pairs as a built--in disjoint type;
only basic functions are implemented by @library{vicare}, the bulk of
the utilities is implemented by @ansrfi{116}, in the library
@library{srfi :116}, @libsref{srfi ilists, @ansrfi{116} immutable
lists}.

Notice that @syntax{syntax-rules} and @syntax{syntax-case} patterns do
@strong{not} recognise immutable pairs.


@defun ipair @vari{obj} @varii{obj}
Build and return a new immutable pair object, using @vari{obj} as car
and @varii{obj} as cdr.
@end defun


@defun ikpair? @var{obj}
Return @true{} if @var{obj} is an immutable pair; otherwise return
@false{}.
@end defun


@defun icar @var{ipair}
@defunx icdr @var{ipair}
Return the car and cdr of the immutable pair @var{ipair}.  It is an
error if @var{ipair} is not an immutable pair.
@end defun

@c page
@node iklib lists
@section Additional list functions


@menu
* iklib lists weak::            Weak pairs.
* iklib lists queue::           Queues of items.
* iklib lists misc::            Miscellaneous functions.
@end menu

@c page
@node iklib lists weak
@subsection Weak pairs


Weak references do not cause the referenced value to be considered used
by the garbage collector.  The following bindings are exported by the
library @library{vicare}.


@defun weak-cons @var{A} @var{D}
Like @func{cons} build and return a new pair, but holding weak
references to @var{A}; notice that the reference to @var{D} is not weak.
This function allows to build a non--weak list spine holding weak
references to values.
@end defun


@defun weak-pair? @var{obj}
Return true if @var{obj} is a weak pair.
@end defun


@defun bwp-object
Return the @acronym{BWP} object.  @acronym{BWP} stands for ``broken weak
pointer''.
@end defun


@defun bwp-object? @var{obj}
Return true if @var{obj} is a weak reference to a value which has been
already garbage collected.  Example:

@example
vicare> (define x (weak-cons (cons 1 2) #f))
vicare> x
((1 . 2) . #f)
vicare> (bwp-object? (car x))
#f
vicare> (collect)
vicare> x
 (#!bwp . #f)
vicare> (bwp-object? (car x))
#t
@end example
@end defun

@c page
@node iklib lists queue
@subsection Queues of items


Queues are object containers that allow constructing a first-in
first-out sequence.  The following bindings are exported by the library
@library{vicare}.


@defun make-queue-procs
@defunx make-queue-procs @var{init-values}
Build a queue of items and return @math{3} values:

@enumerate
@item
A predicate thunk returning @true{} if the queue is empty.

@item
A function which, applied to a single argument, enqueues it as last
item.

@item
A thunk extracting and returning the first item from the queue.  If the
queue is empty an error is raised.
@end enumerate

The optional @var{init-values} must be null or the list of initial
values.

Usage examples:

@example
#!r6rs
(import (vicare))

(let-values (((empty? enqueue! dequeue!)
              (make-queue-procs)))
  (empty?))
@result{} #t

(let-values (((empty? enqueue! dequeue!)
              (make-queue-procs)))
  (enqueue! 1)
  (empty?))
@result{} #f

(let-values (((empty? enqueue! dequeue!)
              (make-queue-procs)))
  (enqueue! 1)
  (empty?)      @result{} #f
  (dequeue!)    @result{} 1
  (empty?))
@result{} #t

(let-values (((empty? enqueue! dequeue!)
              (make-queue-procs)))
  (enqueue! 1)
  (enqueue! 2)
  (enqueue! 3)
  (dequeue!)    @result{} 1
  (dequeue!)    @result{} 2
  (dequeue!)    @result{} 3
  (empty?))
@result{} #t
@end example
@end defun

@c page
@node iklib lists misc
@subsection Miscellaneous functions


The following bindings are exported by the library @library{vicare}.


@defun nlist? @var{obj}
Return @true{} if @var{obj} is a non-empty proper list; otherwise return
@false{}.
@end defun


@defun make-list @var{len}
@defunx make-list @var{len} @var{fill}
Build and return a new list of @var{len} elements.  @var{fill} is used
to initialise the the list pairs; when not given: it defaults to the
return value of @code{(void)}.
@end defun


@defun last-pair @var{pair}
Return the last pair in the non--empty, finite list @var{pair}.

@example
(last-pair '(a b c))    @result{} (c)
@end example
@end defun


@defun for-each-in-order @var{proc} @varo{list} @var{list} ...
Like @func{for-each} from @rsixlibrary{base} but guarantees that
@var{proc} is applied starting from the head of the lists.
@end defun


@defun map1 @var{proc} @var{ell}
Like @func{map} from @rsixlibrary{lists} for a single list argument, but
it is meant to be faster.  It does not check for circular list; it
processes the input list from head to tail (in order).
@end defun


@defun for-each1 @var{proc} @var{ell}
Like @func{for-each} from @rsixlibrary{lists} for a single list
argument, but it is meant to be faster.  It does not check for circular
list; it processes the input list from head to tail (in order).
@end defun


@defun for-all1 @var{proc} @var{ell}
Like @func{for-all} from @rsixlibrary{lists} for a single list argument,
but it is meant to be faster.  It does not check for circular list; it
processes the input list from head to tail (in order).
@end defun


@defun exists1 @var{proc} @var{ell}
Like @func{exists} from @rsixlibrary{lists} for a single list argument,
but it is meant to be faster.  It does not check for circular list; it
processes the input list from head to tail (in order).
@end defun


@defun andmap @var{proc} @var{ell}
@defunx andmap @var{proc} @vari{ell} @varii{ell}
Iterate in order the list arguments, applying @var{proc} to the items in
the lists, left to right.  If @var{proc} returns @false{}: @func{andmap}
stops the iteration and returns false.  If @var{proc} returns a
non--false value for all the items from the list arguments:
@func{andmap} returns the result of the last @var{proc} application.  If
all the list arguments are null: the return value is @true{}.

When applied to two arguments: @var{proc} must be a function accepting a
single argument and returning a single value; @var{ell} must be proper
list (possibly empty).

When applied to three arguments: @var{proc} must be a function accepting
a two arguments and returning a single value; @vari{ell} and @varii{ell}
must be proper lists of equal length (possibly empty).

@example
(andmap (lambda (x) x) '())
@result{} #t

(andmap (lambda (x) x) '(1 2 3))
@result{} 3

(andmap (lambda (x) x) '(1 #f 3))
@result{} #f

(andmap (lambda (x y) (and x y))
        '() '())
@result{} #t

(andmap (lambda (x y) (and x y))
        '(1 2) '(3 4))
@result{} 4

(andmap (lambda (x y) (and x y))
        '(1 2) '(3 #f))
@result{} #f
@end example
@end defun


@defun ormap @var{proc} @var{ell}
Iterate in order the list arguments, applying @var{proc} to the items in
the list argument @var{ell}.  If @var{proc} returns non--false:
@func{ormap} stops the iteration and returns the non--false value.  If
@var{proc} returns @false{} for all the items in @var{ell}: @func{ormap}
returns @false{}.  If @var{ell} is null: the return value is @false{}.

@var{proc} must be a function accepting a single argument and returning
a single value; @var{ell} must be proper list (possibly empty).

@example
(ormap (lambda (x) x) '())
@result{} #f

(ormap (lambda (x) x) '(#f #f #f))
@result{} #f

(ormap (lambda (x) x) '(#f 123 #f))
@result{} 123

(ormap (lambda (x) (or x 123)) '())
@result{} #f

(ormap (lambda (x) (or x 123)) '(1 2 3))
@result{} 1

(ormap (lambda (x) (or x 123)) '(#f #f 1))
@result{} 123
@end example
@end defun

@c page
@node iklib bytevectors
@section Additional bytevector functions


The description of bytevectors uses the term @emph{byte} for an exact
integer object in the inclusive interval @math{(-128, @dots{}, 127)} and
the term @emph{octet} for an exact integer object in the inclusive
interval @math{(0, @dots{}, 255)}.  A byte corresponds to its two's
complement representation as an octet.

@menu
* iklib bytevectors predicates::  Predicate functions.
* iklib bytevectors comparison::  Comparing bytevectors.
* iklib bytevectors conversion::  Converting bytevectors.
* iklib bytevectors valpred::     Validation predicates for bytevector.
* iklib bytevectors sub::         Building subbytevectors.
* iklib bytevectors generic::     Generic bytevector operations.
@end menu

@c page
@node iklib bytevectors predicates
@subsection Predicate functions


@defun list-of-bytevectors? @var{obj}
Return @true{} if OBJ is null or a proper list of bytevectors; otherwise
return @false{}.
@end defun

@c page
@node iklib bytevectors comparison
@subsection Comparing bytevectors


@defun bytevector!=? @varo{bv} @var{bv} @dots{}
Return @true{} if all the bytevector arguments are different; otherwise
return @false{}.
@end defun


@deffn Procedure {bytevector-u8<?} @varo{bv} @dots{}
@deffnx Procedure {bytevector-u8>?} @varo{bv} @dots{}
@deffnx Procedure {bytevector-u8<=?} @varo{bv} @dots{}
@deffnx Procedure {bytevector-u8>=?} @varo{bv} @dots{}
These procedures are the extensions to bytevectors of the corresponding
orderings on unsigned fixnums; the bytevectors are compared octet by
octet.
@end deffn


@deffn Procedure {bytevector-s8<?} @varo{bv} @dots{}
@deffnx Procedure {bytevector-s8>?} @varo{bv} @dots{}
@deffnx Procedure {bytevector-s8<=?} @varo{bv} @dots{}
@deffnx Procedure {bytevector-s8>=?} @varo{bv} @dots{}
These procedures are the extensions to bytevectors of the corresponding
orderings on signed fixnums; the bytevectors are compared byte by byte.
@end deffn


@defun bytevector-u8-max @varo{bv} @var{bv} @dots{}
@defunx bytevector-u8-min @varo{bv} @var{bv} @dots{}
Return the maximal or minimal bytevector argument according to
@func{bytevector-u8<?}.
@end defun


@defun bytevector-s8-max @varo{bv} @var{bv} @dots{}
@defunx bytevector-s8-min @varo{bv} @var{bv} @dots{}
Return the maximal or minimal bytevector argument according to
@func{bytevector-s8<?}.
@end defun

@c page
@node iklib bytevectors conversion
@subsection Converting bytevectors


These conversion functions work like @func{bytevector->u8-list} and
@func{u8-list->bytevector}.  The following bindings are exported by the
library @library{vicare}.


@defun utf8->string-length @var{bv}
@defunx utf8->string-length @var{bv} @var{handling-mode}
Given a bytevector representing a string in @utf{}-8 encoding: compute
and return the length of the Scheme string required to hold the
characters.

The optional @var{handling-mode} must be an error handling mode as
validated by the standard syntax @syntax{error-handling-mode}; when not
given: it defaults to @samp{raise}.  This argument has the same meaning
it has for @func{utf8->string} (@pxref{stdlib bytevector strings,
utf8->string}).
@end defun


@defun utf16->string-length @var{bytevector} @var{endianness}
@defunx utf16->string-length @var{bytevector} @var{endianness} @var{endianness-mandatory}
@defunx utf16->string-length @var{bytevector} @var{endianness} @var{endianness-mandatory} @var{handling-mode}
Given a bytevector representing a string in @utf{}-16 encoding: compute
the length of the Scheme string required to hold the characters and
return it as non--negative fixnum.

All the arguments have the same meaning they have for
@func{utf16->string} (@pxref{stdlib bytevector strings, utf16->string}).
@end defun


@defun utf32->string-length @var{bytevector} @var{endianness}
@defunx utf32->string-length @var{bytevector} @var{endianness} @var{endianness-mandatory}
@defunx utf32->string-length @var{bytevector} @var{endianness} @var{endianness-mandatory} @var{handling-mode}
Given a bytevector representing a string in @utf{}-32 encoding: compute
the length of the Scheme string required to hold the characters and
return it as non--negative fixnum.

All the arguments have the same meaning they have for
@func{utf32->string} (@pxref{stdlib bytevector strings, utf32->string}).
@end defun


@defun {bytevector->s8-list} @var{bytevector}
@defunx {s8-list->bytevector} @var{list}
Convert between a list of signed bytes and a bytevector.
@end defun


@defun s16l-list->bytevector @var{list}
@defunx s16b-list->bytevector @var{list}
@defunx s16n-list->bytevector @var{list}
@defunx u16l-list->bytevector @var{list}
@defunx u16b-list->bytevector @var{list}
@defunx u16n-list->bytevector @var{list}
@defunx bytevector->s16l-list @var{bytevector}
@defunx bytevector->s16b-list @var{bytevector}
@defunx bytevector->s16n-list @var{bytevector}
@defunx bytevector->u16l-list @var{bytevector}
@defunx bytevector->u16b-list @var{bytevector}
@defunx bytevector->u16n-list @var{bytevector}
Convert between a list of signed or unsigned 16-bit words and a
bytevector in which the words are stored in little, big or native
endianness.
@end defun


@defun s32l-list->bytevector @var{list}
@defunx s32b-list->bytevector @var{list}
@defunx s32n-list->bytevector @var{list}
@defunx u32l-list->bytevector @var{list}
@defunx u32b-list->bytevector @var{list}
@defunx u32n-list->bytevector @var{list}
@defunx bytevector->s32l-list @var{bytevector}
@defunx bytevector->s32b-list @var{bytevector}
@defunx bytevector->s32n-list @var{bytevector}
@defunx bytevector->u32l-list @var{bytevector}
@defunx bytevector->u32b-list @var{bytevector}
@defunx bytevector->u32n-list @var{bytevector}
Convert between a list of signed or unsigned 32-bit words and a
bytevector in which the words are stored in little, big or native
endianness.
@end defun


@defun s64l-list->bytevector @var{list}
@defunx s64b-list->bytevector @var{list}
@defunx s64n-list->bytevector @var{list}
@defunx u64l-list->bytevector @var{list}
@defunx u64b-list->bytevector @var{list}
@defunx u64n-list->bytevector @var{list}
@defunx bytevector->s64l-list @var{bytevector}
@defunx bytevector->s64b-list @var{bytevector}
@defunx bytevector->s64n-list @var{bytevector}
@defunx bytevector->u64l-list @var{bytevector}
@defunx bytevector->u64b-list @var{bytevector}
@defunx bytevector->u64n-list @var{bytevector}
Convert between a list of signed or unsigned 64-bit words and a
bytevector in which the words are stored in little, big or native
endianness.
@end defun


@defun f4l-list->bytevector @var{list}
@defunx f4b-list->bytevector @var{list}
@defunx f4n-list->bytevector @var{list}
@defunx bytevector->f4l-list @var{bytevector}
@defunx bytevector->f4b-list @var{bytevector}
@defunx bytevector->f4n-list @var{bytevector}
Convert between a list of single--precision flonums and a bytevector in
which the flonums are stored in little, big or native endianness.
@end defun


@defun f8l-list->bytevector @var{list}
@defunx f8b-list->bytevector @var{list}
@defunx f8n-list->bytevector @var{list}
@defunx bytevector->f8l-list @var{bytevector}
@defunx bytevector->f8b-list @var{bytevector}
@defunx bytevector->f8n-list @var{bytevector}
Convert between a list of double--precision flonums and a bytevector in
which the flonums are stored in little, big or native endianness.
@end defun


@defun c4l-list->bytevector @var{list}
@defunx c4b-list->bytevector @var{list}
@defunx c4n-list->bytevector @var{list}
@defunx bytevector->c4l-list @var{bytevector}
@defunx bytevector->c4b-list @var{bytevector}
@defunx bytevector->c4n-list @var{bytevector}
Convert between a list of single--precision cflonums and a bytevector in
which the cflonums are stored in little, big or native endianness, real
part first.
@end defun


@defun c8l-list->bytevector @var{list}
@defunx c8b-list->bytevector @var{list}
@defunx c8n-list->bytevector @var{list}
@defunx bytevector->c8l-list @var{bytevector}
@defunx bytevector->c8b-list @var{bytevector}
@defunx bytevector->c8n-list @var{bytevector}
Convert between a list of double--precision cflonums and a bytevector in
which the flonums are stored in little, big or native endianness, real
part first.
@end defun


@defun octets-encoded-bytevector? @var{bytevector}
Return @true{} if @var{bytevector} is a bytevector object.
@end defun


@defun ascii-encoded-bytevector? @var{bytevector}
Return @true{} if @var{bytevector} can be interpreted as an @ascii{}
encoded string, otherwise return @false{}.  An octet @var{chi} is
considered an @ascii{} code point if:

@example
(<= #x00 chi #x7F)      @result{} #t
@end example
@end defun


@defun latin1-encoded-bytevector? @var{bytevector}
Return @true{} if @var{bytevector} can be interpreted as a Latin1
encoded string, otherwise return @false{}.  @ref{iklib chars unicode
latin1} for the definition of Latin-1 encoding used by @value{PRJNAME}.
@end defun


@defun hex->bytevector @var{bytevector}
@defunx bytevector->hex @var{bytevector}
Convert to and from a Scheme bytevector containing octets and a Scheme
bytevector containing the @ascii{} hexadecimal representation of the
octets.

The input hex bytevector contains the uppercase or lowercase hexadecimal
representation of the octets.  The output hex bytevector contains the
uppercase hexadecimal representation of octets.

If an error occurs in the conversion: the return value is @false{}.
@end defun


@defun base64->bytevector @var{bytevector}
@defunx bytevector->base64 @var{bytevector}
Convert to and from a Scheme bytevector containing octets and a Scheme
bytevector containing the @ascii{} Base64 representation of the octets.

If an error occurs in the conversion: the return value is @false{}.
@end defun


@defun uri-encode @var{bytevector}
@defunx uri-decode @var{bytevector}
@defunx percent-encode @var{bytevector}
@defunx percent-decode @var{bytevector}
Encode or decode a bytevector according to @rfc{} 3986 @acronym{URI}
percent encoding; return a bytevector.  All the octets are encoded
except the ones having the following @ascii{} representation:

@example
ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789
-._~
@end example
@end defun


@defun normalise-uri-encoding @var{bytevector}
@defunx normalise-percent-encoding @var{bytevector}
Given a bytevector encoded according to to @rfc{} 3986 @acronym{URI}
percent encoding: return an encoded and normalised bytevector, octets
that are encoded but should not are decoded.
@end defun


@defun uri-encoded-bytevector? @var{bv}
@defunx percent-encoded-bytevector? @var{bv}
Return @true{} if the argument is a correctly percent--encoded
bytevector according to @rfc{} 3986.  This means every octet represents
either one of the following characters in @ascii{} encoding:

@example
ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789
-._~
@end example

@noindent
or it is part of a percent--encoded sequence defined by the following
grammar:

@example
pct-encoded   = "%" HEXDIG HEXDIG
HEXDIG        = [0-9a-fA-F]
@end example
@end defun

@c page
@node iklib bytevectors valpred
@subsection Validation predicates for bytevector


@defun bytevector-length? @var{obj}
Return @true{} if @var{obj} is valid as bytevector length: it is a
non--negative fixnum; otherwise return @false{}.
@end defun


@defun bytevector-index? @var{obj}
Return @true{} if @var{obj} is a Scheme object valid as bytevector
index: it is a non--negative fixnum; otherwise return @false{}.  Before
being used, @var{obj} needs further validation against a specific
bytevector and word size.
@end defun


@defun bytevector-word-size? @var{obj}
Return @true{} if @var{obj} is valid as word size to be accessed in a
bytevector; otherwise return @false{}.  @var{obj} must be further
validated for a specific bytevector word start offset.
@end defun


@defun bytevector-word-count? @var{obj}
Return @true{} if @var{obj} is valid as word count for bytevector items,
either a byte count, 16-bit words count, 32-bit words count, @dots{};
otherwise return @false{}.  @var{obj} must be further validated for the
specific bytevector and word size with which it is to be used.
@end defun


@defun bytevector-index-for-word? @var{bv} @var{idx} @var{word-size-in-bytes}
Return @true{} if: @var{bv} is a bytevector, @var{idx} is a
non--negative fixnum, @var{word-size-in-bytes} is a non--negative
fixnum, @var{idx} is a valid index in @var{bv} to reference a word whose
size is @var{word-size-in-bytes}; otherwise return @false{}.  This
validation is for getter and setter indexes.
@end defun


@defun bytevector-index-for-word8? @var{bv} @var{idx}
@defunx bytevector-index-for-word16? @var{bv} @var{idx}
@defunx bytevector-index-for-word32? @var{bv} @var{idx}
@defunx bytevector-index-for-word64? @var{bv} @var{idx}
@defunx bytevector-index-for-single-flonum? @var{bv} @var{idx}
@defunx bytevector-index-for-double-flonum? @var{bv} @var{idx}
Specialised variants of @func{bytevector-index-for-word?} for a specific
word size in bits.
@end defun


@defun bytevector-start-index-and-count-for-word? @var{bv} @var{idx} @var{word-size-in-bytes} @var{count}
Return @true{} if: @var{bv} is a bytevector, @var{idx} is a
non--negative fixnum, @var{count} is a non--negative fixnum,
@var{word-size-in-bytes} is a non--negative fixnum, @var{idx} is a valid
index in @var{bv} to reference @var{count} words whose size is
@var{word-size-in-bytes}; otherwise return @false{}.  Notice that if
@var{count} is zero: it is fine for @var{idx} to be equal to the length
of @var{bv}.  This validation is for getter and setter indexes.
@end defun


@defun bytevector-start-index-and-count-for-word8? @var{bv} @var{idx}
@defunx bytevector-start-index-and-count-for-word16? @var{bv} @var{idx}
@defunx bytevector-start-index-and-count-for-word32? @var{bv} @var{idx}
@defunx bytevector-start-index-and-count-for-word64? @var{bv} @var{idx}
Specialised variants of
@func{bytevector-start-index-and-count-for-word?} for a specific word
size in bits.
@end defun

@c page
@node iklib bytevectors sub
@subsection Building subbytevectors


The following bindings are exported by the library @library{vicare}.


@defun subbytevector-u8 @var{bv} @var{start}
@defunx subbytevector-u8 @var{bv} @var{start} @var{end}
Build and return a new bytevector holding the bytes in @var{bv} from
index @var{start} (inclusive) to index @var{end} (exclusive).  The start
and end indexes must be such that:

@example
0 <= @var{start} <= @var{end} <= (bytevector-length @var{bv})
@end example
@end defun


@defun subbytevector-u8/count @var{bv} @var{start} @var{count}
Build and return a new bytevector holding @var{count} bytes in @var{bv}
from index @var{start} (inclusive).  The start index and the byte count
must be such that:

@example
0 <= @var{start} <= @var{start} + @var{count} <= (bytevector-length @var{bv})
@end example
@end defun


@defun subbytevector-s8 @var{bv} @var{start}
@defunx subbytevector-s8 @var{bv} @var{start} @var{end}
Build and return a new bytevector holding the bytes in @var{bv} from
index @var{start} (inclusive) to index @var{end} (exclusive).  The start
and end indexes must be such that:

@example
0 <= @var{start} <= @var{end} <= (bytevector-length @var{bv})
@end example
@end defun


@defun subbytevector-s8/count @var{bv} @var{start} @var{count}
Build and return a new bytevector holding @var{count} bytes in @var{bv}
from index @var{start} (inclusive).  The start index and the byte count
must be such that:

@example
0 <= @var{start} <= @var{start} + @var{count} <= (bytevector-length @var{bv})
@end example
@end defun

@c page
@node iklib bytevectors generic
@subsection Generic bytevector operations


The following bindings are exported by the library @library{vicare}.


@defun bytevector-empty? @var{bytevector}
Return @true{} if the bytevector @var{bytevector} has zero length,
otherwise return @false{}.
@end defun


@defun bytevector-append @var{bytevector} ...
Concatenate the bytevector arguments and return the result.  If no
arguments are given: return the empty bytevector.
@end defun


@defun bytevector-concatenate @var{bvs}
Concatenate the list of bytevectors @var{bvs} and return the resulting
bytevector.  It is an error if the sum of the bytevector lengths is not
in the range of the maximum bytevector length.
@end defun


@defun bytevector-reverse-and-concatenate @var{bvs}
Reverse the list of bytevectors @var{bvs}, concatenate them and return
the resulting bytevector.  It is an error if the sum of the bytevector
lengths is not in the range of the maximum bytevector length.
@end defun

@c page
@node iklib strings
@section Additional string functions


@menu
* iklib strings predicates::    Predicates about strings.
* iklib strings constructors::  Constructing new strings.
* iklib strings comparison::    Comparison functions.
* iklib strings conversion::    Converting between strings and
                                other objects.
* iklib strings misc::          Miscellaneous string operations.
@end menu

@c page
@node iklib strings predicates
@subsection Predicates about strings


@defun list-of-strings? @var{obj}
Return @true{} if @var{obj} is null or a proper list of strings;
otherwise return @false{}.
@end defun


@defun string-empty? @var{str}
Return @true{} if the string @var{str} is empty, otherwise return
@false{}.
@end defun

@c page
@node iklib strings constructors
@subsection Constructing new strings


@defun string-copy! @var{src.str} @var{src.start} @var{dst.str} @var{dst.start} @var{count}
Copy @var{count} characters from @var{src.str} starting at
@var{src.start} (inclusive) to @var{dst.str} starting at
@var{dst.start}.  Return unspecified values.
@end defun


@defun string-concatenate @var{strs}
Concatenate the list of strings @var{strs} and return the resulting
string.  It is an error if the sum of the string lengths is not in the
range of the maximum string length.
@end defun


@defun string-reverse-and-concatenate @var{strs}
Reverse the list of strings @var{strs}, concatenate them and return the
resulting string.  It is an error if the sum of the string lengths is
not in the range of the maximum string length.
@end defun

@c page
@node iklib strings comparison
@subsection Comparison functions


@defun string!=? @varo{str} @var{str} @dots{}
Return @true{} if all the string arguments are different; otherwise
return @false{}.
@end defun


@defun string-max @varo{str} @var{str} @dots{}
@defunx string-min @varo{str} @var{str} @dots{}
Return the maximal or minimal string argument according to
@func{string<?}.
@end defun

@c page
@node iklib strings conversion
@subsection Converting between strings and other objects


@defun string->utf8-length @var{str}
Given a string compute and return the length of the bytevector that
would contain its @utf{}-8 representation.  If the bytevector length
would exceed the maximum length of a bytevector: return @false{}.
@end defun


@defun string->utf16-length @var{str}
Given a string compute and return the length of the bytevector that
would contain its @utf{}-16 representation.  If the bytevector length
would exceed the maximum length of a bytevector: return @false{}.
@end defun


@defun string->utf32-length @var{str}
Given a string compute and return the length of the bytevector that
would contain its @utf{}-32 representation.  If the bytevector length
would exceed the maximum length of a bytevector: return @false{}.
@end defun


@defun string->octets @var{string}
@defunx octets->string @var{bytevector}
Convert to and from a Scheme string and a Scheme bytevector holding the
raw octets encoding of the characters.  Octets are converted to
characters with @func{integer->char}; characters are converted to octets
with @func{char->integer}.  Raise an exception if the conversion is not
possible.
@end defun


@defun string->ascii @var{string}
@defunx ascii->string @var{bytevevctor}
Convert to and from a Scheme string and a Scheme bytevector holding the
@ascii{} encoding of the characters.
@end defun


@defun octets-encoded-string? @var{string}
Return @true{} if @var{string} can be interpreted as an octets encoded
string, otherwise return @false{}.  A character is considered an
octets--encoded if its integer representation @var{chi} satisfies:

@example
(<= 0 @var{chi} 255)      @result{} #t
@end example
@end defun


@defun ascii-encoded-string? @var{string}
Return @true{} if @var{string} can be interpreted as an @ascii{} encoded
string, otherwise return @false{}.  A character is considered an
@ascii{} code point if its integer representation @var{chi} satisfies:

@example
(<= #x00 @var{chi} #x7F)      @result{} #t
@end example
@end defun


@defun string->latin1 @var{string}
@defunx latin1->string @var{bytevevctor}
Convert to and from a Scheme string and a Scheme bytevector holding the
Latin-1 encoding of the characters.
@end defun


@defun latin1-encoded-string? @var{string}
Return @true{} if @var{string} can be interpreted as a Latin1 encoded
string, otherwise return @false{}.  @ref{iklib chars unicode latin1} for
the definition of Latin-1 encoding used by @value{PRJNAME}.
@end defun


@defun string->utf16le @var{string}
@defunx string->utf16be @var{string}
@defunx string->utf16n @var{string}
Convert from a Scheme string to a Scheme bytevector holding the
@utf{}-16 encoding of the characters under little, big or native
endianness respectively.
@end defun


@defun utf16le->string @var{bytevector}
@defunx utf16be->string @var{bytevector}
@defunx utf16n->string @var{bytevector}
@defunx utf16le->string @var{bytevector} @var{error-handling-mode}
@defunx utf16be->string @var{bytevector} @var{error-handling-mode}
@defunx utf16n->string @var{bytevector} @var{error-handling-mode}
Convert to a Scheme string from a Scheme bytevector holding the
@utf{}-16 encoding of characters under little, big or native endianness
respectively.

The optional argument @var{error-handling-mode} has the same values and
meaning it has for @func{utf16->string}.
@end defun


@defun string-hex->bytevector @var{string}
@defunx bytevector->string-hex @var{bytevector}
Convert to and from a Scheme string and a Scheme bytevector.

The input string contains the uppercase or lowercase hexadecimal
representation of the octets.  The output string contains the uppercase
hexadecimal representation of octets.

If an error occurs in the conversion: the return value is @false{}.
@end defun


@defun string-base64->bytevector @var{string}
@defunx bytevector->string-base64 @var{bytevector}
Convert to and from a Scheme string and a Scheme bytevector.  The input
string contains the @ascii{} Base64 representation of the octets.  The
output string contains the @ascii{} Base64 representation of octets.  If
an error occurs in the conversion: an exception is raised.
@end defun


@defun string->uri-encoding @var{str}
@defunx string->percent-encoding @var{str}
Convert the string @var{str} to its @utf{}-8 representation, then encode
such representation according to @rfc{} 3986, @acronym{URI} percent
encoding.
@end defun


@defun uri-encoding->string @var{bytevector}
@defunx percent-encoding->string @var{bytevector}
Interpret the bytevector as encoded according to @rfc{} 3986,
@acronym{URI} percent encoding, decode it and interpret the result as
the @utf{}-8 representation of a string; return the string.
@end defun


@defun uri-encoded-string? @var{string}
@defunx percent-encoded-string? @var{string}
Return @true{} if the argument is correctly percent--encoded string
according to @rfc{} 3986.  This means every character in the string is
associated to a character in the @ascii{} encoding and additionally the
constraints of @rfc{} 3986 are satisfied.
@end defun


@defun string-or-symbol->string @var{obj}
If @var{obj} is a string return a copy of it; if it is a symbol return a
new string object equal to its string name.
@end defun


@defun string-or-symbol->symbol @var{obj}
If @var{obj} is a symbol return it; if it is a string return a symbol
having it as string name.
@end defun

@c page
@node iklib strings misc
@subsection Miscellaneous string operations


@defun uuid
Attempt to build a unique string and return it.  If an internal error
occurs because of impossible generation: raise an error.
@end defun

@c page
@node iklib vectors
@section Additional vector functions


@menu
* iklib vectors constructors::  Vector constructors.
* iklib vectors predicates::    Vector predicates.
* iklib vectors copying::       Copying vectors.
* iklib vectors iteration::     Iterating vectors.
@end menu

@c page
@node iklib vectors constructors
@subsection Vector constructors


@defun vector-append @var{vec} @dots{}
Return a newly allocated vector whose items form the concatenation of
the given vectors.
@end defun


@defun vector-resize @var{vec} @var{new-length}
@defunx vector-resize @var{vec} @var{new-length} @var{fill}
Return a new vector of length @var{new-length} whose first slots are
filled with the items from @var{vec} and whose last slots, if any left,
are filled with @var{fill}.  When not used: @var{fill} defaults to
@false{}.

@example
(vector-resize '#() 0)          @result{} #()
(vector-resize '#() 3)          @result{} #(#f #f #f)
(vector-resize '#(1 2 3) 5)     @result{} #(1 2 3 #f #f)
(vector-resize '#(1 2 3) 2)     @result{} #(1 2)
@end example
@end defun

@c page
@node iklib vectors predicates
@subsection Vector predicates


@defun vector-empty? @var{vec}
Return @true{} if the vector @var{vec} has zero length, otherwise return
@false{}.
@end defun


@defun non-empty-vector? @var{obj}
Return @true{} if @var{obj} is a vector object with non--zero length;
otherwise return @false{}.  This function does @strong{not} raise an
exception if @var{obj} is not a vector object.
@end defun


@defun list-of-vectors? @var{obj}
Return @true{} if @var{obj} is null or a proper list of vector objects;
otherwise return @false{}.
@end defun


@defun vectors-of-same-length? @varo{vec} @var{vec} @dots{}
Return @true{} if all the arguments are vectors of the same length;
otherwise return @false{}.  It is an error if an argument is not a
vector object.
@end defun


@defun list-of-vectors-of-same-length? @var{obj}
Return @true{} if @var{obj} is null or a proper list of vector objects,
all with the same length; otherwise return @false{}.
@end defun

@c page
@node iklib vectors copying
@subsection Copying vectors


@defun subvector @var{vec} @var{start} @var{end}
@var{vec} must be a vector, and @var{start} and @var{end} must be exact
integer objects satisfying:

@example
0 <= @var{start} <= @var{end} <= (vector-length @var{vec})
@end example

Return a newly allocated vector formed from the items of @var{vec}
beginning with index @var{start} (inclusive) and ending with index
@var{end} (exclusive).
@end defun


@defun vector-copy @var{vec}
Return a newly allocated copy of the given vector.  This is ``shallow''
copy, @strong{not} a ``deep'' copy: the returned vector holds the same
items of @var{vec}.
@end defun


@defun vector-copy! @var{src.vec} @var{src.start} @var{dst.vec} @var{dst.start} @var{count}
Copy @var{count} items from @var{src.vec} starting at @var{src.start}
(inclusive) to @var{dst.vec} starting at @var{dst.start}.  Return
unspecified values.
@end defun

@c page
@node iklib vectors iteration
@subsection Iterating vectors


@defun vector-find @var{proc} @var{vec}
@var{proc} should accept one argument and return a single value.
@var{proc} should not mutate @var{vec}.  @func{vector-find} applies
@var{proc} to the elements of @var{vec} in order.  If @var{proc} returns
a true value for an element, @func{vector-find} immediately returns that
element.  If @var{proc} returns @false{} for all elements of the vector,
@func{vector-find} returns @false{}.  @var{proc} is always called in the
same dynamic environment as @func{vector-find} itself.

@example
(vector-find even? '#(3 1 4 1 5 9))
@result{} 4

(vector-find even? '#(3 1 5 1 5 9))
@result{} #f
@end example
@end defun


@defun vector-for-all @var{proc} @vari{vec} @varii{vec} @dots{} @varn{vec}
@defunx vector-exists @var{proc} @vari{vec} @varii{vec} @dots{} @varn{vec}
The @var{vec}s should all have the same length, and @var{proc} should
accept @math{N} arguments and return a single value.  @var{proc} should
not mutate the @var{vec} arguments.

For natural numbers @math{i = 0, 1, @dots{}}, the @func{vector-for-all}
procedure successively applies @var{proc} to arguments @math{x_i^1
@dots{} x_i^N}, where @math{x_i^j} is the @math{i}-th element of
@var{vecj}, until @false{} is returned.

If @var{proc} returns true values for all but the last element of
@vari{vec}, @func{vector-for-all} performs a tail call of @var{proc} on
the @math{k}-th elements, where @math{k} is the length of @vari{vec}.
If @var{proc} returns @false{} on any set of elements,
@func{vector-for-all} returns @false{} after the first such application
of @var{proc}.  If the @var{vec}s are all empty, @func{vector-for-all}
returns @true{}.

@lisp
(vector-for-all even? '#())             @result{} #t
(vector-for-all even? '#(3 1 4 1 5 9))  @result{} #f
(vector-for-all even? '#(2 4 14))       @result{} #t
(vector-for-all (lambda (n)
                  (and (even? n) n))
                '#(2 4 14))
@result{} 14
(vector-for-all < '#(1 2 3) '#(2 3 4))  @result{} #t
(vector-for-all < '#(1 2 4) '#(2 3 4))  @result{} #f
@end lisp

For natural numbers @math{i = 0, 1, @dots{}}, the @func{vector-exists}
procedure applies @var{proc} successively to arguments @math{x_i^1
@dots{} x_i^n}, where @math{x_i^j} is the @math{i}-th element of
@var{vecj}, until a true value is returned.

If @var{proc} returns @false{} for all but the last elements of the
@var{vec}s, @func{vector-exists} performs a tail call of @var{proc} on
the @math{k}-th elements, where @math{k} is the length of @vari{vec}.
If @var{proc} returns a true value on any set of elements,
@func{vector-exists} returns that value after the first such application
of @var{proc}.  If the @var{vec}s are all empty, @func{vector-exists}
returns @false{}.

@lisp
(vector-exists even? '#(3 1 4 1 5 9))   @result{} #t
(vector-exists even? '#(3 1 1 5 9))     @result{} #f
(vector-exists even? '#())              @result{} #f
(vector-exists (lambda (n)
                 (and (even? n) n))
               '#(2 1 4 14))
@result{} 2
(vector-exists < '#(1 2 4) '#(2 3 4))   @result{} #t
(vector-exists > '#(1 2 3) '#(2 3 4))   @result{} #f
@end lisp

@var{proc} is always called in the same dynamic environment as
@func{vector-for-all} or, respectively, @func{vector-exists} itself.
@end defun


@deffn Function vector-fold-left @var{combine} @var{knil} @varo{vec} @var{vec} @dots{}
@deffnx Function vector-fold-right @var{combine} @var{knil} @varo{vec} @var{vec} @dots{}
Fold the function @var{combine} over the vector arguments, which must
have the same length.  The return value is the return value of the last
evaluated call to @var{combine}; if all the vector arguments are empty,
the return value is @var{knil}.

The left--folding variant iterate @var{combine} left--to--right over
each element of equal index in all the vectors; @var{combine} is applied
as:

@example
(@var{combine} @var{state}
  (vector-ref @varo{vec} @var{idx})
  (vector-ref @var{vec}  @var{idx})
  )
@end example

@noindent
where @var{state} is the current state value, and it is the
@strong{first} argument; the current state value begins with @var{knil},
and becomes whatever @var{combine} returned at the respective iteration.

The right--folding variant iterate @var{combine} right--to--left over
each element of equal index in all the vectors; @var{combine} is applied
as:

@example
(@var{combine}
  (vector-ref @var{vec0} @var{idx})
  (vector-ref @var{vec}  @var{idx})
  
  @var{state})
@end example

@noindent
in which @var{state} is the @strong{last} argument.
@end deffn

@c page
@node iklib symbols
@section Additional symbol functions


@menu
* iklib symbols predicates::    Predicates about symbols.
* iklib symbols comparison::    Comparing symbols.
* iklib symbols value::         Symbol values.
* iklib symbols plists::        Property lists.
@end menu

@c page
@node iklib symbols predicates
@subsection Predicates about symbols


@defun list-of-symbols? @var{obj}
Return @true{} if @var{obj} is null or a proper list of symbols;
otherwise return @false{}.
@end defun

@c page
@node iklib symbols comparison
@subsection Comparing symbols


@deffn Procedure {symbol<?} @varo{sym} @dots{}
@deffnx Procedure {symbol>?} @varo{sym} @dots{}
@deffnx Procedure {symbol<=?} @varo{sym} @dots{}
@deffnx Procedure {symbol>=?} @varo{sym} @dots{}
These procedures are the extensions to symbols of the corresponding
orderings on strings.

@example
(symbol<? z a)          @result{} #t
(symbol<? z zz)         @result{} #t
(symbol<? z Z)          @result{} #f
@end example
@end deffn


@defun symbol!=? @varo{ptr} @var{ptr} @dots{}
Return @true{} if all the symbol arguments are different; otherwise
return @false{}.
@end defun


@defun symbol-max @varo{ptr} @var{ptr} @dots{}
@defunx symbol-min @varo{ptr} @var{ptr} @dots{}
Return the maximal or minimal symbol argument according to
@func{symbol<?}.
@end defun

@c page
@node iklib symbols value
@subsection Symbol values


Under @value{PRJNAME}, Scheme symbols are data structures having a field
@code{value} initialised, at symbol construction time, to the built--in
value @samp{#<unbound-object>}; this field has multiple purposes:

@itemize
@item
When the symbol is the unique identifier of a @value{PRJNAME} data
structure type: @code{value} holds the struct--type descriptor of the
data structure.

@item
When the symbol is the unique identifier of a @rnrs{6} record type:
@code{value} holds the type--descriptor of the record.

@item
When the symbol is the ``public name'' of a core primitive defined by
@value{PRJNAME} (for example @func{display} or @func{+}): we have to
assume that @code{value} holds a Scheme object for internal use by
@value{PRJNAME}.

@item
When the symbol is a label gensym associated to a syntactic binding
exported by the boot image: @code{value} holds the syntactic binding
descriptor.

@item
When the symbol is a label gensym associated to a syntactic binding
imported in the current lexical environment: @code{value} holds the
syntactic binding descriptor.

@item
When the symbol is a storage location gensym (loc gensym) associated to
a lexical syntactic binding: @code{value} holds the current value of the
lexical variable.

@item
When the symbol is a fresh symbol returned by a call to @func{gensym}:
we can use @code{value} for any purpose we want.
@end itemize

In practise, we should never use the @code{value} field of symbols
unless they are gensyms we are using for a specific purpose, in which
case the ability to associate a value with a symbol can be quite useful
in building some form of associative array with distributed storage.

The following bindings are exported by the library @library{vicare}.


@defun top-level-value @var{loc}
Expect the argument to be a loc gensym associated to a binding; extract
the value from the slot @code{value} of the symbol object and return it.
If the value is the unbound object: raise an exception.

This is both a primitive function and a core primitive operation.

@quotation
@strong{NOTE} In binary code, this function has a specific purpose: to
retrieve the value of a binding defined in a previously evaluated
expression in the context of an interaction environment; we have to know
the internals of the expander to understand it.  Let's say we are
evaluating expressions at the @repl{}; first we do:

@example
vicare> (define a 1)
@end example

@noindent
the expander creates a new top level binding in the interaction
environment; such interaction environment bindings are special in that
they have a single gensym to serve both as lex gensym and loc gensym;
the expander transforms the input form into the core language form:

@example
(set! lex.a 1)
@end example

@noindent
where @code{lex.a} is both the lex gensym and the loc gensym associated
to the binding; the compiler transforms the core language expression
into:

@example
($init-symbol-value! lex.a 1)
@end example

@noindent
which, compiled and evaluated, will store the value in the @code{value}
field of the gensym @code{lex.a}.

Later we do:

@example
vicare> a
@end example

@noindent
the expander finds the binding in the interaction environment and
transforms the variable reference into the core language expression:

@example
lex.a
@end example

@noindent
the compiler then transforms the core language variable reference into:

@example
(top-level-value 'lex.a)
@end example

@noindent
which, compiled and evaluated, will return the binding's value.

The same processing happens when we evaluate multiple expressions with
@func{eval} in the context of the same interaction environment.
@end quotation
@end defun


@defun top-level-bound? @var{loc}
Return @true{} if the symbol object @var{loc} has a proper value in its
@code{value} field; return @false{} if the field @code{value} is set to
the unbound object.
@end defun


@defun set-top-level-value! @var{loc} @var{value}
This function can be used to set a new object in a @var{loc} gensym, so
that it can be later retrieved by @func{top-level-value}.
@end defun


@defun reset-symbol-proc! @var{sym}
@var{sym} is meant to be a location gensym.  If the value currently in
the field @code{value} of @var{sym} is a closure object: store such
value also in the field @code{proc} of @var{sym}X.

@quotation
@strong{NOTE} Whenever binary code performs a call to a global closure
object, it does the following:

@itemize
@item
From the relocation vector of the current code object: retrieve the loc
gensym of the procedure to call.

@item
From the loc gensym: extract the value of the @code{proc} slot, which is
meant to be a closure object.  This is done by accessing the gensym
object with a low--level assembly instruction, @strong{not} by using the
primitive operation @func{$symbol-proc}.

@item
Actually call the closure object.
@end itemize
@end quotation
@end defun


@defun set-symbol-value! @var{sym} @var{value}
Store @var{value} in the @code{value} field of the symbol @var{sym}.
@end defun


@defun symbol-value @var{sym}
Return the value in the @code{value} field of the symbol @var{sym}.
@end defun


@defun symbol-bound? @var{sym}
Return true if @var{sym} is a symbol and its @code{value} field is
@strong{not} set to the built--in @samp{#<unbound-object>} machine word
value.
@end defun


@defun unbound-object
Return the unbound object.
@end defun


@defun unbound-object? @var{obj}
Return @true{} if @var{obj} is the unbound object.
@end defun

@c page
@node iklib symbols plists
@subsection Property lists


Property lists are key/value associations that can be attached to any
Scheme symbol.

@example
#!ikarus
(import (vicare))

(putprop 'ciao 'british 'hello)
(putprop 'ciao 'spanish 'hola)

(getprop 'ciao 'british)        @result{} hello
(getprop 'ciao 'spanish)        @result{} hola

(remprop 'ciao 'british)
(getprop 'ciao 'british)        @result{} #f

(property-list 'ciao)           @result{} ((spanish . hola))
@end example

The following bindings are exported by the library @library{vicare}.


@defun putprop @var{symbol} @var{key} @var{value}
Add a new property @var{key} with @var{value} to the property list of
@var{symbol}.  @var{key} must be a symbol, @var{value} can be any value.

If @var{key} is already set: the old entry is mutated to reference the
new @var{value}.
@end defun


@defun getprop @var{symbol} @var{key}
Return the value of the property @var{key} in the property list of
@var{symbol}; if @var{key} is not set return false.  @var{key} must be a
symbol.
@end defun


@defun remprop @var{symbol} @var{key}
Remove property @var{key} from the list associated to @var{symbol}.
@end defun


@defun property-list @var{symbol}
Return a new association list representing the property list of
@var{symbol}.  The order of the entries is the same as the property
creation order.
@end defun

@c page
@node iklib fixnums
@section Additional functions on fixnums


@menu
* iklib fixnums predicates::    Predicates.
* iklib fixnums comparison::    Comparison functions.
* iklib fixnums arithmetics::   Arithmetics.
* iklib fixnums bitwise::       Bitwise functions.
* iklib fixnums conversion::    Conversion functions.
@end menu

@c page
@node iklib fixnums predicates
@subsection Predicates


@defun list-of-fixnums? @var{obj}
Return @true{} if @var{obj} is null or a proper list of fixnums;
otherwise return @false{}.
@end defun


@defun fxnonpositive? @var{fx}
@defunx fxnonnegative? @var{fx}
Return @true{} if @var{fx} is, respectively, non--positive or
non--negative; else return @false{}.
@end defun


@defun non-zero-fixnum? @var{obj}
Return @true{} if @var{obj} is a non--zero fixnum; otherwise return
@false{}.  If @var{obj} is not a fixnum: return @false{}.
@end defun


@defun positive-fixnum? @var{obj}
@defunx negative-fixnum? @var{obj}
@defunx non-positive-fixnum? @var{obj}
@defunx non-negative-fixnum? @var{obj}
Return @true{} if @var{obj} is a fixnum respectively: positive,
negative, non--positive, non--negative; otherwise return @false{}.  If
@var{obj} is not a fixnum: return @false{}.
@end defun

@c page
@node iklib fixnums comparison
@subsection Comparison functions


@defun fx= @vari{fx} @var{fx} @dots{}
@defunx fx< @vari{fx} @var{fx} @dots{}
@defunx fx> @vari{fx} @var{fx} @dots{}
@defunx fx<= @vari{fx} @var{fx} @dots{}
@defunx fx>= @vari{fx} @var{fx} @dots{}
Aliases for @func{fx=?}, @func{fx<?}, @func{fx>?}, @func{fx<=?},
@func{fx>=?}.
@end defun


@defun fx!=? @varo{fx} @var{fx} @dots{}
@defunx fx!= @varo{fx} @var{fx} @dots{}
Return @true{} if all the arguments are different; otherwise return
@false{}.  The arguments must be fixnums.
@end defun

@c page
@node iklib fixnums arithmetics
@subsection Arithmetics


@defun fxadd1 @var{fx}
@defunx fxsub1 @var{fx}
Add or subtract @samp{1} to @var{fx}.
@end defun


@defun fxabs @var{fx}
Return the absolute value of the fixnum @var{fx} as a fixnum; if
@var{fx} is @code{(least-fixnum)}: its absolute value is a bignum, in
which case this function raises an implementation restriction violation.

To compute the general absolute value without overflow we must use
@func{abs} or @func{$abs-fixnum}.
@end defun


@defun fxsign @var{fx}
Return one of the fixnums @code{+1}, @code{-1}, @code{0} representing
the sign of the fixnum @var{fx}.
@end defun


@deffn Procedure fxquotient @vari{fx} @varii{fx}
@deffnx Procedure fxremainder @vari{fx} @varii{fx}
@deffnx Procedure fxmodulo @vari{fx} @varii{fx}
These procedures implement number--theoretic (integer) division on
fixnum arguments.  @varii{fx} must be non--zero.  All three procedures
return fixnum objects.  If @vari{fx}/@varii{fx} is an integer object:

@example
(fxquotient  @vari{fx} @varii{fx})  @result{} @vari{fx}/@varii{fx}
(fxremainder @vari{fx} @varii{fx})  @result{} 0
(fxmodulo    @vari{fx} @varii{fx})  @result{} 0
@end example

If @vari{fx}/@varii{fx} is not an integer object:

@example
(fxquotient  @vari{fx} @varii{fx})  @result{} @var{n_q}
(fxremainder @vari{fx} @varii{fx})  @result{} @var{n_r}
(fxmodulo    @vari{fx} @varii{fx})  @result{} @var{n_m}
@end example

@noindent
where @var{n_q} is @vari{fx}/@varii{fx} rounded towards zero,

@example
0 < |@var{n_r}| < |@varii{fx}|
0 < |@var{n_m}| < |@varii{fx}|
@end example

@noindent
@var{n_r} and @var{n_m} differ from @vari{fx} by a multiple of @varii{fx},
@var{n_r} has the same sign as @vari{fx}, and @var{n_m} has the same sign
as @varii{fx}.

Consequently, for integer objects @vari{fx} and @varii{fx} with @varii{fx}
not equal to @math{0},

@example
(= @vari{fx} (+ (* @varii{fx} (fxquotient  @vari{fx} @varii{fx}))
                 (fxremainder @vari{fx} @varii{fx})))
@result{} #t
@end example

@noindent
provided all number object involved in that computation are exact.

@example
(fxmodulo 13 4)           @result{}  1
(fxremainder 13 4)        @result{}  1

(fxmodulo -13 4)          @result{}  3
(fxremainder -13 4)       @result{}  -1

(fxmodulo 13 -4)          @result{}  -3
(fxremainder 13 -4)       @result{}  1

(fxmodulo -13 -4)         @result{}  -1
(fxremainder -13 -4)      @result{}  -1
@end example
@end deffn

@c page
@node iklib fixnums bitwise
@subsection Bitwise functions


@defun fxlognot @var{fx}
@defunx fxlogor @vari{fx} @varii{fx}
@defunx fxlogand @vari{fx} @varii{fx}
@defunx fxlogxor @vari{fx} @varii{fx}
Aliases for @func{fxnot}, @func{fxior}, @func{fxand}, @func{fxxor}.
@end defun

@c page
@node iklib fixnums conversion
@subsection Conversion functions


@defun fixnum->char @var{fx}
@defunx char->fixnum @var{ch}
Convert a fixnum to and from a character.
@end defun


@defun fixnum->string @var{fx}
@defunx fixnum->string @var{fx} @var{base}
Return a string representation of @var{fx}.  @var{base} must be one
among @math{2}, @math{8}, @math{10}, @math{16}; when not given it
defaults to @math{10}.
@end defun

@c page
@node iklib flonums
@section Additional functions on flonums


The following bindings are exported by the library @library{vicare}.

@c ------------------------------------------------------------

@subsubheading Predicates


@defun list-of-flonums? @var{obj}
Return @true{} if @var{obj} is null or a proper list of flonums;
otherwise return @false{}.
@end defun


@defun flnonpositive? @var{fl}
@defunx flnonnegative? @var{fl}
Return @true{} if @var{fl} is, respectively, non--positive or
non--negative; else return @false{}.
@end defun


@defun positive-flonum? @var{obj}
@defunx negative-flonum? @var{obj}
@defunx non-positive-flonum? @var{obj}
@defunx non-negative-flonum? @var{obj}
Return @true{} if @var{obj} is a flonum respectively: positive,
negative, non--positive, non--negative; otherwise return @false{}.  If
@var{obj} is not a flonum: return @false{}.

Notice the following behaviour with zero:

@lisp
(positive-flonum? +0.0)         @result{} #f
(positive-flonum? -0.0)         @result{} #f

(negative-flonum? +0.0)         @result{} #f
(negative-flonum? -0.0)         @result{} #f

(non-positive-flonum? +0.0)     @result{} #f
(non-positive-flonum? -0.0)     @result{} #t

(non-negative-flonum? +0.0)     @result{} #t
(non-negative-flonum? -0.0)     @result{} #f
@end lisp
@end defun

@c ------------------------------------------------------------

@subsubheading Comparison

@defun fl!=? @varo{fl} @var{fl} @dots{}
Return @true{} if the operands are equal; else return @false{}.  The
operands must be flonums, otherwise an exception is raised.
@end defun

@c ------------------------------------------------------------

@subsubheading String conversion


@defun flzero?/positive @var{fl}
@defunx flzero?/negative @var{fl}
Return true if the operand is @code{+0.0} or @code{-0.0}, respectively.
Notice that @func{flzero?} does @strong{not} make this distinction.
@end defun

@c ------------------------------------------------------------

@subsubheading String conversion


@defun string->flonum @var{fl}
@defunx flonum->string @var{str}
Convert between a flonum and its string representation.
@end defun

@c ------------------------------------------------------------

@subsubheading Exponents and logarithms


@defun fllog1p @var{fl}
Return a flonum equivalent to @math{log(1 + @var{fl})}.
@end defun


@defun flexpm1 @var{fl}
Return a flonum equivalent to @math{exp(@var{fl}) - 1}.
@end defun


@defun flhypot @vari{fl} @varii{fl}
Compute the Euclidean distance function: @math{\sqrt(X*X+Y*Y)}.
@glibcref{Exponents and Logarithms, hypot}.
@end defun

@c ------------------------------------------------------------

@subsubheading Hyperbolic functions


@defun flsinh @var{fl}
@defunx flcosh @var{fl}
@defunx fltanh @var{fl}
Compute the hyperbolic functions.  Return flonum objects.
@end defun


@defun flasinh @var{fl}
@defunx flacosh @var{fl}
@defunx flatanh @var{fl}
Compute the inverse hyperbolic functions.  Return flonum objects.
@end defun

@c ------------------------------------------------------------

@subsubheading Power functions


@defun flsquare @var{fl}
Return the square of @var{fl}, that is @var{fl} multiplied by itself.
@end defun


@defun flcube @var{fl}
Return the cube of @var{fl}, that is @var{fl} times @var{fl} times
@var{fl}.
@end defun


@defun flcbrt @var{fl}
Return the real cube root function of @var{fl}.
@end defun

@c ------------------------------------------------------------

@subsubheading Miscellaneous functions


@defun flonum-bytes @var{fl}
Return @math{8} values being fixnums representing octects from the
binary representation of @var{fl}.
@end defun


@defun flonum-parts @var{fl}
Return @math{3} values begin: a boolean, true if @var{fl} is positive; a
fixnum representing the exponent's @math{11} bits; an exact integer
representing the mantissa's @math{53} bits.

@example
(flonum-parts 2.0)
@result{} #t #b10000000000 #b0

(flonum-parts 4.0)
@result{} #t #b10000000001 #b0

(flonum-parts +0.0)
@result{} #t #b00000000000 #b0

(flonum-parts -0.0)
@result{} #f #b00000000000 #b0
@end example
@end defun

@c page
@node iklib numerics
@section Additional functions on numbers


@menu
* iklib numerics constants::    Numeric constants.
* iklib numerics compar::       Additional comparison functions.
* iklib numerics preds::        Additional numeric predicates.
* iklib numerics bignums::      Additional bignum functions.
* iklib numerics math::         Additional math functions.
* iklib numerics bitwise::      Additional bitwise functions.
@end menu

@c page
@node iklib numerics constants
@subsection Numeric constants


@cindex Library @library{vicare numerics constants}
@cindex @library{vicare numerics constants}, library


The following bindings are exported by the library @library{vicare
numerics constants}.  Notice that under @gnu{} Emacs it is easy to
display the symbol @code{greek-pi} with the Unicode glyph for the greek
letter adding the following to the Scheme hook:

@example
(defun my-pretty-chars-scheme-pi ()
  (interactive)
  (font-lock-add-keywords
   nil '(("\\(\\<[-+]?\\(greek-pi\\)\\)"
          (0 (progn
               (compose-region (match-beginning 2)
                               (match-end 2)
                               ?\u03C0)
               nil))))))
@end example


@deffn Constant greek-pi
@deffnx Constant +greek-pi
@deffnx Constant -greek-pi
Evaluate to a constant flonum object representing plus or minus pi.
@end deffn


@deffn Constant greek-pi/2
@deffnx Constant +greek-pi/2
@deffnx Constant -greek-pi/2
Evaluate to a constant flonum object representing plus or minus pi
divided by @math{2}.
@end deffn


@deffn Constant greek-pi/3
@deffnx Constant +greek-pi/3
@deffnx Constant -greek-pi/3
Evaluate to a constant flonum object representing plus or minus pi
divided by @math{3}.
@end deffn


@deffn Constant greek-pi/4
@deffnx Constant +greek-pi/4
@deffnx Constant -greek-pi/4
Evaluate to a constant flonum object representing plus or minus pi
divided by @math{4}.
@end deffn


@deffn Constant greek-pi/6
@deffnx Constant +greek-pi/6
@deffnx Constant -greek-pi/6
Evaluate to a constant flonum object representing plus or minus pi
divided by @math{6}.
@end deffn


@deffn Constant greek-pi*2
@deffnx Constant +greek-pi*2
@deffnx Constant -greek-pi*2
Evaluate to a constant flonum object representing plus or minus pi
multiplied by @math{2}.
@end deffn


@deffn Constant greek-pi*2/3
@deffnx Constant +greek-pi*2/3
@deffnx Constant -greek-pi*2/3
Evaluate to a constant flonum object representing plus or minus pi
multiplied by @math{2/3}.
@end deffn


@deffn Constant greek-pi*3/4
@deffnx Constant +greek-pi*3/4
@deffnx Constant -greek-pi*3/4
Evaluate to a constant flonum object representing plus or minus pi
multiplied by @math{3/4}.
@end deffn

@c page
@node iklib numerics compar
@subsection Additional comparison functions


@defun != @vari{Z} @varii{Z} @variii{Z} @dots{}
Return @true{} if all the arguments are equal, otherwise return
@false{}; all the arguments must be numbers according to
@func{number?}.  This function is equivalent to:

@example
(not (= @vari{Z} @varii{Z} @variii{Z} ...))
@end example
@end defun

@c page
@node iklib numerics preds
@subsection Additional numeric predicates


The following bindings are exported by the library @library{vicare}.


@defun bignum? @var{obj}
Return @true{} if @var{obj} is an exact integer represented by a big
number; otherwise return @false{}.
@end defun


@defun ratnum? @var{obj}
Return @true{} if @var{obj} is an exact rational number; otherwise
return @false{}.
@end defun


@defun cflonum? @var{obj}
Return @true{} if @var{obj} is a complex number having flonums as both
real and imaginary parts; otherwise return @false{}.
@end defun


@defun compnum? @var{obj}
Return @true{} if @var{obj} is a complex number having any possible
combination of number representations as real and imaginary parts, but
not both flonums; otherwise return @false{}.
@end defun


@defun exact-integer? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum; otherwise return
@false{}.
@end defun

@c ------------------------------------------------------------

@defun non-positive? @var{X}
@defunx non-negative? @var{X}
Return @true{} if @var{X} is a real number object and it is,
respectively, non--positive or non--negative.
@end defun


@defun zero-exact-integer? @var{obj}
Return @true{} if @var{obj} is an exact integer whose value is zero,
otherwise return @false{}; only fixnums can be zero.  If @var{obj} is
not a number object: return @false{}.
@end defun


@defun positive-exact-integer? @var{obj}
@defunx negative-exact-integer? @var{obj}
Return @true{} if @var{obj} is a positive or negative exact integer;
otherwise return @false{}.  If @var{obj} is not a number object: return
@false{}.
@end defun


@defun non-positive-exact-integer? @var{obj}
@defunx non-negative-exact-integer? @var{obj}
Return @true{} if @var{obj} is a non--positive or non--negative exact
integer; otherwise return @false{}.  If @var{obj} is not a number
object: return @false{}.
@end defun

@c page
@node iklib numerics bignums
@subsection Additional bignum functions


@defun bignum-positive? @var{bn}
@defunx bignum-non-negative? @var{bn}
The argument must be a bignum.  Return @true{} if it is positive,
otherwise return @false{}.
@end defun


@defun bignum-negative? @var{bn}
@defunx bignum-non-positive? @var{bn}
The argument must be a bignum.  Return @true{} if it is negative,
otherwise return @false{}.
@end defun


@defun bignum-odd? @var{bn}
The argument must be a bignum.  Return @true{} if it is odd, otherwise
return @false{}.
@end defun


@defun bignum-even? @var{bn}
The argument must be a bignum.  Return @true{} if it is even, otherwise
return @false{}.
@end defun


@defun least-positive-bignum
Return the smallest positive bignum.
@end defun


@defun greatest-negative-bignum
Return the greatest negative bignum.
@end defun

@c page
@node iklib numerics math
@subsection Additional math functions


The following bindings are exported by the library @library{vicare}.

@c ------------------------------------------------------------

@subsubheading Arithmetic functions


@defun add1 @var{num}
@defunx sub1 @var{num}
Add or subtract @samp{1} to @var{num}, which can be any number.
@end defun


@defun square @var{num}
Return the square of @var{num}: @var{num} times @var{num}.
@end defun


@defun cube @var{num}
Return the cube of @var{num}: @var{num} times @var{num} times @var{num}.
@end defun


@defun cbrt @var{num}
Return the cubic root of @var{num}.
@end defun


@defun quotient @vari{N} @varii{N}
@defunx remainder @vari{N} @varii{N}
@defunx quotient+remainder @vari{N} @varii{N}
@func{quotient+remainder} returns two values: the quotient and the
remainder of the number--theoretic integer division between the
operands; @func{quotient} returns the quotient; @func{remainder} returns
the remainder.  @vari{N} and @varii{N} must be exact or inexact integers
(fixnums, bignums, flonums); @varii{N} must be non--zero.

The operations are defined as for @func{quotient} and @func{remainder}
from @rsixlibrary{r5rs}.

Note that considering:

@example
(quotient+remainder X Y)
@end example

@noindent
according to @rnrs{6}:

@example
(define (sign n)
  (cond ((negative? n) -1)
        ((positive? n) 1)
        (else 0)))

(define (quotient n1 n2)
  (* (sign n1) (sign n2) (div (abs n1) (abs n2))))

(define (remainder n1 n2)
  (* (sign n1) (mod (abs n1) (abs n2))))

(define (modulo n1 n2)
  (* (sign n2) (mod (* (sign n2) n1) (abs n2))))
@end example

@noindent
so we have:

@example
sign(quotient)  = sign(X) * sign(Y)
sign(remainder) = sign(X)
@end example
@end defun


@defun sign @var{X}
Return a number object representing the sign of @var{X}, which must be
a real number.  When @var{X} is a:

@table @strong
@item fixnum
@itemx bignum
Return a fixnum representing the sign of @var{X}: @code{+1} for
positive, @code{-1} for negative, @code{0} for zero.

@item flonum
Return a flonum representing the sign of @var{X}: @code{+1.0} for
positive, including @code{+0.0} and @code{+inf.0}; @code{-1} for
negative, including @code{-0.0} and @code{-inf.0}; @code{+nan.0} for
not--a--number.

@item ratnum
Return a fixnum representing the sign of the numerator of @var{rn}:
@code{+1} for positive, @code{-1} for negative, @code{0} for zero.
@end table
@end defun


@defun factorial @var{I}
Return the factorial of the non--negative integer @var{I} (which can be
exact or inexact).
@end defun

@c ------------------------------------------------------------

@subsubheading Hyperbolic functions

The @var{num} operand must be a real or complex number.


@defun sinh @var{num}
@defunx cosh @var{num}
@defunx tanh @var{num}
Hyperbolic functions.
@end defun


@defun asinh @var{num}
@defunx acosh @var{num}
@defunx atanh @var{num}
Inverse hyperbolic functions.
@end defun

@c ------------------------------------------------------------

@subsubheading Complex number functions


@defun complex-conjugate @var{num}
@cindex Conjugate of a complex number
Return the complex conjugate of the number object @var{num}.
@end defun

@c page
@node iklib numerics bitwise
@subsection Additional bitwise functions


The following bindings are exported by the library @library{vicare}.


@defun sra @var{integer} @var{offset}
An alias for @func{bitwise-arithmetic-shift-right}.
@end defun


@defun sll @var{integer} @var{offset}
An alias for @func{bitwise-arithmetic-shift-left}.
@end defun

@c page
@node iklib enumerations
@section Additional functions on enumerations


The following bindings are exported by the library @library{vicare}.


@defun enum-set? @var{obj}
Return @true{} if @var{obj} is an enumeration set object, else return
@false{}.
@end defun

@c page
@node iklib hashtables
@section Additional functions on hash tables


@menu
* iklib hashtables pred::       Predicates on hash tables.
* iklib hashtables iterators::  Hash table iterators.
* iklib hashtables hashfun::    Additional hash functions.
@end menu

@c page
@node iklib hashtables pred
@subsection Predicates on hash tables


@defun mutable-hashtable? @var{obj}
Return @true{} if @var{obj} is a hash table and it is mutable; return
@false{} otherwise.  This function is different from the standard
@func{hashtable-mutable?} because it does @strong{not} raise an error if
@var{obj} is not a hash table.
@end defun


@defun hashtable-eq? @var{obj}
@defunx hashtable-eqv? @var{obj}
@defunx hashtable-equiv? @var{obj}
Return @true{} if @var{obj} is a hashtable object and it has, as
equivalence function, respectively: @func{eq?}, @func{eqv?}, a user
supplied function.
@end defun

@c page
@node iklib hashtables iterators
@subsection Hash table iterators


Ghuloum and Dybvig explain in the paper:

@quotation
Ghuloum, Dybvig.  ``Generation--Friendly Eq Hash Tables''.  Proceedings
of the 2007 Workshop on Scheme and Functional Programming.
@end quotation

@noindent
why it is not possible to iterate a hash table by visiting the buckets:
there's a problem with rehashing entries that are moved by the garbage
collector.  The iterators always use @func{hashtable-keys} and
@func{hashtable-entries}, which is slow and memory consuming, but it is
safe.


@defun hashtable-map-keys @var{proc} @var{table}
Build and return a new hash table with the same hash function and
equivalence function of @var{table}; add associations to the new table
by applying @var{proc} to every key in @var{table}, in unspecified
order, and using the returned value as association value.

@lisp
(let* ((A '((a . 1) (b . 2) (c . 3)))
       (T (alist->hashtable! (make-eq-hashtable) A))
       (M (hashtable-map-keys
              (lambda (key) 123)
            T)))
  (hashtable->alist M (lambda (s1 s2)
                        (string<? (symbol->string s1)
                                  (symbol->string s2)))))
@result{} ((a . 123) (b . 123) (c . 123))
@end lisp
@end defun


@defun hashtable-map-entries @var{proc} @var{table}
Build and return a new hash table with the same hash function and
equivalence function of @var{table}; add associations to the new table
by applying @var{proc} to every key and value in @var{table}, in
unspecified order, and using the returned value as association value.

@lisp
(let* ((A '((a . 1) (b . 2) (c . 3)))
       (T (alist->hashtable! (make-eq-hashtable) A))
       (M (hashtable-map-entries
              (lambda (key val)
                (* 10 val))
            T)))
  (hashtable->alist M (lambda (s1 s2)
                        (string<? (symbol->string s1)
                                  (symbol->string s2)))))
@result{} ((a . 10) (b . 20) (c . 30))
@end lisp
@end defun


@defun hashtable-for-each-key @var{proc} @var{table}
Apply @var{proc} to every key in table, in unspecified order, and
discard the results.  It is implemented as follows:

@lisp
(vector-for-each proc (hashtable-keys table))
@end lisp
@end defun


@defun hashtable-for-each-entry @var{proc} @var{table}
Apply @var{proc} to every key and value in table, in unspecified order,
and discard the results.  It is implemented as follows:

@lisp
(receive (keys vals)
    (hashtable-entries table)
  (vector-for-each proc keys vals))
@end lisp
@end defun


@defun hashtable-for-all-keys @var{pred} @var{table}
Apply @var{pred} to every key in @var{table}, in unspecified order,
stopping at the first key for which @var{pred} returns @false{}.

@itemize
@item
If @var{pred} returns non-false for every key: the return value is the
return value of the last call to @var{pred}.

@item
If @var{pred} returns @false{} for a key: the return value is @false{}.
@end itemize

It is implemented as follows:

@lisp
(vector-for-all pred (hashtable-keys table))
@end lisp
@end defun


@defun hashtable-for-all-entries @var{pred} @var{table}
Apply @var{pred} to every key and value in @var{table}, in unspecified
order, stopping at the first application for which @var{PRED} returns
@false{}.

@itemize
@item
If @var{pred} returns non--false for every key and value: the return
value is the return value of the last call to @var{pred}.

@item
If @var{pred} returns @false{} for a key and value: the return value is
@false{}.
@end itemize

It is implemented as follows:

@lisp
(receive (keys vals)
    (hashtable-entries table)
  (vector-for-all pred keys vals))
@end lisp
@end defun


@defun hashtable-exists-key @var{proc} @var{table}
Apply @var{proc} to every key in @var{table} in unspecified order.

@itemize
@item
If @var{proc} returns @false{} for every key: the return value is
@false{}.

@item
If @var{proc} returns non--false for a key: the return value is the
value returned by @var{proc}.
@end itemize

@lisp
(vector-exists proc (hashtable-keys table)))
@end lisp
@end defun


@defun hashtable-exists-entry @var{proc} @var{table}
Apply @var{proc} to every key and value in @var{table} in unspecified
order.

@itemize
@item
If @var{proc} returns @false{} for every key and value: the return value
is @false{}.

@item
If @var{proc} returns non--false for a key and value: the return value
is the value returned by @var{proc}.
@end itemize

@lisp
(receive (keys vals)
    (hashtable-entries table)
  (vector-exists proc keys vals))
@end lisp
@end defun


@defun hashtable-find-key @var{proc} @var{table}
Apply @var{proc} to every key in @var{table} in unspecified order.

@itemize
@item
If @var{proc} returns @false{} for every key: the return value is
@false{}.

@item
If @var{proc} returns non--false for a key: the return value is that
key.
@end itemize

@lisp
(vector-find pred (hashtable-keys table)))
@end lisp
@end defun


@defun hashtable-find-entry @var{proc} @var{table}
Apply @var{proc} to every key and value in @var{table} in unspecified
order.

@itemize
@item
If @var{proc} returns @false{} for every key and value: the return value
is @false{}.

@item
If @var{proc} returns non--false for a key and value: the return value
is a pair having that key as car and that value as cdr.
@end itemize
@end defun


@defun hashtable-fold-keys @var{proc} @var{nil} @var{table}
Apply @var{proc} to every key in @var{table}, in unspecified order; the
second argument of the first @var{proc} application is @var{nil}, then
it is the return value of the previous application.  Return the return
value of the last @var{proc} application.

It is implemented as follows:

@lisp
(vector-fold-right proc nil (hashtable-keys table))
@end lisp

To build an list of keys we do:

@lisp
(hashtable-fold-keys
    (lambda (key nil)
      (cons key nil))
  '() table)
@end lisp
@end defun


@defun hashtable-fold-entries @var{proc} @var{nil} @var{table}
Apply @var{proc} to every key and value in @var{table}, in unspecified
order; the third argument of the first @var{proc} application is
@var{nil}, then it is the return value of the previous application.
Return the return value of the last @var{proc} application.

It is implemented as follows:

@lisp
(receive (keys vals)
    (hashtable-entries table)
  (vector-fold-right proc nil keys vals))
@end lisp

To build an alist from a table we do:

@lisp
(hashtable-fold-entries
    (lambda (key val nil)
      (cons (cons key val) nil))
  '() table)
@end lisp
@end defun


@defun hashtable->alist @var{table}
@defunx hashtable->alist @var{table} @var{compar}
Build and return an alist holding the keys and values of @var{table}.
This function is mostly useful for debugging.

If the optional argument @var{compar} is the boolean @false{}: just
return the alist; if it is a procedure: sort the resulting alist with
the standard @func{list-sort} using @var{compar} as comparison predicate
for the keys.
@end defun


@defun {alist->hashtable!} @var{table} @var{al}
Fill @var{table} with the entries of the alist @var{al}.  Return
@var{table} itself.
@end defun

@c page
@node iklib hashtables hashfun
@subsection Additional hash functions


@defun bytevector-hash @var{bv}
@defunx bytevector-hash @var{bv} @var{max-len}
Return a non--negative fixnum representing the hash value for @var{bv},
based on its current contents.  When creating hash tables using
bytevectors as keys: this hash function is suitable for use with
@func{bytevector=?} as an equivalence function.

About the @var{max-len} argument:

@itemize
@item
When @var{max-len} is a non--negative fixnum: it is the maximum number
of bytes to use to compute the hash value, starting from the beginning
of @var{bv}.  If the length of @var{bv} is greater than @var{max-len}:
only the first @var{max-len} bytes are used.  If the length of @var{bv}
is less than or equal to @var{max-len}: all the bytes in @var{bv} are
used.

@item
When @var{max-len} is @false{} or not present: if the length of @var{bv}
is greater than @math{256} bytes, only the first @math{256} bytes are
used to compute the hash.

@item
When @var{max-len} is @true{}: all the bytes in @var{bv} are used.
@end itemize

@strong{NOTE} When the hash value is computed using a number of bytes
@math{N} less than the bytevector length: applications @strong{must not}
assume that two bytevectors having the first @math{N} bytes equal will
have the same hash value.
@end defun


@defun char-hash @var{ch}
@defunx char-ci-hash @var{ch}
Hash function for characters.  @func{char-ci-hash} first applies
@func{char-foldcase} to @var{ch}.
@end defun


@defun boolean-hash @var{bool}
Hash function for booleans.
@end defun


@defun fixnum-hash @var{fx}
Hash function for fixnums.
@end defun


@defun exact-integer-hash @var{N}
Hash function for exact integers, fixnums and bignums.
@end defun


@defun flonum-hash @var{fl}
Hash function for flonums.
@end defun


@defun number-hash @var{Z}
Hash function for number objects.
@end defun


@defun struct-hash @var{stru}
Hash function for @value{PRJNAME} structs.  This is a very low quality
hash function.
@end defun


@defun record-hash @var{reco}
Hash function for @rnrs{6} records.  This is a very low quality hash
function.
@end defun


@defun void-hash @var{obj}
@defunx eof-object-hash @var{obj}
@defunx would-block-hash @var{obj}
Ignore @var{obj} and return a non--negative exact integer representing
the hash value for @code{(void)}, @code{(eof-object)} and
@code{(would-block-object)}.
@end defun


@defun object-hash @var{obj}
Hash function for any Scheme object.  For some object types: this is a
very low quality hash function.
@end defun


@defun pointer-value @var{obj}
This is used by @func{eq?} hashtables to obtain a fixnum from references
to objects that are meant to be compared with @func{eq?}.
@end defun

@c page
@node iklib load
@section Loading source files


Loading of source files can be done explicitly or by requesting a
library with the @func{import} form.  Here we see how to load files by
specifying their pathname on the file system.


@defun load @var{pathname}
@defunx load @var{pathname} @var{eval-proc}
Read and evaluate the file selected by the string @var{pathname}.

If @var{eval-proc} is given: it must be a procedure that takes a single
argument, an annotated form, and evaluates it.  The default
@var{eval-proc} looks like this:

@example
(define (load-handler x)
  (eval x (interaction-environment)))
@end example

The format of the annotated source is the one which is comprehensible by
@func{eval}.
@end defun

@c page
@node iklib modules
@section Local modules


Modules are somewhat like libraries in that they define a set of
bindings in a ``private namespace''; bindings can be exported from a
module and imported into other modules and libraries.  The main
difference between modules and @rnrs{6} libraries is that modules are
defined in a single form nested into a library; so, in a way, they are
sub--libraries.


@deffn Syntax module @meta{interface} @meta{definition} ... @meta{expression} ...
@deffnx Syntax module @meta{name} @meta{interface} @meta{definition} ... @meta{expression} ...
Define a new local module.  The first form defines an @emph{anonymous}
module, while the second form defines a @emph{named} module called
@meta{name}, which must be a symbol.

@meta{interface} is a list of symbols selecting bindings from this
module to be exported; every listed symbol must be bound in this
module's @meta{definition}, otherwise an error is raised.

@meta{definition} is a set of bindings like the one that may appear at
the beginning of a @func{let} body, with the addition of @func{import}
forms that may import bindings from libraries and other modules.

@meta{expression} is a set of expressions that is evaluated at module's
definition time.

Modules ``exist'' only in the enclosing region, bindings exported from a
module are not accessible outside of the enclosing region.  Modules can
be nested and import/export relations are possible according to the
regions nesting hierarchy.

Bindings in the @meta{interface} declared by anonymous modules are
imported by default in the enclosing region: there is no need to use
@func{import}.  Bindings in the @meta{interface} declared by named
modules are visible only in regions that @func{import} the module.

@meta{definition} and @meta{expression} have no default access to the
bindings in the enclosing region; only imported bindings are visible
from the module.
@end deffn

@c ------------------------------------------------------------

@subsubheading Examples of anonymous modules

The following example defines an anonymous module, without expressions,
and invokes its functions from the enclosing region (which is the top
level):

@example
(import (vicare))

(module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (cons 'three (hidden)))
    (define (hidden)    'hidden))

(fprintf (current-error-port)
         "calling anonymous: ~s ~s ~s\n" (one) (two) (three))
@end example

@noindent
notice that the @func{hidden} function is visible inside the module but
not in the enclosing region.

The following example defines a module, with expressions, and invokes
its functions from the enclosing region (which is the top level):

@example
(import (vicare))

(module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (cons 'three (hidden)))
    (define (hidden)    'hidden)

    (fprintf (current-error-port)
             "defining an anonymous module\n"))

(fprintf (current-error-port)
         "calling anonymous: ~s ~s ~s\n" (one) (two) (three))
@end example

@noindent
notice that when the enclosing region is the top level: the expressions
at the end of a module are evaluated @strong{after} the expressions at
the top level; so the output from the example is:

@example
calling anonymous: one two (three . hidden)
defining an anonymous module
@end example

@noindent
this can lead to undesired results if the module's expressions are meant
to initialise the state of the module, and the expressions at the top
level invoke the module's functions (before initialisation).  On the
other hand: this behaviour allows the module to access definitions from
the enclosing region and the top level region despite their placement in
the file; see below for an example.  The same behaviour is shown by
named modules.

The following example defines a module, with expressions, and invokes
its functions from the enclosing region (which is a @func{let} form):

@example
(import (vicare))

(let ()
  (module (one two three)
      (define (one)       'one)
      (define (two)       'two)
      (define (three)     (cons 'three (hidden)))
      (define (hidden)    'hidden)

      (printf (current-error-port)
              "defining an anonymous module\n"))

  (fprintf (current-error-port)
           "calling anonymous: ~s ~s ~s\n" (one) (two) (three)))
@end example

@noindent
notice that when the enclosing region is @strong{not} the top level: the
expressions at the end of a module are evaluated @strong{before} the
expressions in the body of the enclosing region; so the output from the
example is:

@example
defining an anonymous module
calling anonymous: one two (three . hidden)
@end example

@noindent
so the state of the module can be correctly initialised before its
functions are invoked.  The same behaviour is shown by named modules.

The following example shows that bindings from the enclosing region and
the top level environment are accessible from the modules:

@example
(import (vicare))

(define (top-level-before) 'top-level-before)

(let ()

  (define (outer-before) 'outer-before)

  (module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (list 'three
                              (outer-before)
                              (outer-after)
                              (top-level-before)
                              (top-level-after))))

  (define (outer-after) 'outer-after)

  (fprintf (current-error-port)
           "calling anonymous: ~s ~s ~s\n" (one) (two) (three)))

(define (top-level-after) 'top-level-after)
@end example

@noindent
this happens both when the enclosing region is the top level and when
the enclosing region is not the top level.  The same behaviour is shown
by named modules.

@c ------------------------------------------------------------

@subsubheading Named modules


The following example defines a module named @code{blue} and invokes
functions from it in the top level region:

@example
(import (vicare))

(module blue (blue-one blue-two blue-three)
    (define (blue-one)          'blue-one)
    (define (blue-two)          'blue-two)
    (define (blue-three)        (cons 'blue-three (hidden)))
    (define (hidden)            'blue-hidden))

(import blue)
(fprintf (current-error-port)
         "calling blue: ~s ~s ~s\n"
         (blue-one) (blue-two) (blue-three))
@end example

@noindent
notice that bindings from a named module are accessible only if imported
in the enclosing region.

The following example defines two modules named @code{green} and
@code{red}, then it imports their bindings in different regions:

@example
(import (vicare))

(let ()

  (module green (one two three)
    (define (one)       'green-one)
    (define (two)       'green-two)
    (define (three)     (cons 'green-three (hidden)))
    (define (hidden)    'green-hidden))

  (module red (one two three)
    (define (one)       'red-one)
    (define (two)       'red-two)
    (define (three)     (cons 'red-three (hidden)))
    (define (hidden)    'red-hidden))

  (import green)

  (let ()
    (import red)
    (fprintf (current-error-port)
             "calling red: ~s ~s ~s\n" (one) (two) (three)))

  (fprintf (current-error-port)
           "calling green: ~s ~s ~s\n" (one) (two) (three)))
@end example

The following example shows that modules in the same enclosing region
can import their bindings:

@example
(import (vicare))

(let ()

  (module green (one two)
    (define (one)       'one)
    (define (two)       'two))

  (module red (f g)
    (import green)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two))))

  (import red)
  (fprintf (current-error-port)
           "calling red: ~s ~s\n" (f) (g)))
@end example

@noindent
while the following example shows that bindings from an anonymous module
are automatically available in modules defined in the same enclosing
region:

@example
(import (vicare))

(let ()

  (module (one two)
    (define (one)       'one)
    (define (two)       'two))

  (module red (f g)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two))))

  (import red)
  (fprintf (current-error-port)
           "calling red: ~s ~s\n" (f) (g)))
@end example

@noindent
and the following example shows that the order of module definitions
does not matter in determining visibility of bindings from
@strong{anonymous} modules:

@example
(import (vicare))

(let ()

  (module red (f g)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two))))

  (module (one two)
    (define (one)       'one)
    (define (two)       'two))

  (import red)
  (fprintf (current-error-port)
           "calling red: ~s ~s\n" (f) (g)))
@end example

@noindent
the following is an @strong{error} because it tries to import bindings
from a @strong{named} module before its definition:

@example
(import (vicare))

(let ()

  (module red (f g)
    (import green) ;; error here!!!
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two))))

  (module green (one two)
    (define (one)       'one)
    (define (two)       'two))

  (import red)
  (fprintf (current-error-port)
           "calling red: ~s ~s\n" (f) (g)))
@end example

@c ------------------------------------------------------------

@subsubheading Utilities examples


The following example shows how syntactic abstractions can be used to
access definitions in a module without explicitly using the
@func{import} form:

@example
(import (vicare))

(let ()

  (define-syntax in-module
    (syntax-rules ()
      ((_ ?module ?expr ...)
       (let () (import ?module) ?expr ...))))

  (module red (one two)
    (define (one arg)   (cons 'red-one arg))
    (define (two arg)   (cons 'red-two arg)))

  (module green (one two)
    (define (one arg)   (cons 'green-one arg))
    (define (two arg)   (cons 'green-two arg)))

  (fprintf (current-error-port)
           "calling ones: ~s ~s\n"
           ((in-module red one)   123)
           ((in-module green one) 456)))
@end example

@c page
@node iklib parameters
@section Parameters


Parameters in @value{PRJNAME} are intended for customizing the behavior
of a procedure during the dynamic execution of some piece of code.
Parameters are first class entities (represented as procedures) that
hold the parameter value.  We can think of a parameter function as:

@example
(let ((the-value @meta{init-value})
      (guard     @meta{guard-func}))
  (case-lambda
    (()
     the-value)
    ((new-value)
     (set! the-value (guard new-value)))
    ((new-value guard?)
     (if guard?
         (set! the-value (guard new-value))
       (set! the-value new-value)))))
@end example

@noindent
where @meta{init-value} is the parameter's initialisation value and
@meta{guard-func} is a function accepting one argument and returning one
value.  The behaviour is as follows:

@itemize
@item
When applied to no arguments: the parameter function returns the current
value of the parameter.

@item
When applied to a single argument: the parameter function sets the
current value of the parameter to the return value of the guard function
applied to the argument.

@item
When applied to two arguments: the parameter function sets the current
value of the parameter to either the return value of the guard function
applied to the first argument or directly to the first argument without
applying the guard function.
@end itemize

Parameter functions are created by @func{make-parameter}; the
parameter's initialisation value is @strong{not} automatically passed
through the guard function by @func{make-parameter}.  About guarding or
not the initialisation value there are pros and cons for both the
choices; @value{PRJNAME} does not guard the initialisation value because
a parameter can be used to hold ``complex'' objects and it is not always
desirable to create one of those at program start time.  When needed it
is possible to validate the value by explicitly writing the required
predicate.

@quotation
As example, consider a parameter used to hold the ``current database
connection''; we may not want to connect to a database right at program
start time.  With a validating parameter: we should create a ``null''
connection object for the only purpose of initialising the parameter and
then test for it; with a non--validating parameter: we just initialise
the parameter to @false{}.
@end quotation

Parameters replace the older concept of using starred @code{*global*}
customization variables.  For example, instead of writing:

@example
(define *screen-width* 72)
@end example

@noindent
and then mutating the variable @code{*screen-width*} with @code{set!},
we could wrap the variable @code{*screen-width*} with a
@code{screen-width} parameter as follows:

@example
(define *screen-width* 72)
(define screen-width
   (case-lambda
     (()  *screen-width*)
     ((x) (set! *screen-width* x))))
@end example

@noindent
the value of @code{screen-width} can now be passed as argument, returned
as a value, and exported from libraries.  With parameters we can write
this code succinctly as:

@example
(define screen-width (make-parameter 72))
@end example

Typical uses of the guard function include checking some constraints on
the passed argument or converting it to a different data type.  The
@code{screen-width} parameter may be constructed more robustly as:

@example
(define screen-width
  (make-parameter 72
    (lambda (w)
      (assert (and (integer? w) (exact? w)))
      (max w 1))))
@end example

@noindent
this definition ensures, through @func{assert}, that the argument passed
is an exact integer; it also ensures, through @func{max} that the
assigned value is always positive.


@deffn Procedure make-parameter @var{init}
@deffnx Procedure make-parameter @var{init} @var{guard}
Build and return a new parameter function using @var{init} as
initialisation value and @var{guard} as guard function.
@end deffn


@deffn Syntax parametrise ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
@deffnx Syntax parameterize ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
@deffnx Syntax parameterise ((@meta{lhs} @meta{rhs}) @dots{}) @metao{body} @meta{body} @dots{}
Parameters can be assigned to by simply calling the parameter procedure
with a single argument.  The @func{parameterize} syntax is used to set
the value of a parameter within the dynamic extent of the @code{body
body* ...} expressions.

The @code{lhs* ...} are expressions, each of which must evaluate to a
parameter.  Such parameters are not necessarily constructed by
@func{make-parameter}---any procedure that follows the parameters
protocol works.

The advantage of using @func{parameterize} over explicitly assigning to
parameters (same argument applies to global variables) is that you're
guaranteed that whenever control exits the body of a @func{parameterize}
expression, the value of the parameter is reset back to what it was
before the body expressions were entered.  This is true even in the
presence of @func{call/cc}, errors, and exceptions.

The following example shows how to set the text property of a terminal
window.  The parameter @code{terminal-property} sends an @ansi{} escape
sequence to the terminal whenever the parameter value is changed.  The
use of @code{terminal-property} within @func{parameterize} changes the
property before @code{(display "RED!")} is called and resets it back to
normal when the body returns.

@example
(define terminal-property
  (make-parameter "0"
    (lambda (x)
      (display "\x1b;[")
      (display x)
      (display "m")
      x)))

(display "Normal and ")
(parameterize ((terminal-property "41;37"))
  (display "RED!"))
(newline)
@end example

Notice that this syntax applies the parameters' guard functions when
setting new values, but does @strong{not} apply them when restoring the
original value.
@end deffn

@c page
@node iklib gensym
@section Gensyms


Gensym stands for @emph{generated symbol}---a fresh symbol that is
generated at run time and is guaranteed to be @emph{not} @func{eq?} to
any other symbol present in the system.  Gensyms are useful in many
applications including expanders, compilers, and interpreters when
generating an arbitrary number of unique names is needed.

@value{PRJNAME} is similar to Chez Scheme in that the readers (including the
@func{read} procedure) and writers (including @func{write} and
@func{pretty-print}) maintain the read/write invariance on gensyms.
When a gensym is written to an output port, the system automatically
generates a random unique identifier for the gensym.  When the gensym is
read back though the @code{#@{gensym@}} read syntax, a new gensym is
@emph{not} regenerated, but instead, it is looked up in the global
symbol table.

A gensym's name is composed of two parts: a @emph{pretty} string and a
@emph{unique} string.  The Scheme procedure @func{symbol->string}
returns the pretty string of the gensym and not its unique string.
Gensyms are printed by default as @code{#@{pretty-string unique-string@}}.

The reader supports special syntaxes to generate symbols, @ref{iklib
reader stx}.


@deffn Procedure gensym
@deffnx Procedure gensym @var{string}
@deffnx Procedure gensym @var{symbol}
Construct a new gensym.  If passed no arguments, construct a gensym with
no pretty name.  The pretty name is constructed when and if the pretty
name of the resulting gensym is needed.  If @func{gensym} is passed a
string, that string is used as the pretty name.  If @func{gensym} is
passed a symbol, the pretty name of the symbol is used as the pretty
name of the returned gensym.  See @func{gensym-prefix} and
@func{gensym-count} for details.

@example
> (gensym)
#@{g0 |y0zf>GlFvcTJE0xw|@}
> (gensym)
#@{g1 |U%X&sF6kX!YC8LW=|@}
> (eq? (gensym) (gensym))
#f
@end example

@code{(gensym string)} constructs a new gensym with @var{string} as its
pretty name.  Similarly, @code{(gensym symbol)} constructs a new gensym
with the pretty name of @var{symbol}, if it has one, as its pretty name.

@example
> (gensym "foo")
#@{foo |>VgOllCM&$dSvRN=|@}
> (gensym 'foo)
#@{foo |!TqQLmtw2hoEYfU>|@}
> (gensym (gensym 'foo))
#@{foo |N2C>5O0>C?OROUBU|@}
@end example
@end deffn


@deffn Procedure gensym? @var{x}
Return @true{} if its argument is a gensym, return @false{} otherwise.

@example
> (gensym? (gensym))
#t
> (gensym? 'foo)
#f
> (gensym? 12)
#f
@end example
@end deffn


@deffn Procedure gensym->unique-string @var{gensym}
Return the unique name associated with the gensym argument.

@example
> (gensym->unique-string (gensym))
"YukrolLMgP?%ElcR"
@end example
@end deffn

@c ------------------------------------------------------------

@subsubheading An example

The @library{rnrs syntax-case} library provides a
@func{generate-temporaries} procedure, which takes a syntax object
(representing a list of things) and returns a list of fresh identifiers.
Using @func{gensym}, that procedure can be defined as follows:

@example
(define (generate-temporaries* stx)
  (syntax-case stx ()
    [(x* ...)
     (map (lambda (x)
            (datum->syntax #'unimportant
              (gensym
                (if (identifier? x)
                    (syntax->datum x)
                    't))))
          #'(x* ...))]))
@end example

The above definition works by taking the input @var{stx} and
destructuring it into the list of syntax objects @code{x* ...}.  The
inner procedure maps each @var{x} into a new syntax object (constructed
with @func{datum->syntax}).  The datum is a gensym, whose name is the
same name as @var{x} if @var{x} is an identifier, or the symbol @code{t}
if @var{x} is not an identifier.  The output of
@func{generate-temporaries*} generates names similar to their input
counterpart:

@example
> (print-gensym #f)
> (generate-temporaries* #'(x y z 1 2))
(#<syntax x> #<syntax y> #<syntax z> #<syntax t> #<syntax t>)
@end example

@c page
@node iklib printing
@section Printing


@menu
* iklib printing formatting::   Formatting and printing strings.
* iklib printing pretty::       Pretty printing Scheme objects.
* iklib printing debug::        Printing for debugging.
@end menu

@c page
@node iklib printing formatting
@subsection Formatting and printing strings


@defun format @var{template} @var{arg} @dots{}
Build and return a new string formatted according to the template in the
string @var{template} and the supplied arguments.  The template string
contains markers in which the string representation of each argument is
placed.  The markers include:

@table @code
@item ~s
Instructs the formatter to place the next argument as if the procedure
@func{write} has printed it; if the argument contains a string, the
string will be quoted and all quotes and backslashes in the string will
be escaped; similarly, characters will be printed using the @code{#\x}
notation.

@item ~a
Instructs the formatter to place the next argument as if the procedure
@func{display} has printed it; strings and characters are placed as they
are in the output.

@item ~b
Instructs the formatter to convert the next argument to its binary (base
2) representation; the argument must be an exact number.

@item ~o
Similar to @code{~b} except that the number is printed in octal (base
8).

@item ~x
Similar to @code{~b} except that the number is printed in hexadecimal
(base 16).

@item ~d
Outputs the next argument, which can be an exact or inexact number, in
its decimal (base 10) representation.

@item ~~
Instructs the formatter to place a tilde character, @code{~}, in the
output without consuming an argument.

@item ~%
Instructs the formatter to place a newline character in the output
without consuming an argument.
@end table

Note that the @code{#b}, @code{#o}, and @code{#x} numeric prefixes are
not added to the output when @code{~b}, @code{~o}, and @code{~x} are
used.

@example
> (format "message: ~s, ~s, and ~s" 'symbol "string" #\c)
"message: symbol, \"string\", and #\\c"

> (format "message: ~a, ~a, and ~a" 'symbol "string" #\c)
"message: symbol, string, and c"
@end example
@end defun


@defun printf @var{template} @var{arg} @dots{}
Similar to @func{format} except that the output is sent to the
@code{current-output-port} instead of being collected in a string.

@example
> (let ([n (+ (expt 2 32) #b11001)])
    (printf "~d = #b~b = #x~x\n" n n n))
4294967321 = #b100000000000000000000000000011001 = #x100000019
@end example
@end defun


@defun fprintf @var{output-port} @var{template} @var{arg} @dots{}
Similar to @func{printf} except that the textual output port to which
the output is sent is specified as the first argument.
@end defun

@c page
@node iklib printing pretty
@subsection Pretty printing Scheme objects


@defun pretty-print @var{datum}
@defunx pretty-print @var{datum} @var{output-port}
Printi Scheme data, typically Scheme programs, in a format close to how
a Scheme programmer would write it.  Unlike @func{write}, which writes
its input all in one line, @func{pretty-print} inserts spaces and new
lines in order to produce more pleasant output.

@example
(define fact-code
  '(letrec ([fact (lambda (n)
                    (if (zero? n)
                        1
                      (* n (fact (- n 1)))))])
     (fact 5)))

> (pretty-print fact-code)
(letrec ((fact
          (lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))))
  (fact 5))
@end example

The second argument to @func{pretty-print}, if supplied, must be an open
textual output port.  If not supplied, the @func{current-output-port} is
used.
@end defun


@defun pretty-print* @var{datum} @var{output-port} @var{start-column} @var{ending-newline?}
Like @func{pretty-print} but accepts the additional arguments:

@table @var
@item start-column
A non--negative fixnum.  The zero--based column offset at which the
first line is displayed.  When printing a multiline symbolic expression,
the column offset of the first line depends upon what has been already
printed on such line; this argument allows us to correctly align the
second and subsequent lines.  For example the following program:

@example
#!r6rs
(import (vicare))

(pretty-width 10)
(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))

(display "01234")
(pretty-print  '("56789" "8 7 6 5"))

(newline)

(display "01234")
(pretty-print* '("56789" "8 7 6 5")
               (current-output-port) 5 #t)
@end example

@noindent
prints:

@example
01234("56789"
  "8 7 6 5")

01234("56789"
       "8 7 6 5")
@end example

@item ending-newline?
Interpreted as boolean value.  If true: a newline character is output
after the symbolic expression.
@end table
@end defun


@deffn Parameter pretty-width
@deffnx Parameter pretty-width @var{n}
@cindex Parameter @func{pretty-width}
The parameter @func{pretty-width} controls the number of characters
after which the @func{pretty-print} starts breaking long lines into
multiple lines.  The initial value of @func{pretty-width} is set to 60
characters, which is suitable for most terminals and printed material.

@example
> (parameterize ([pretty-width 40])
     (pretty-print fact-code))
(letrec ((fact
          (lambda (n)
            (if (zero? n)
                1
                (* n (fact (- n 1)))))))
  (fact 5))
@end example

Note that @func{pretty-width} does not guarantee that the output will
not extend beyond the specified number.  Very long symbols, for
examples, cannot be split into multiple lines and may force the printer
to go beyond the value of @func{pretty-width}.
@end deffn


@defun pretty-format @var{obj}
Still undocumented.
@end defun


@deffn Parameter print-unicode
@deffnx Parameter print-unicode #t
@deffnx Parameter print-unicode #f
@cindex Parameter @func{print-unicode}
If set to true: print Scheme Unicode characters outside of the printable
@ascii{} range in hex format, else print them using the encoding of the
output port.  This parameter is initialised to @false{}.
@end deffn


@deffn Parameter printer-integer-radix
@cindex Parameter @func{printer-integer-radix}
The radix used to print exact integers (fixnums and bignums) with
@func{write}, @func{display} and similar functions.  Initialised to
@code{10}, it must hold a value usable as second argument to
@func{string->number}.
@end deffn


@deffn Parameter print-gensym
@deffnx Parameter print-gensym #t
@deffnx Parameter print-gensym #f
@deffnx Parameter print-gensym 'pretty
@cindex Parameter @func{print-gensym}
Control how gensyms are printed by the various writers.

@itemize
@item
If the value is @false{}: gensym syntax is suppressed by the writers and
only the gensyms' pretty names are printed.

@item
If the value is @true{}: the full @code{#@{pretty unique@}} syntax is
printed.

@item
If the value is the symbol @code{pretty}: then gensyms are printed using
the @code{#:pretty} notation.
@end itemize

This parameter is initialised to @true{}.  Examples:

@example
> (parametrise ((print-gensym #f))
    (pretty-print (list (gensym) (gensym))))
(g0 g1)

> (parametrise ((print-gensym #t))
    (pretty-print (list (gensym) (gensym))))
(#@{g2 |KR1M2&CTt1<B0n/m|@} #@{g3 |FBAb&7NC6&=c82!O|@})

> (parametrise ((print-gensym 'pretty))
    (pretty-print (list (gensym) (gensym))))
(#:g4 #:g5)
@end example
@end deffn


@deffn Parameter gensym-prefix
@deffnx Parameter gensym-prefix @var{string}
@cindex Parameter @func{gensym-prefix}
Specify the string to be used as the prefix to generated pretty names.
The initialisation value is the string @samp{g}, which causes generated
strings to have pretty names in the sequence @samp{g0}, @samp{g1},
@samp{g2}, etc.

@example
> (parametrise ((gensym-prefix "var")
                (print-gensym  #f))
    (pretty-print (list (gensym) (gensym) (gensym))))
(var0 var1 var2)
@end example

This parameter controls how pretty names are generated, and has nothing
to do with how @func{gensym} constructs a new gensym; in particular,
knowing that it is @func{pretty-print} that generates the pretty names,
notice the difference between the output in the first example with the
output of the examples below:

@example
> (pretty-print
    (parametrise ((gensym-prefix "var")
                  (print-gensym  #f))
      (list (gensym) (gensym) (gensym))))
(g3 g4 g5)

> (let ((ls (list (gensym) (gensym) (gensym))))
    (parametrise ((gensym-prefix "var")
                  (print-gensym  #f))
      (pretty-print ls)))
(var5 var6 var7)
@end example
@end deffn


@deffn Parameter gensym-count
@deffnx Parameter gensym-count @var{n}
@cindex Parameter @func{gensym-count}
Determine the number which is attached to the @func{gensym-prefix} when
gensyms' pretty names are generated.  The initialisation value is
@samp{0} and it is incremented every time a pretty name is generated.
It might be set to any non--negative integer value.

@example
> (let ((x (gensym)))
    (parametrise ((gensym-count 100)
                  (print-gensym #f))
      (pretty-print (list (gensym) x (gensym)))))
(g100 g101 g102)
@end example
@end deffn


Notice from all the examples so far that pretty names are generated in
the order at which the gensyms are printed, not in the order in which
gensyms were created.

@c page
@node iklib printing debug
@subsection Printing for debugging


@defun debug-print . @var{args}
Print the given arguments on the current error port using
@func{pretty-print}.  This is a convenience function, useful while
debugging code.
@end defun


@deffn Parameter debug-print-enabled?
@cindex Parameter @func{debug-print-enabled?}
When set to true, @func{debug-print*} will print its arguments.  It is
initialised to @false{}.  We can set this parameter to any value,
internally the value is normalised to @true{} or @false{}.
@end deffn


@defun debug-print* . @var{args}
Like @func{debug-print}, but print arguments only when the parameter
@func{debug-print-enabled?} is set to true.
@end defun

@c page
@node iklib tracing
@section Tracing for debugging


@deffn Syntax trace-define (name . args) body body* ...
@deffnx Syntax trace-define name expression
The @func{trace-define} syntax is similar to @func{define} except that
the bound value, which must be a procedure, becomes a traced procedure.
A traced procedure prints its arguments when it is called and prints its
values when it returns.

@example
> (trace-define (fact n)
    (if (zero? n) 1 (* n (fact (- n 1)))))
> (fact 5)
|(fact 5)
| (fact 4)
| |(fact 3)
| | (fact 2)
| | |(fact 1)
| | | (fact 0)
| | | 1
| | |1
| | 2
| |6
| 24
|120
120
@end example

The tracing facility in @value{PRJNAME} preserves and shows tail recursion and
distinguishes it from non--tail recursion by showing tail calls starting
at the same line in which their parent was called.

@example
> (trace-define (fact n)
    (trace-define (fact-aux n m)
      (if (zero? n) m (fact-aux (- n 1) (* n m))))
    (fact-aux n 1))
> (fact 5)
|(fact 5)
|(fact-aux 5 1)
|(fact-aux 4 5)
|(fact-aux 3 20)
|(fact-aux 2 60)
|(fact-aux 1 120)
|(fact-aux 0 120)
|120
120
@end example

Moreover, the tracing facility interacts well with continuations and
exceptions.

@example
> (call/cc
    (lambda (k)
      (trace-define (loop n)
        (if (zero? n)
            (k 'done)
            (+ (loop (- n 1)) 1)))
      (loop 5)))
|(loop 5)
| (loop 4)
| |(loop 3)
| | (loop 2)
| | |(loop 1)
| | | (loop 0)
done
@end example
@end deffn


@deffn Syntax trace-lambda name args body body* ...
The @func{trace-lambda} macro is similar to @func{lambda} except that
the resulting procedure is traced: it prints the arguments it receives
and the results it returns.
@end deffn


@deffn Procedure make-traced-procedure @var{name} @var{proc}
The procedure @func{make-traced-procedure} takes a name (typically a
symbol) and a procedure.  It returns a procedure similar to @var{proc}
except that it traces its arguments and values.

@example
> (define (fact n)
    (if (zero? n)
        (lambda (k) (k 1))
        (lambda (k)
          ((fact (- n 1))
           (make-traced-procedure `(k ,n)
             (lambda (v)
               (k (* v n))))))))
> (call/cc
    (lambda (k)
      ((fact 5) (make-traced-procedure 'K k))))
|((k 1) 1)
|((k 2) 1)
|((k 3) 2)
|((k 4) 6)
|((k 5) 24)
|(K 120)
120
@end example
@end deffn


@deffn Syntax trace-define-syntax @meta{keyword} @meta{expression}
Like @func{define-syntax} but create a tracing transformer function.
Whenever the macro is expanded the transformer function will print its
argument (the input form) and its return value (the output form).
Example:

@example
(trace-define-syntax ciao
  (syntax-rules ()
    ((_ ?a)
     (list 1 ?a 3))))

(ciao 2)
@print{} |(ciao (ciao 2))
@print{} |(list 1 2 3)
@end example

@noindent
the first printed symbolic expression @code{(ciao (ciao 2))} shows the
called tranformer function @code{(ciao ---)} and its argument being the
input form @code{(ciao 2)}, filtered through @func{syntax->datum}.
@end deffn


@deffn Syntax trace-let-syntax @meta{bindings} @meta{form} ...
@deffnx Syntax trace-letrec-syntax @meta{bindings} @meta{form} ...
Like @func{let-syntax} and @func{letrec-syntax} but define tracing
transformer functions.
@end deffn

@c page
@node iklib timing
@section Timing


This section describes some of @value{PRJNAME}'s timing facilities which may be
useful for benchmarking and performance tuning.


@deffn Syntax time @var{expression}
The @func{time} macro performs the following: it evaluates
@var{expression}, then prints a summary of the run time statistics, then
returns the values returned by @var{expression}.  The run--time summary
includes the number of bytes allocated, the number of garbage collection
runs, and the time spent in both the mutator and the collector.

@example
> (let ()                                   ;;; 10 million
    (define ls (time (vector->list (make-vector 10000000))))
    (time (append ls ls))
    (values))
running stats for (vector->list (make-vector 10000000)):
    3 collections
    672 ms elapsed cpu time, including 547 ms collecting
    674 ms elapsed real time, including 549 ms collecting
    120012328 bytes allocated
running stats for (append ls ls):
    4 collections
    1536 ms elapsed cpu time, including 1336 ms collecting
    1538 ms elapsed real time, including 1337 ms collecting
    160000040 bytes allocated
@end example

@quotation
@emph{Note:} The output listed above is @emph{just a sample} that was
taken at some point on some machine.  The output on your machine at the
time you read this may vary.
@end quotation
@end deffn


@deffn Procedure time-it @var{message} @var{thunk}
The procedure @func{time-it} takes a datum denoting the name of the
computation and a thunk (i.e. a procedure with no arguments), invokes
the thunk, prints the stats, and returns the values obtained from
invoking the thunk.  If the value of @var{message} is true,
@var{message} is used when displaying the run--time statistics; if the
value of @var{message} is @false{}, then no name for the computation is
displayed.

@example
> (time-it "a very fast computation"
    (lambda () (values 1 2 3)))
running stats for a very fast computation:
    no collections
    0 ms elapsed cpu time, including 0 ms collecting
    0 ms elapsed real time, including 0 ms collecting
    24 bytes allocated
1
2
3

> (time-it #f (lambda () 12))
running stats:
    no collections
    0 ms elapsed cpu time, including 0 ms collecting
    0 ms elapsed real time, including 0 ms collecting
    0 bytes allocated
12
@end example
@end deffn


@defun time-and-gather @var{gather} @var{thunk}
Like @func{time-it} evaluate the procedure @var{thunk} timing its
execution; return the return values of @var{thunk}.  Build two objects
of type @code{stats} and apply the procedure @var{gather} to them: the
first represents the statistics before @var{thunk} evaluation, the
second represents the statistics after @var{thunk} evaluation.
@end defun


@deffn Parameter verbose-timer
@cindex Parameter @func{verbose-timer}
When set to non--false: print more informations as result of
@func{time-it} and @func{time-and-gather}.
@end deffn


@defun stats? @var{obj}
Return true if @var{obj} is an object of type @code{stats}.
@end defun


All the fields of a @code{stats} object hold fixnums.


@defun stats-user-secs @var{stats}
Return the user seconds field of @var{stats}.
@end defun


@defun stats-user-usecs @var{stats}
Return the user microseconds field of @var{stats}.
@end defun


@defun stats-sys-secs @var{stats}
Return the system seconds field of @var{stats}.
@end defun


@defun stats-sys-usecs @var{stats}
Return the system microseconds field of @var{stats}.
@end defun


@defun stats-real-secs @var{stats}
Return the real seconds field of @var{stats}.
@end defun


@defun stats-real-usecs @var{stats}
Return the real microseconds field of @var{stats}.
@end defun


@defun stats-collection-id @var{stats}
Return the collection identifier field of @var{stats}.
@end defun

@defun stats-gc-user-secs @var{stats}
Return the garbage collection user seconds field of @var{stats}.
@end defun


@defun stats-gc-user-usecs @var{stats}
Return the garbage collection user microseconds field of @var{stats}.
@end defun


@defun stats-gc-sys-secs @var{stats}
Return the garbage collection system seconds field of @var{stats}.
@end defun


@defun stats-gc-sys-usecs @var{stats}
Return the garbage collection system microseconds field of @var{stats}.
@end defun


@defun stats-gc-real-secs @var{stats}
Return the garbage collection real seconds field of @var{stats}.
@end defun


@defun stats-gc-real-usecs @var{stats}
Return the garbage collection real microseconds field of @var{stats}.
@end defun


@defun stats-bytes-minor @var{stats}
Return the garbage collection bytes minor field of @var{stats}.
@end defun


@defun stats-bytes-major @var{stats}
Return the garbage collection bytes major field of @var{stats}.
@end defun

@c page
@node iklib gc
@section Interfacing with garbage collection


@defun collect
@defunx collect @var{requested-generation}
Explicitly run the garbage collector.  If post--garbage collection hooks
are registered, they are run.  This function does @strong{not} care if
automatic garbage collection is disabled.

The optional argument @var{requested-generation} represents the oldest
objects generation to collect: when @false{} the generation is
determined internally; when a fixnum between @code{0} inclusive and
@code{4} inclusive the fixnum represents the generation, where @code{0}
is the youngest generation and @code{4} is the oldest generation.  The
symbol @samp{fastest} is equivalent to @code{0}, the symbol
@samp{fullest} is equivalent to @code{4}.
@end defun


@defun automatic-collect
@defunx automatic-collect @var{requested-generation}
Like @func{collect}, but @strong{does} care if automatic garbage
collection is disabled.  This function exists mostly for debugging
purposes, to track what happens when automatic garbage collection is
disabled and the collector is invoked.
@end defun


@defun automatic-garbage-collection
@defunx automatic-garbage-collection @var{obj}
When called with one argument: if @var{obj} is @false{}, disable
automatic garbage collection; otherwise enable it.  Return a boolean:
@true{} if automatic garbage collection is enabled; @false{} otherwise.

When called without arguments, return a boolean: @true{} if automatic
garbage collection is enabled, @false{} otherwise.

When automatic garbage collection is disabled: every memory allocation
for Scheme objects is performed by enlarging, when needed, the Scheme
heap's nursery.

We must use with care this function, possibly in conjunction with
@func{collect}: explicitly calling @func{collect} will still perform
garbage collection even when the automatic one is disabled.

Strictly speaking, this function is not a parameter, but its @api{} is
compatible with the one of parameters; so it is possible to use it in a
@syntax{parametrise} syntax:

@lisp
(parametrise ((automatic-garbage-collection #f))
  @meta{body})
@end lisp
@end defun

@c ------------------------------------------------------------

@subsubheading Avoiding garbage collection of objects


The following @api{} allows us to register objects in the internal state
of Vicare so that they are not garbage collected even though we may
loose all the Scheme references to them.

This mechanism is useful when we create a Scheme object and register it
in a data structure controlled by a foreign library (for example when
interfacing with C language libraries); we can loose the Scheme
references to such object without having it garbage collected, and later
we retrieve the object reference and use it.

@center @strong{This @api{} is to be considered experimental.}


@defun register-to-avoid-collecting @var{obj}
Register @var{obj} in the internal state of Vicare so that it is not
garbage collected even when we loose all the Scheme references to it;
return a pointer object which can be used to uniquely identify the
collected @var{obj}.

If @var{obj} is the return value of @code{(void)}: the returned value is
a @cnull{} pointer.
@end defun


@defun forget-to-avoid-collecting @var{pointer}
Remove the Scheme object associated to @var{pointer} from the internal
state of Vicare, so that it is garbage collected when we loose all the
Scheme references to it; return the referenced object.  @var{pointer}
must be the return value of a previous call to
@func{register-to-avoid-collecting}.

If @var{pointer} is @cnull{}: nothing happens and the returned value is
@code{(void)}.
@end defun


@defun retrieve-to-avoid-collecting @var{pointer}
Return the Scheme object associated to @var{pointer} in the internal
state of Vicare.  @var{pointer} must be the return value of a previous
call to @func{register-to-avoid-collecting}.

If @var{pointer} is @cnull{}: nothing happens and the returned value is
@code{(void)}.
@end defun


@defun replace-to-avoid-collecting @var{pointer} @var{new-obj}
Replace the Scheme object associated to @var{pointer} in the internal
state of Vicare with @var{new-obj}; return the previously registered
object.  @var{pointer} must be the return value of a previous call to
@func{register-to-avoid-collecting}.

If @var{pointer} is @cnull{}: nothing happens and the returned value is
@code{(void)}.
@end defun


@defun collection-avoidance-list
Return the list of objects that where registered to avoid collection by
@func{register-to-avoid-collecting}; it can be the empty list.
@end defun


@defun purge-collection-avoidance-list
Reset to empty the list of objects registered to avoid collection with
@func{register-to-avoid-collecting}.  Use with care.
@end defun

@c page
@node iklib guardians
@section Guardians and garbage collection


@cindex Guardians and garbage collection
@cindex Guarded values
@cindex Finalisation of objects through guardians
@cindex Objects finalisation through guardians
@cindex Destruction of objects through guardians
@cindex Objects destruction through guardians
@cindex Destructors, objects and guardians
@cindex Finalisers, objects and guardians


Guardians are available in the @library{vicare} library; quoting
@bibref{DYBGUA}:

@quotation
Guardians provide a means to protect objects from destruction by the
garbage collector.  A guardian is an object with which objects can be
registered for preservation and from which objects actually saved from
destruction can be retrieved, one at a time, at the convenience of the
program.
@end quotation

@menu
* iklib guardians examples::    Usage examples for guardians.
* iklib guardians api::         Guardians programming interface.
@end menu

@c page
@node iklib guardians examples
@subsection Usage examples for guardians


Let's say that we use the @value{PRJNAME} @ffi{} to handle some memory
block (@ref{ffi} for details on the @ffi{}); memory blocks allocated
with @func{malloc} are not released by the @value{PRJNAME} garbage
collector: we have to explicitly apply @func{free} to the pointer value
referencing them.

If we use the blocks synchronously with the evaluation of forms, we do
(assuming we do not use continuations, so this use of
@func{dynamic-wind} is fine):

@example
(import (vicare)
  (vicare ffi))

(define (do-something-with . args)
  (display args)
  (newline))

(let ((p        #f)
      (size     4096))
  (dynamic-wind
      (lambda ()
        (set! p (malloc size))
        (unless p (error #f "memory allocation")))
      (lambda ()
        (do-something-with p))
      (lambda ()
        (free p))))
@end example

@noindent
and we can define a syntax for it:

@example
(import (vicare)
  (vicare ffi))

(define (do-something-with . args)
  (display args)
  (newline))

(define-syntax with-block
  (syntax-rules ()
    ((_ ?pointer ?size ?body ...)
     (let ((?pointer    #f))
       (dynamic-wind
           (lambda ()
             (set! ?pointer (malloc ?size))
             (unless ?pointer (error #f "memory allocation")))
           (lambda ()
             ?body ...)
           (lambda ()
             (free ?pointer)))))))

(with-block p 2048
  (do-something-with p))

(with-block p 4096
  (do-something-with p))

(with-block p 8192
  (do-something-with p))
@end example

If we need the block in an event driven program: we will probably need
to use it asynchronously with the evaluation of forms.  For example, we
store the pointer value that references a block in a thunk (a closure
that takes no arguments):

@example
(import (vicare)
  (vicare ffi))

(define *event-source* '())

(define (enqueue-event event)
  (set! *event-source*
        (reverse (cons event (reverse *event-source*)))))

(define (pop-event)
  (if (null? *event-source*)
      #f
    (let ((event (car *event-source*)))
      (set! *event-source* (cdr *event-source*))
      event)))

;; Usage:

(define (do-something-with . args)
  (display args)
  (newline))

(let ((p (malloc 4096)))
  (unless p (error #f "memory allocation"))
  (enqueue-event (lambda ()
                   (do-something-with p)))
  (enqueue-event (lambda ()
                   (do-something-with 123)))
  (enqueue-event (lambda ()
                   (do-something-with p))))

(do ((event (pop-event) (pop-event)))
    ((not event))
  (event))
@end example

@noindent
once the thunks have been evaluated, the pointer value is garbage
collected, but the allocated memory block becomes leaked memory.  We
need a way to be notified of the pointer value garbage collection, so
that we can apply @func{free} to it; this is the job for guardians.

The following script shows the usage of a guardian to free a memory
block:

@example
(import (vicare)
  (vicare ffi))

(define g (make-guardian))

(let ((a (malloc (expt 2 20))))
  (unless p (error #f "memory allocation"))
  (g a)
  (printf "value ~s~%" a))

(printf "value from guardian ~s~%" (g))

;; This triggers a garbage collection.
(collect)

(let ((p (g)))
  (printf "value from guardian ~s~%" p)
  (free p))
@end example

In an event driven program what we have to do is to register the pointer
into the guardian, and then periodically enqueue as event a call to the
guardian:

@example
(import (vicare)
  (vicare ffi))

;; Event source handling.

(define *event-source* '())

(define (enqueue-event event)
  (set! *event-source*
        (reverse (cons event (reverse *event-source*)))))

(define (pop-event)
  (if (null? *event-source*)
      #f
    (let ((event (car *event-source*)))
      (set! *event-source* (cdr *event-source*))
      event)))

;; Block guardian.

(define block-guardian (make-guardian))

(define (run-block-guardian)
  (do ((p (block-guardian) (block-guardian)))
      ((not p))
    (printf "collecting ~s~%" p)
    (free p)))

;; Application follows.

(define (do-something-with . args)
  (display args)
  (newline))

(let ((p (malloc (expt 2 20))))
  (unless p (error #f "memory allocation"))
  (block-guardian p)
  (enqueue-event (lambda () (do-something-with p)))
  (enqueue-event (lambda () (do-something-with 123)))
  (enqueue-event (lambda () (do-something-with p)))
  (enqueue-event (lambda () (do-something-with 456))))

(do ((event (pop-event) (pop-event))
     (i 1 (+ i 1)))
    ((= i 20))
  (when event
    (event))
  (when (= 0 (modulo i 10))
    (collect)
    (enqueue-event run-block-guardian)))
@end example

@c page
@node iklib guardians api
@subsection Guardians programming interface


@defun make-guardian
Build and return a new guardian object: a closure that can be called
with one or zero arguments, and that is interfaced with the garbage
collector of @value{PRJNAME} in a non--portable way.

The guardian work like this:

@itemize
@item
When the closure is called with one argument: it adds the argument to an
internal set of ``guarded values'', accessible to the garbage collector;
the return value if the argument itself.

@item
When the garbage collector detects no other references to a value in the
set of guarded values: the guardian removes it from the set and appends
it to an internal queue (@acronym{FIFO}).

@item
When the closure is called with zero arguments: it removes the first
value from the internal queue and returns it; if no values are in the
queue it returns @false{}.
@end itemize

After an object has been returned by the guardian, it is no more
``guarded'' so it will be garbage collected when it will become
inaccessible (unless it is again registered in a guardian).

@quotation
@strong{NOTE} It is possible to register an object in more than one
guardian; when the object is found inaccessible all the guardian
closures that have it will return it to the caller.  This may lead to
invalid finalisation operations, it is the responsibility of the
programmer to avoid this.
@end quotation

@quotation
@strong{NOTE} It is possible to register an object multiple times in the
same guardian; when the object is found inaccessible the guardian
closure that has it will return it to the caller multiple times.  This
may lead to invalid finalisation operations, it is the responsibility of
the programmer to avoid this.
@end quotation
@end defun


@deffn Parameter post-gc-hooks
@cindex Parameter @func{post-gc-hooks}
Hold a list of thunks evaluated after each garbage collection run.  It
can be used to run a guardian cleanup function like this (using the
example in the previous section):

@example
(define (run-block-guardian)
  (do ((p (block-guardian) (block-guardian)))
      ((not p))
    (free p)))

(post-gc-hooks
 (cons run-block-guardian
  (post-gc-hooks)))
@end example
@end deffn

@c page
@node iklib engines
@section Engines


@deffn Parameter interrupt-handler
@cindex Parameter @func{interrupt-handler}
Still undocumented.
@end deffn


@deffn Parameter engine-handler
@cindex Parameter @func{engine-handler}
Still undocumented.
@end deffn

@c page
@node iklib io
@section Input/output library


@value{PRJNAME} extends the input/output facilities defined by @rnrs{6}.

@menu
* iklib io pathnames::          String and bytevector pathnames
                                handling.
* iklib io codecs::             Transcoders and additional codecs.
* iklib io non-blocking::       Handling non--blocking devices.
* iklib io binary::             Additional binary port features.
* iklib io textual::            Additional textual port features.
* iklib io buffer::             Buffer size customisation.
* iklib io plists::             Port property lists.
* iklib io misc::               Miscellaneous port functions.
@end menu

@c page
@node iklib io pathnames
@subsection String and bytevector pathnames handling


All the file--related functions defined by @rnrs{6} accept a Scheme
string as representing a file pathname; internally such string is
converted to a bytevector to be handed to the underlying operating
system.

The following bindings are exported by the library @library{vicare}.


@deffn Parameter string->filename-func
@deffnx Parameter string->pathname-func
@cindex Parameter @func{string->filename-func}
@cindex Parameter @func{string->pathname-func}
In @value{PRJNAME} the string--to--filename conversion is performed by
the function returned by @func{string->filename-func}, which defaults to
@func{string->utf8}.
@end deffn


@deffn Parameter filename->string-func
@deffnx Parameter pathname->string-func
@cindex Parameter @func{filename->string-func}
@cindex Parameter @func{pathname->string-func}
In @value{PRJNAME} the filename--to--string conversion is performed by
the function returned by @func{filename->string-func}, which defaults to
@func{utf8->string}.
@end deffn


@defun directory-exists? @var{ptn}
Return @true{} if @var{ptn} is a string or bytevector representing the
pathname of an existent directory; otherwise return @false{}.
@end defun


The following bindings are exported by the library @library{vicare
language-extensions posix}.


@defun file-pathname? @var{obj}
@defunx file-string-pathname? @var{obj}
@defunx file-bytevector-pathname? @var{obj}
Return @true{} if @var{obj} is a string or bytevector, not empty, not
including a character whose @ascii{} representation is the null byte.
@end defun


@defun file-absolute-pathname? @var{pathname}
@defunx file-string-absolute-pathname? @var{pathname}
@defunx file-bytevector-absolute-pathname? @var{pathname}
The argument @var{pathname} must be a string or bytevector.  Return
@true{} if @var{pathname} starts with a @code{/} character, which means
it is valid as Unix--style absolute pathname; otherwise return @false{}.

This function only acts upon its argument, never accessing the file
system.
@end defun


@defun file-relative-pathname? @var{pathname}
@defunx file-string-relative-pathname? @var{pathname}
@defunx file-bytevector-relative-pathname? @var{pathname}
The argument @var{pathname} must be a string or bytevector.  Return
@true{} if @var{pathname} doest @strong{not} start with a @code{/}
character, which means it is valid as Unix--style relative pathname;
otherwise return @false{}.

This function only acts upon its argument, never accessing the file
system.
@end defun


@defun split-pathname-root-and-tail @var{pathname}
Given a string representing a pathname: split it into the directory part
and the tail part.  Return 2 values: a string representing the directory
part and a string representing the tail name part.  If @var{pathname} is
just the name of a file or directory relative to the current directory:
the directory part is empty and the first returned value is the empty
string.

Assume the pathname components separator is @code{/}, which is
Unix--specific.

@example
(receive (root tail)
    (split-pathname-root-and-tail "a/b")
  (list root tail))
@result{} ("a" "b")

(receive (root tail)
    (split-pathname-root-and-tail "ciao")
  (list root tail))
@result{} ("" "ciao")
@end example
@end defun


@defun file-colon-search-path? @var{obj}
@defunx file-string-colon-search-path? @var{obj}
@defunx file-bytevector-colon-search-path? @var{obj}
Return @true{} if @var{obj} is a string or bytevector, possibly empty,
not including a character whose @ascii{} representation is the null
byte.
@end defun


@defun split-search-path @var{path}
@defunx split-search-path-bytevector @var{bytevector-path}
@defunx split-search-path-string @var{string-path}
Split a file search path into its components and return a list of
pathnames.  A search path is meant to be a list of directory pathnames
separated by a colon character; @var{bytevector-path} must be a
bytevector, @var{string-path} must be a Scheme string, @var{path} must
be a Scheme string or bytevector.  Empty pathnames are discarded.

@example
#!vicare
(import (vicare))

(split-search-path-bytevector '#vu8())
@result{} ()

(split-search-path-bytevector #ve(ascii "ciao:hello"))
@result{} (#ve(ascii "ciao") #ve(ascii "hello"))

(split-search-path-bytevector '#ve(ascii "::::"))
@result{} ()

(split-search-path-string "")
@result{} ()

(split-search-path-string "ciao:hello:salut")
@result{} ("ciao" "hello" "salut")

(split-search-path-string "::::")
@result{} ()

(split-search-path "ciao:hello:salut")
@result{} ("ciao" "hello" "salut")

(split-search-path '#ve(ascii "ciao:hello:salut"))
@result{} (#ve(ascii "ciao") #ve(ascii "hello") #ve(ascii "salut"))
@end example
@end defun


@defun list-of-pathnames? @var{obj}
@defunx list-of-string-pathnames? @var{obj}
@defunx list-of-bytevector-pathnames? @var{obj}
Return @true{} if @var{obj} is a proper list of pathnames according to
@func{file-pathname?}, @func{file-string-pathname?},
@func{file-bytevector-pathname?}.
@end defun


@defun split-pathname @var{pathname}
@defunx split-pathname-bytevector @var{bytevector-pathname}
@defunx split-pathname-string @var{string-pathname}
Split a file pathname into its components and return two values: a
boolean, true if the pathname starts with a slash characters; the list
of components which can be empty.

A pathname is meant to be a file or directory name with components
separated by a slash character; @var{bytevector-pathname} must be a
bytevector, @var{string-pathname} must be a Scheme string, @var{path}
must be a Scheme string or bytevector.

Empty components are discarded.

@example
#!vicare
(import (vicare))

(split-pathname-bytevector '#vu8())
@error{} "invalid pathname"

(split-pathname-bytevector '#ve(ascii "ciao/hello"))
@result{} #f (#ve(ascii "ciao") #ve(ascii "hello"))

(split-pathname-bytevector '#ve(ascii "////"))
@result{} #t ()

(split-pathname-string "")
@error{} "invalid pathname"

(split-pathname-string "ciao/hello/salut")
@result{} #f ("ciao" "hello" "salut")

(split-pathname-string "////")
@result{} #t ()

(split-pathname "ciao/hello/salut")
@result{} #f ("ciao" "hello" "salut")

(split-pathname '#ve(ascii "/ciao/hello/salut"))
@result{} #t (#ve(ascii "ciao") #ve(ascii "hello") #ve(ascii "salut"))
@end example
@end defun


@defun search-file-in-environment-path @var{pathname} @var{environment-variable}
Search a file pathname (regular file or directory) in the given search
path.

@var{pathname} must be a string representing a file pathname;
@var{environment-variable} must be a string representing a system
environment variable.

@itemize
@item
If @var{pathname} is absolute, test its existence: when found, return a
string representing the real absolute file pathname; otherwise return
@false{}.

@item
If @var{pathname} is relative and it has a directory part, test its
existence: when found, return a string representing the real absolute
file pathname; otherwise return @false{}.

@item
If @var{pathname} is relative and it has no directory part, read the
environment variable as colon--separated list of directories and search
the file in them, from the first to the last: when found, return a
string representing the real absolute file pathname; otherwise return
@false{}.

Notice that the file is searched in the process' current working
directory only if such directory is listed in the given path.
@end itemize
@end defun


@defun search-file-in-list-path @var{pathname} @var{list-of-directories}
Search a file pathname (regular file or directory) in the given search
path.

@var{pathname} must be a string representing a file pathname;
@var{list-of-directories} must be a list of strings representing
directory pathnames.

@itemize
@item
If @var{pathname} is absolute, test its existence: when found, return a
string representing the real absolute file pathname; otherwise return
@false{}.

@item
If @var{pathname} is relative and it has a directory part, test its
existence: when found, return a string representing the real absolute
file pathname; otherwise return @false{}.

@item
If @var{pathname} is relative and it has no directory part, search the
file in the given directories, from the first to the last: when found,
return a string representing the real absolute file pathname; otherwise
return @false{}.

Notice that the file is searched in the process' current working
directory only if such directory is listed in the given path.
@end itemize
@end defun

@c page
@node iklib io codecs
@subsection Transcoders and additional codecs


The following bindings are exported by the @library{vicare} library.


@defun transcoder? @var{obj}
Return @true{} if @var{obj} is a transcoder, else return @false{}.
@end defun


@deffn Parameter native-transcoder
@cindex Parameter @func{native-transcoder}
@findex open-input-file
@findex with-input-from-file
@findex call-with-input-file
@findex open-output-file
@findex with-output-to-file
@findex call-with-output-file
The function @func{native-transcoder} defined by @rnrs{6} returns a
transcoder representing acceptable defaults for the platform on which
the Scheme implementation is running.  Under @value{PRJNAME} such
default is:

@example
(make-transcoder (utf-8-codec) (native-eol-style) 'replace)
@end example

@noindent
and additionally the function is a parameter, so the default can be
configured.  Notice that the following functions create Scheme ports
using the transcoder returned by @func{native-transcoder}:

@example
open-input-file         open-output-file
with-input-from-file    with-output-to-file
call-with-input-file    call-with-output-file
@end example
@end deffn


The codec returned by @func{utf-16-codec}, defined by @rnrs{6}, has
different semantics depending upon the type of the port:

@itemize
@item
For output and input/output ports it defaults to @utf{}-16 big endian
(which seems mandated by the Unicode Consortium).

@item
For input ports the endianness is left unspecified until the first bytes
are read: such bytes must be a valid @utf{}-16 Byte Order Mark which
dynamically configures the port.@footnote{The big endian @acronym{BOM}
for @utf{}-16 is the sequence of bytes @code{#xFE #xFF}; the little
endian @acronym{BOM} for @utf{}-16 is the sequence of bytes @code{#xFF
#xFE}.}
@end itemize


@deffn Procedure utf-16le-codec
@deffnx Procedure utf-16be-codec
Codecs for the @utf{}-16 encoding schemes, little endian and big endian.
A call to any of these procedures returns a value that is equal in the
sense of @func{eqv?} to the result of any other call to the same
procedure.
@end deffn


@deffn Procedure utf-16n-codec
Return a codec for the @utf{}-16 encoding scheme, with endianness equal
to the one returned by @func{(native-endianness)}.  A call to this
procedure returns a value that is equal in the sense of @func{eqv?} to
the result of any other call to the same procedure.
@end deffn


@deffn Procedure utf-bom-codec
Codec for @utf{} encoding schemes whose data open with a Byte Order
Mark.  A call to this procedure returns a value that is equal in the
sense of @func{eqv?} to the result of any other call to the same
procedure.

At present this codec is supported only by input ports.
@end deffn

@c page
@node iklib io non-blocking
@subsection Handling non--blocking devices


@cindex Non--blocking mode, input/output ports
@cindex Input/output ports in non--blocking mode
@cindex Would--block object
@cindex Unique objects, would--block object


@rnrs{6} defines the input operations on Scheme ports as properly
blocking when no input data is available; this is fine when the
underlying device is configured in blocking mode.  @value{PRJNAME}
extends the Scheme input/output ports to support underlying devices
configured in non--blocking mode; such ports are typically the ones
whose underlying device is a @posix{} file or socket descriptor.

The implementation of Scheme ports read from the underlying device
through a function @func{read!}; if the device is configured in
non--blocking mode: @func{read!} might raise an exception with condition
object type @condition{i/o-eagain}, which means: there are no available
bytes, but this is not the end--of--file.  This scenario corresponds to
the case in which a @posix{} function fails with @code{errno} set to
@code{EAGAIN} or @code{EWOULDBLOCK}.

The functions extended by @value{PRJNAME} behave as described in this
section.  The extended behaviour is disabled when running with the
command line @option{--strict-r6rs}: in this case the port will block as
mandated by @rnrs{6}.

@menu
* iklib io non-blocking object::  The would--block object.
* iklib io non-blocking mode::    Ports and non-blocking mode.
* iklib io non-blocking binary::  Extended binary input functions.
* iklib io non-blocking textual:: Extended textual input functions.
@end menu

@c page
@node iklib io non-blocking object
@subsubsection The would--block object


@defun would-block-object
Return a unique object representing the condition ``no bytes, not EOF''
on a device configured in non--blocking mode.  The would--block object
can be compared with @func{eq?}.
@end defun


@defun would-block-object? @var{obj}
Return @true{} if @var{obj} is the would--block object, else return
@false{}.
@end defun

@c page
@node iklib io non-blocking mode
@subsubsection Ports and non-blocking mode


@defun port-set-non-blocking-mode! @var{port}
Set non--blocking mode for @var{port}; if successful return unspecified
values, if an error occurs raise an exception.  @var{port} must have a
file descriptor as underlying device.
@end defun


@defun port-unset-non-blocking-mode! @var{port}
Unset non--blocking mode for @var{port}; if successful return
unspecified values, if an error occurs raise an exception.  @var{port}
must have a file descriptor as underlying device.
@end defun


@defun port-in-non-blocking-mode? @var{port}
Query @var{port} for its non--blocking mode; if successful: return
@true{} if the port is in non--blocking mode, @false{} otherwise.  If an
error occurs: raise an exception.

@var{port} can be any Scheme port: this function will recognise
non-blocking mode only for ports having a file descriptor as underlying
device; for all the other ports the return value is @false{}.
@end defun

@c page
@node iklib io non-blocking binary
@subsubsection Extended binary input functions


@defun get-u8 @var{port}
Return the @eof{} object, the would--block object or a fixnum:

@itemize
@item
If a byte is available: return the byte as an octet and update
@var{port} to point just past that byte.

@item
If no input byte is seen before an end of file is reached: the @eof{}
object is returned.

@item
If the underlying device is in non--blocking mode and no bytes are
available: return the would--block object.
@end itemize
@end defun


@defun lookahead-u8 @var{port}
Like GET-U8, but it does not update @var{PORT} to point past the byte.
@end defun


@defun get-bytevector-n @var{port} @var{count}
Return the @eof{} object, the would--block object or a bytevector:

@itemize
@item
If @var{count} bytes are available before an end of file: return a
bytevector of size @var{count}.  The input port is updated to point just
past the bytes read.

@item
If fewer than @var{count} bytes are available before an end of file:
return a bytevector containing those bytes.  The input port is updated
to point just past the bytes read.

@item
If an end of file is reached before any bytes are available: return the
@eof{} object.

@item
If the underlying device is in non--blocking mode and fewer than
@var{count} bytes are available: return a bytevector containing those
bytes.  The input port is updated to point just past the bytes read.

@item
If the underlying device is in non--blocking mode and no bytes are
available: return the would--block object.
@end itemize
@end defun


@defun get-bytevector-n! @var{port} @var{dst.bv} @var{dst.start} @var{count}
Return the @eof{} object, the would--block object or the number of bytes
written in the given bytevector:

@itemize
@item
If @var{count} bytes are available before the end of file: they are
written into @var{dst.bv} starting at index @var{dst.start}, and the
result is @var{count}.  The input port is updated to point just past the
bytes read.

@item
If fewer than @var{count} bytes are available before the end of file:
the available bytes are written into @var{dst.bv} starting at index
@var{dst.start}, and the result is a number object representing the
number of bytes actually read.  The input port is updated to point just
past the bytes read.

@item
If the end of file is reached before any bytes are available: return the
@eof{} object.

@item
If the underlying device is in non--blocking mode and fewer than
@var{count} bytes are available: the available bytes are written into
@var{dst.bv} starting at index @var{dst.start}, and the result is a
number object representing the number of bytes actually read.  The input
port is updated to point just past the bytes read.

@item
If the underlying device is in non--blocking mode and no bytes are
available: return the would--block object.
@end itemize
@end defun


@defun get-bytevector-some @var{port}
Return the @eof{} object, the would--block object or a bytevector:

@itemize
@item
If bytes are available: return a freshly allocated bytevector containing
the initial available bytes (at least one), and update @var{port} to
point just past these bytes.

@item
If no input bytes are seen before an end of file is reached: the @eof{}
object is returned.

@item
If the underlying device is in non--blocking mode and no bytes are
available: return the would--block object.
@end itemize
@end defun

@c page
@node iklib io non-blocking textual
@subsubsection Extended textual input functions


@defun get-char @var{port}
Return the @eof{} object, the would--block object or a character:

@itemize
@item
If a complete character is available before the next end of file: return
that character and update the input port to point past the character.

@item
If an end of file is reached before any character is read: return the
@eof{} object.

@item
If the underlying device is in non--blocking mode and no full character
is available: return the would--block object.
@end itemize
@end defun


@defun read-char
@defunx read-char @var{port}
Like @func{get-char}.
@end defun


@defun lookahead-char @var{port}
Like @func{get-char}, but it does not update @var{port} to point past
the character.
@end defun


@defun peek-char
@defunx peek-char @var{port}
Like @func{lookahead-char}.
@end defun


@defun get-string-n @var{port} @var{requested-count}
Return the @eof{} object, the would--block object or a string and update
the input port to point past the consumed characters:

@itemize
@item
If @var{requested-count} characters are available before end of file:
return a string consisting of those @var{requested-count} characters.

@item
If fewer than @var{requested-count} characters are available before an
end of file, but one or more characters can be read: return a string
containing those characters.

@item
If no characters can be read before an end of file: return the @eof{}
object.

@item
If the underlying device is in non--blocking mode and no characters are
available: return the would--block object.
@end itemize
@end defun


@defun get-string-n! @var{port} @var{dst.str} @var{dst.start} @var{count}
Return the @eof{} object, the would--block object or a string and update
the input port to point past the consumed characters:

@itemize
@item
If @var{count} characters are available before an end of file: they are
written into @var{DST.STR} starting at index @var{DST.START}, and
@var{count} is returned.

@item
If fewer than @var{count} characters are available before an end of
file, but one or more can be read: those characters are written into
@var{dst.str} starting at index @var{dst.start} and the number of
characters actually read is returned as an exact integer object.

@item
If no characters can be read before an end of file: the @eof{} object is
returned.

@item
If the underlying device is in non--blocking mode and fewer than
@var{count} characters are available before a would--block condition,
but one or more can be read: those characters are written into
@var{dst.str} starting at index @var{dst.start} and the number of
characters actually read is returned as an exact integer object.

@item
If the underlying device is in non--blocking mode and no characters are
available: return the would--block object.
@end itemize
@end defun


@defun get-string-all @var{port}
Return the @eof{} object or a string and update the input port to point
past the consumed characters:

@itemize
@item
If characters are available before the end of file: a string containing
all the characters decoded from that data is returned.  Further reading
from the port will return the @eof{} object.

@item
If no character precedes the end of file: the @eof{} object is returned.
@end itemize

Even when the underlying device is in non--blocking mode: this function
attempts to read input until the @eof{} is found.
@end defun


@defun get-string-some @var{port}
Return the @eof{} object, the would--block object or a string and update
the input port to point past the consumed characters:

@itemize
@item
If characters become available before the end of file: return a freshly
allocated string containing the initial available characters (at least
one), and update @var{port} to point just past these characters.

@item
If no input characters are available before the end of file: the @eof{}
object is returned.

@item
If no input characters are available before a would--block condition:
the would--block object is returned.
@end itemize
@end defun

@c page
@node iklib io binary
@subsection Additional binary port features


The following bindings are exported by the @library{vicare} library.


@defun binary-input-port? @var{obj}
@defunx binary-output-port? @var{obj}
@defunx binary-input/output-port? @var{obj}
Return @true{} if @var{obj} is a binary port and, respectively, it is
input, output or input/output.
@end defun


@defun open-binary-port? @var{obj}
@defunx open-binary-input-port? @var{obj}
@defunx open-binary-output-port? @var{obj}
@defunx open-binary-input/output-port? @var{obj}
Return @true{} if @var{obj} is an open binary port and, respectively, it
is input, output or input/output.
@end defun


@defun lookahead-two-u8 @var{port}
Like @func{lookahead-u8} but peeks at @math{2} octets and return two
values: the @eof{} object, the would--block object or a fixnum
representing first octet; the @eof{} object, the would--block object or
a fixnum representing the second octet.
@end defun


@defun console-input-port
@defunx console-input-port @var{textual-input-port}
Return the default textual input port: the default value of the
parameter @func{current-input-port}; each call returns the same port.
When the readline interface is not used, this port is used by the
@repl{} and the debugger.

When applied to an argument: the argument must be a textual input port
which replaces the old value; the old port is left untouched (it is not
closed).  When selecting a new console input port: the same port should
be used as top value for the parameter @func{current-input-port}.
@end defun


@defun console-output-port
@defunx console-output-port @var{textual-output-port}
Return the default textual output port: the default value of the
parameter @func{current-output-port}; each call returns the same port.
This port is used by the @repl{} and the debugger.

When applied to an argument: the argument must be a textual output port
which replaces the old value; the old port is left untouched (it is not
closed).  When selecting a new console output port: the same port should
be used as top value for the parameter @func{current-output-port}.
@end defun


@defun console-error-port
@defunx console-error-port @var{textual-output-port}
Return the default textual error port: the default value of the
parameter @func{current-input-port}; each call returns the same port.

When applied to an argument: the argument must be a textual output port
and it replaces the old value; the old port is left untouched (it is not
closed).  When selecting a new console error port: the same port should
be used as top value for the parameter @func{current-error-port}.
@end defun


@defvr Constant stdin
@defvrx Constant stdout
@defvrx Constant stderr
Bound to the values returned by @func{console-input-port},
@func{console-output-port}, @func{console-error-port} respectively.
@end defvr


@defun make-binary-file-descriptor-input-port @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-output-port @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-input/output-port @var{fd} @var{identifier}
Build and return binary Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  Closing the Scheme ports will close the file
descriptors too.

File descriptor ports do support port position operations.
@end defun


@defun make-binary-file-descriptor-input-port* @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-output-port* @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-input/output-port* @var{fd} @var{identifier}
Build and return binary Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  Closing the Scheme ports will @strong{not} close the
file descriptors.

File descriptor ports do support port position operations.
@end defun


@defun make-binary-socket-input-port @var{sock} @var{identifier}
@defunx make-binary-socket-output-port @var{sock} @var{identifier}
@defunx make-binary-socket-input/output-port @var{sock} @var{identifier}
Build and return a binary Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  Closing the Scheme port will close the
socket descriptor too.

Socket ports do @strong{not} support port position operations.
@end defun


@defun make-binary-socket-input-port* @var{sock} @var{identifier}
@defunx make-binary-socket-output-port* @var{sock} @var{identifier}
@defunx make-binary-socket-input/output-port* @var{sock} @var{identifier}
Build and return a binary Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  Closing the Scheme port will @strong{not}
close the socket descriptor.

Socket ports do @strong{not} support port position operations.
@end defun

@c page
@node iklib io textual
@subsection Additional textual port features


The following bindings are exported by the @library{vicare} library.


@deffn Parameter current-input-port
@cindex Parameter @func{current-input-port}
As defined by @rnrs{6}: return a default textual port for input.
@value{PRJNAME} extends its definition to allow selecting a new textual
input port.
@end deffn


@deffn Parameter current-output-port
@cindex Parameter @func{current-output-port}
As defined by @rnrs{6}: return a default textual port for output.
@value{PRJNAME} extends its definition to allow selecting a new textual
output port.
@end deffn


@deffn Parameter current-error-port
@cindex Parameter @func{current-error-port}
As defined by @rnrs{6}: return a default textual port for error messages
output.  @value{PRJNAME} extends its definition to allow selecting a new
textual output port.
@end deffn


@defun textual-input-port? @var{obj}
@defunx textual-output-port? @var{obj}
@defunx textual-input/output-port? @var{obj}
Return @true{} if @var{obj} is a textual port and, respectively, it is
input, output or input/output.
@end defun


@defun open-textual-port? @var{obj}
@defunx open-textual-input-port? @var{obj}
@defunx open-textual-output-port? @var{obj}
@defunx open-textual-input/output-port? @var{obj}
Return @true{} if @var{obj} is an open textual port and, respectively,
it is input, output or input/output.
@end defun


@defun open-string-input-port @var{string}
@defunx open-string-input-port @var{string} @var{eol-style}
As defined by @rnrs{6}: return a textual input port whose characters are
drawn from @var{string}.  When @var{eol-style} is given: it must be a
symbol selecting an end--of--line style conversion, as accepted by
@func{eol-style}; such conversion is applied to the characters drawn
from @var{string}.

If @var{string} is modified after @func{open-string-input-port} has been
called, the effect on the returned port is unspecified.
@end defun


@defun open-string-input-port/id @var{string} @var{id}
@defunx open-string-input-port/id @var{string} @var{id} @var{eol-style}
Like @func{open-string-input-port} but allows the specification of a
customised port identifier @var{id}, which must be a Scheme string.
@end defun


@defun open-string-output-port
@defunx open-string-output-port @var{eol-style}
As defined by @rnrs{6}, return two values: a textual output port and an
extraction procedure; the output port accumulates the characters written
to it for later extraction by the procedure.

As a @value{PRJNAME} extension, when @var{eol-style} is given: it must
be a symbol selecting an end--of--line style conversion, as accepted by
@func{eol-style}; such conversion is applied to the characters written
to the port.
@end defun


@defun get-output-string @var{port}
Return the string accumulated in the @var{port} opened by
@func{open-string-output-port}.  This function can be called also when
the port has been closed.
@end defun


@defun get-char-and-track-textual-position @var{port}
Like @func{get-char} but track the textual position.  Recognise only
linefeed characters as line-ending.
@end defun


@defun port-textual-position @var{port}
Given a textual port, return the current textual position as a condition
object of type @condition{source-position}.
@end defun


@defun make-textual-file-descriptor-input-port @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-output-port @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-input/output-port @var{fd} @var{identifier} @var{transcoder}
Build and return textual Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  @var{transcoder} must be a transcoder object.  Closing
the Scheme ports will close the file descriptors too.

File descriptor ports do support port position operations.
@end defun


@defun make-textual-file-descriptor-input-port* @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-output-port* @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-input/output-port* @var{fd} @var{identifier} @var{transcoder}
Build and return textual Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  @var{transcoder} must be a transcoder object.  Closing
the Scheme ports will @strong{not} close the file descriptors.

File descriptor ports do support port position operations.
@end defun


@defun make-textual-socket-input/output-port @var{sock} @var{identifier} @var{transcoder}
Build and return a textual Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  @var{transcoder} must be a transcoder
object.  Closing the Scheme port will close the socket descriptor too.

Socket ports do @strong{not} support port position operations.
@end defun


@defun make-textual-socket-input/output-port* @var{sock} @var{identifier} @var{transcoder}
Build and return a textual Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  @var{transcoder} must be a transcoder
object.  Closing the Scheme port will @strong{not} close the socket
descriptor.

Socket ports do @strong{not} support port position operations.
@end defun


@defun read-line
@defunx read-line @var{port}
Read from the textual input @var{port} up to and including the linefeed
character or end of file, decoding characters in the same manner as
@func{get-string-n} and @func{get-string-n!}.  This function is exactly
like @func{get-line}, defined by @rsixlibrary{io ports}, but it uses the
return value of @func{current-input-port} if no @var{port} argument is
used.
@end defun


@defun get-string-some @var{port}
Defined by Vicare.  Read from the textual input @var{port}, blocking as
necessary, until characters are available or until an end of file is
reached.

If characters become available, @func{get-string-some} returns a freshly
allocated string containing the initial available characters (at least
one), and it updates @var{port} to point just past these characters.

If no input characters are available: the @eof{} object is returned.
@end defun


@defun with-input-from-string @var{string} @var{thunk}
@var{thunk} must be a procedure and it must accept zero arguments.
@var{string} must be a Scheme string.

The @var{string} is used as argument for @func{open-string-input-port};
during the dynamic extent of the call to @var{thunk}, the obtained port
is made the value returned by @func{current-input-port}; the previous
default value is reinstated when the dynamic extent is exited.

When @var{thunk} returns, the port is closed automatically.  The values
returned by @var{thunk} are returned.

If, after @var{thunk} has returned, an escape procedure is used to
reenter the dynamic extent of the call to @var{thunk}: the behaviour is
unspecified.
@end defun


@defun with-output-to-string @var{thunk}
Create a textual output port that accumulates the characters written to
it, set it as the current output port and call @var{thunk} with no
arguments.  The port is the current output port only for the extent of
the call to @var{thunk}.

Whenever @var{thunk} returns, a string consisting of all of the port's
accumulated characters (regardless of the port's current position) is
returned and the port is closed.
@end defun

@c page
@node iklib io buffer
@subsection Buffer size customisation


The following bindings are exported by the @library{vicare} library.


@deffn Parameter bytevector-port-buffer-size
@deffnx Parameter bytevector-port-buffer-size @var{fixnum}
@cindex Parameter @func{bytevector-port-buffer-size}
Hold the buffer size for bytevector ports, like the one returned by
@func{open-bytevector-output-port}.  It is initialised to @math{16384}.
@end deffn


@deffn Parameter string-port-buffer-size
@deffnx Parameter string-port-buffer-size @var{fixnum}
@cindex Parameter @func{string-port-buffer-size}
Hold the buffer size for string ports, like the one returned by
@func{open-string-output-port}.  It is initialised to @math{256}.
@end deffn


@deffn Parameter input-file-buffer-size
@deffnx Parameter input-file-buffer-size @var{fixnum}
@cindex Parameter @func{input-file-buffer-size}
Hold the buffer size for input file ports, like the one returned by
@func{open-input-file}.  It is initialised to @math{16384}.
@end deffn


@deffn Parameter output-file-buffer-size
@deffnx Parameter output-file-buffer-size @var{fixnum}
@cindex Parameter @func{output-file-buffer-size}
Hold the buffer size for output file ports, like the one returned by
@func{open-output-file}.  It is initialised to @math{16384}.
@end deffn


@deffn Parameter input/output-file-buffer-size
@deffnx Parameter input/output-file-buffer-size @var{fixnum}
@cindex Parameter @func{input/output-file-buffer-size}
Hold the buffer size for input/output file ports, like the one returned
by @func{open-file-input/output-prot}.  It is initialised to
@math{16384}.
@end deffn


@deffn Parameter input/output-socket-buffer-size
@deffnx Parameter input/output-socket-buffer-size @var{fixnum}
@cindex Parameter @func{input/output-socket-buffer-size}
Hold the buffer size for socket ports.  It is initialised to
@math{16384}.
@end deffn

@c page
@node iklib io plists
@subsection Port property lists


Port property work like symbol property lists; they are a simple way to
tag I/O ports with values.


@defun port-putprop @var{port} @var{key} @var{value}
Add a new property @var{key} with @var{value} to the property list of
@var{port}.  If @var{key} is already set: the old entry is mutated to
reference @var{value}.  @var{key} must be a symbol.
@end defun


@defun port-getprop @var{port} @var{key}
Return the value of the property @var{key} in the property list of
@var{port}; if @var{key} is not set return @false{}.  @var{key} must be
a symbol.
@end defun


@defun port-remprop @var{port} @var{key}
Remove the property @var{key} from the property list of @var{port}.
@var{key} must be a symbol.
@end defun


@defun port-property-list @var{port}
Return a new association list representing the property list of
@var{port}.
@end defun

@c page
@node iklib io misc
@subsection Miscellaneous port functions


The following bindings are exported by the @library{vicare} library.


@defun input/output-port? @var{port}
Return a boolean, @true{} if @var{port} is an input and output port.
@end defun


@defun port-fd @var{port}
If @var{port} is a port with a file descriptor as device: return a
fixnum representing the device, else return @false{}.
@end defun


@defun port-id @var{port}
Return a Scheme string representing the identifier of @var{port}.
@end defun


@defun port-uid @var{port}
Return a gensym uniquely associated to @var{port}.  The gensym is
generated the first time this function is applied to @var{port}.
@end defun


@defun port-hash @var{port}
Return a fixnum associated to @var{port} to be used as hash key.  The
gensym is generated the first time this function is applied to
@var{port}.
@end defun


@defun port-closed? @var{port}
Return @true{} if @var{port} has already been closed, else return
@false{}.
@end defun


@defun open-input-port? @var{obj}
@defunx open-output-port? @var{obj}
@defunx open-input/output-port? @var{obj}
Return @true{} if @var{obj} is an open port and, respectively, it is
input, output or input/output.
@end defun


@defun set-port-buffer-mode! @var{port} @var{buffer-mode}
Reset the port buffer mode to @var{buffer-mode}, which must be one of
the arguments accepted by @func{buffer-mode}.  It is an error to select
@code{line} mode if @var{port} is a binary port.
@end defun


@defun port-dump-status @var{port}
To be used for debugging purposes.  Write to the current error port some
informations on the internals of @var{port}.
@end defun


@defun reset-input-port! @var{input-port}
@defunx reset-output-port! @var{output-port}
Reset to empty the port buffer; return unspecified values.  These
procedures should be used to attempt an error recovery, only when the
port's underlying device is stateless, for example at the @repl{}.
@end defun


@defun make-file-options @var{symbol} ...
Return an enumeration set as defined by @func{file-options}.
@end defun


@deffn Syntax file-options @meta{file-options-symbol} @dots{}
As defined by @rnrs{6}: return a file--options object that encapsulates
the specified options.  Each @meta{file-options-symbol} must be a
symbol.

@value{PRJNAME} extends the standard options adding the following:

@table @code
@item executable
Open the file with executable permissions; before the process' file mode
creation mask is applied, executable permissions are granted to user,
group and others.  @manpage{umask, Set file mode creation mask}.
@end table
@end deffn

@c page
@node iklib pointers
@section Handling pointer objects


Pointer objects are a disjoint type identified by the @func{pointer?}
predicate.

@menu
* iklib pointers cons::         Constructors.
* iklib pointers pred::         Predicates.
* iklib pointers compar::       Comparison.
* iklib pointers conv::         Conversion.
* iklib pointers misc::         Miscellaneous operations.
* iklib pointers poke::         Poking values.
* iklib pointers peek::         Peeking values.
* iklib arrays poke::           Poking values into arrays.
* iklib arrays peek::           Peeking values from arrays.
@end menu

@c page
@node iklib pointers cons
@subsection Constructors


The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@defun null-pointer
Return a newly allocated pointer object representing @cnull{}.
@end defun


@defun pointer-clone @var{ptr}
Return a new pointer object being a copy of @var{ptr}.  This is useful
when we need a pointer that might be reset to another value in the
future.
@end defun

@c page
@node iklib pointers pred
@subsection Predicates


The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@defun pointer? @var{obj}
Return @true{} if @var{obj} is a pointer object, return @false{}
otherwise.
@end defun


@defun maybe-pointer? @var{obj}
Return @true{} if @var{obj} is a pointer object or @void{}, return @false{}
otherwise.
@end defun


@defun false-or-pointer? @var{obj}
Return @true{} if @var{obj} is a pointer object or @false{}, return
@false{} otherwise.
@end defun


@defun pointer-null? @var{obj}
Return @true{} if @var{obj} is a pointer object and it represents
@cnull{}; otherwise return @false{}.  If @var{obj} is not a pointer:
return @false{}.
@end defun


@defun pointer-non-null? @var{obj}
Return @true{} if @var{obj} is a pointer object and it is not @cnull{};
otherwise return @false{}.  If @var{obj} is not a pointer: return
@false{}.
@end defun


@defun pointer-and-offset? @var{ptr} @var{diff}
Return true if the exact integer @var{diff} can be added to @var{ptr}
without causing a pointer overflow or underflow.
@end defun


@defun list-of-pointers? @var{obj}
Return @true{} if @var{obj} is a, possibly empty, proper list of pointer
objects; otherwise return @false{}.
@end defun

@c page
@node iklib pointers compar
@subsection Comparison


When applied to pointer objects:

@itemize
@item
The result of calling @func{eq?} is true only if the two arguments are
both pointers and they refer to the same Scheme storage location.

@item
The result of calling @func{eqv?} and @func{equal?} is true only if the
two arguments are both pointers and they reference the same raw memory
location.
@end itemize

@noindent
pointers also have @func{pointer=?} as specialised comparison predicate.

The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@defun {pointer=?} @varo{ptr} @dots{}
@defunx {pointer<?} @varo{ptr} @dots{}
@defunx {pointer>?} @varo{ptr} @dots{}
@defunx {pointer<=?} @varo{ptr} @dots{}
@defunx {pointer>=?} @varo{ptr} @dots{}
Compare the pointer arguments as indicated by the name.
@end defun


@defun pointer!=? @varo{ptr} @var{ptr} @dots{}
Return @true{} if all the pointer arguments are different; otherwise
return @false{}.
@end defun


@defun pointer-max @varo{ptr} @var{ptr} @dots{}
@defunx pointer-min @varo{ptr} @var{ptr} @dots{}
Return the maximal or minimal pointer argument according to
@func{pointer<?}.
@end defun

@c page
@node iklib pointers conv
@subsection Conversion


The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@defun pointer->integer @var{pointer}
Convert the value of @var{pointer} to an exact integer value.  The
result may be a fixnum or a bignum depending on the pointer.
@end defun


@defun integer->pointer @var{exact-integer}
Convert @var{exact-integer} to a pointer value.  The argument must be
non--negative and in the appropriate range for 32-bit or 64-bit
platforms.  It is guaranteed that:

@example
(integer->pointer (pointer->integer p))
@end example

@noindent
points to the same address as @var{p}.
@end defun

@c page
@node iklib pointers misc
@subsection Miscellaneous operations


The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@defun set-pointer-null! @var{pointer}
Mutate the pointer object @var{pointer} to represent the @cnull{}
pointer.
@end defun


@defun pointer-diff @vari{ptr} @varii{ptr}
Return an exact integer representing the difference between the two
pointer objects @vari{ptr} and @varii{ptr}.  The returned value is such
that:

@example
(pointer=? P (pointer-add Q (pointer-diff P Q)))
@result{} #t
@end example
@end defun


@defun pointer-add @var{ptr} @var{diff}
Return a new pointer object holding the memory reference resulting from
adding @var{diff}, which must be an exact integer, to @var{ptr}.  If the
addition would cause an overflow or underflow in machine words: raise an
assertion violation.
@end defun

@c page
@node iklib pointers poke
@subsection Poking values


With all the following functions: the @var{memory} argument must be a
valid pointer object or @code{memory-block} instance; the @var{offset}
argument must be an exact integer in the range of the C language type
@code{ptrdiff_t}.  When adding an offset to a pointer: all the following
functions @strong{do not} scale the offset to the size of the poked
value; pointer arithmetics is performed with byte offsets.

The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.

@macro bitpoker{BYTENUM,BITNUM}
Set to @var{value} the \BYTENUM\ of memory located at @var{offset} from
@var{memory}.  @var{VALUE} must be an exact integer in the range
representable by \BITNUM\ bits.
@end macro

@macro cpoker{TYPE}
Set to @var{value} a number of bytes corresponding to the @code{signed
\TYPE\} or @code{unsigned \TYPE\} type located at @var{offset} from
@var{memory}.
@end macro

@c ------------------------------------------------------------

@subsubheading Poking bitwise sized exact integers

The following functions store signed and unsigned exact integers in raw
memory location selecting the size with the number of bits required to
represent the value.


@defun pointer-set-c-sint8! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-uint8! @var{memory} @var{offset} @var{value}
@bitpoker{single byte,8}
@end defun


@defun pointer-set-c-sint16! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-uint16! @var{memory} @var{offset} @var{value}
@bitpoker{two bytes,16}
@end defun


@defun pointer-set-c-sint32! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-uint32! @var{memory} @var{offset} @var{value}
@bitpoker{four bytes,32}
@end defun


@defun pointer-set-c-sint64! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-uint64! @var{memory} @var{offset} @var{value}
@bitpoker{eigth bytes,64}
@end defun

@c ------------------------------------------------------------

@subsubheading Poking C language exact integers

The following functions store signed and unsigned exact integers in raw
memory locations selecting the size according to the one used by the C
language implementation.


@defun pointer-set-c-signed-char! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-char! @var{memory} @var{offset} @var{value}
@cpoker{char}
@end defun


@defun pointer-set-c-signed-short! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-short! @var{memory} @var{offset} @var{value}
@cpoker{short int}
@end defun


@defun pointer-set-c-signed-int! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-int! @var{memory} @var{offset} @var{value}
@cpoker{int}
@end defun



@defun pointer-set-c-signed-long! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-long! @var{memory} @var{offset} @var{value}
@cpoker{long}
@end defun


@defun pointer-set-c-signed-long-long! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-long-long! @var{memory} @var{offset} @var{value}
@cpoker{long long}
@end defun


@defun pointer-set-c-size_t! @var{memory} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{size_t}
type located at @var{offset} from @var{memory}.
@end defun


@defun pointer-set-c-ssize_t! @var{memory} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{ssize_t}
type located at @var{offset} from @var{memory}.
@end defun


@defun pointer-set-c-off_t! @var{memory} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{off_t}
type located at @var{offset} from @var{memory}.
@end defun


@defun pointer-set-c-ptrdiff_t! @var{memory} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the
@code{ptrdiff_t} type located at @var{offset} from @var{memory}.
@end defun

@c ------------------------------------------------------------

@subsubheading Poking floating point numbers


@defun pointer-set-c-float! @var{memory} @var{offset} @var{flonum}
Convert the Scheme floating point number @var{flonum} (represented in
@value{PRJNAME} as an @ieee{} 754 double precision floating point number) to a
float (an @ieee{} 754 single precision floating point number) and store
the result in the four bytes at @var{offset} from @var{memory}.
@end defun


@defun pointer-set-c-double! @var{memory} @var{offset} @var{flonum}
Store the double precision @ieee{} 754 floating point value of the
Scheme @var{flonum} in the eight bytes at @var{offset} from
@var{memory}.
@end defun


@defun pointer-set-c-double-complex! @var{memory} @var{offset} @var{cflonum}
Store the double precision @ieee{} 754 floating point values composing
the Scheme @var{cflonum} in the 16 bytes at @var{offset} from
@var{memory}, real part at the lowest address.
@end defun


@c ------------------------------------------------------------

@subsubheading Poking pointers


@defun pointer-set-c-pointer! @var{memory} @var{offset} @var{value}
Store address of the raw memory location referenced by the pointer
@var{value} at @var{offset} from @var{memory}.
@end defun

@c page
@node iklib pointers peek
@subsection Peeking values


With all the following functions: the @var{memory} argument must be a
valid pointer object; the @var{offset} argument must be an exact integer
in the range of the C language type @code{ptrdiff_t}.  When adding an
offset to a pointer: all the following functions @strong{do not} scale
the offset to the size of the peeked value; pointer arithmetics is
performed with byte offsets.

The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.

@macro bitpeeker{BITNUM}
Peek the \BITNUM\ bits located at @var{offset} from @var{memory} and
return them as signed or unsigned exact integer.
@end macro

@macro cpeeker{TYPE}
Peek the @code{signed \TYPE\} or @code{unsigned \TYPE\} integer located
at @var{offset} from @var{memory} and return it as signed or unsigned
exact integer.
@end macro

@c ------------------------------------------------------------

@subsubheading Peeking bitwise sized exact integers

The following functions retrieve signed and unsigned exact integers from
raw memory location selecting the size with the number of bits required
to represent the value.


@defun pointer-ref-c-sint8 @var{memory} @var{offset}
@defunx pointer-ref-c-uint8 @var{memory} @var{offset}
@bitpeeker{8}
@end defun


@defun pointer-ref-c-sint16 @var{memory} @var{offset}
@defunx pointer-ref-c-uint16 @var{memory} @var{offset}
@bitpeeker{16}
@end defun


@defun pointer-ref-c-sint32 @var{memory} @var{offset}
@defunx pointer-ref-c-uint32 @var{memory} @var{offset}
@bitpeeker{32}
@end defun


@defun pointer-ref-c-sint64 @var{memory} @var{offset}
@defunx pointer-ref-c-uint64 @var{memory} @var{offset}
@bitpeeker{64}
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking C language exact integers

The following functions store signed and unsigned exact integers from
raw memory locations selecting the size according to the one used by the
C language implementation.


@defun pointer-ref-c-signed-char @var{memory} @var{offset}
@defunx pointer-ref-c-signed-char @var{memory} @var{offset}
@cpeeker{char}
@end defun


@defun pointer-ref-c-signed-short @var{memory} @var{offset}
@defunx pointer-ref-c-unsigned-short @var{memory} @var{offset}
@cpeeker{short int}
@end defun


@defun pointer-ref-c-signed-int @var{memory} @var{offset}
@defunx pointer-ref-c-unsigned-int @var{memory} @var{offset}
@cpeeker{int}
@end defun


@defun pointer-ref-c-signed-long @var{memory} @var{offset}
@defunx pointer-ref-c-unsigned-long @var{memory} @var{offset}
@cpeeker{long}
@end defun


@defun pointer-ref-c-signed-long-long @var{memory} @var{offset}
@defunx pointer-ref-c-unsigned-long-long @var{memory} @var{offset}
@cpeeker{long long}
@end defun


@defun pointer-ref-c-size_t @var{memory} @var{offset}
Peek the @code{size_t} integer located at @var{offset} from @var{memory}
and return it as exact integer.
@end defun


@defun pointer-ref-c-ssize_t @var{memory} @var{offset}
Peek the @code{ssize_t} integer located at @var{offset} from @var{memory}
and return it as exact integer.
@end defun


@defun pointer-ref-c-off_t @var{memory} @var{offset}
Peek the @code{off_t} integer located at @var{offset} from @var{memory}
and return it as exact integer.
@end defun


@defun pointer-ref-c-ptrdiff_t @var{memory} @var{offset}
Peek the @code{ptrdiff_t} integer located at @var{offset} from
@var{memory} and return it as exact integer.
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking floating point numbers


@defun pointer-ref-c-float @var{memory} @var{offset}
Return the four--byte float (represented as @ieee{} 754 single precision
floating point number) stored at @var{offset} from @var{memory}.  The
value is extended to an @ieee{} 754 double precision floating point
number that @value{PRJNAME} uses to represent inexact numbers.
@end defun


@defun pointer-ref-c-double @var{memory} @var{offset}
Return the eight--byte float (represented as @ieee{} 754 double
precision floating point number) stored at @var{offset} from
@var{memory}.
@end defun


@defun pointer-ref-c-double-complex @var{memory} @var{offset}
Return a cflonum built from the two eight--byte floats (represented as
@ieee{} 754 double precision floating point numbers) stored at
@var{offset} from @var{memory}, real part at the lowest address.
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking pointers


@defun pointer-ref-c-pointer @var{memory} @var{offset}
Return the pointer stored at @var{offset} from @var{memory}.  The size
of the pointer (also the number of bytes loaded) depends on the
architecture: it is 4 bytes on 32-bit systems and 8 bytes on 64-bit
systems.
@end defun

@c page
@node iklib arrays poke
@subsection Poking values into arrays


With all the following functions: the @var{memory} argument must be a
valid pointer object or @code{memory-block} instance; the @var{index}
argument must be an exact integer in the range of the C language type
@code{ptrdiff_t}.  When adding an offset to a pointer: all the following
functions @strong{do} scale the index to the size of the poked value.

The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.

@macro abitpoker{BYTENUM,BITNUM}
Set to @var{value} the \BYTENUM\ of memory located at @var{index} from
@var{memory}.  @var{VALUE} must be an exact integer in the range
representable by \BITNUM\ bits.
@end macro

@macro acpoker{TYPE}
Set to @var{value} a number of bytes corresponding to the @code{signed
\TYPE\} or @code{unsigned \TYPE\} type located at @var{index} from
@var{memory}.
@end macro

@c ------------------------------------------------------------

@subsubheading Poking bitwise sized exact integers

The following functions store signed and unsigned exact integers in raw
memory location selecting the size with the number of bits required to
represent the value.


@defun array-set-c-sint8! @var{memory} @var{index} @var{value}
@defunx array-set-c-uint8! @var{memory} @var{index} @var{value}
@abitpoker{single byte,8}
@end defun


@defun array-set-c-sint16! @var{memory} @var{index} @var{value}
@defunx array-set-c-uint16! @var{memory} @var{index} @var{value}
@abitpoker{two bytes,16}
@end defun


@defun array-set-c-sint32! @var{memory} @var{index} @var{value}
@defunx array-set-c-uint32! @var{memory} @var{index} @var{value}
@abitpoker{four bytes,32}
@end defun


@defun array-set-c-sint64! @var{memory} @var{index} @var{value}
@defunx array-set-c-uint64! @var{memory} @var{index} @var{value}
@abitpoker{eight bytes,64}
@end defun

@c ------------------------------------------------------------

@subsubheading Poking C language exact integers

The following functions store signed and unsigned exact integers in raw
memory locations selecting the size according to the one used by the C
language implementation.


@defun array-set-c-signed-char! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-char! @var{memory} @var{index} @var{value}
@acpoker{char}
@end defun


@defun array-set-c-signed-short! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-short! @var{memory} @var{index} @var{value}
@acpoker{short int}
@end defun


@defun array-set-c-signed-int! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-int! @var{memory} @var{index} @var{value}
@acpoker{int}
@end defun


@defun array-set-c-signed-long! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-long! @var{memory} @var{index} @var{value}
@acpoker{long}
@end defun


@defun array-set-c-signed-long-long! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-long-long! @var{memory} @var{index} @var{value}
@acpoker{long long}
@end defun


@defun array-set-c-size_t! @var{memory} @var{index} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{size_t}
type located at @var{index} from @var{memory}.
@end defun


@defun array-set-c-ssize_t! @var{memory} @var{index} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{ssize_t}
type located at @var{index} from @var{memory}.
@end defun


@defun array-set-c-off_t! @var{memory} @var{index} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{off_t}
type located at @var{index} from @var{memory}.
@end defun


@defun array-set-c-ptrdiff_t! @var{memory} @var{index} @var{value}
Set to @var{value} a number of bytes corresponding to the
@code{ptrdiff_t} type located at @var{index} from @var{memory}.
@end defun

@c ------------------------------------------------------------

@subsubheading Poking floating point numbers


@defun array-set-c-float! @var{memory} @var{index} @var{flonum}
Convert the Scheme floating point number @var{flonum} (represented in
@value{PRJNAME} as an @ieee{} 754 double precision floating point number) to a
float (an @ieee{} 754 single precision floating point number) and store
the result in the four bytes at @var{index} from @var{memory}.
@end defun


@defun array-set-c-double! @var{memory} @var{index} @var{flonum}
Store the double precision @ieee{} 754 floating point value of the
Scheme @var{flonum} in the eight bytes at @var{index} from
@var{memory}.
@end defun


@defun array-set-c-double-complex! @var{memory} @var{index} @var{cflonum}
Store the double precision @ieee{} 754 floating point values composing
the Scheme @var{cflonum} in the 16 bytes at @var{index} from
@var{memory}.
@end defun


@c ------------------------------------------------------------

@subsubheading Poking pointers


@defun array-set-c-pointer! @var{memory} @var{index} @var{value}
Store address of the raw memory location referenced by the pointer
@var{value} at @var{index} from @var{memory}.
@end defun

@c page
@node iklib arrays peek
@subsection Peeking values from arrays


With all the following functions: the @var{memory} argument must be a
valid pointer object; the @var{index} argument must be an exact integer
in the range of the C language type @code{ptrdiff_t}.  When adding an
offset to a pointer: all the following functions @strong{do} scale the
index to the size of the peeked value.

The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.

@macro abitpeeker{BITNUM}
Peek the \BITNUM\ bits located at @var{index} from @var{memory} and
return them as signed or unsigned exact integer.
@end macro

@macro acpeeker{TYPE}
Peek the @code{signed \TYPE\} or @code{unsigned \TYPE\} integer located
at @var{index} from @var{memory} and return it as signed or unsigned
exact integer.
@end macro

@c ------------------------------------------------------------

@subsubheading Peeking bitwise sized exact integers

The following functions retrieve signed and unsigned exact integers from
raw memory location selecting the size with the number of bits required
to represent the value.


@defun array-ref-c-sint8 @var{memory} @var{index}
@defunx array-ref-c-uint8 @var{memory} @var{index}
@abitpeeker{8}
@end defun


@defun array-ref-c-sint16 @var{memory} @var{index}
@defunx array-ref-c-uint16 @var{memory} @var{index}
@abitpeeker{16}
@end defun


@defun array-ref-c-sint32 @var{memory} @var{index}
@defunx array-ref-c-uint32 @var{memory} @var{index}
@abitpeeker{32}
@end defun


@defun array-ref-c-sint64 @var{memory} @var{index}
@defunx array-ref-c-uint64 @var{memory} @var{index}
@abitpeeker{64}
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking C language exact integers

The following functions store signed and unsigned exact integers from
raw memory locations selecting the size according to the one used by the
C language implementation.


@defun array-ref-c-signed-char @var{memory} @var{index}
@defunx array-ref-c-signed-char @var{memory} @var{index}
@acpeeker{char}
@end defun


@defun array-ref-c-signed-short @var{memory} @var{index}
@defunx array-ref-c-unsigned-short @var{memory} @var{index}
@acpeeker{short int}
@end defun


@defun array-ref-c-signed-int @var{memory} @var{index}
@defunx array-ref-c-unsigned-int @var{memory} @var{index}
@acpeeker{int}
@end defun


@defun array-ref-c-signed-long @var{memory} @var{index}
@defunx array-ref-c-unsigned-long @var{memory} @var{index}
@acpeeker{long}
@end defun


@defun array-ref-c-signed-long-long @var{memory} @var{index}
@defunx array-ref-c-unsigned-long-long @var{memory} @var{index}
@acpeeker{long long}
@end defun


@defun array-ref-c-size_t @var{memory} @var{index}
Peek the @code{size_t} integer located at @var{index} from @var{memory}
and return it as signed or unsigned exact integer.
@end defun


@defun array-ref-c-ssize_t @var{memory} @var{index}
Peek the @code{ssize_t} integer located at @var{index} from @var{memory}
and return it as signed or unsigned exact integer.
@end defun


@defun array-ref-c-off_t @var{memory} @var{index}
Peek the @code{off_t} integer located at @var{index} from @var{memory}
and return it as signed or unsigned exact integer.
@end defun


@defun array-ref-c-ptrdiff_t @var{memory} @var{index}
Peek the @code{ptrdiff_t} integer located at @var{index} from
@var{memory} and return it as signed or unsigned exact integer.
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking floating point numbers


@defun array-ref-c-float @var{memory} @var{index}
Return the four--byte float (represented as @ieee{} 754 single precision
floating point number) stored at @var{index} from @var{memory}.  The
value is extended to an @ieee{} 754 double precision floating point
number that @value{PRJNAME} uses to represent inexact numbers.
@end defun


@defun array-ref-c-double @var{memory} @var{index}
Return the eight--byte float (represented as @ieee{} 754 double
precision floating point number) stored at @var{index} from
@var{memory}.
@end defun


@defun array-ref-c-double-complex @var{memory} @var{index}
Return a cflonum composed by the two eight--byte floats (represented as
@ieee{} 754 double precision floating point numbers) stored at
@var{index} from @var{memory}.
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking pointers


@defun array-ref-c-pointer @var{memory} @var{index}
Return the pointer stored at @var{index} from @var{memory}.  The size
of the pointer (also the number of bytes loaded) depends on the
architecture: it is 4 bytes on 32-bit systems and 8 bytes on 64-bit
systems.
@end defun

@c page
@node iklib memory
@section Memory management


@menu
* iklib memory intro::          Introduction to managing memory.
* iklib memory alloc::          Allocating and freeing memory.
* iklib memory ops::            Memory operations.
* iklib memory blocks::         Memory blocks.
* iklib memory condition::      Memory allocation condition objects.
@end menu

@c page
@node iklib memory intro
@subsection Introduction to managing memory


@value{PRJNAME} Scheme is a managed environment: Scheme objects are
allocated in a special memory region (the Scheme heap) and have
type--specific object layouts; this allows the run time system to
distinguish object types and the garbage collector to locate all
potentially live objects, and reclaim the memory of dead objects.

Scheme objects are also @emph{opaque} in the sense that the data
structures used to represent Scheme objects are not exposed, at the
Scheme level, to the programmer who can only interact with objects
through an interface.

Unmanaged environments, such as the operating system on which
@value{PRJNAME} runs, require that the programmer manages the allocation
and deallocation of system resources herself.  Memory regions, file
handles, external devices, the screen, etc., are all examples of
resources whose management must be coordinated among the different parts
of the system, and this becomes the responsibility of the programmer who
is wiring the different subsystems together.

The procedures acting on pointer objects are meant to provide a way to
interface with the low level memory operations such as setting and
getting bytes from specific locations in memory.

@c page
@node iklib memory alloc
@subsection Allocating and freeing memory


The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@defun malloc @var{number-of-bytes}
@defunx guarded-malloc @var{number-of-bytes}
Interface to the C function @cfunc{malloc}, @glibcref{Basic Allocation,
malloc}.  Allocate a block of memory @var{number-of-bytes} wide;
@var{number-of-bytes} must be an exact integer in the range of the C
language type @code{size_t}.  If successful return a pointer object,
else return @false{}.

Memory allocated by @func{malloc} must be released by @func{free};
memory allocated by @func{guarded-malloc} is automatically released
whenever the returned pointer object is garbage collected.
@end defun


@defun malloc* @var{number-of-bytes}
@defunx guarded-malloc* @var{number-of-bytes}
Like @func{malloc} and @func{guarded-malloc}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun realloc @var{memory} @var{number-of-bytes}
@defunx guarded-realloc @var{memory} @var{number-of-bytes}
Interface to the C function @cfunc{realloc}, @glibcref{Changing Block
Size, realloc}.  Reallocate the block of memory referenced by
@var{memory} to the new size @var{number-of-bytes}.

@var{memory} must be a pointer object or @code{memory-block} instance.

@var{number-of-bytes} must be an exact integer in the range of the C
language type @code{size_t}.

If successful: mutate the pointer in @var{memory} to reference the new
memory block and return @var{memory} itself; when @var{memory} is a
@code{memory-block}: mutate the size field to @var{number-of-bytes}.  If
an error occurs: return @false{} and leave untouched both @var{memory}
and its referenced memory.

Memory allocated by @func{realloc} must be released by @func{free},
unless @var{memory} was already scheduled to be removed by the garbage
collector; when @func{guarded-realloc} is used:

@itemize
@item
When @var{memory} is a pointer object: the allocated memory is
automatically released whenever the returned pointer object is garbage
collected.  If @var{memory} was already scheduled to be removed by the
garbage collector: we should use @func{realloc} not
@func{guarded-realloc}.

@item
When @var{memory} is an instance of @code{memory-block}: the allocated
memory is automatically released by the garbage collector only if
@code{memory-block} was built by @func{make-memory-block/guarded}.
@end itemize
@end defun


@defun realloc* @var{pointer} @var{number-of-bytes}
@defunx guarded-realloc* @var{pointer} @var{number-of-bytes}
Like @func{realloc} and @func{guarded-realloc}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun calloc @var{number-of-elements} @var{element-size}
@defunx guarded-calloc @var{number-of-elements} @var{element-size}
Interface to the C function @cfunc{calloc}, @glibcref{Allocating Cleared
Space, calloc}.  Allocate and clear to zero a block of memory capable of
holding @var{number-of-elements} each @var{element-size} wide; both the
arguments must be exact integers in the range of the C language type
@code{size_t}.  If successful return a pointer object, else return
@false{}.

Memory allocated by @func{calloc} must be released by @func{free};
memory allocated by @func{guarded-calloc} is automatically released
whenever the returned pointer object is garbage collected.
@end defun


@defun calloc @var{number-of-elements} @var{element-size}
@defunx guarded-calloc @var{number-of-elements} @var{element-size}
Like @func{calloc} and @func{guarded-calloc}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun free @var{memory}
Release the memory referenced by @var{memory}, which must be either a
pointer object returned by @cfunc{malloc}, @cfunc{realloc},
@cfunc{calloc} or a similar system procedure or an instance of
@code{memory-block}.  The pointer object in @var{memory} is mutated to
reference the @cnull{} pointer; when @var{memory} is a
@code{memory-block}: the @code{size} field is also reset to zero.

If memory allocated by a guarding function is released by @func{free}:
@value{PRJNAME} will @strong{not} try to automatically release the old
memory again.

If the pointer in @var{memory} is @cnull{} nothing happens.
@end defun


@defun with-local-storage @var{lengths} @var{proc}
Call @var{proc} with arguments being pointers to memory blocks allocated
just for the dynamic extent of @var{proc}.  The number and size of the
memory blocks is determined by @var{lengths}, which must be a vector of
non--negative fixnums.

@ignore
@c This is not clear, so far letting the flow go through with an
@c exception seems to work (Marco Maggi; Dec  7, 2011)

We must not let control flow go through a call to
@func{with-local-storage} by raising an exception.  @var{proc}
@strong{must} return to the caller.
@end ignore

@strong{NOTE} We must not let control flow go through a call to
@func{with-local-storage} with an escaping continuation.

@example
#!r6rs
(import (rnrs)
  (prefix (vicare ffi) ffi.))

;; no allocated memory
(let ((a 1) (b 2))
  (ffi.with-local-storage '#()
    (lambda ()
      (+ a b 4))))
@result{} 7

;; allocate a single block of 4 bytes
(let ((a 1) (b 2))
  (ffi.with-local-storage '#(4)
    (lambda (&int32)
      (ffi.pointer-set-c-sint32! &int32 0 4)
      (+ a b (ffi.pointer-ref-c-sint32 &int32 0)))))
@result{} 7

;; allocate two blocks of 4 and 8 bytes
(let ((a 1) (b 2))
  (ffi.with-local-storage '#(4 8)
    (lambda (&int32 &int64)
      (ffi.pointer-set-c-sint32! &int32 0 4)
      (ffi.pointer-set-c-sint64! &int64 0 8)
      (+ a b
         (ffi.pointer-ref-c-sint32 &int32 0)
         (ffi.pointer-ref-c-sint64 &int64 0)))))
@result{} 15
@end example

The memory blocks are actually allocated on the stack of
@value{PRJNAME}'s runtime.
@end defun

@c page
@node iklib memory ops
@subsection Memory operations


The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@defun memcpy @var{dst} @var{src} @var{count}
Interface to the C function @cfunc{memcpy}, @glibcref{Copying and
Concatenation, memcpy}.  Copy @var{count} bytes from the memory
referenced by the pointer @var{src} to the memory referenced by the
pointer @var{dst}; @var{count} must be an exact integer in the range of
the C language type @code{size_t}.  The two memory regions must not
overlap.  Return unspecified values.
@end defun


@defun memmove @var{dst} @var{src} @var{count}
Interface to the C function @cfunc{memmove}, @glibcref{Copying and
Concatenation, memmove}.  Copy @var{count} bytes from the memory
referenced by the pointer @var{src} to the memory referenced by the
pointer @var{dst}; @var{count} must be an exact integer in the range of
the C language type @code{size_t}.  The two memory regions can be
overlapping.  Return unspecified values.
@end defun


@defun memset @var{ptr} @var{value} @var{count}
Interface to the C function @cfunc{memset}, @glibcref{Copying and
Concatenation, memset}.Set to @var{value} @var{count} bytes of the
memory referenced by the pointer @var{ptr}.  @var{count} must be an
exact integer in the range of the C language type @code{size_t},
@var{value} must be an exact fixnum in the range @math{[-128, 255]}.
Return unspecified values.
@end defun


@defun memcmp @vari{pointer} @varii{pointer} @var{count}
Interface to the C function @cfunc{memcmp}, @glibcref{String/Array
Comparison, memcmp}.  Compare @var{count} bytes in the memory blocks
referenced by @vari{pointer} and @varii{pointer}, return a fixnum
representing the classic comparison ternary result.  @var{count} must be
an exact integer in the range of the C language type @code{size_t}.
@end defun


@defun memory-copy dst dst.start src src.start count
Copy @var{count} bytes from @var{src} starting at offset @var{src.start}
to @var{dst} starting at offset @var{dst.start}.  @var{src} and
@var{dst} can be pointers or bytevectors; @var{dst.start},
@var{src.start} and @var{count} must be non--negative fixnums.  The two
memory regions must not overlap.  Return unspecified values.
@end defun


@defun memory->bytevector @var{pointer} @var{number-of-bytes}
Build and return a new bytevector object holding @var{number-of-bytes}
from the memory region starting at @var{pointer}.  @var{number-of-bytes}
must be a non--negative fixnum.
@end defun


@defun bytevector->memory @var{bv}
@defunx bytevector->guarded-memory @var{bv}
Allocate a new raw memory block and copy into it the contents of
@var{bv}.  If successful return two values being the pointer object
referencing the memory and a fixnum representing the length of the
memory block; if allocating memory fails return @false{} and @false{}.

Memory allocated by @func{bytevector->memory} must be released by
@func{free}; memory allocated by @func{bytevector->guarded-memory} is
automatically released whenever the returned pointer object is garbage
collected.
@end defun


@defun bytevector->memory* @var{bv}
@defunx bytevector->guarded-memory* @var{bv}
Like @func{bytevector->memory*} and @func{bytevector->guarded-memory*},
but if allocation fails raise a non--continuable exception with
components: @condition{who}, @condition{message},
@condition{out-of-memory-error}.
@end defun

@c page
@node iklib memory blocks
@subsection Memory blocks


The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@deftp {Struct Type} memory-block
Data structure used to reference a raw memory block through a pointer
and number of bytes.  It has the following public fields:

@table @code
@item pointer
A pointer object referencing the first byte of memory.

@item size
The number of bytes in the memory block; it is an exact integer in the
range of the C language type @code{size_t}.
@end table
@end deftp


@defun make-memory-block @var{pointer} @var{size}
@defunx make-memory-block/guarded @var{pointer} @var{size}
Build and return a new instance of @code{memory-block} referencing a
memory block pointed to by @var{pointer} and of @var{size} number of
bytes.

When a @code{memory-block} built by @func{make-memory-block} is garbage
collected: nothing happens.

When a @code{memory-block} built by @func{make-memory-block/guarded} is
garbage collected: the referenced memory block is released with
@func{free} from @library{vicare}.
@end defun


@defun memory-block? @var{obj}
Return @true{} if @var{obj} is an instance of @code{memory-block}.
@end defun


@defun memory-block?/non-null @var{obj}
@defunx memory-block?/not-null @var{obj}
Return @true{} if @var{obj} is an instance of @code{memory-block} and
the pointer is not @cnull{}.
@end defun


@defun memory-block-pointer @var{mblock}
@defunx memory-block-size @var{mblock}
Accessors for the fields of @code{memory-block} instances.  The pointer
object returned by @func{memory-block-pointer} is a copy of the pointer
object in @var{mblock}.
@end defun


@defun memory-block-reset @var{mblock}
Reset an instance of @code{memory-block} to a @cnull{} pointer and zero
size; return unspecified values.  If @var{mblock} has been created to
release the referenced memory block: the memory block is freed.
@end defun


@defun null-memory-block
Build and return a new instance of @code{memory-block} holding a new
@cnull{} pointer object and zero as size.
@end defun

@c page
@node iklib memory condition
@subsection Memory allocation condition objects


The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@deftp {Condition Type} &out-of-memory-error
Condition object type used to tag conditions representing memory
allocation errors; it is derived from @condition{error}.  It has no
fields.
@end deftp


@defun make-out-of-memory-error
@defunx out-of-memory-error? @var{obj}
Maker and predicate for condition objects of type
@condition{out-of-memory-error}.
@end defun

@c page
@node iklib cstrings
@section Raw C strings


The following functions perform operations on raw @ascii{} coded strings
terminated by a zero byte, for short @asciiz{} strings; some functions
act upon raw @utf{}-16 strings.  The following bindings are exported by
the libraries @library{vicare} and @library{vicare system $foreign} and
reexported by the library @library{vicare ffi}.


@defun bytevector->cstring @var{bv}
@defunx bytevector->guarded-cstring @var{bv}
Convert from a Scheme bytevector to an @asciiz{} string.  If successful
return a pointer object referencing the string, else return @false{}.

Memory allocated by @func{bytevector->cstring} must be explicitly
released by @func{free}; memory allocated by
@func{bytevector->guarded-cstring} is automatically released by the
garbage collector whenever the returned pointer is garbage collected.
@end defun


@defun bytevector->cstring* @var{bv}
@defunx bytevector->guarded-cstring* @var{bv}
Like @func{bytevector->cstring} and @func{bytevector->guarded-cstring},
but if allocation fails raise a non--continuable exception with
components: @condition{who}, @condition{message},
@condition{out-of-memory-error}.
@end defun


@defun cstring->bytevector @var{pointer}
@defunx cstring->bytevector @var{pointer} @var{count}
Convert between an @asciiz{} string and a Scheme bytevector.  When used,
@var{count} must be a fixnum representing the number of bytes to include
in the bytevector.
@end defun


@defun string->cstring @var{str}
@defunx string->guarded-cstring @var{str}
Convert from a Scheme string to an @asciiz{} string.  If successful
return a pointer object referencing the string, else return @false{}.

The string argument must contain only characters with Unicode code
points in the range @math{[0, 255]}.

Memory allocated by @func{string->cstring} must be explicitly
released by @func{free}; memory allocated by
@func{string->guarded-cstring} is automatically released by the
garbage collector whenever the returned pointer is garbage collected.
@end defun


@defun cstring16->bytevector @var{pointer}
Convert between an @utf{}-16 string and a Scheme bytevector; this
function works with all the possible encodings of the string.  The end
of the string is determined by searching for a sequence of two
consecutive zero bytes, starting at even offset.
@end defun


@defun cstring16n->string @var{pointer}
@defunx cstring16le->string @var{pointer}
@defunx cstring16be->string @var{pointer}
Like @func{cstring16->bytevector}, but convert the result to a Scheme
string assuming the specified byte order (native, little endian, big
endian).
@end defun


@defun string->cstring* @var{str}
@defunx string->guarded-cstring* @var{str}
Like @func{string->cstring} and @func{string->guarded-cstring}, but if
allocation fails raise a non--continuable exception with components:
@condition{who}, @condition{message}, @condition{out-of-memory-error}.
@end defun


@defun cstring->string @var{pointer}
@defunx cstring->string @var{pointer} @var{count}
Convert between an @asciiz{} string and a Scheme string.  When used,
@var{count} must be a fixnum representing the number of bytes to include
in the string.
@end defun


@defun strlen @var{pointer}
Interface to the C function @cfunc{strlen}, @glibcref{String Length,
strlen}.  Return an exact integer representing the length of the
@asciiz{} string referenced by @var{pointer}.
@end defun


@defun strcmp @vari{pointer} @varii{pointer}
Interface to the C function @cfunc{strcmp}, @glibcref{String/Array
Comparison, strcmp}.  Return a fixnum representing the classic
comparison ternary result of comparing the @asciiz{} strings referenced
by @vari{pointer} and @varii{pointer}.
@end defun


@defun strncmp @vari{pointer} @varii{pointer} @var{count}
Interface to the C function @cfunc{strncmp}, @glibcref{String/Array
Comparison, strncmp}.  Return a fixnum representing the classic
comparison ternary result of comparing the first @var{count} bytes in
the @asciiz{} strings referenced by @vari{pointer} and @varii{pointer}.
@var{count} must be an exact integer in the range of the C language type
@code{size_t}.
@end defun


@defun strdup @var{pointer}
@defunx guarded-strdup @var{pointer}
Interface to the C function @cfunc{strdup}, @glibcref{Copying and
Concatenation, strdup}.  Duplicate the @asciiz{} string referenced by
@var{pointer}; if successful return a new pointer object, else return
@false{}.

Memory allocated by @func{strdup} must be explicitly released by
@func{free}; memory allocated by @func{guarded-strdup} is automatically
released by the garbage collector whenever the returned pointer is
garbage collected.
@end defun


@defun strdup* @var{pointer}
@defunx guarded-strdup* @var{pointer}
Like @func{strdup} and @func{guarded-strdup}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun strndup @var{pointer} @var{count}
@defunx guarded-strndup @var{pointer} @var{count}
Interface to the C function @cfunc{strndup}, @glibcref{Copying and
Concatenation, strndup}.  Duplicate the first @var{count} bytes in the
@asciiz{} string referenced by @var{pointer}; if successful return a new
pointer object, else return @false{}.  @var{count} must be an exact
integer in the range of the C language type @code{size_t}.

Memory allocated by @func{strdup} must be explicitly released by
@func{free}; memory allocated by @func{guarded-strdup} is automatically
released by the garbage collector whenever the returned pointer is
garbage collected.
@end defun


@defun strndup* @var{pointer} @var{count}
@defunx guarded-strndup* @var{pointer} @var{count}
Like @func{strndup} and @func{guarded-strndup}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun bytevectors->argv @var{list-of-bytevectors}
@defunx bytevectors->guarded-argv @var{list-of-bytevectors}
Given a list of bytevectors: convert them into @asciiz{} strings and
build a @cnull{} terminated array of C pointers referencing the strings.
The strings and the array are stored in a single memory block.  If
successful return the pointer object, otherwise return @false{}.

Memory allocated by @func{bytevectors->argv} must be explicitly released
by @func{free}; memory allocated by @func{bytevectors->guarded-argv} is
automatically released by the garbage collector whenever the returned
pointer is garbage collected.
@end defun


@defun bytevectors->argv* @var{list-of-bytevectors}
@defunx bytevectors->guarded-argv* @var{list-of-bytevectors}
Like @func{bytevectors->argv*} and @func{bytevectors->guarded-argv*},
but if allocation fails raise a non--continuable exception with
components: @condition{who}, @condition{message},
@condition{out-of-memory-error}.
@end defun


@defun argv->bytevectors @var{pointer}
Given a pointer to a @cnull{} terminated array of C pointers referencing
@asciiz{} strings: build and return a list of bytevectors holding the
same bytes of the strings.
@end defun


@defun strings->argv @var{list-of-strings}
@defunx strings->guarded-argv @var{list-of-strings}
Given a list of Scheme strings: convert them into @asciiz{} strings and
build a @cnull{} terminated array of C pointers referencing the strings.
Return a pointer to the array.  The strings and the array are stored in
a single memory block.

The string arguments must contain only characters with Unicode code
points in the range @math{[0, 255]}.

Memory allocated by @func{strings->argv} must be explicitly released
by @func{free}; memory allocated by @func{strings->guarded-argv} is
automatically released by the garbage collector whenever the returned
pointer is garbage collected.
@end defun


@defun strings->argv* @var{list-of-strings}
@defunx strings->guarded-argv* @var{list-of-strings}
Like @func{strings->argv} and @func{strings->guarded-argv}, but if
allocation fails raise a non--continuable exception with components:
@condition{who}, @condition{message}, @condition{out-of-memory-error}.
@end defun

@defun argv->strings @var{pointer}
Given a pointer to a @cnull{} terminated array of C pointers referencing
@asciiz{} strings: build and return a list of strings holding the same
bytes of the strings.
@end defun


@defun argv-length @var{argv}
Return the number of strings in the @cnull{}--terminated array of
strings referenced by the @var{argv} pointer.
@end defun

@c page
@node iklib errno
@section Interface to @code{errno}


Most C language system functions report errors by setting a the special
variable @code{errno} to some predefined integer constant,
@glibcref{Checking for Errors, errno}.  The Scheme code accessing
@code{errno} values should be agnostic with respect to the actual error
codes; for this to happen we should use the following facilities along
with bindings from @library{vicare platform errno}, @libsref{errno, More
features for @code{errno}} for details.

Values for the C language variable @code{errno} are encoded as negated
fixnum values: if @code{EPERM} is defined to @code{1} at the C language
level, @value{PRJNAME} defines it as the fixnum @code{-1}; at present
all the known error codes fit into fixnums range.  One syntax identifier
binding for each known @code{errno} value is exported by the library
@library{vicare platform errno} and reexported by the library
@library{vicare platform constants}.

If some error codes are not defined on a platform: the corresponding
binding evaluates to @true{}.  Notice that if no error occurred
@code{errno} is set to the fixnum zero.

The following bindings are exported by the libraries @library{vicare}
and @library{vicare system $foreign} and reexported by the library
@library{vicare ffi}.


@defun errno
@defunx errno @var{code}
Interface to the C language level @code{errno} variable to be used with
the foreign--functions interface (@ffi{}).

When called with no values return the value of the C variable
@code{errno} right after the last call to a C function performed by the
current process through the @ffi{}.  When called with one argument: set
the C variable @code{errno} of the current process to @var{code},
appropriately handling the coding of the value.

Notice that bindings exported by @library{vicare posix}, @library{vicare
glibc} and @library{vicare linux} do @strong{not} use this mechanism;
rather they raise an exception whenever an error happen.

As special cases: when the C variable @code{errno} is set to zero,
@func{errno} returns @false{}; when @var{code} is @false{}, the C
variable @code{errno} is set to zero; when @var{code} is @true{}, the C
variable @code{errno} is set to @code{EFAULT}.

The mechanism is such that the following form:

@example
(let ((rv (call-foreign-function)))
  (values rv (errno)))
@end example

@noindent
performs a foreign--function call and evaluates to two values: the
return value from the foreign function and the value of the C variable
@code{errno} right after the foreign call.
@end defun

@c page
@node iklib time
@section Basic time and date functions


The following bindings are exported by the library @library{vicare}.


@defun current-time
Return an object of disjoint type representing the current time as
determined by @cfunc{gettimeofday}: this is the elapsed time since the
Epoch.
@end defun


@defun time-from-now @var{delta}
Return a time object representing the current time plus the time object
@var{delta}.
@end defun


@defun make-time @var{seconds} @var{nanoseconds}
Build and return a new time object with microseconds resolution.  If
@var{nanoseconds} exceeds @math{1000000} its value is normalised and the
excess added to @var{seconds}.
@end defun


@defun time? @var{obj}
Return @true{} if @var{obj} is a time object returned by
@func{current-time}.
@end defun


@defun time-second @var{time}
@defunx time-nanosecond @var{time}
Accessors, returning exact integers, for the seconds and nanoseconds
components of the time objects returned by @func{current-time}.
@end defun


@defun time-gmt-offset @var{time}
Return the @acronym{GMT} offset in seconds of the @var{time} object
returned by @func{current-time}, as determined ty @cfunc{gmtime_r}.
@end defun


@defun date-string
Return a string representing the current date in the simple format:
year, month, day.
@end defun

@c ------------------------------------------------------------

@subsubheading Time operations


@defun time-addition @vari{time} @varii{time}
Compute the addition between two times: @code{@vari{time} +
@varii{time}} and return a time struct representing it.
@end defun


@defun time-difference @vari{time} @varii{time}
Compute the difference between two times: @code{@vari{time} -
@varii{time}} and return a time struct representing it.
@end defun

@c ------------------------------------------------------------

@subsubheading Time comparison


@defun time=? @vari{time} @varii{time}
Return @true{} if the time objects are equal, else return @false{}.
@end defun


@defun time<? @vari{time} @varii{time}
Return @true{} if the @vari{time} is less than @varii{time}, else return
@false{}.
@end defun


@defun time<=? @vari{time} @varii{time}
Return @true{} if the @vari{time} is less than or equal to @varii{time},
else return @false{}.
@end defun


@defun time>? @vari{time} @varii{time}
Return @true{} if the @vari{time} is greater than @varii{time}, else
return @false{}.
@end defun


@defun time>=? @vari{time} @varii{time}
Return @true{} if the @vari{time} is greater than or equal to
@varii{time}, else return @false{}.
@end defun

@c page
@node iklib readline
@section Readline interface


The following bindings are exported by the library @library{vicare}.  An
extended @api{} for @gnu{} Readline is available through the
@library{vicare readline} library; @libsref{readline, Extended interface
to @gnu{} Readline} for details.


@defun readline-enabled?
Return @true{} is support for readline is enabled, return @false{}
otherwise.  When this function returns @false{}: no other readline
functions must be called, lest the process be aborted.
@end defun


@defun readline
@defunx readline @var{prompt}
Read a single line and return it as a Scheme string @strong{not}
terminated by a newline character.  @var{prompt} must be @false{}, a
bytevector or a string to be used as input prompt; when @false{} or not
present: no prompt will be displayed.
@end defun


@defun make-readline-input-port
@defunx make-readline-input-port @var{prompt-maker}
Return a custom textual input port reading character through
@func{readline}.

@var{prompt-maker} must be a @false{} or a thunk, when not used it
defaults to @false{}; the thunk, when evaluated, must return a string or
bytevector representing the input prompt in @ascii{} characters; if the
return value is @false{} or @var{prompt-maker} is not used: no prompt
will be displayed.
@end defun

@c page
@node iklib debug
@section Debugging utilities


@defun integer->machine-word @var{exact-integer}
@defunx machine-word->integer @var{word}
Convert between an exact integer and a machine word.  This operation
shows at the Scheme level the internal representation of values.  Care
must be taken when using these functions because it is very easy to
cause undefined behaviour.

@example
;; on 32-bit platforms
(integer->machine-word #b11100) @result{} #b111

;; on 64-bit platforms
(integer->machine-word #b111000) @result{} #b111

(integer->machine-word #x3F)    @result{} #t
(integer->machine-word #x2F)    @result{} #f

(machine-word->integer #t)      @result{} #x3F
(machine-word->integer #f)      @result{} #x2F
@end example
@end defun


@defun flonum->bytevector @var{flo}
@defunx bytevector->flonum @var{bv}
Convert a flonum to a bytevector and vice versa.  The flonum's memory
block is copied byte by byte in the data area of the bytevector; and
vice versa.

For @func{bytevector->flonum}: if the bytevector does not have the
length of a flonum's memory block, the return value is @false{}.
@end defun


@defun bignum->bytevector @var{flo}
@defunx bytevector->bignum @var{bv}
Convert a bignum to a bytevector and vice versa.  The bignum's memory
block is copied byte by byte in the data area of the bytevector; and
vice versa.
@end defun

@c page
@node iklib misc
@section Miscellaneous functions


@defun neq? @vari{obj} @varii{obj}
Compare the arguments as @func{eq?} would do, but return a negated
result.  Equivalent (but more efficient) to:

@example
(not (eq? @vari{obj} @varii{obj}))
@end example
@end defun


@defun immediate? @var{obj}
Return true if @var{obj} is an immediate object: an object contained in
a single machine word.  Compound objects (like lists and vectors) are
@strong{not} immediate.
@end defun


@defun void
Return the void value.  It is the value returned by forms that do not
return a meaningful value.
@end defun


@defun void-object? @var{obj}
Return @true{} if @var{obj} is the void value; otherwise return
@false{}.
@end defun


@defun always-true @var{arg} @dots{}
@defunx always-false @var{arg} @dots{}
Always return @true{} or @false{}, ignoring the arguments.
@end defun


@defun apropos @var{key}
Given a string or symbol @var{key}, search among the internally
installed libraries all the exported bindings having @var{key} as
substring of their name and print a report to the standard output port.
Useful when using the @repl{}.  Example:

@example
vicare> (apropos "-length")
*** in library (vicare):
(bitwise-length bytevector-length string-length
  struct-length vector-length)

*** in library (rnrs):
(bitwise-length bytevector-length string-length
  vector-length)

*** in library (rnrs arithmetic bitwise):
(bitwise-length)

*** in library (rnrs base):
(string-length vector-length)

*** in library (rnrs bytevectors):
(bytevector-length)

*** in library (vicare):
(bitwise-length bytevector-length string-length
  struct-length vector-length)

vicare>
@end example
@end defun


@defun getenv @var{varname}
Interface to the C function @cfunc{getenv}, @glibcref{Environment
Access, getenv}.  Retrieve the value of environment variables.
@var{variable} must reference a string object representing the name of
the environment variable.  If the environment variable is set: return a
string representing its value; else return false.

@example
(getenv "PATH")
@result{} "/usr/local/bin:/usr/bin:/bin"
@end example

The Scheme level representation of environment variables names and
values is a string, but internally it is a bytevector; strings are
internally converted to bytevectors using @func{string->utf8}.
@end defun


@defun environ
Interface to the global C variable @code{environ}, @glibcref{Environment
Access, unsetenv}.  Retrieve the full environment.  Return a list of
strings representing the contents of the @code{environ} array; if the
environment is empty (no environment variables set) return nil.
@end defun


@defun strerror @var{errno}
Return a string describing the @code{errno} code @var{errno}.  Makes use
of the system function @cfunc{strerror}.  If @var{errno} is not a valid
@code{errno} value: return a string telling it.  As special cases
@var{errno} can be also @true{}, meaning ``unknown error'', and
@false{}, meaning ``no error''.

@glibcref{Error Messages, Error Messages}
@end defun


@defun warning @var{who} @var{message} @var{irritant} ...
Similar to @func{error}, but raise a @strong{continuable} exception with
condition components: @condition{warning}, @condition{who},
@condition{message}, @condition{irritants}.
@end defun


@defun die @var{who} @var{message} @var{irritant} ...
A deprecated alias for @func{assertion-violation}.
@end defun


@defun random @var{fx}
Return a random fixnum object between zero (included) and @var{fx}
(excluded).  @var{fx} must be a strictly positive fixnum.
@end defun


@deffn Parameter exit-hooks
@cindex Parameter @func{exit-hooks}
Contains null or a list of thunks to be evaluated by @func{exit}
whenever the process is normally terminated.  Any exception raised by
the thunks is catched and discarded.  To add an exit hook:

@example
(define (do-something-at-exit)
  ---)

(exit-hooks (cons do-something-at-exit
                  (exit-hooks)))
@end example
@end deffn

@c end of file
