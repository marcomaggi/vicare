@node libs
@chapter Other libraries


@value{PRJNAME} comes with a set of additional libraries.

@menu
* args::                        Optional function arguments validation.
* errno::                       More features for @code{errno}.
* platform::                    Hosting platform utilities.
* words::                       Exact integer predicates and constants.
* cbuffers::                    Generalised C buffers and strings.
* bytevectors::                 Additional bytevector utilities.
* readline::                    Extended interface to @gnu{} Readline.
* parser logic::                Defining parsers logic.
* gcc::                         A toy library interface to @gcc{}.
* wtables::                     Weak hashtables.
* flonum format::               Formatting flonums.
* flonum parse::                Parsing flonums.
* sentinels::                   Sentinel values.
* debugging::                   Debugging facilities.
* bytevector compounds::        Bytevector compounds.
* net channels::                Interprocess connection channels.
@end menu

@c page
@node args
@section Optional function arguments validation


@cindex Library @library{vicare arguments validation}
@cindex @library{vicare arguments validation}, library


The library @library{vicare arguments validation} provides bindings to
macros that extend the Scheme language implemented by @library{vicare}
and @library{rnrs}.

@menu
* args config::                 Enabling or disabling arguments
                                validation.
* args definitions::            Defining arguments validation clauses.
* args using::                  Performing arguments validation.
* args forms::                  Optional validation forms.

* args predefined::             Predefined validation clauses.
@end menu

@c page
@node args config
@subsection Enabling or disabling arguments validation


@cindex @env{VICARE_ARGUMENTS_VALIDATION} environment variable
@cindex Environment variable @env{VICARE_ARGUMENTS_VALIDATION}


Global arguments validation is enabled or disabled by setting to @true{}
or @false{} the @code{arguments-validation} identifier syntax exported
by @library{vicare platform configuration}, the default is @true{}; such
value can be configured as follows:

@enumerate
@item
Argument validation is @strong{enabled} by setting to the string
@code{yes}, or the string @code{1}, the environment variable
@env{VICARE_ARGUMENTS_VALIDATION}.

@item
Argument validation is @strong{disabled} by setting to the string
@code{no}, or the string @code{0}, the environment variable
@env{VICARE_ARGUMENTS_VALIDATION}.

@item
If the environment variable @env{VICARE_ARGUMENTS_VALIDATION} is unset
or set to some string different from @code{yes}, @code{no}, @code{1},
@code{0}:

@itemize
@item
Arguments validation is @strong{enabled} if the
@option{--enable-arguments-validation} option of the @command{configure}
script was used.

@item
Arguments validation is @strong{disabled} if the
@option{--disable-arguments-validation} option of the
@command{configure} script was used.
@end itemize
@end enumerate

@c page
@node args definitions
@subsection Defining argument validation clauses


The following bindings are exported by the library @library{vicare
arguments validation}.


@defmac define-argument-validation (@meta{name} @meta{who} @meta{arg} ...) @meta{predicate} @meta{error-handler}
Define a validation clause to be used along with the syntax
@func{WITH-ARGUMENTS-VALIDATION}.  Example:

@example
(define-argument-validation (bytevector who bv)
  (bytevector? bv)
  (assertion-violation who
    "expected a bytevector as argument"
    bv))
@end example

We have to assume that the values @meta{arg} are evaluated multiple
times.
@end defmac

@c page
@node args using
@subsection Performing arguments validation


The following bindings are exported by the library @library{vicare
arguments validation}.


@defmac with-arguments-validation (@meta{who}) ((@meta{validator} @meta{arg} ...) ...) @metao{body} . @meta{body}
If arguments validation is enabled: expand to code that validates the
@meta{arg} expressions using to the @meta{validator} clause, then
evaluate the @meta{body} forms; if arguments validation is disabled:
just evaluate the @meta{body} forms.

@meta{who} must be an identifier used as argument when building a
@condition{who} condition object.

@meta{validator} must be an identifier previously used as name of
validation clause by the @func{define-argument-validation} macro.  As a
special case when @meta{validator} is the identifier @func{void},
exported by @library{vicare}, no validation is generated: the @var{arg}
values are considered always valid; this is sometimes useful when using
this macro in the expansion of another macro.

Simple example:

@example
(define-argument-validation (fixnum who obj)
  (fixnum? obj)
  (assertion-violation who
    "expected fixnum as argument"
    obj))

(define-argument-validation (integer who obj)
  (integer? obj)
  (assertion-violation who
    "expected integer as argument"
    obj))

(with-arguments-validation (who)
     ((fixnum  X)
      (integer Y))
  (do-this)
  (do-that))
@end example

@noindent
multiple clauses are evaluated from first to last, so the above example
is equivalent to:

@example
(with-arguments-validation (who)
     ((fixnum  X))
  (with-arguments-validation (who)
       ((integer Y))
    (do-this)
    (do-that)))
@end example

@noindent
which is equivalent to something like:

@example
(if (fixnum? X)
    (if (integer? X)
        (begin
          (do-this)
          (do-that))
      (assertion-violation who
        "expected integer as argument"
        obj))
  (assertion-violation who
    "expected fixnum as argument"
    obj))
@end example
@end defmac


@defmac with-dangerous-arguments-validation (@meta{who}) ((@meta{validator} @meta{arg} ...) ...) @metao{body} . @meta{body}
Like @func{with-arguments-validation}, but the validation is always
performed even when global arguments validation is disabled.
@end defmac

@c page
@node args forms
@subsection Optional validation forms


The following bindings are exported by the library @library{vicare
arguments validation}.


@defmac arguments-validation-forms
@defmacx arguments-validation-forms @metao{body} . @meta{body}
When used without arguments or arguments validation disabled: expand to
@code{(values)}; else expand to:

@example
(begin @metao{body} . @meta{body})
@end example
@end defmac

@c page
@node args predefined
@subsection Predefined validation clauses


@menu
* args predefined pairs::          Validating pairs and lists.
* args predefined booleans::       Validating booleans.
* args predefined numbers::        Validating numbers.
* args predefined fixnums::        Validating fixnums.
* args predefined exact integers:: Validating exact integers.
* args predefined keywords::       Validating keywords.
* args predefined promises::       Validating promises.
* args predefined bits::           Validating bit--sized integers.
* args predefined signed int::     Validating C language @code{int} values.
* args predefined clang::          Validating C language values.
* args predefined chars::          Validating characters.
* args predefined strings::        Validating string and
                                   related arguments.
* args predefined vectors::        Validating vector and
                                   related arguments.
* args predefined bytevectors::    Validating bytevector and related
                                   arguments.
* args predefined symbols::        Validating symbols.
* args predefined enum-sets::      Validating enum-sets.
* args predefined pointers::       Validating pointers.
* args predefined memory-blocks::  Validating @code{memory-block} values.
* args predefined flonums::        Validating flonums.
* args predefined bignums::        Validating bignums.
* args predefined ratnums::        Validating ratnums.
* args predefined reals::          Validating reals.
* args predefined compnums::       Validating compnums.
* args predefined cflonums::       Validating cflonums.
* args predefined complexes::      Validating complexes.
* args predefined ports::          Validating input/output ports.
* args predefined transcoders::    Validating port transcoders.
* args predefined procedures::     Validating procedures.
* args predefined genstrings::     Validating generalised C string
                                   arguments.
* args predefined genbuffers::     Validating generalised C buffer
                                   arguments.
* args predefined time::           Time objects.
@end menu

@c page
@node args predefined pairs
@subsubsection Validating pairs and lists


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} pair @var{obj}
Succeed if @var{obj} satisfies the predicate @func{pair?}.
@end deffn


@deffn {Validation Clause} list @var{obj}
Succeed if @var{obj} satisfies the predicate @func{list?}.
@end deffn

@c page
@node args predefined booleans
@subsubsection Validating booleans


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} boolean @var{obj}
Succeed if @var{obj} satisfies the predicate @func{boolean?}.
@end deffn

@c page
@node args predefined numbers
@subsubsection Validating numbers


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} number @var{obj}
Succeed if @var{obj} satisfies the predicate @func{number?}.
@end deffn

@c page
@node args predefined fixnums
@subsubsection Validating fixnums


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} fixnum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{fixnum?}.
@end deffn


@deffn {Validation Clause} fixnum/false @var{obj}
Succeed if @var{obj} is @false{} or it satisfies the predicate
@func{fixnum?}.
@end deffn


@deffn {Validation Clause} positive-fixnum @var{obj}
@deffnx {Validation Clause} negative-fixnum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{fixnum?} and it is
strictly positive or strictly negative.
@end deffn


@deffn {Validation Clause} non-positive-fixnum @var{obj}
@deffnx {Validation Clause} non-negative-fixnum @var{obj}
@deffnx {Validation Clause} fixnum-index @var{obj}
Succeed if @var{obj} satisfies the predicate @func{fixnum?} and it is
strictly positive or strictly negative.

The clause @code{fixnum-index} is an alias for
@code{non-negative-fixnum}.
@end deffn


@deffn {Validation Clause} non-zero-fixnum @var{obj}
Fails if @var{obj} satisfies the predicate @func{fxzero?}.
@end deffn


@deffn {Validation Clause} fixnum-in-inclusive-range @var{obj} @var{min} @var{max}
@deffnx {Validation Clause} fixnum-in-exclusive-range @var{obj} @var{min} @var{max}
Succeed if @var{obj} satisfies the predicate @func{fixnum?} and it is in
the specified range.  @var{min} and @var{max} must be fixnums.
@end deffn


@deffn {Validation Clause} even-fixnum @var{obj}
@deffnx {Validation Clause} odd-fixnum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{fixnum?} and the
predicate @func{fxeven?} or @func{fxodd?}.
@end deffn

@c page
@node args predefined exact integers
@subsubsection Validating exact integers


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} exact-integer @var{obj}
Succeed if @var{obj} satisfies the predicates @func{integer?} and
@func{exact?}.
@end deffn


@deffn {Validation Clause} exact-integer/false @var{obj}
Succeed if @var{obj} is @false{} or it satisfies the predicates
@func{integer?} and @func{exact?}.
@end deffn


@deffn {Validation Clause} positive-exact-integer @var{obj}
@deffnx {Validation Clause} negative-exact-integer @var{obj}
Succeed if @var{obj} satisfies the predicates @func{integer?} and
@func{exact?} and it is strictly positive or strictly negative.
@end deffn


@deffn {Validation Clause} non-positive-exact-integer @var{obj}
@deffnx {Validation Clause} non-negative-exact-integer @var{obj}
Succeed if @var{obj} satisfies the predicates @func{integer?} and
@func{exact?} and it is strictly positive or strictly negative.
@end deffn


@deffn {Validation Clause} exact-integer-in-inclusive-range @var{obj} @var{min} @var{max}
@deffnx {Validation Clause} exact-integer-in-exclusive-range @var{obj} @var{min} @var{max}
Succeed if @var{obj} satisfies the predicates @func{integer?} and
@func{exact?} and it is in the specified range.  @var{min} and @var{max}
must be exact integers.
@end deffn


@deffn {Validation Clause} even-exact-integer @var{obj}
@deffnx {Validation Clause} odd-exact-integer @var{obj}
Succeed if @var{obj} satisfies the predicates @func{integer?} and
@func{exact?} and the predicate @func{even?} or @func{odd?}.
@end deffn

@c page
@node args predefined keywords
@subsubsection Validating keywords


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} keyword @var{obj}
Succeed if @var{obj} is a keyword object: it satisfies the predicate
@func{keyword?} exported by @library{vicare}.
@end deffn

@c page
@node args predefined promises
@subsubsection Validating promises


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} promise @var{obj}
Succeed if @var{obj} is a promise object: it satisfies the predicate
@func{promise?} exported by @library{vicare}.
@end deffn


@deffn {Validation Clause} false-or-promise @var{obj}
Succeed if @var{obj} is @false{} or a promise object: it satisfies the
predicate @func{promise?} exported by @library{vicare}.
@end deffn

@c page
@node args predefined bits
@subsubsection Validating bit--sized integers


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} octet @var{obj}
@deffnx {Validation Clause} false-or-octet @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an octet.
@end deffn


@deffn {Validation Clause} byte @var{obj}
@deffnx {Validation Clause} false-or-byte @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an byte.
@end deffn


@deffn {Validation Clause} word-u8 @var{obj}
@deffnx {Validation Clause} word-u8/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an octet.
@end deffn


@deffn {Validation Clause} word-s8 @var{obj}
@deffnx {Validation Clause} word-s8/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of a byte.
@end deffn


@deffn {Validation Clause} word-u16 @var{obj}
@deffnx {Validation Clause} word-u16/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an unsigned @math{16}-bit integer.
@end deffn


@deffn {Validation Clause} word-s16 @var{obj}
@deffnx {Validation Clause} word-s16/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of a signed @math{16}-bit integer.
@end deffn


@deffn {Validation Clause} word-u32 @var{obj}
@deffnx {Validation Clause} word-u32/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an unsigned @math{32}-bit integer.
@end deffn


@deffn {Validation Clause} word-s32 @var{obj}
@deffnx {Validation Clause} word-s32/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of a signed @math{32}-bit integer.
@end deffn


@deffn {Validation Clause} word-u64 @var{obj}
@deffnx {Validation Clause} word-u64/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an unsigned @math{64}-bit integer.
@end deffn


@deffn {Validation Clause} word-s64 @var{obj}
@deffnx {Validation Clause} word-s64/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of a signed @math{64}-bit integer.
@end deffn


@deffn {Validation Clause} word-u128 @var{obj}
@deffnx {Validation Clause} word-u128/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an unsigned @math{128}-bit integer.
@end deffn


@deffn {Validation Clause} word-s128 @var{obj}
@deffnx {Validation Clause} word-s128/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of a signed @math{128}-bit integer.
@end deffn


@deffn {Validation Clause} word-u256 @var{obj}
@deffnx {Validation Clause} word-u256/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an unsigned @math{256}-bit integer.
@end deffn


@deffn {Validation Clause} word-s256 @var{obj}
@deffnx {Validation Clause} word-s256/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of a signed @math{256}-bit integer.
@end deffn


@deffn {Validation Clause} machine-word @var{obj}
@deffnx {Validation Clause} machine-word/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an unsigned machine word integer; a
machine word is @math{32}-bit or @math{64}-bit integer.
@end deffn

@c page
@node args predefined signed int
@subsubsection Validating C language @code{int} values


Exact integers in the range of the C language type @code{int} are used
often when interfacing with a foreign C language library; the library
@library{vicare platform words} provides the predicate @func{signed-int?} to
validated such values; @ref{words predicates} for details.

The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} signed-int @var{obj}
Succeed if @var{obj} satisfies the predicate @func{signed-int?}.
@end deffn


@deffn {Validation Clause} signed-int/false @var{obj}
Succeed if @var{obj} is @false{} or it satisfies the predicate
@func{signed-int?}.
@end deffn


@deffn {Validation Clause} positive-signed-int @var{obj}
@deffnx {Validation Clause} negative-signed-int @var{obj}
Succeed if @var{obj} satisfies the predicate @func{signed-int?} and it
is strictly positive or strictly negative.
@end deffn


@deffn {Validation Clause} non-positive-signed-int @var{obj}
@deffnx {Validation Clause} non-negative-signed-int @var{obj}
Succeed if @var{obj} satisfies the predicate @func{signed-int?} and it
is strictly positive or strictly negative.
@end deffn


@deffn {Validation Clause} signed-int-in-inclusive-range @var{obj} @var{min} @var{max}
@deffnx {Validation Clause} signed-int-in-exclusive-range @var{obj} @var{min} @var{max}
Succeed if @var{obj} satisfies the predicate @func{signed-int?} and it
is in the specified range.  @var{min} and @var{max} must be exact
integers.
@end deffn


@deffn {Validation Clause} even-signed-int @var{obj}
@deffnx {Validation Clause} odd-signed-int @var{obj}
Succeed if @var{obj} satisfies the predicate @func{signed-int?} and the
predicate @func{even?} or @func{odd?}.
@end deffn

@c page
@node args predefined clang
@subsubsection Validating C language values


The library @library{vicare platform words} provides the predicates to validate
typical values used when interfacing with foreign C language libraries;
@ref{words predicates} for details.

The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} unsigned-char @var{obj}
@deffnx {Validation Clause} unsigned-char/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{unsigned char}.
@end deffn


@deffn {Validation Clause} signed-char @var{obj}
@deffnx {Validation Clause} signed-char/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{signed char}.
@end deffn


@deffn {Validation Clause} unsigned-short @var{obj}
@deffnx {Validation Clause} unsigned-short/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{unsigned short int}.
@end deffn


@deffn {Validation Clause} signed-short @var{obj}
@deffnx {Validation Clause} signed-short/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{signed short int}.
@end deffn


@deffn {Validation Clause} unsigned-int @var{obj}
@deffnx {Validation Clause} unsigned-int/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{unsigned int}.
@end deffn


@deffn {Validation Clause} unsigned-long @var{obj}
@deffnx {Validation Clause} unsigned-long/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{unsigned long}.
@end deffn


@deffn {Validation Clause} signed-long @var{obj}
@deffnx {Validation Clause} signed-long/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{signed long}.
@end deffn


@deffn {Validation Clause} unsigned-long-long @var{obj}
@deffnx {Validation Clause} unsigned-long-long/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{unsigned long long}.
@end deffn


@deffn {Validation Clause} signed-long-long @var{obj}
@deffnx {Validation Clause} signed-long-long/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{signed long long}.
@end deffn


@deffn {Validation Clause} pointer-integer @var{obj}
@deffnx {Validation Clause} pointer-integer/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{void *}.
@end deffn


@deffn {Validation Clause} size_t @var{obj}
@deffnx {Validation Clause} size_t/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{size_t}.
@end deffn


@deffn {Validation Clause} ssize_t @var{obj}
@deffnx {Validation Clause} ssize_t/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{ssize_t}.
@end deffn


@deffn {Validation Clause} off_t @var{obj}
@deffnx {Validation Clause} off_t/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{off_t}.
@end deffn


@deffn {Validation Clause} ptrdiff_t @var{obj}
@deffnx {Validation Clause} ptrdiff_t/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{ptrdiff_t}.
@end deffn

@c page
@node args predefined chars
@subsubsection Validating characters


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} char @var{obj}
Succeed if @var{obj} is a character.
@end deffn

@c page
@node args predefined strings
@subsubsection Validating string and related arguments


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} string @var{obj}
Succeed if @var{obj} is a string.
@end deffn


@deffn {Validation Clause} string/false @var{obj}
Succeed if @var{obj} is @false{} or a string.
@end deffn


@deffn {Validation Clause} non-empty-string @var{obj}
Succeed if @var{obj} is a string and its length is greater than zero.
@end deffn


@deffn {Validation Clause} non-empty-string/false @var{obj}
Succeed if @var{obj} is @false{} or a string and its length is greater
than zero.
@end deffn


@deffn {Validation Clause} list-of-strings @var{obj}
Succeed if @var{obj} is null or a list of strings.
@end deffn


@deffn {Validation Clause} string-or-symbol @var{obj}
@deffnx {Validation Clause} string-or-symbol-or-false @var{obj}
Succeed if @var{obj} is a string or symbol; the second clause accepts
also @false{}.
@end deffn

@c ------------------------------------------------------------

@deffn {Validation Clause} index-for-string @var{str} @var{idx}
Succeed if @var{idx} is a fixnum usable as index (not out of range) for
@var{str}, which is expected to be an already validated string.
@var{idx} must satisfy the constraints:

@example
0 <= @var{idx} < (string-length @var{str})
@end example
@end deffn


@deffn {Validation Clause} one-off-index-for-string @var{str} @var{idx}
Succeed if @var{idx} is a fixnum usable as index for @var{str}, which is
expected to be an already validated string, or it is equal to the string
length.  @var{idx} must satisfy the constraints:

@example
0 <= @var{idx} <= (string-length @var{str})
@end example
@end deffn


@deffn {Validation Clause} index-and-count-for-string @var{str} @var{idx} @var{count}
Assuming that @var{str} is an already validated string: succeed if
@var{idx} is a fixnum usable as index (not out of range) for @var{str},
and @var{count} is a fixnum which can be used as characters count in
@var{str} starting and @var{idx} without going out of range.

In other words: @var{idx} and @var{count} select a substring of
@var{str}.
@end deffn


@deffn {Validation Clause} start-and-end-for-string @var{str} @var{start} @var{end}
Assuming that @var{str} is an already validated string: succeed if both
@var{start} and @var{end} are fixnums usable as indexes (not out of
range) for @var{str}, and @var{start} is less than or equal to
@var{end}.

In other words: @var{start} and @var{end} select a substring of
@var{str} by specifying inclusive limits.
@end deffn


@deffn {Validation Clause} start-and-past-for-string @var{str} @var{start} @var{past}
Assuming that @var{str} is an already validated string: succeed if both
@var{start} and @var{past} are fixnums satisfying the constraints:

@example
0 <= @var{start} <= (string-length @var{str})
@var{start} <= @var{past} <= (string-length @var{str})
@end example

In other words: @var{start} and @var{past} select a substring of
@var{str} by specifying left--inclusive and right--exclusive limits.
@end deffn

@c page
@node args predefined vectors
@subsubsection Validating vector and related arguments


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} vector @var{obj}
Succeed if @var{obj} is a vector.
@end deffn


@deffn {Validation Clause} vector/false @var{obj}
Succeed if @var{obj} is @false{} or a vector.
@end deffn


@deffn {Validation Clause} non-empty-vector @var{obj}
Succeed if @var{obj} is a vector and its length is greater than zero.
@end deffn


@deffn {Validation Clause} non-empty-vector/false @var{obj}
Succeed if @var{obj} is @false{} or a vector and its length is greater
than zero.
@end deffn


@deffn {Validation Clause} index-for-vector @var{vec} @var{idx}
Succeed if @var{idx} is a fixnum usable as index (not out of range) for
@var{vec}, which is expected to be an already validated vector.
@end deffn


@deffn {Validation Clause} index-and-count-for-vector @var{vec} @var{idx} @var{count}
Assuming that @var{vec} is an already validated vector: succeed if
@var{idx} is a fixnum usable as index (not out of range) for @var{vec},
and @var{count} is a fixnum which can be used as characters count in
@var{vec} starting and @var{idx} without going out of range.

In other words: @var{idx} and @var{count} select a subvector of
@var{vec}.
@end deffn


@deffn {Validation Clause} start-and-end-for-vector @var{vec} @var{start} @var{end}
Assuming that @var{vec} is an already validated vector: succeed if both
@var{start} and @var{end} are fixnums usable as indexes (not out of
range) for @var{vec}, and @var{start} is less than or equal to
@var{end}.

In other words: @var{start} and @var{end} select a subvector of
@var{vec} by specifying inclusive limits.
@end deffn


@deffn {Validation Clause} start-and-past-for-vector @var{vec} @var{start} @var{past}
Assuming that @var{vec} is an already validated vector: succeed if both
@var{start} and @var{past} are fixnums satisfying the constraints:

@example
0 <= @var{start} <= (vector-length @var{vec})
@var{start} <= @var{past} <= (vector-length @var{vec})
@end example

In other words: @var{start} and @var{past} select a subvector of
@var{vec} by specifying left--inclusive and right--exclusive limits.
@end deffn

@c page
@node args predefined bytevectors
@subsubsection Validating bytevector and related arguments


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} bytevector @var{obj}
Succeed if @var{obj} is a bytevector.
@end deffn


@deffn {Validation Clause} bytevector/false @var{obj}
Succeed if @var{obj} is @false{} or a bytevector.
@end deffn


@deffn {Validation Clause} non-empty-bytevector @var{obj}
Succeed if @var{obj} is a bytevector and its length is greater than
zero.
@end deffn


@deffn {Validation Clause} non-empty-bytevector/false @var{obj}
Succeed if @var{obj} is @false{} or a bytevector and its length is
greater than zero.
@end deffn


@deffn {Validation Clause} list-of-bytevectors @var{obj}
Succeed if @var{obj} is null or a list of bytevectors.
@end deffn

@c ------------------------------------------------------------

@deffn {Validation Clause} index-for-bytevector @var{bv} @var{idx}
Succeed if @var{idx} is a fixnum usable as index (not out of range) for
@var{bv}, which is expected to be an already validated bytevector.
@end deffn


@deffn {Validation Clause} bytevector-length @var{len}
Succeed if @var{len} is a non--negative fixnum usable as bytevector
length.
@end deffn


@deffn {Validation Clause} index-and-count-for-bytevector @var{bv} @var{idx} @var{count}
Assuming that @var{bv} is an already validated bytevector: succeed if
@var{idx} is a fixnum usable as index (not out of range) for @var{bv},
and @var{count} is a fixnum which can be used as characters count in
@var{bv} starting and @var{idx} without going out of range.

In other words: @var{idx} and @var{count} select a subbytevector of
@var{bv}.
@end deffn


@deffn {Validation Clause} start-and-end-for-bytevector @var{bv} @var{start} @var{end}
Assuming that @var{bv} is an already validated bytevector: succeed if
both @var{start} and @var{end} are fixnums usable as indexes (not out of
range) for @var{bv}, and @var{start} is less than or equal to
@var{end}.

In other words: @var{start} and @var{end} select a subbytevector of
@var{bv} by specifying inclusive limits.
@end deffn


@deffn {Validation Clause} start-and-past-for-bytevector @var{bv} @var{start} @var{past}
Assuming that @var{bv} is an already validated bytevector: succeed if
both @var{start} and @var{past} are fixnums satisfying the constraints:

@example
0 <= @var{start} <= (bytevector-length @var{bv})
@var{start} <= @var{past} <= (bytevector-length @var{bv})
@end example

In other words: @var{start} and @var{past} select a subbytevector of
@var{bv} by specifying left--inclusive and right--exclusive limits.
@end deffn

@c page
@node args predefined symbols
@subsubsection Validating symbols


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} symbol @var{obj}
Succeed if @var{obj} is a symbol.
@end deffn


@deffn {Validation Clause} symbol/false @var{obj}
Succeed if @var{obj} is @false{} or a symbol.
@end deffn

@c page
@node args predefined enum-sets
@subsubsection Validating enum-sets


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} enum-set @var{obj}
Succeed if @var{obj} is a enum-set.
@end deffn


@deffn {Validation Clause} enum-set/false @var{obj}
Succeed if @var{obj} is @false{} or a enum-set.
@end deffn

@c page
@node args predefined pointers
@subsubsection Validating pointers


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} pointer @var{obj}
Succeed if @var{obj} is a pointer.
@end deffn


@deffn {Validation Clause} pointer/false @var{obj}
Succeed if @var{obj} is @false{} or a pointer.
@end deffn


@deffn {Validation Clause} non-null-pointer @var{obj}
Succeed if @var{obj} is a pointer and it does @strong{not} represent
@cnull{}.
@end deffn

@c page
@node args predefined memory-blocks
@subsubsection Validating @code{memory-block} values


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} memory-block @var{obj}
Succeed if @var{obj} is a memory-block.
@end deffn


@deffn {Validation Clause} memory-block/false @var{obj}
Succeed if @var{obj} is @false{} or a memory-block.
@end deffn

@c page
@node args predefined flonums
@subsubsection Validating flonums


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} flonum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{flonum?}.
@end deffn

@c page
@node args predefined bignums
@subsubsection Validating bignums


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} bignum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{bignum?}.
@end deffn

@c page
@node args predefined ratnums
@subsubsection Validating ratnums


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} ratnum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{ratnum?}.
@end deffn

@c page
@node args predefined reals
@subsubsection Validating reals


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} real @var{obj}
Succeed if @var{obj} satisfies the predicate @func{real?}.
@end deffn


@deffn {Validation Clause} real-exact @var{obj}
Succeed if @var{obj} satisfies one of the predicates @func{fixnum?},
@func{bignum?}, @func{ratnum?}.
@end deffn

@c page
@node args predefined compnums
@subsubsection Validating compnums


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} compnum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{compnum?}.
@end deffn

@c page
@node args predefined cflonums
@subsubsection Validating cflonums


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} cflonum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{cflonum?}.
@end deffn

@c page
@node args predefined complexes
@subsubsection Validating complexes


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} complex @var{obj}
Succeed if @var{obj} satisfies the predicate @func{complex?}.
@end deffn

@c page
@node args predefined ports
@subsubsection Validating input/output ports


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} port @var{obj}
Succeed if @var{obj} is a port.
@end deffn


@deffn {Validation Clause} port/false @var{obj}
Succeed if @var{obj} is @false{} or a port.
@end deffn


@deffn {Validation Clause} input-port @var{obj}
@deffnx {Validation Clause} output-port @var{obj}
@deffnx {Validation Clause} input/output-port @var{obj}
Succeed if @var{obj} is an input, output or input/output port.
@end deffn


@deffn {Validation Clause} input-port/false @var{obj}
@deffnx {Validation Clause} output-port/false @var{obj}
@deffnx {Validation Clause} input/output-port/false @var{obj}
Succeed if @var{obj} is @false{} or an input, output or input/output
port.
@end deffn


@deffn {Validation Clause} textual-port @var{obj}
@deffnx {Validation Clause} binary-port @var{obj}
Succeed if @var{obj} is an textual or binary port.
@end deffn


@deffn {Validation Clause} textual-port/false @var{obj}
@deffnx {Validation Clause} binary-port/false @var{obj}
Succeed if @var{obj} is @false{} or an textual or binary port.
@end deffn


@deffn {Validation Clause} open-port @var{obj}
Succeed if @var{obj} is an open port.
@end deffn

@c page
@node args predefined transcoders
@subsubsection Validating port transcoders


The following bindings are extranscodered by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} transcoder @var{obj}
Succeed if @var{obj} is a transcoder.
@end deffn


@deffn {Validation Clause} transcoder/false @var{obj}
Succeed if @var{obj} is @false{} or a transcoder.
@end deffn

@c page
@node args predefined procedures
@subsubsection Validating procedures


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} procedure @var{obj}
Succeed if @var{obj} is a procedure.
@end deffn


@deffn {Validation Clause} procedure/false @var{obj}
Succeed if @var{obj} is @false{} or a procedure.
@end deffn

@c page
@node args predefined genstrings
@subsubsection Validating generalised C string arguments


@ref{cbuffers strings, Introduction to generalised C strings}, for
details on generalised C strings.

The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn Syntax general-c-string? @meta{obj}
Expand to an expression which evaluates @meta{obj} once and returns
@true{} if the result is a generalised C string.
@end deffn


@deffn {Validation Clause} general-c-string @var{obj}
Succeed if @var{obj} is a generalised C string.
@end deffn


@deffn {Validation Clause} general-c-string/false @var{obj}
Succeed if @var{obj} is @false{} or a generalised C string.
@end deffn


@deffn {Validation Clause} general-c-string.len @var{str} @var{str.len}
If @var{str} is a pointer object: succeed if @var{str.len} an exact
integer in the range of the C language type @code{size_t}.  Otherwise
succeed if @var{str.len} is @false{}.
@end deffn


@deffn {Validation Clause} general-c-string* @var{obj} @var{obj.len}
Succeed if @var{obj} is a generalised C string and @var{obj.len} its
optional length.
@end deffn


@deffn {Validation Clause} general-c-string*/false @var{obj} @var{obj.len}
Succeed if @var{obj} is a @false{} or a generalised C string and
@var{obj.len} its optional length.  If @var{obj} is @false{}:
@var{obj.len} must be false too.
@end deffn

@c page
@node args predefined genbuffers
@subsubsection Validating generalised C buffer arguments


@ref{cbuffers buffers, Introduction to generalised C buffers}, for
details on generalised C buffers.

The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn Syntax general-c-buffer? @meta{obj}
Expand to an expression which evaluates @meta{obj} once and returns
@true{} if the result is a generalised C buffer.
@end deffn


@deffn {Validation Clause} general-c-buffer @var{obj}
Succeed if @var{obj} is a generalised C buffer.
@end deffn


@deffn {Validation Clause} general-c-buffer/false @var{obj}
Succeed if @var{obj} is @false{} or a generalised C buffer.
@end deffn


@deffn Syntax general-c-sticky-buffer? @meta{obj}
Expand to an expression which evaluates @meta{obj} once and returns
@true{} if the result is a generalised C sticky buffer.
@end deffn


@deffn {Validation Clause} general-c-sticky-buffer @var{obj}
Succeed if @var{obj} is a generalised C sticky buffer.
@end deffn


@deffn {Validation Clause} general-c-sticky-buffer/false @var{obj}
Succeed if @var{obj} is @false{} or a generalised C sticky buffer.
@end deffn


@deffn {Validation Clause} general-c-buffer.len @var{buf} @var{buf.len}
If @var{buf} is a pointer object: succeed if @var{buf.len} an exact
integer in the range of the C language type @code{size_t}.  Otherwise
succeed if @var{buf.len} is @false{}.
@end deffn


@deffn {Validation Clause} general-c-buffer* @var{obj} @var{obj.len}
Succeed if @var{obj} is a generalised C buffer and @var{obj.len} its
optional length.
@end deffn


@deffn {Validation Clause} general-c-sticky-buffer* @var{obj} @var{obj.len}
Succeed if @var{obj} is a generalised C sticky buffer and @var{obj.len}
its optional length.
@end deffn


@deffn {Validation Clause} general-c-buffer*/false @var{obj} @var{obj.len}
Succeed if @var{obj} is a @false{} or a generalised C buffer and
@var{obj.len} its optional length.  If @var{obj} is @false{}:
@var{obj.len} must be false too.
@end deffn


@deffn {Validation Clause} general-c-sticky-buffer*/false @var{obj} @var{obj.len}
Succeed if @var{obj} is a @false{} or a generalised C sticky buffer and
@var{obj.len} its optional length.  If @var{obj} is @false{}:
@var{obj.len} must be false too.
@end deffn

@c page
@node args predefined time
@subsubsection Validating time objects


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} time @var{obj}
Succeed if @var{obj} is a time object: it satisfies the predicate
@func{time?} exported by @library{vicare}.
@end deffn


@deffn {Validation Clause} time/false @var{obj}
Succeed if @var{obj} is @false{} or a time object: it satisfies the
predicate @func{time?} exported by @library{vicare}.
@end deffn

@c page
@node errno
@section More features for @code{errno}


@cindex Library @library{vicare platform errno}
@cindex @library{vicare platform errno}, library


One syntax identifier binding for each known @code{errno} value is
exported by the library @library{vicare platform errno} and reexported
by the library @library{vicare platform constants}; @ref{iklib errno}
for details on @value{PRJNAME} internal encoding of @code{errno} codes.
The following bindings are exported by the library @library{vicare
platform errno}.


@deffn Syntax errno-code @meta{symbol}
Verify that @meta{symbol} is one of the symbolic names of @code{errno};
if successful expand to an expression evaluating to the coded
@code{errno} value, else raise a syntax violation.
@end deffn


@deffn Syntax case-errno @meta{errno} ((@metao{code} @meta{code} ...) . @meta{cbody}) ...
@deffnx Syntax case-errno @meta{errno} ((@metao{code} @meta{code} ...) . @meta{cbody}) ... (else . @meta{ebody})
@deffnx {Auxiliary Syntax} else
Specialised @func{case} macro for @code{errno} values.  @func{else} is
the auxiliary keyword exported by @library{rnrs}.  Example:

@example
#!r6rs
(import (rnrs)
  (vicare platform errno))

(define identifier "some-port")

(case-errno (errno)
  ((EACCES EFAULT)
   (make-i/o-file-protection-error identifier))
  ((EROFS)
   (make-i/o-file-is-read-only-error identifier))
  ((EEXIST)
   (make-i/o-file-already-exists-error identifier))
  ((EIO)
   (make-i/o-error))
  ((ENOENT)
   (make-i/o-file-does-not-exist-error identifier))
  (else
   (make-irritants-condition (list identifier))))
@end example

The @meta{code} must be symbols representing @code{errno} codes, they
are @strong{not} meant to be binding identifiers.
@end deffn

@c page
@node platform
@section Hosting platform utilities


@cindex Library @library{vicare platform constants}
@cindex @library{vicare platform constants}, library
@cindex Library @library{vicare platform utilities}
@cindex @library{vicare platform utilities}, library
@cindex Library @library{vicare platform features}
@cindex @library{vicare platform features}, library


The library @library{vicare platform constants} exports one syntax
identifier binding for each platform constant that makes sense to access
from Scheme.  The library @library{vicare platform utilities} defines
helper functions to deal with platform specific issues. The library
@library{vicare platform features} exports an identifier syntax for
every @code{HAVE_} symbol defined by the configuration script
@command{configure}; such syntaxes expand to a boolean value: @true{} if
the feature is available, @false{} otherwise.

The following bindings are exported by the library @library{vicare
platform utilities}.


@deffn Syntax posix-signal->symbol @var{code}
Given an integer representing an interprocess @posix{} signal code,
return the corresponding symbol; if @var{code} is not recognised as
@posix{} signal code: return @false{}.

@example
(import (rnrs)
  (vicare platform constants)
  (vicare platform utilities))

(posix-signal->symbol SIGTERM)            @result{} SIGTERM
(posix-signal->symbol (greatest-fixnum))  @result{} #f
@end example
@end deffn


@defun errno-code->symbol @var{code}
Given a fixnum representing an encoded @code{errno} value, return the
corresponding symbol; if @var{code} is not recognised as encoded
@code{errno} value: return @false{}.

@example
(import (rnrs)
  (vicare platform constants)
  (vicare platform utilities))

(errno-code->symbol EINVAL)             @result{} EINVAL
(errno-code->symbol (greatest-fixnum))  @result{} #f
@end example
@end defun

@c page
@node words
@section Exact integer predicates and constants


@cindex Library @library{vicare platform words}
@cindex @library{vicare platform words}, library


It is often needed to validate exact integers agains fixed range bounds,
for example for 32-bit and 64-bit representations or some platform
specific C language type.  The library @library{vicare platform words} implements
such predicates and minimum/maximum range constants.

@menu
* words syntaxes::              Miscellaneous syntaxes.
* words sizeof::                Knowing the size of C language types.
* words predicates::            Verifying the range of integers.
* words limits::                Exact integer range limits.
@end menu

@c page
@node words syntaxes
@subsection Miscellaneous syntaxes


The following bindings are exported by the @library{vicare platform words}
library.


@deffn Syntax case-word-size ((32) . @meta{body-32}) ((64) . @meta{body-64})
If the platform word size is 32-bit expand to @meta{body-32}, else
expand to @meta{body-64}.
@end deffn


@deffn Syntax case-endianness (@meta{who} @meta{endianness}) ((little) . @meta{lit-body}) ((big) . @meta{big-body})
@deffnx Syntax case-endianness (@meta{who} @meta{endianness}) ((big) . @meta{big-body}) ((little) . @meta{lit-body})
@deffnx {Auxiliary Syntax} big
@deffnx {Auxiliary Syntax} little
If the platform endianness is little expand to @meta{lit-body}, else
expand to @meta{big-body}.
@end deffn

@c page
@node words sizeof
@subsection Knowing the size of C language types


The following bindings are exported by the @library{vicare platform words}
library.


@deffn {Identifier Syntax} SIZEOF_CHAR
Number of bytes in the C language type @code{char}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_SHORT
Number of bytes in the C language type @code{short int}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_INT
Number of bytes in the C language type @code{int}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_LONG
Number of bytes in the C language type @code{long}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_LONG_LONG
Number of bytes in the C language type @code{long long}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_SIZE_T
Number of bytes in the C language type @code{size_t}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_SSIZE_T
Number of bytes in the C language type @code{ssize_t}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_OFF_T
Number of bytes in the C language type @code{off_t}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_PTRDIFF_T
Number of bytes in the C language type @code{ptrdiff_t}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_FLOAT
Number of bytes in the C language type @code{float}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_DOUBLE
Number of bytes in the C language type @code{double}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_POINTER
Number of bytes in the C language type @code{void *}.
@end deffn

@c page
@node words predicates
@subsection Verifying the range of integers


The following bindings are exported by the @library{vicare platform words}
library.


@deffn Syntax word? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum, that is an exact
integer; else return @false{}.
@end deffn


@deffn Syntax machine-word? @var{obj}
On 32-bit platforms: return @true{} if @var{obj} is a fixnum or bignum
in the 32-bit range; on 64-bit platforms: return @true{} if @var{obj} is
a fixnum or bignum in the 64-bit range; else return @false{}.
@end deffn


@deffn Syntax word-u8? @var{obj}
@deffnx Syntax word-s8? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum in the 8-bit
range; else return @false{}.
@end deffn


@deffn Syntax word-u16? @var{obj}
@deffnx Syntax word-s16? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum in the 16-bit
range; else return @false{}.
@end deffn


@deffn Syntax word-u32? @var{obj}
@deffnx Syntax word-s32? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum or bignum in
the 32-bit range; else return @false{}.
@end deffn


@deffn Syntax word-u64? @var{obj}
@deffnx Syntax word-s64? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum or bignum in
the 64-bit range; else return @false{}.
@end deffn


@deffn Syntax word-u128? @var{obj}
@deffnx Syntax word-s128? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum or bignum in
the 128-bit range; else return @false{}.
@end deffn


@deffn Syntax word-u256? @var{obj}
@deffnx Syntax word-s256? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum or bignum in
the 256-bit range; else return @false{}.
@end deffn


@deffn Syntax unsigned-char? @var{obj}
@deffnx Syntax signed-char? @var{obj}
Return @true{} if @var{obj} is a fixnum in the range representable with
a platform C language type @code{signed char} or @code{unsigned char}.
@end deffn


@deffn Syntax unsigned-short? @var{obj}
@deffnx Syntax signed-short? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{signed short int} or
@code{unsigned short int}.
@end deffn


@deffn Syntax unsigned-int? @var{obj}
@deffnx Syntax signed-int? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{signed int} or
@code{unsigned int}.
@end deffn


@deffn Syntax unsigned-long? @var{obj}
@deffnx Syntax signed-long? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{signed long int} or
@code{unsigned long int}.
@end deffn


@deffn Syntax unsigned-long-long? @var{obj}
@deffnx Syntax signed-long-long? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{signed long long
int} or @code{unsigned long long int}.
@end deffn


@deffn Syntax pointer-integer? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{void *}.
@end deffn


@deffn Syntax size_t? @var{obj}
@deffnx Syntax ssize_t? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{size_t} or
@code{ssize_t} as defined by @file{stddef.h}.
@end deffn


@deffn Syntax off_t? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{off_t} as defined by
@file{stdio.h}.
@end deffn


@deffn Syntax ptrdiff_t? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{ptrdiff_t} as
defined by @file{stddef.h}.
@end deffn


The following predicates are meant to be used to validate indices in
bytevectors.


@deffn Syntax fixnum-aligned-to-2? @var{N}
@strong{Unsafe syntax: @var{N} must be a fixnum.}  Evaluate to @true{}
if @var{N} is a fixnum multiple of @math{2}; else evaluate to @false{}.
@end deffn


@deffn Syntax fixnum-aligned-to-4? @var{N}
@strong{Unsafe syntax: @var{N} must be a fixnum.}  Evaluate to @true{}
if @var{N} is a fixnum multiple of @math{4}; else evaluate to @false{}.
@end deffn


@deffn Syntax fixnum-aligned-to-8? @var{N}
@strong{Unsafe syntax: @var{N} must be a fixnum.}  Evaluate to @true{}
if @var{N} is a fixnum multiple of @math{8}; else evaluate to @false{}.
@end deffn


@deffn Syntax fixnum-aligned-to? @var{N} @var{alignment}
@strong{Unsafe syntax: @var{N} and @var{alignment} must be fixnums.}
Evaluate to @true{} if @var{N} is a fixnum multiple of @math{alignment};
else evaluate to @false{}.
@end deffn

@c page
@node words limits
@subsection Exact integer range limits


The following bindings are exported by the @library{vicare platform
words} library.

@c ------------------------------------------------------------

@subsubheading Inclusive limits


@deffn Syntax greatest-u8
@deffnx Syntax greatest-s8
@deffnx Syntax least-u8
@deffnx Syntax least-s8
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 8-bit range.
@end deffn


@deffn Syntax greatest-u16
@deffnx Syntax greatest-s16
@deffnx Syntax least-u16
@deffnx Syntax least-s16
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 16-bit range.
@end deffn


@deffn Syntax greatest-u32
@deffnx Syntax greatest-s32
@deffnx Syntax least-u32
@deffnx Syntax least-s32
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 32-bit range.
@end deffn


@deffn Syntax greatest-u64
@deffnx Syntax greatest-s64
@deffnx Syntax least-u64
@deffnx Syntax least-s64
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 64-bit range.
@end deffn


@deffn Syntax greatest-s128
@deffnx Syntax greatest-u128
@deffnx Syntax least-u128
@deffnx Syntax least-s128
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 128-bit range.
@end deffn


@deffn Syntax greatest-s256
@deffnx Syntax greatest-u256
@deffnx Syntax least-u256
@deffnx Syntax least-s256
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 256-bit range.
@end deffn


@deffn Syntax greatest-machine-word
@deffnx Syntax least-machine-word
On 32-bit platforms: evaluate to the greatest or least unsigned exact
integer in the 32-bit range.

On 64-bit platforms: evaluate to the greatest or least unsigned exact
integer in the 64-bit range.
@end deffn


@deffn Syntax greatest-c-unsigned-char
@deffnx Syntax greatest-c-signed-char
@deffnx Syntax least-c-unsigned-char
@deffnx Syntax least-c-signed-char
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{char} range.
@end deffn


@deffn Syntax greatest-c-unsigned-short
@deffnx Syntax greatest-c-signed-short
@deffnx Syntax least-c-unsigned-short
@deffnx Syntax least-c-signed-short
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{short int} range.
@end deffn


@deffn Syntax greatest-c-unsigned-int
@deffnx Syntax greatest-c-signed-int
@deffnx Syntax least-c-unsigned-int
@deffnx Syntax least-c-signed-int
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{int} range.
@end deffn


@deffn Syntax greatest-c-unsigned-long
@deffnx Syntax greatest-c-signed-long
@deffnx Syntax least-c-unsigned-long
@deffnx Syntax least-c-signed-long
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{long} range.
@end deffn


@deffn Syntax greatest-c-unsigned-long-long
@deffnx Syntax greatest-c-signed-long-long
@deffnx Syntax least-c-unsigned-long-long
@deffnx Syntax least-c-signed-long-long
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{long long} range.
@end deffn


@deffn Syntax greatest-c-pointer
@deffnx Syntax least-c-pointer
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{void *} range.
@end deffn


@deffn Syntax greatest-c-size_t
@deffnx Syntax least-c-size_t
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{size_t} range.
@end deffn


@deffn Syntax greatest-c-ssize_t
@deffnx Syntax least-c-ssize_t
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{ssize_t} range.
@end deffn


@deffn Syntax greatest-c-off_t
@deffnx Syntax least-c-off_t
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{off_t} range.
@end deffn


@deffn Syntax greatest-c-ptrdiff_t
@deffnx Syntax least-c-ptrdiff_t
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{ptrdiff_t} range.
@end deffn

@c ------------------------------------------------------------

@subsubheading Exclusive limits


@deffn Syntax greatest-u8*
@deffnx Syntax greatest-s8*
@deffnx Syntax least-u8*
@deffnx Syntax least-s8*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 8-bit range.
@end deffn


@deffn Syntax greatest-u16*
@deffnx Syntax greatest-s16*
@deffnx Syntax least-u16*
@deffnx Syntax least-s16*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 16-bit range.
@end deffn


@deffn Syntax greatest-u32*
@deffnx Syntax greatest-s32*
@deffnx Syntax least-u32*
@deffnx Syntax least-s32*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 32-bit range.
@end deffn


@deffn Syntax greatest-u64*
@deffnx Syntax greatest-s64*
@deffnx Syntax least-u64*
@deffnx Syntax least-s64*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 64-bit range.
@end deffn


@deffn Syntax greatest-s128*
@deffnx Syntax greatest-u128*
@deffnx Syntax least-u128*
@deffnx Syntax least-s128*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 128-bit range.
@end deffn


@deffn Syntax greatest-s256*
@deffnx Syntax greatest-u256*
@deffnx Syntax least-u256*
@deffnx Syntax least-s256*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 256-bit range.
@end deffn


@deffn Syntax greatest-machine-word*
@deffnx Syntax least-machine-word*
On 32-bit platforms: evaluate to the greatest--plus--1 or
least--minus--1 unsigned exact integer in the 32-bit range.

On 64-bit platforms: evaluate to the greatest--plus--1 or
least--minus--1 unsigned exact integer in the 64-bit range.
@end deffn


@deffn Syntax greatest-c-unsigned-char*
@deffnx Syntax greatest-c-signed-char*
@deffnx Syntax least-c-unsigned-char*
@deffnx Syntax least-c-signed-char*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{char} range.
@end deffn


@deffn Syntax greatest-c-unsigned-short*
@deffnx Syntax greatest-c-signed-short*
@deffnx Syntax least-c-unsigned-short*
@deffnx Syntax least-c-signed-short*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{short int} range.
@end deffn


@deffn Syntax greatest-c-unsigned-int*
@deffnx Syntax greatest-c-signed-int*
@deffnx Syntax least-c-unsigned-int*
@deffnx Syntax least-c-signed-int*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{int} range.
@end deffn


@deffn Syntax greatest-c-unsigned-long*
@deffnx Syntax greatest-c-signed-long*
@deffnx Syntax least-c-unsigned-long*
@deffnx Syntax least-c-signed-long*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{long} range.
@end deffn


@deffn Syntax greatest-c-unsigned-long-long*
@deffnx Syntax greatest-c-signed-long-long*
@deffnx Syntax least-c-unsigned-long-long*
@deffnx Syntax least-c-signed-long-long*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{long long} range.
@end deffn


@deffn Syntax greatest-c-pointer*
@deffnx Syntax least-c-pointer*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{void *} range.
@end deffn


@deffn Syntax greatest-c-size_t*
@deffnx Syntax least-c-size_t*
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{size_t*} range.
@end deffn


@deffn Syntax greatest-c-ssize_t*
@deffnx Syntax least-c-ssize_t*
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{ssize_t*} range.
@end deffn


@deffn Syntax greatest-c-off_t*
@deffnx Syntax least-c-off_t*
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{off_t} range.
@end deffn


@deffn Syntax greatest-c-ptrdiff_t*
@deffnx Syntax least-c-ptrdiff_t*
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{ptrdiff_t} range.
@end deffn

@c page
@node cbuffers
@section Generalised C buffers and strings


When interfacing a C language foreign library with @value{PRJNAME}, it
is often needed to convert Scheme objects to raw memory blocks, possibly
containing @asciiz{} strings.

@menu
* cbuffers buffers::            Introduction to generalised C buffers.
* cbuffers strings::            Introduction to generalised C strings.
* cbuffers api::                Programming interface to generalised
                                C buffers and strings.
@end menu

@c page
@node cbuffers buffers
@subsection Introduction to generalised C buffers


Generalised C buffers are meant to be used in interfaces to foreign C
language libraries, when a pointer to raw data is required as argument.

A @dfn{generalised C buffer} is an object capable of holding an array of
mutable bytes referenced by a pointer; such Scheme objects are:
bytevectors, pointer objects, instances of @code{memory-block}.

A @dfn{generalised C sticky buffer} is an object capable of holding an
array of mutable bytes referenced by a pointer, whose data area is never
moved around by the garbage collector; such Scheme objects are: pointer
objects, instances of @code{memory-block}.  Sticky buffers are meant to
be used when calling out to C functions that call back to Scheme.

@ref{iklib memory blocks} for details on memory blocks.

Two arguments to function are usually needed to represent a generalised
C buffer: the buffer value itself and an optional length.

@enumerate
@item
The buffer argument is meant to be either bytevector, or
@code{memory-block} instance, or pointer object.

@item
The length argument is meant to be @false{} or an exact integer in the
range of the C language type @code{size_t}.  When the buffer argument is
a pointer object: the length argument must represent the number of bytes
available in the referenced memory block; otherwise the length argument
is ignored.
@end enumerate

Here is an example function accepting a generalised C buffer argument
@var{buf} and its optional length argument @var{buf.len}:

@example
(define fun
  (case-lambda
    ((buf)
     (fun buf #f))
    ((buf buf.len)
     (define who 'fun)
     (with-arguments-validation (who)
         ((general-c-buffer     buf)
          (general-c-buffer.len buf buf.len))
       (do-something-with buf buf.len)))))
@end example

@c page
@node cbuffers strings
@subsection Introduction to generalised C strings


Generalised C strings are meant to be used in interfaces to foreign C
language libraries, when a pointer to C string or input buffer is
required as argument.

A @dfn{generalised C string} is an object capable of holding the
representation of a C language string; such Scheme objects are: strings,
bytevectors, pointer objects, instances of @code{memory-block}.
@ref{iklib memory blocks} for details on memory blocks.

When a Scheme string is used as generalised C string: the application
must take care of converting the Scheme string into a C string
representation, for example using @func{string->ascii}.

When using generalised C strings we have to remember that:

@itemize
@item
A run of the garbage collector may move the data area of Scheme
bytevectors; for this reason Scheme bytevectors and Scheme strings
converted to bytevectors are not suitable as arguments to Scheme
functions interfacing to C functions that call back to Scheme.

@item
If a Scheme string is used as argument: the C function cannot modify it
by using it as output buffer.
@end itemize

@noindent
in these cases we should use generalised C buffers, @ref{cbuffers
buffers, Introduction to generalised C buffers}.

Two arguments to function are usually needed to represent a generalised
C string: the string value itself and an optional length.

@enumerate
@item
The string argument is meant to be either a string, or bytevector, or
@code{memory-block} instance, or pointer object.

@item
The length argument is meant to be @false{} or an exact integer in the
range of the C language type @code{size_t}.  When the string argument is
a pointer object: the length argument must represent the number of bytes
available in the referenced memory block; otherwise the length argument
is ignored.
@end enumerate

Here is an example function accepting a generalised C string argument
@var{str} and its optional length argument @var{str.len}, the string is
converted to bytevector with @func{string->ascii}:

@example
(define fun
  (case-lambda
    ((str)
     (fun str #f))
    ((str str.len)
     (define who 'fun)
     (with-arguments-validation (who)
         ((general-c-string     str)
          (general-c-string.len str str.len))
       (with-general-c-strings
           ((str^         str))
         (do-something-with str^ str.len))))))
@end example

@c page
@node cbuffers api
@subsection Programming interface to generalised C buffers and strings


@cindex Library @library{vicare arguments general-c-buffers}
@cindex @library{vicare arguments general-c-buffers}, library


The @api{} dealing with generalised C buffers and strings, is composed
of syntaxes used to validate and normalise the arguments before handing
them to the foreign function.

@ref{args predefined genbuffers, Validating generalised C buffer
arguments} for details on how to validation generalised C buffer
arguments.

@ref{args predefined genstrings, Validating generalised C string
arguments} for details on how to validation generalised C string
arguments.


The following bindings are exported by the library @library{vicare
arguments general-c-buffers}.


@defun general-c-buffer-len @var{buf} @var{buf.len}
Return the number of bytes in a generalised C buffer object.

@var{buf} must be a bytevector, pointer object or @code{memory-block}
struct instance.

When @var{buf} is a pointer object: @var{buf.len} must be an exact
integer (in the range of the C language type @code{size_t}) representing
the number of bytes available in the referenced memory block.  Otherwise
@var{buf.len} is ignored.
@end defun


@deffn Syntax with-general-c-strings ((@meta{str} @meta{expr}) ...) (string-to-bytevector @meta{string->bytevector}) @metao{body} . @meta{body}
@deffnx Syntax with-general-c-strings ((@meta{str} @meta{expr}) ...) @metao{body} . @meta{body}
@deffnx {Auxiliary Syntax} string-to-bytevector
Prepare some generalised C strings to be used by a chunk of code
expecting access to raw memory holding a C language string or input
buffer.

The values @meta{str} must be identifiers, unique according to
@func{bound-identifier=?}.

The values @meta{expr} must be expressions which will always be
evaluated only once.

The value @meta{string->bytevector} must be an expression evaluating to
a procedure which converts a string to a bytevector, for example
@func{string->ascii}.  In the second form of the syntax use:
@meta{string->bytevector} defaults to @func{string->ascii}.

For each couple @meta{str} and @meta{expr} do the following:

@itemize
@item
If the result of evaluating @meta{expr} is a bytevector, pointer object
or @code{memory-block} instance bind it to @meta{str}.

@item
If the result of evaluating @meta{expr} is a string: convert it to a
bytevector using the procedure result of evaluating
@meta{string->bytevector}, then bind it to @meta{str}.
@end itemize

Evaluate the @meta{body} forms in the region in which such bindings are
effective.  Return the return value of the last @meta{body} form.
@end deffn


@deffn Syntax with-general-c-strings/false ((@meta{str} @meta{expr}) ...) (string-to-bytevector @meta{string->bytevector}) @metao{body} . @meta{body}
@deffnx Syntax with-general-c-strings/false ((@meta{str} @meta{expr}) ...) @metao{body} . @meta{body}
@deffnx {Auxiliary Syntax} string-to-bytevector
Like @func{with-general-c-strings} but if a @meta{expr} evaluates
to @false{} accept the value.
@end deffn


@deffn Syntax with-general-c-pathnames ((@meta{ptn} @meta{expr}) ...) @metao{body} . @meta{body}
Prepare some generalised C strings to be used by a chunk of code
expecting access to raw memory holding a C language string representing
a file system pathname.

The values @meta{ptn} must be identifiers, unique according to
@func{bound-identifier=?}.

The values @meta{expr} must be expressions which will always be
evaluated only once.

For each couple @meta{ptn} and @meta{expr} do the following:

@itemize
@item
If the result of evaluating @meta{expr} is a bytevector, pointer object
or @code{memory-block} instance bind it to @meta{ptn}.

@item
If the result of evaluating @meta{expr} is a string: convert it to a
bytevector using the function referenced by the parameter
@func{string->pathname-func}, then bind it to @meta{ptn}.
@end itemize

Evaluate the @meta{body} forms in the region in which such bindings are
effective.  Return the return value of the last @meta{body} form.
@end deffn


@deffn Syntax with-general-c-pathnames/false ((@meta{ptn} @meta{expr}) ...) @metao{body} . @meta{body}
Like @func{with-general-c-pathnames} but if a @meta{expr} evaluates to
@false{} accept the value.
@end deffn


As example, let's say we have loaded C language code exposing a function
@cfunc{ikptr_posix_file_size}, which given a file pathname returns its
size; we can interface it as follows:

@example
#!r6rs
(import (vicare)
  (vicare arguments validation))

(define (file-size pathname)
  (define who 'file-size)
  (with-arguments-validation (who)
      ((general-c-string pathname))
    (with-general-c-pathnames ((pathname^ pathname))
      (foreign-call "ikptr_posix_file_size" pathname^))))
@end example

@c page
@node bytevectors
@section Additional bytevector utilities


@cindex Library @library{vicare bytevectors}
@cindex @library{vicare bytevectors}, library


The library @library{vicare bytevectors} exports bindings for additional
bytevector handling utilities.

@menu
* bytevectors setget::          Single--identifier setters and getters.
* bytevectors scaled::          Scaled setters and getters.
@end menu

@c page
@node bytevectors setget
@subsection Single--identifier setters and getters


The following syntaxes are wrappers for @func{bytevector-*-ref} and
@func{bytevector-*-set!} specifying the endiannes in their name, without
the need of an additional argument (useful in macros).  The following
bindings are exported by the library @library{vicare bytevectors}.

@c ------------------------------------------------------------

@subsubheading Words of 8-bit


The 8-bit setters and getters exist with the only purpose of having
8-bit identifiers with the same naming scheme of the others; this is
useful when building identifiers in macros.


@deffn Syntax bytevector-u8-litend-set! @var{bv} @var{idx} @var{val}
Setter for unsigned 8-bit words.  An alias for @func{bytevector-u8-set!}.
@end deffn


@deffn Syntax bytevector-u8-bigend-set! @var{bv} @var{idx} @var{val}
Setter for unsigned 8-bit words.  An alias for @func{bytevector-u8-set!}.
@end deffn


@deffn Syntax bytevector-u8-litend-ref @var{bv} @var{idx} @var{val}
Getter for unsigned 8-bit words.  An alias for @func{bytevector-u8-ref}.
@end deffn


@deffn Syntax bytevector-u8-bigend-ref @var{bv} @var{idx} @var{val}
Getter for unsigned 8-bit words.  An alias for @func{bytevector-u8-ref}.
@end deffn


@deffn Syntax bytevector-s8-litend-set! @var{bv} @var{idx} @var{val}
Setter for signed 8-bit words.  An alias for @func{bytevector-s8-set!}.
@end deffn


@deffn Syntax bytevector-s8-bigend-set! @var{bv} @var{idx} @var{val}
Setter for signed 8-bit words.  An alias for @func{bytevector-s8-set!}.
@end deffn


@deffn Syntax bytevector-s8-litend-ref @var{bv} @var{idx} @var{val}
Getter for signed 8-bit words.  An alias for @func{bytevector-s8-ref}.
@end deffn


@deffn Syntax bytevector-s8-bigend-ref @var{bv} @var{idx} @var{val}
Getter for signed 8-bit words.  An alias for @func{bytevector-s8-ref}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Words of 16-bit


@deffn Syntax bytevector-u16-litend-set! @var{bv} @var{idx} @var{val}
Setter for unsigned 16-bit little--endian words.
@end deffn


@deffn Syntax bytevector-u16-bigend-set! @var{bv} @var{idx} @var{val}
Setter for unsigned 16-bit big--endian words.
@end deffn


@deffn Syntax bytevector-u16-litend-ref @var{bv} @var{idx} @var{val}
Getter for unsigned 16-bit little--endian words.
@end deffn


@deffn Syntax bytevector-u16-bigend-ref @var{bv} @var{idx} @var{val}
Getter for unsigned 16-bit big--endian words.
@end deffn


@deffn Syntax bytevector-s16-litend-set! @var{bv} @var{idx} @var{val}
Setter for signed 16-bit little--endian words.
@end deffn


@deffn Syntax bytevector-s16-bigend-set! @var{bv} @var{idx} @var{val}
Setter for signed 16-bit big--endian words.
@end deffn


@deffn Syntax bytevector-s16-litend-ref @var{bv} @var{idx} @var{val}
Getter for signed 16-bit little--endian words.
@end deffn


@deffn Syntax bytevector-s16-bigend-ref @var{bv} @var{idx} @var{val}
Getter for signed 16-bit big--endian words.
@end deffn

@c ------------------------------------------------------------

@subsubheading Words of 32-bit


@deffn Syntax bytevector-u32-litend-set! @var{bv} @var{idx} @var{val}
Setter for unsigned 32-bit little--endian words.
@end deffn


@deffn Syntax bytevector-u32-bigend-set! @var{bv} @var{idx} @var{val}
Setter for unsigned 32-bit big--endian words.
@end deffn


@deffn Syntax bytevector-u32-litend-ref @var{bv} @var{idx} @var{val}
Getter for unsigned 32-bit little--endian words.
@end deffn


@deffn Syntax bytevector-u32-bigend-ref @var{bv} @var{idx} @var{val}
Getter for unsigned 32-bit big--endian words.
@end deffn


@deffn Syntax bytevector-s32-litend-set! @var{bv} @var{idx} @var{val}
Setter for signed 32-bit little--endian words.
@end deffn


@deffn Syntax bytevector-s32-bigend-set! @var{bv} @var{idx} @var{val}
Setter for signed 32-bit big--endian words.
@end deffn


@deffn Syntax bytevector-s32-litend-ref @var{bv} @var{idx} @var{val}
Getter for signed 32-bit little--endian words.
@end deffn


@deffn Syntax bytevector-s32-bigend-ref @var{bv} @var{idx} @var{val}
Getter for signed 32-bit big--endian words.
@end deffn

@c ------------------------------------------------------------

@subsubheading Words of 64-bit


@deffn Syntax bytevector-u64-litend-set! @var{bv} @var{idx} @var{val}
Setter for unsigned 64-bit little--endian words.
@end deffn


@deffn Syntax bytevector-u64-bigend-set! @var{bv} @var{idx} @var{val}
Setter for unsigned 64-bit big--endian words.
@end deffn


@deffn Syntax bytevector-u64-litend-ref @var{bv} @var{idx} @var{val}
Getter for unsigned 64-bit little--endian words.
@end deffn


@deffn Syntax bytevector-u64-bigend-ref @var{bv} @var{idx} @var{val}
Getter for unsigned 64-bit big--endian words.
@end deffn


@deffn Syntax bytevector-s64-litend-set! @var{bv} @var{idx} @var{val}
Setter for signed 64-bit little--endian words.
@end deffn


@deffn Syntax bytevector-s64-bigend-set! @var{bv} @var{idx} @var{val}
Setter for signed 64-bit big--endian words.
@end deffn


@deffn Syntax bytevector-s64-litend-ref @var{bv} @var{idx} @var{val}
Getter for signed 64-bit little--endian words.
@end deffn


@deffn Syntax bytevector-s64-bigend-ref @var{bv} @var{idx} @var{val}
Getter for signed 64-bit big--endian words.
@end deffn

@c ------------------------------------------------------------

@subsubheading Single--precision floating--point numbers


@deffn Syntax bytevector-ieee-single-litend-set! @var{bv} @var{idx} @var{val}
Setter for single--precision floating--point little--endian words.
@end deffn


@deffn Syntax bytevector-ieee-single-bigend-set! @var{bv} @var{idx} @var{val}
Setter for single--precision floating--point big--endian words.
@end deffn


@deffn Syntax bytevector-ieee-single-litend-ref @var{bv} @var{idx} @var{val}
Getter for single--precision floating--point little--endian words.
@end deffn


@deffn Syntax bytevector-ieee-single-bigend-ref @var{bv} @var{idx} @var{val}
Getter for single--precision floating--point big--endian words.
@end deffn

@c ------------------------------------------------------------

@subsubheading Double precision floating--point numbers


@deffn Syntax bytevector-ieee-double-litend-set! @var{bv} @var{idx} @var{val}
Setter for double--precision floating--point little--endian words.
@end deffn


@deffn Syntax bytevector-ieee-double-bigend-set! @var{bv} @var{idx} @var{val}
Setter for double--precision floating--point big--endian words.
@end deffn


@deffn Syntax bytevector-ieee-double-litend-ref @var{bv} @var{idx} @var{val}
Getter for double--precision floating--point little--endian words.
@end deffn


@deffn Syntax bytevector-ieee-double-bigend-ref @var{bv} @var{idx} @var{val}
Getter for double--precision floating--point big--endian words.
@end deffn

@c page
@node bytevectors scaled
@subsection Scaled setters and getters


The following syntaxes are wrappers for @func{bytevector-*-ref} and
@func{bytevector-*-set!} specifying the endiannes in their name, without
the need of an additional argument (useful in macros), and scaling the
index with the size of the word.  The following bindings are exported by
the library @library{vicare bytevectors}.

@c ------------------------------------------------------------

@subsubheading Unsigned words of 8-bit


The 8-bit setters and getters exist with the only purpose of having
8-bit identifiers with the same naming scheme of the others; this is
useful when building identifiers in macros.


@deffn Syntax bytevector-u8-litend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-u8-bigend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-u8-native-scaled-set! @var{bv} @var{idx} @var{val}
Scaled setters.
@end deffn


@deffn Syntax bytevector-u8-litend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-u8-bigend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-u8-native-scaled-ref @var{bv} @var{idx}
Scaled getters.
@end deffn

@c ------------------------------------------------------------

@subsubheading Signed words of 8-bit


The 8-bit setters and getters exist with the only purpose of having
8-bit identifiers with the same naming scheme of the others; this is
useful when building identifiers in macros.


@deffn Syntax bytevector-s8-litend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-s8-bigend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-s8-native-scaled-set! @var{bv} @var{idx} @var{val}
Scaled setters.
@end deffn


@deffn Syntax bytevector-s8-litend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-s8-bigend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-s8-native-scaled-ref @var{bv} @var{idx}
Scaled getters.
@end deffn

@c ------------------------------------------------------------

@subsubheading Unsigned words of 16-bit


@deffn Syntax bytevector-u16-litend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-u16-bigend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-u16-native-scaled-set! @var{bv} @var{idx} @var{val}
Scaled setters.
@end deffn


@deffn Syntax bytevector-u16-litend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-u16-bigend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-u16-native-scaled-ref @var{bv} @var{idx}
Scaled getters.
@end deffn

@c ------------------------------------------------------------

@subsubheading Signed words of 16-bit


@deffn Syntax bytevector-s16-litend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-s16-bigend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-s16-native-scaled-set! @var{bv} @var{idx} @var{val}
Scaled setters.
@end deffn


@deffn Syntax bytevector-s16-litend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-s16-bigend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-s16-native-scaled-ref @var{bv} @var{idx}
Scaled getters.
@end deffn

@c ------------------------------------------------------------

@subsubheading Unsigned words of 32-bit


@deffn Syntax bytevector-u32-litend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-u32-bigend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-u32-native-scaled-set! @var{bv} @var{idx} @var{val}
Scaled setters.
@end deffn


@deffn Syntax bytevector-u32-litend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-u32-bigend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-u32-native-scaled-ref @var{bv} @var{idx}
Scaled getters.
@end deffn

@c ------------------------------------------------------------

@subsubheading Signed words of 32-bit


@deffn Syntax bytevector-s32-litend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-s32-bigend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-s32-native-scaled-set! @var{bv} @var{idx} @var{val}
Scaled setters.
@end deffn


@deffn Syntax bytevector-s32-litend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-s32-bigend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-s32-native-scaled-ref @var{bv} @var{idx}
Scaled getters.
@end deffn

@c ------------------------------------------------------------

@subsubheading Unsigned words of 64-bit


@deffn Syntax bytevector-u64-litend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-u64-bigend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-u64-native-scaled-set! @var{bv} @var{idx} @var{val}
Scaled setters.
@end deffn


@deffn Syntax bytevector-u64-litend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-u64-bigend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-u64-native-scaled-ref @var{bv} @var{idx}
Scaled getters.
@end deffn

@c ------------------------------------------------------------

@subsubheading Signed words of 64-bit


@deffn Syntax bytevector-s64-litend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-s64-bigend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-s64-native-scaled-set! @var{bv} @var{idx} @var{val}
Scaled setters.
@end deffn


@deffn Syntax bytevector-s64-litend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-s64-bigend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-s64-native-scaled-ref @var{bv} @var{idx}
Scaled getters.
@end deffn

@c ------------------------------------------------------------

@subsubheading Single--precision floating--point words


@deffn Syntax bytevector-ieee-single-litend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-ieee-single-bigend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-ieee-single-native-scaled-set! @var{bv} @var{idx} @var{val}
Scaled setters.
@end deffn


@deffn Syntax bytevector-ieee-single-litend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-ieee-single-bigend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-ieee-single-native-scaled-ref @var{bv} @var{idx}
Scaled getters.
@end deffn

@c ------------------------------------------------------------

@subsubheading Double--precision floating--point words


@deffn Syntax bytevector-ieee-double-litend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-ieee-double-bigend-scaled-set! @var{bv} @var{idx} @var{val}
@deffnx Syntax bytevector-ieee-double-native-scaled-set! @var{bv} @var{idx} @var{val}
Scaled setters.
@end deffn


@deffn Syntax bytevector-ieee-double-litend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-ieee-double-bigend-scaled-ref @var{bv} @var{idx}
@deffnx Syntax bytevector-ieee-double-native-scaled-ref @var{bv} @var{idx}
Scaled getters.
@end deffn

@c page
@node readline
@section Extended interface to @gnu{} Readline


@cindex Library @library{vicare readline}
@cindex @library{vicare readline}, library


The library @library{vicare readline} extends the basic readline @api{}
exported by @library{vicare} (@pxref{iklib readline}) with features
specific to the @gnu{} Readline library.  The following bindings:

@example
readline-enabled?
readline
make-readline-input-port
@end example

@noindent
exported by @library{vicare} are reexported by @library{vicare
readline}.


@defun rl-version
If support for readline is enabled and the linked library is @gnu{}
Readline: return an exact integer representing the @gnu{} Readline
version number as encoded in the C symbol @code{RL_READLINE_VERSION};
else return @false{}.  When this function returns @false{}: no other
@gnu{} Readline functions must be called, lest the process be aborted.
@end defun

@c page
@node parser logic
@section Defining parsers logic


@cindex Library @library{vicare parser-logic}
@cindex @library{vicare parser-logic}, library


The library @library{vicare parser-logic} defines an infrastructure to
declare the logic of a parser for sequences of characters; such logic
can be specialised for different underlying devices.  The library
heavily relies on macros.

@menu
* parser logic intro::          Introductory examples.
* parser logic operators::      The logic of parser operators.
* parser logic api::            Programming interface to
                                parser definition.
@end menu

@c page
@node parser logic intro
@subsection Introductory examples


@subsubheading Parsing a string of selected characters

As first usage example, let's see a simple parser using a full Scheme
string as argument and accepting lexemes being the empty string or
strings of characters @samp{#\a} and @samp{\#b}; the result of a call to
the parser is the list of characters or @false{} if the input is
invalid:

@example
#!r6rs
(import (vicare)
  (vicare parser-logic))

(module (parse-abba)

  (define (parse-abba input-string)
    (assert (string? input-string))
    (%parse-string input-string
                   (string-length input-string)
                   0    ;start index
                   '()  ;start value for ACCUMULATOR
                   ))

  (define-parser-logic define-string->abba-parser ch next fail
    (%parse-string (accumulator)
       ((:end-of-input)
        (reverse accumulator))
       ((#\a #\b)
        (next %parse-string (cons ch accumulator)))))

  (define-string->abba-parser string->token-or-false
    (%parse-string))

  #| end of module |# )

(parse-abba "")         @result{} ()
(parse-abba "a")        @result{} (#\a)
(parse-abba "b")        @result{} (#\b)
(parse-abba "1")        @result{} #f)
(parse-abba "ciao")     @result{} #f)
(parse-abba "abb")      @result{} (#\a #\b #\b)
@end example

@noindent
notice the use of @func{next} to recursively tail--call
@func{parse-string}.

The macro @func{string->token-or-false} is exported by @library{vicare
parser-logic}; it implements the device logic for a full input Scheme
string representing a lexeme; it is to be used in a parser returning
@false{} when the input is invalid.

The macros in the module combine their output and expand to the
definition of a function @func{%parse-string} equivalent to the
following:

@example
(define (%parse-string input.string input.length input.index
                       accumulator)
  (if (fx=? input.index input.length)
      (reverse accumulator)
    (let ((ch (string-ref input.string input.index)))
      (cond ((or (char=? #\a ch)
                 (char=? #\b ch))
             (%parse-string input.string input.length
                            (fx+ 1 input.index)
                            (cons ch accumulator)))
            (else #f)))))
@end example

@c ------------------------------------------------------------

@subsubheading Parsing a string of intermixed selected characters

Let's see a parser using a full Scheme string as argument and accepting
lexemes being the empty string or strings of characters @samp{#\a} and
@samp{\#b}:

@itemize
@item
@samp{#\a} can be followed only by @samp{#\b} or end--of--input.

@item
@samp{#\b} can be followed only by @samp{#\a} or end--of--input.
@end itemize

@noindent
the result of a call to the parser is the list of characters or @false{}
if the input is invalid:

@example
#!r6rs
(import (vicare)
  (vicare parser-logic))

(module (parse-abab)

  (define (parse-abab input-string)
    (assert (string? input-string))
    (%parse-string input-string
                   (string-length input-string)
                   0    ;start index
                   '()  ;start value for ACCUMULATOR
                   ))

  ;;Parser logic to convert a string of intermixed
  ;;#\a and #\b into a list of characters.
  (define-parser-logic define-string->abab-parser ch next fail
    (%parse-string (accumulator)
       ((:end-of-input)
        (reverse accumulator))
       ((#\a #\b)
        (if (or (null? accumulator)
                (case ch
                  ((#\a) (char=? #\b (car accumulator)))
                  ((#\b) (char=? #\a (car accumulator)))))
            (next %parse-string (cons ch accumulator))
          (fail)))))

  ;;Actual parser drawing characters from an input string.
  (define-string->abab-parser string->token-or-false
    (%parse-string))

  #| end of module |# )

(parse-abab "")         @result{} ()
(parse-abab "a")        @result{} (#\a)
(parse-abab "b")        @result{} (#\b)
(parse-abab "1")        @result{} #f
(parse-abab "ciao")     @result{} #f
(parse-abab "abb")      @result{} #f
(parse-abab "baa")      @result{} #f
(parse-abab "abab")     @result{} (#\a #\b #\a #\b)
(parse-abab "baba")     @result{} (#\b #\a #\b #\a)
@end example

@noindent
notice the use of @func{fail} to signal an input error from inside an
operator clause.

The macros in the module combine their output and expand to the
definition of a function @func{%parse-string} equivalent to the
following:

@example
(define (%parse-string input.string input.length input.index
                       accumulator)
  (if (fx=? input.index input.length)
      (reverse accumulator)
    (let ((ch (string-ref input.string input.index)))
      (cond ((or (char=? #\a ch)
                 (char=? #\b ch))
             (if (or (null? accumulator)
                     (case ch
                       ((#\a) (char=? #\b (car accumulator)))
                       ((#\b) (char=? #\a (car accumulator)))))
                 (%parse-string input.string input.length
                                (fx+ 1 input.index)
                                (cons ch accumulator))
               #f))
            (else #f)))))
@end example

@c ------------------------------------------------------------

@subsubheading Parsing exact integers in base @math{10}

Let's see a parser using a full Scheme string as argument and accepting
lexemes representing exact integers in base @math{10}; the result of a
call to the parser is the exact integer object or @false{} if the input
is invalid:

@example
#!r6rs
(import (vicare)
  (vicare parser-logic))

(define (parse-integer input-string)

  (define (%digit ch)
    ;;Given a character argument: return the corresponding
    ;;fixnum if the character is between #\0 and #\9, else
    ;;return false.
    ;;
    (let ((N (fx- (char->integer ch) (char->integer #\0))))
      (and (fx>= N 0)
           (fx<  N 10)
           N)))

  ;;Parser logic to convert a string into an exact integer
  ;;in base 10.
  (define-parser-logic define-string->integer-parser ch next fail
    (%parse-integer ()
       ((%digit) => D
        (next %parse-digit+ D)))
    (%parse-digit+ (accumulator)
       ((:end-of-input)
        accumulator)
       ((%digit) => D
        (next %parse-digit+ (+ D (* 10 accumulator))))))

  ;;Actual parser drawing characters from an input string.
  (define-string->integer-parser string->token-or-false
    (%parse-integer))

  (assert (string? input-string))
  (%parse-integer input-string (string-length input-string) 0))

(parse-integer "")              @result{} #f
(parse-integer "1")             @result{} 1
(parse-integer "123")           @result{} 123
(parse-integer "ciao")          @result{} #f
(parse-integer "123ciao")       @result{} #f
@end example

The macros in the body of @func{parse-integer} combine their output and
expand to the definition of two functions @func{%parse-integer} and
@func{%parse-digit+} equivalent to the following:

@example
(define (%parse-integer input.string input.length input.index)
  (if (fx=? input.index input.length)
      #f
    (let ((ch (string-ref input.string input.index)))
      (cond ((%digit ch)
             => (lambda (D)
                  (%parse-digit+ input.string input.length
                                 (fx+ 1 input.index) D)))
            (else #f)))))

(define (%parse-digit+ input.string input.length input.index
                       accumulator)
  (if (fx=? input.index input.length)
      accumulator
    (let ((ch (string-ref input.string input.index)))
      (cond ((%digit ch)
             => (lambda (D)
                  (%parse-digit+ input.string input.length
                                 (fx+ 1 input.index)
                                 (+ D (* 10 accumulator)))))
            (else #f)))))
@end example



@c page
@node parser logic operators
@subsection The logic of parser operators


After all the macros have been expanded, the parser is a set of
@dfn{operator functions} extracting characters from an input device with
the purpose of producing a token.  Some operators are ``entry points''
to the parser: public functions we can call to start parsing; other
operators are for internal use only.  Each operator is meant to either:
tail--call another operator, terminate parsing by raising an exception,
terminate parsing by returning an error value, terminate parsing
successfully by returning a token value.

@quotation
@strong{NOTE} Operator functions are just ordinary Scheme functions
playing a special role in a parser; they are given a name with the only
purpose of letting us talk about them, and it happens that such name is
``operator''.
@end quotation

Operators are generated by macros from a symbolic expression specifying
an abstract parser:

@example
(define-parser-logic define-parser ch next fail . @meta{operators})
@end example

@noindent
and containing a subexpression for each operator.  Access to the input
device is specified by another macro which must implement a set of
@func{syntax-rules}:

@example
(define-syntax device-logic
  (syntax-rules (:introduce-device-arguments
                 :generate-end-of-input-or-char-tests
                 :unexpected-end-of-input
                 :generate-delimiter-test
                 :invalid-input-char)
    ((_ :introduce-device-arguments          ---) ---)
    ((_ :generate-end-of-input-or-char-tests ---) ---)
    ((_ :unexpected-end-of-input             ---) ---)
    ((_ :generate-delimiter-test             ---) ---)
    ((_ :invalid-input-char                  ---) ---)))
@end example

Concrete parsers are defined by combining the parser logic with the
device logic:

@example
(define-parser device-logic (@meta{operator-name} ...))
@end example

@noindent
we can define any number of concrete parsers using the same parser logic
and different device logics; at the end of the expansion, the input
device forms are hard coded into the operator.  The list of
@meta{operator-name} is a list of identifiers bound to the operators
being entry points to the parser.

To understand the semantics of operators, let's consider one accepting
only the characters @samp{#\X} or @samp{#\Y} and rejecting the
end--of-input:

@example
(define (operator-1 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (error-form))
          ((char=? X ch)
           (a-clause-form))
          ((char=? Y ch)
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
such operator would be specified by the following @meta{operator}
symbolic subexpression:

@example
(operator-1 (parser-state)
  ((#\X)
   (a-clause-form))
  ((#\Y)
   (another-clause-form)))
@end example

@noindent
notice how the end--of--input test is automatically generated.  The
operator has some arguments representing the input device state and
other arguments representing the parser state; the list of input device
arguments comes first and is specified by the device logic, discussed
later; the list of parser state arguments comes last and is specified in
the @meta{operator} symbolic expression.

An operator function accepting characters @samp{#\X}, @samp{#\Y} or
@samp{#\Z}, with @samp{#\Y} and @samp{#\Z} to be processed in the same
way, and rejecting the end--of-input looks like this:

@example
(define (operator-2 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (error-form))
          ((char=? #\X ch)
           (a-clause-form))
          ((or (char=? #\Y ch)
               (char=? #\Z ch))
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
such operator would be specified by the following @meta{operator}
symbolic subexpression:

@example
(operator-2 (parser-state)
  ((#\X)
   (a-clause-form))
  ((#\Y #\Z)
   (another-clause-form)))
@end example

An operator function accepting characters @samp{#\X} or @samp{#\Y}, but
also the end--of--input from the device, looks like this:

@example
(define (operator-3 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (end-of-input-form))
          ((char=? #\X ch)
           (a-clause-form))
          ((char=? #\Y ch)
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
and is specified in the parser logic as the following @meta{operator}
symbolic subexpression:

@example
(operator-3 (parser-state)
  ((:end-of-input)
   (end-of-input-form))
  ((#\X)
   (a-clause-form))
  ((#\Y)
   (another-clause-form)))
@end example

An operator function accepting characters @samp{#\X} or @samp{#\Y}, the
end--of--input from the device, and also a set of end--of--lexeme
delimiter characters, looks like this:

@example
(define (operator-4 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (end-of-input-form))
          ((char=? #\X ch)
           (a-clause-form))
          ((char=? #\Y ch)
           (another-clause-form))
          ((end-of-lexeme-delimiter? ch)
           (end-of-input-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
notice how the @code{end-of-input-form} is used for both the proper
end--of--input state and the end--of--lexeme state; such operator is
specified in the parser logic as the following @meta{operator} symbolic
subexpression:

@example
(operator-4 (parser-state)
  ((:end-of-input)
   (end-of-input-form))
  ((X)
   (a-clause-form))
  ((Y)
   (another-clause-form)))
@end example

@noindent
notice that processing of the end--of--lexeme state is not specified in
the parser logic: its generation is completely delegated to the device
logic.

Sometimes it is useful to apply a test function or macro to an input
character and collect the result for further processing; this can be
done as follows:

@example
(define (the-test ch arg1 arg2 arg3)
  ---)

(define (operator-5 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (error-form))
          ((the-test ch 1 2 3)
           => (lambda (result)
                (a-clause-form)))
          ((char=? #\Y ch)
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
and is specified in the parser logic as the symbolic subexpression:

@example
(operator-5 (parser-state)
  ((the-test 1 2 3) => result
   (a-clause-form))
  ((#\Y)
   (another-clause-form)))
@end example

@noindent
where @func{=>} is the auxiliary syntax exported by @rsixlibrary{base}.

@c page
@node parser logic api
@subsection Programming interface to parser definition


The following bindings are exported by the library @library{vicare
parser-logic}.


@deffn Syntax define-parser-logic @meta{definer} @meta{ch} @meta{next} @meta{fail} . @meta{operators}
@deffnx {Auxiliary Syntax} :end-of-input
Define an abstract parser specifying the rules for parsing the input
characters through calls to a set of operator functions; the result of
the expansion is a syntax definition which can be used to instantiate a
concrete parser by combining the parser logic with the input device
logic.

The input arguments are:

@table @asis
@item @meta{definer}
It must be an identifier.  It is bound to the generated syntax
definition; such syntax is used as follows:

@example
(@meta{definer} @meta{device-logic} (@meta{operator-name} @dots{}))
@end example

@noindent
where: @meta{device-logic} is the identifier bound to the device logic
syntax; the @meta{operator-name} are identifiers among the public
operator function names.

@item @meta{ch}
It must be an identifier.  When a character is successfully extracted
from the input device, it is bound to this identifier and made available
to the operator clauses.

@item @meta{next}
It must be an identifier.  The device logic rule
@code{:generate-end-of-input-or-char-tests} must bind it to a syntax;
such syntax must expand to a tail--call to an operator processing the
next input character.  @meta{next} is used as follows in the operator
clauses:

@example
(next @meta{operator-name} @meta{operator-arg} @dots{})
@end example

@noindent
and it should expand to something like:

@example
(@meta{operator-name} @meta{device-arg} @dots{} @meta{operator-arg} @dots{})
@end example

@noindent
where: @meta{device-arg} are the arguments representing the input device
state; @meta{operator-arg} are the arguments representing the parser
state as specified in the @meta{operator-spec}.

@item @meta{fail}
It must be an identifier.  The device logic rule
@code{:generate-end-of-input-or-char-tests} must bind it to a syntax;
such syntax is used to handle parsing errors detected by the operator
clauses.  @meta{fail} is simply used as @code{(@meta{fail})}.
@end table

Each @meta{operator-spec} must have the form:

@example
(@meta{operator-name} (@meta{operator-arg} @dots{}) @meta{operator-clause} @dots{})
@end example

@noindent
where:

@table @asis
@item @meta{operator-name}
Must be an identifier.  It is bound to a generated operator function.

There is no difference in the way public operators and private ones are
specified; the public operators names are listed in the concrete parser
definition.  An operator can be public in a concrete parser and private
in another concrete parser.

@item @meta{operator-arg}
Must be identifiers bound to the formal arguments associated to the
parser state.

@item @meta{operator-clause}
Are symbolic expressions specifying the input accepted by the operator.
@end table

Each @meta{operator-clause} must have one of the formats:

@table @code
@item ((@metao{char} @meta{char} @dots{}) @metao{body} @meta{body} @dots{})
Each @meta{char} must be an expression evaluating to a Scheme character
object.  The @meta{body} forms are evaluated if the input character
bound to @meta{ch} is equal, according to @func{char=?}, to one among
the @meta{char} characters.

@item ((@meta{func} @meta{expr} @dots{}) => @meta{ret} @metao{body} @meta{body} @dots{})
@meta{func} must be an expression evaluating to a function; the
@meta{expr} must be expressions; @meta{ret} must be an identifier.  The
@meta{body} forms are evaluated if the form:

@example
(@meta{func} @meta{ch} @meta{expr} @dots{})
@end example

@noindent
evaluates to a true value; such true value is bound to @meta{ret} prior
to evaluating the @meta{body}.

@item ((:end-of-input) @metao{body} @meta{body} @dots{})
The @meta{body} forms are evaluated if no more characters are available
from the input device.  This clause is to be used by operators accepting
the end--of--input state as valid; if such rule is not present: the
end--of--input will cause an error and the device logic is used to
handle it.
@end table
@end deffn

@c ------------------------------------------------------------

@deffn {Auxiliary Syntax} :introduce-device-arguments
@deffnx {Auxiliary Syntax} :generate-end-of-input-or-char-tests
@deffnx {Auxiliary Syntax} :unexpected-end-of-input
@deffnx {Auxiliary Syntax} :generate-delimiter-test
@deffnx {Auxiliary Syntax} :invalid-input-char
Identifiers used to specify device logic syntax rules; they must be used
in a syntax definition like:

@example
(define-syntax device-logic
  (syntax-rules (:introduce-device-arguments
                 :generate-end-of-input-or-char-tests
                 :unexpected-end-of-input
                 :generate-delimiter-test
                 :invalid-input-char)
    ((_ :introduce-device-arguments          ---) ---)
    ((_ :generate-end-of-input-or-char-tests ---) ---)
    ((_ :unexpected-end-of-input             ---) ---)
    ((_ :generate-delimiter-test             ---) ---)
    ((_ :invalid-input-char                  ---) ---)))
@end example

@noindent
the rules have the following syntax:

@table @code
@item :introduce-device-arguments
The input form is:

@example
(_ :introduce-device-arguments @meta{kont} . @meta{rest})
@end example

@noindent
this rule introduces a list of identifiers used as device--specific
arguments; they will be the first arguments for each parser operator
function.  The output form must be:

@example
(@meta{kont} (@meta{device-arg} @dots{}) . @meta{rest})
@end example

@noindent
where the @meta{device-arg} are identifiers.

@item :generate-end-of-input-or-char-tests
The input form is:

@example
(_ :generate-end-of-input-or-char-tests
   @meta{ch} @meta{next} @meta{fail}
   (@meta{device-arg} @dots{})
   @meta{end-of-input-kont} @meta{parse-input-char-kont})
@end example

@noindent
this rule is used to generate the input device tests for an operator
function.  The expanded code must first test for the end--of--input
state and then proceed to evaluate code for the input character; in
pseudocode the output form should be:

@example
(if (end-of-input? @meta{device-arg} ...)
    @meta{end-of-input-kont}
  (let ((@meta{ch} (get-next-char @meta{device-arg} ...)))
    @meta{parse-input-char-kont}))
@end example

@meta{ch} is an identifier.  The input character must be bound to it
before evaluating @meta{parse-input-char-kont}.

@meta{next} is an identifier.  This rule must bind it to a syntax used
to tail--call another operator using @meta{device-arg} as first
arguments; for example:

@example
(define-syntax @meta{next}
  (syntax-rules ()
    ((_ ?operator-name ?operator-arg ...)
     (?operator-name @meta{device-arg} ... ?operator-arg))))
@end example

@meta{fail} is an identifier.  This rule must bind it to a syntax used
to signal an error detected by an operator clause; for example:

@example
(define-syntax @meta{fail}
  (syntax-rules ()
    ((_)
     (error #f "invalid input character"
       @meta{device-arg} ...))))
@end example

The @meta{device-arg} are the identifiers introduced by
@code{:introduce-device-arguments}.

@meta{end-of-input-kont} is a form to be evaluated whenever the
end--of--input is detected.

@meta{parse-input-char-kont} is a form to be evaluated whenever a
character is extracted from the input device.

@item :unexpected-end-of-input
The input form is:

@example
(_ :unexpected-end-of-input (@meta{device-arg} @dots{}))
@end example

@noindent
whenever the end--of--input is found by an operator that does not accept
it as valid, this rule is used to decide what to do.

The @meta{device-arg} are the identifiers introduced by
@code{:introduce-device-arguments}.

The output form can return a value or raise an exception; the returned
value becomes the return value of the call to the parser.

@item :generate-delimiter-test
The input form is:

@example
(_ :generate-delimiter-test
   @meta{ch}
   @meta{ch-is-delimiter-kont}
   @meta{ch-is-not-delimiter-kont})
@end example

@noindent
this rule is used for input devices for which the lexeme string is
embedded into a sequence of other characters, so there exists a set of
characters that delimit the end--of--lexeme.  The parser delegates to
the device the responsibility of knowing which characters are
delimiters, if any.

@meta{ch} is an identifier bound to the input character.
@meta{ch-is-delimiter-kont} is a form to be evaluated whenever @meta{ch}
is a delimiter character.  @meta{ch-is-not-delimiter-kont} is a form to
be evaluated whenever @meta{ch} is not a delimiter character.

For parsers accepting a full Scheme string as lexeme: there are no
delimiters,3 the end--of--lexeme is the end--of--input; such parsers
should just use @meta{ch-is-not-delimiter-kont} as output form.

For parsers having delimiter characters, for example, recognised by a
function like:

@example
(define (delimiter? ch)
  (or (char=? ch #\space)
      (char=? ch #\linefeed)))
@end example

@noindent
the output form should be something like:

@example
(if (delimiter? @meta{ch})
    @meta{ch-is-delimiter-kont}
  @meta{ch-is-not-delimiter-kont})
@end example

@item :invalid-input-char
The input form is:

@example
(_ :invalid-input-char (@meta{device-arg} @dots{}) @meta{ch})
@end example

@noindent
whenever an input character is not accepted by an operator function this
rule is used to decide what to do.

The @meta{device-arg} are the identifiers introduced by
@code{:introduce-device-arguments}; @meta{ch} is an identifier bound to
the invalid input character.

The output form can return a value or raise an exception; the returned
value becomes the return value of the call to the parser.
@end table
@end deffn

@c ------------------------------------------------------------

@deffn Syntax string->token-or-false @meta{keyword} @meta{arg} ...
Define the device logic to parse a lexeme from a full Scheme string
object as in @func{string->number}.  It is implemented as follows:

@example
(define-syntax string->token-or-false
  (syntax-rules (:introduce-device-arguments
                 :generate-end-of-input-or-char-tests
                 :unexpected-end-of-input
                 :generate-delimiter-test
                 :invalid-input-char)
    ((_ :introduce-device-arguments
        ?kont . ?rest)
     (?kont (input.string input.length input.index) . ?rest))

    ((_ :invalid-input-char
        (?input.string ?input.length ?input.index)
        ?ch)
     #f)

    ((_ :unexpected-end-of-input
        (?input.string ?input.length ?input.index))
     #f)

    ((_ :generate-delimiter-test
        ?ch ?ch-is-delimiter-kont ?ch-is-not-delimiter-kont)
     ?ch-is-not-delimiter-kont)

    ((_ :generate-end-of-input-or-char-tests
        ?ch ?next ?fail
        (?input.string ?input.length ?input.index)
        ?end-of-input-kont ?parse-input-char-kont)
     (let-syntax
         ((?fail (syntax-rules ()
                   ((_) #f)))
          (?next (syntax-rules ()
                   ((_ ?operator-name ?operator-arg (... ...))
                    (?operator-name ?input.string ?input.length
                                    (fx+ 1 ?input.index)
                                    ?operator-arg (... ...))))))
       (if (fx=? ?input.index ?input.length)
           ?end-of-input-kont
         (let ((?ch (string-ref ?input.string ?input.index)))
           ?parse-input-char-kont))))
    ))
@end example
@end deffn

@c page
@node gcc
@section A toy library interface to @gcc{}


@cindex Library @library{vicare gcc}
@cindex @library{vicare gcc}, library


The library @library{vicare gcc} is installed along with
@value{PRJNAME}; it implements a toy interface to @command{gcc}, the
@gnu{} C Compiler.  Its purpose is to build, at runtime, a C language
shared library from possibly dynamically constructed C code; then load
the library and access a C function as @ffi{} callout.

@library{vicare gcc} must be considered as a toy to demonstrate the
features of @value{PRJNAME}; it is installed only if the @posix{},
@gnu{} C library and Libffi @api{}s are enabled at package configuration
time.

The following is an example of function to increment an integer:

@example
#!r6rs
(import (vicare)
  (prefix (vicare gcc) gcc.))

(gcc.initialise "/usr/local/bin/gcc" "/home/marco/var/tmp/")

(gcc.define-c-function
  signed-int incr (signed-int)
  "#include <stdio.h>
   int incr (int a) @{
     return 1+a;
   @}")

(incr 1)        @result{} 2
@end example

@noindent
the code creates a shared library @code{libincr.so} in a subdirectory of
the given initialisation directory, then load it and access the symbol
@code{incr}.

@library{vicare gcc} depends upon the following libraries:

@example
(vicare ffi)
(vicare posix)
(vicare glibc)
(vicare platform constants)
(vicare language-extensions syntaxes)
@end example


@defun initialise @var{gcc} @var{tmpdir}
Initialise the library.  @var{gcc} must be the string full filename of
the @gcc{} executable.  @var{tmpdir} must be the string pathname of an
existing directory on a partition with executable permissions; it is
used to create temporary files, including the shared libraries.

Temporary files go in a subdirectory of @var{tmpdir}; it is the
responsibility of the system administrator to clean up regularly such
subdirectories.
@end defun


@deffn Syntax define-c-function @meta{retval} @meta{name} @meta{args} @meta{code}
Define a new Scheme function wrapping a C function from a shared
library.  @meta{name} must be an identifier representing the name of the
function.

@meta{retval} must be a symbol selecting the type of the return value;
@meta{args} must be a list of symbols selecting the types of the
arguments; @ref{ffi call types} for details.

@meta{code} must be a Scheme string representing the C code to be
compiled.
@end deffn


@deffn Parameter COMPILE-FLAGS
References a list of string.  Base options for the compiler, it is
initialised to @code{("-c")}.
@end deffn


@deffn Parameter LINK-FLAGS
References a list of string.  Base options for the linker, it is
initialised to @code{("-pipe" "-shared" "-fPIC")}.
@end deffn


@deffn Parameter CFLAGS
References a list of string.  Additional options for the compiler, it is
initialised to @code{("-O2")}.
@end deffn


@deffn Parameter LDFLAGS
References a list of string.  Additional options for the linker, it is
initialised to nil.
@end deffn

@c page
@node wtables
@section Weak hashtables


@cindex Library @library{vicare containers weak-hashtables}
@cindex @library{vicare containers weak-hashtables}, library


Weak hashtables are associative containers whose keys are held by weak
references; registering a key into a weak hashtable does not prevent its
garbage collection.  A weak hashtable is a vector holding nulls or
alists; each vector location is called @dfn{bucket}.  Alists have the
spine composed of strong pairs, while the entries are weak pairs:

@example
|-----|-----|-----|-----|-----| vector of buckets
         |
         v
      |-----|-----|strong pair
         |      |
         |       ------------> |-----|-----|strong pair
         |                        |     |
      |-----|-----|weak pair      |      -------> null
        key  value                v
                               |-----|-----| weak pair
                                 key  value
@end example

Whenever a key in a weak hashtable is garbage collected: the
corresponding location in the weak pair is set to the @acronym{BWP}
object; whenever a bucket is accessed, it is first cleared of weak pairs
holding @acronym{BWP} in key position.  Notice that fixnums, characters
and the other values that fit in a single machine word are never
collected from the point of view of a weak hashtable.

@quotation
@strong{NOTE} Immediate values (@true{}, @false{}, nil, fixnums, etc.)
used as weak hashtable keys are @strong{never} garbage collected; so the
associated entries will never be removed from the table unless we
explicitly do it with @func{weak-hashtable-delete!} or
@func{weak-hashtable-clear!}.
@end quotation

When the number of collected objects equals the number of buckets
(whatever the distribution of elements), the table is enlarged doubling
the number of buckets; the table is @strong{never} restricted by
reducing the number of buckets.

Weak hashtables are subjected to the following constraints:

@itemize
@item
The number of buckets is always an exact power of @math{2}.

@item
The maximum number of buckets is the value of @code{(greatest-fixnum)}.

@item
The maximum number of entries is the value of @code{(greatest-fixnum)}.
@end itemize

The @api{} of weak hashtables is similar to the @api{} of @rnrs{6}
hashtables.  The following bindings are exported by the @library{vicare
containers weak-hashtables} library.


@defun make-weak-hashtable @var{hash-function} @var{equiv-function}
@defunx make-weak-hashtable @var{hash-function} @var{equiv-function} @var{dimension}
Build and return a new weak hashtable using @var{hash-function} as hash
function for keys and @var{equiv-function} as comparison function
between keys.  When @var{dimension} is used: it is approximately the
initial number of buckets; when not used it defaults to @math{16}.
@end defun


@defun weak-hashtable? @var{obj}
Return true if @var{obj} is a weak hashtable.  Weak hashtables are
disjoint values.
@end defun


@defun weak-hashtable-set! @var{table} @var{key} @var{value}
Add an entry to @var{table} holding @var{key} and @var{value}.  Return
unspecified values.
@end defun


@defun weak-hashtable-ref @var{table} @var{key} @var{default}
Search for @var{key} in @var{table}; if found: return the corresponding
value, else return @var{default}.
@end defun


@defun weak-hashtable-contains? @var{table} @var{key}
Return @true{} if @var{table} contains an entry for @var{key}, else
return @false{}.
@end defun


@defun weak-hashtable-delete! @var{table} @var{key}
If @var{key} is in @var{table}: remove it, else do nothing.  Return
unspecified values.
@end defun


@defun weak-hashtable-size @var{table}
Return the approximate number of entries in @var{table}.  The returned
value can be incorrect if some keys have been garbage collected but the
corresponding entries in the table are not yet removed.
@end defun


@defun weak-hashtable-clear! @var{table}
Remove all the entries from @var{table}.  The number of buckets is reset
to the its initial value.  Return unspecified values.
@end defun


@defun weak-hashtable-keys @var{table}
Return a vector holding the keys in @var{table}.
@end defun


@defun weak-hashtable-entries @var{table}
Return two values: a vector holding the keys in @var{table}, a vector
holding the values in @var{table}.
@end defun


@defun weak-hashtable-update! @var{table} @var{key} @var{proc} @var{default}
If no entry exists for @var{key} in @var{table}: create a new entry
associating @var{key} to the result of applying @var{proc} to
@var{default}.

If an entry exists for @var{key} in @var{table}: replace the its value
with the result of applying @var{proc} to the old value.
@end defun

@c page
@node flonum format
@section Formatting flonums


@cindex Library @library{vicare numerics flonum-formatter}
@cindex @library{vicare numerics flonum-formatter}, library


The following bindings are exported by the library @library{vicare
numerics flonum-formatter}.


@defun format-flonum @var{positive?} @var{digits} @var{exponent}
Given a list of characters @var{digits} and a fixnum @var{exponent}
compose a string representing the corresponding flonum.  @var{positive?}
determines the sign.

@example
#!r6rs
(import (vicare)
  (vicare numerics flonum-formatter))

(define digits
  '(#\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))

(format-flonum #t digits 0)     @result{} "0.123456789"
(format-flonum #t digits 1)     @result{} "1.23456789"
(format-flonum #t digits 2)     @result{} "12.3456789"
(format-flonum #t digits 3)     @result{} "123.456789"
(format-flonum #t digits 8)     @result{} "12345678.9"
(format-flonum #t digits 9)     @result{} "123456789.0"
(format-flonum #t digits 10)    @result{} "1.23456789e9"

(format-flonum #t digits -1)    @result{} "0.0123456789"
(format-flonum #t digits -2)    @result{} "0.00123456789"
(format-flonum #t digits -3)    @result{} "0.000123456789"
(format-flonum #t digits -4)    @result{} "1.23456789e-5"

(format-flonum #f digits 1)     @result{} "-1.23456789"
(format-flonum #f digits 2)     @result{} "-12.3456789"
(format-flonum #f digits 3)     @result{} "-123.456789"
(format-flonum #f digits 8)     @result{} "-12345678.9"
(format-flonum #f digits 9)     @result{} "-123456789.0"
(format-flonum #f digits 10)    @result{} "-1.23456789e9"

(format-flonum #f digits -1)    @result{} "-0.0123456789"
(format-flonum #f digits -2)    @result{} "-0.00123456789"
(format-flonum #f digits -3)    @result{} "-0.000123456789"
(format-flonum #f digits -4)    @result{} "-1.23456789e-5"
@end example
@end defun

@c page
@node flonum parse
@section Parsing flonums


@cindex Library @library{vicare numerics flonum-parser}
@cindex @library{vicare numerics flonum-parser}, library


The following bindings are exported by the library @library{vicare
numerics flonum-parser}.


@defun parse-flonum @var{flonum} @var{real-func} @var{unreal-func}
Parse the @var{flonum} its components for string formatting.

If @var{flonum} is representable as real number, apply the function
@var{real-func} to @math{3} arguments: a boolean, true if @var{flonum}
is positive; a list of characters representing the digits of
@var{flonum}; a fixnum representing the exponent of @var{flonum}.
Return the result of the application.

If @var{flonum} is not representable as real number, apply the function
@var{unreal-func} to a single argument being the string representation
of @var{flonum}.  Return the result of the application.

Notice how the arguments handed to @var{real-func} match the argument of
@func{format-flonum} from @library{vicare flonum-formatter}.

@example
#!r6rs
(import (vicare)
  (vicare numerics flonum-parser))

(parse-flonum 1.23456789
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (real #t
    (#\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
     #\0 #\0 #\0 #\0 #\0 #\0 #\0 #\1)
    1)

(parse-flonum 12.34e5
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (real #t (#\1 #\2 #\3 #\4) 7)

(parse-flonum -12.34e5
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (real #f (#\1 #\2 #\3 #\4) 7)

(parse-flonum +inf.0
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (unreal "+inf.0")

(parse-flonum +nan.0
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (unreal "+nan.0")
@end example
@end defun

@c page
@node sentinels
@section Sentinel values


@cindex @library{vicare language-extensions sentinels}, library
@cindex Library @library{vicare language-extensions sentinels}


The library @library{vicare language-extensions sentinels} defines
unique values and predicates to test them.  Sentinel values can be used
as terminators for sequences or as values for uninitialised storage
locations.


@defvr Constant sentinel
The sentinel value.
@end defvr


As usage example, the following form makes use of the sentinel as
terminator for a list:

@example
(let ((ell (list 1 2 3 4 5 sentinel)))
  (let loop ((ell ell)
             (res '()))
    (if (sentinel? (car ell))
        res
      (loop (cdr ell) (cons (car ell) res)))))
@result{} (5 4 3 2 1))
@end example

@noindent
the following form defines an iterator closure using the sentinel to
signal the end of the iteration:

@example
(let* ((ell  '(1 2 3 4 5))
       (iter (lambda ()
               (let ((ell ell))
                 (if (null? ell)
                     sentinel
                   (begin
                     (car ell)
                     (set! ell (cdr ell))))))))
  (let loop ((res '()))
    (let ((v (iter)))
      (if (sentinel? v)
          res
        (loop (cons v res))))))
@result{} (5 4 3 2 1)
@end example


@defun make-sentinel
Return a new sentinel value.  @func{sentinel?} will return @true{} when
applied to such a value, but new sentinel values are meant to be checked
with @func{eq?}.

New sentinels can be used in situations where a unique terminator is
needed: when we need to distinguish @samp{sentinel} from a temporary
sentinel we need for a specific operation.
@end defun


@defun sentinel? @var{obj}
Return @true{} if @var{obj} a sentinel value.
@end defun


@defvr Constant undefined
The undefined value.
@end defvr


@defun undefined? @var{obj}
Return true if @var{obj} is @func{eq?} to @code{undefined}.
@end defun


@defvr Constant unspecified
The unspecified value.
@end defvr


@defun unspecified? @var{obj}
Return true if @var{obj} is @func{eq?} to @code{unspecified}.
@end defun

@c end of file
@c page
@node debugging
@section Debugging facilities


@menu
* debugging compiler::          Inspecting the compiler internals.
@end menu

@c page
@node debugging compiler
@subsection Inspecting the compiler internals


@cindex Library @library{vicare debugging compiler}
@cindex @library{vicare debugging compiler}, library


The following bindings are exported by the library @library{vicare
debugging compiler}.

@c page
@node bytevector compounds
@section Bytevector compounds


@cindex Library @library{vicare containers bytevector-compounds}
@cindex @library{vicare containers bytevector-compounds}, library


A @dfn{bytevector compound} is a sequence of octets split into a
sequence of bytevectors.  Bytevector compounds have a special @api{} to
handle the sequence of octets as a First--in First--out queue.
Bytevector compounds are defined by the library @library{vicare
containers bytevector-compounds}.

@menu
* bytevector compounds types::    Data type definitions.
* bytevector compounds inspect::  Inspecting bytevector compounds.
* bytevector compounds queue::    Queue programming interface.
* bytevector compounds access::   Accessors and mutators.
@end menu

@c page
@node bytevector compounds types
@subsection Data type definitions


The following bindings are exported by the library @library{vicare
containers bytevector-compounds}.


@deftp {@rnrs{6} Record Type} bytevector-compound
@cindex Argument @var{bvcom}
@cindex Function argument @var{bvcom}
@cindex @var{bvcom}, function argument
Record type representing a bytevector compound.  When instances of this
type are used as arguments to functions: this documentation identifies
them as @var{bvcom}.
@end deftp


@defun bytevector-compound? @var{obj}
Return @true{} if @var{obj} is an instance of
@code{bytevector-compound}, else return @false{}.
@end defun

@c ------------------------------------------------------------

@subsubheading Validation clauses

The following bindings are to be used with the facilities of the library
@library{vicare arguments validation}, @ref{args, Optional function
arguments validation}.


@deffn {Validation Clause} bytevector-compound @var{obj}
@deffnx {Validation Clause} false-or-bytevector-compound @var{obj}
Succeed if @var{obj} is an instance of @code{bytevector-compound}.  The
second clause accepts also @false{}.
@end deffn


@deffn {Validation Clause} bytevector-compound/filled @var{obj}
Succeed if @var{obj} is an instance of @code{bytevector-compound} and it
contains at least one octet.
@end deffn

@c page
@node bytevector compounds inspect
@subsection Inspecting bytevector compounds


The following bindings are exported by the library @library{vicare
containers bytevector-compounds}.


@defun bytevector-compound-empty? @var{bvcom}
Return @true{} if @var{bvcom} has no octets in it, else return @false{}.
@end defun


@defun bytevector-compound-filled? @var{bvcom}
Return @true{} if @var{bvcom} has at least one octet in it, else return
@false{}.
@end defun


@defun bytevector-compound-length @var{bvcom}
Return a non--negative exact integer representing the number of octets
currently in @var{bvcom}.
@end defun


@defun bytevector-compound-total-length @var{bvcom}
Return a non--negative exact integer representing the number of octets
in @var{bvcom}, including the ones in the bytevectors that have been
already dequeued.
@end defun


@defun bytevector-compound-data @var{bvcom}
Return the list of bytevectors in @var{bvcom}.  Mutating the return
value results in undefined behaviour.
@end defun

@c page
@node bytevector compounds queue
@subsection Queue programming interface


The following bindings are exported by the library @library{vicare
containers bytevector-compounds}.


@defun bytevector-compound-enqueue! @var{bvcom} @var{item}
Enqueue the bytevector @var{item} into @var{bvcom}.  Return unspecified
values.
@end defun


@defun bytevector-compound-dequeue! @var{bvcom}
Dequeue the next bytevector from @var{bvcom} and return it; return
@false{} if @var{bvcom} is empty.
@end defun

@c page
@node bytevector compounds access
@subsection Accessors and mutators


The following bindings are exported by the library @library{vicare
containers bytevector-compounds}.


@defun bytevector-compound-u8-set! @var{bvcom} @var{idx} @var{octet}
@defunx bytevector-compound-u8-ref @var{bvcom} @var{idx}
Accessor and mutator for non-negative exact integers in the range
@math{[0, 255]}.
@end defun


@defun bytevector-compound-s8-set! @var{bvcom} @var{idx} @var{byte}
@defunx bytevector-compound-s8-ref @var{bvcom} @var{idx}
Accessor and mutator for non-negative exact integers in the range
@math{[-128, 127]}.
@end defun

@c page
@node net channels
@section Interprocess connection channels


@cindex Library @library{vicare net channels}
@cindex @library{vicare net channels}, library

The library @library{vicare net channels} implements utilities to
transfer data through Scheme binary ports, typically between processes.

@menu
* net channels types::          Data type definitions.
* net channels init::           Constructors and destructors.
* net channels config::         Configuration parameters.
* net channels inspect::        Channels inspection.
* net channels preds::          Predicates and arguments validation.
* net channels recv::           Receiving a message.
* net channels send::           Sending a message.
* net channels conditions::     Condition object types.
@end menu

@c page
@node net channels types
@subsection Data type definitions


The following bindings are exported by the library @library{vicare net
channels}.

@c ------------------------------------------------------------

@subsubheading Base channel type


@deftp {@rnrs{6} Record Type} channel
Record type representing an interprocess connection channel.  Whenever
this documentation refers to arguments being instances of this type: it
uses the identifier @var{chan}.
@end deftp


@defun channel? @var{obj}
Return @true{} if @var{obj} is an instance of @code{channel}, else
return @false{}.
@end defun


@deffn {Validation Clause} channel @var{obj}
@deffnx {Validation Clause} false-or-channel @var{obj}
Validation clause to be used with the facilities of the library
@library{vicare arguments validation}.  The first form succeeds if
@var{obj} is an instance of @code{channel}; the second also accepts
@false{}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Binary channel type


@deftp {@rnrs{6} Record Type} binary-channel
Record type representing an interprocess connection binary channel.
@end deftp


@defun binary-channel? @var{obj}
Return @true{} if @var{obj} is an instance of @code{binary-channel},
else return @false{}.
@end defun


@deffn {Validation Clause} binary-channel @var{obj}
@deffnx {Validation Clause} false-or-binary-channel @var{obj}
Validation clause to be used with the facilities of the library
@library{vicare arguments validation}.  The first form succeeds if
@var{obj} is an instance of @code{binary-channel}; the second also
accepts @false{}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Textual channel type


@deftp {@rnrs{6} Record Type} textual-channel
Record type representing an interprocess connection textual channel.
@end deftp


@defun textual-channel? @var{obj}
Return @true{} if @var{obj} is an instance of @code{textual-channel},
else return @false{}.
@end defun


@deffn {Validation Clause} textual-channel @var{obj}
@deffnx {Validation Clause} false-or-textual-channel @var{obj}
Validation clause to be used with the facilities of the library
@library{vicare arguments validation}.  The first form succeeds if
@var{obj} is an instance of @code{textual-channel}; the second also
accepts @false{}.
@end deffn

@c page
@node net channels init
@subsection Constructors and destructors


The following bindings are exported by the library @library{vicare net
channels}.


@defun open-binary-input-channel @var{in-port}
Build and return a new instance of @code{binary-channel} to be used to
receive messages; the returned channel is inactive.  The channel wraps
the binary input or input/output port @var{in-port}.
@end defun


@defun open-binary-output-channel @var{ou-port}
Build and return a new instance of @code{binary-channel} to be used to
send messages; the returned channel is inactive.  The channel wraps the
binary output or input/output port @var{ou-port}.
@end defun


@defun open-binary-input/output-channel @var{port}
@defunx open-binary-input/output-channel @var{in-port} @var{ou-port}
Build and return a new instance of @code{binary-channel} to be used to
both receive and send messages; the returned channel is inactive.

The channel wraps the binary input or input/output port @var{in-port},
used to receive messages, and the binary output or input/output port
@var{ou-port}, used to send messages.  @var{in-port} and @var{ou-port}
can be the same port.

When a single argument is given: @var{port} is used for both input and
output.
@end defun

@c ------------------------------------------------------------

@defun open-textual-input-channel @var{in-port}
Build and return a new instance of @code{textual-channel} to be used to
receive messages; the returned channel is inactive.  The channel wraps
the textual input or input/output port @var{in-port}.
@end defun


@defun open-textual-output-channel @var{ou-port}
Build and return a new instance of @code{textual-channel} to be used to
send messages; the returned channel is inactive.  The channel wraps the
textual output or input/output port @var{ou-port}.
@end defun


@defun open-textual-input/output-channel @var{port}
@defunx open-textual-input/output-channel @var{in-port} @var{ou-port}
Build and return a new instance of @code{textual-channel} to be used to
both receive and send messages; the returned channel is inactive.

The channel wraps the textual input or input/output port @var{in-port},
used to receive messages, and the textual output or input/output port
@var{ou-port}, used to send messages.  @var{in-port} and @var{ou-port}
can be the same port.

When a single argument is given: @var{port} is used for both input and
output.
@end defun

@c ------------------------------------------------------------

@defun close-channel @var{chan}
Finalise a channel closing its connection port; return unspecified
values.  A pending message delivery, if any, is aborted.
@end defun


@defun channel-abort! @var{chan}
Abort the current operation and reset the channel to inactive; return
unspecified values.
@end defun

@c page
@node net channels config
@subsection Configuration parameters


The following bindings are exported by the library @library{vicare net
channels}.


@defun channel-set-maximum-message-size! @var{chan} @var{maximum-message-size}
Configure the maximum message size; return unspecified values.

@var{maximum-message-size} must be a positive exact integer representing
the inclusive maximum message size; if the size of the message exceeds
this value: message delivery will fail.

When not configured: the maximum message size defaults to @math{4096}.

The maximum message size @strong{is not} reset when a message delivery
is completed.
@end defun


@defun channel-set-expiration-time! @var{chan} @var{expiration-time}
Configure the message delivery expiration time; return unspecified
values.

If @var{expiration-time} is a time object (as defined by the library
@library{vicare}): it represents the limit of time since the Epoch to
complete message delivery; if the allotted time expires: message
delivery will fail.  Typically we build such time objects using
@func{time-from-now}.

If @var{expiration-time} is @false{}: there is not time limit.

When not configured: the expiration time defaults to no time limit.

The expiration time @strong{is not} reset when a message delivery is
completed.
@end defun


@defun channel-set-message-terminators! @var{chan} @var{terminators}
Configure the message terminators; return unspecified values.

If @var{chan} is a binary channel: @var{terminators} must be a
non--empty list of non--empty bytevectors representing possible message
terminators.  When not configured: the list of terminators defaults to:

@example
(#ve(ascii "\r\n\r\n") #ve(ascii "\n\n"))
@end example

If @var{chan} is a textual channel: @var{terminators} must be a
non--empty list of non--empty strings representing possible message
terminators.  When not configured: the list of terminators defaults to:

@example
("\r\n\r\n" "\n\n")
@end example

The terminators @strong{are not} reset when a message delivery is
completed.
@end defun


@defun channel-set-maximum-message-portion-size! @var{chan} @var{max-portion-size}
Configure the maximum message portion size; return unspecified values.

@var{max-portion-size} must be a positive fixnum representing the
inclusive maximum message portion size in octets or characters; when
receiving a message portion: this value is used as second argument to
@func{get-bytevector-n} or @func{get-string-n}.

When not configured: the maximum portion size defaults to @math{4096}
for binary channels and to @math{1024} for textual channels.  This value
can be reconfigured any number of times, even between message portion
receptions.

The maximum message portion size @strong{is not} reset when a message
delivery is completed.
@end defun

@c page
@node net channels inspect
@subsection Channels inspection


The following bindings are exported by the library @library{vicare net
channels}.


@defun channel-connect-in-port @var{chan}
@defunx channel-connect-ou-port @var{chan}
Return the input or output port of @var{chan}.
@end defun

@c page
@node net channels preds
@subsection Predicates and arguments validation


The following bindings are exported by the library @library{vicare net
channels}.


@defun receiving-channel? @var{chan}
Return @true{} if @var{chan} is in the course of receiving a message,
else return @false{}.  It is an error if @var{chan} is not an instance
of @code{channel}.
@end defun


@defun sending-channel? @var{chan}
Return @true{} if @var{chan} is in the course of sending a message, else
return @false{}.  It is an error if @var{chan} is not an instance of
@code{channel}.
@end defun


@defun inactive-channel? @var{chan}
Return @true{} if @var{chan} is @strong{neither} in the course of
sending @strong{nor} receiving a message, else return @false{}.  It is
an error if @var{chan} is not an instance of @code{channel}.
@end defun


@defun input-channel? @var{chan}
Return @true{} if @var{chan} is an input or input/output channel, else
return @false{}.  It is an error if @var{chan} is not an instance of
@code{channel}.
@end defun


@defun output-channel? @var{chan}
Return @true{} if @var{chan} is an output or input/output channel, else
return @false{}.  It is an error if @var{chan} is not an instance of
@code{channel}.
@end defun


@defun input/output-channel? @var{chan}
Return @true{} if @var{chan} is an input/output channel, else return
@false{}.  It is an error if @var{chan} is not an instance of
@code{channel}.
@end defun

@c ------------------------------------------------------------

The following bindings are validation clauses to be used with the
facilities of the library @library{vicare arguments validation}.


@deffn {Validation Clause} receiving-channel @var{obj}
Succeed if @var{obj} is an instance of @code{channel} and it is in the
course of receiving a message.
@end deffn


@deffn {Validation Clause} not-receiving-channel @var{obj}
Succeed if @var{obj} is an instance of @code{channel} and it is
@strong{not} in the course of receiving a message.
@end deffn


@deffn {Validation Clause} sending-channel @var{obj}
Succeed if @var{obj} is an instance of @code{channel} and it is in the
course of sending a message.
@end deffn


@deffn {Validation Clause} not-sending-channel @var{obj}
Succeed if @var{obj} is an instance of @code{channel} and it is
@strong{not} in the course of sending a message.
@end deffn


@deffn {Validation Clause} inactive-channel @var{obj}
Succeed if @var{obj} is an instance of @code{channel} and it is
@strong{neither} in the course of sending @strong{nor} receiving a
message.
@end deffn


@deffn {Validation Clause} not-inactive-channel @var{obj}
Succeed if @var{obj} is an instance of @code{channel} and it is
@strong{either} in the course of sending @strong{or} receiving a
message.
@end deffn

@c page
@node net channels recv
@subsection Receiving a message


The following bindings are exported by the library @library{vicare net
channels}.


@defun channel-recv-begin! @var{chan}
Configure a channel to start receiving a message; return unspecified
values.  @var{chan} must be an input or input/output channel; it is an
error if the channel is not inactive.
@end defun


@defun channel-recv-end! @var{chan}
Finish receiving a message and: for binary channels return the
accumulated octets in a bytevector, for textual channels return the
accumulated characters in a string.  It is an error if the channel is
not in the course of receiving a message.

After this function is applied to a channel: the channel itself is
configured as inactive; so it is available to start receiving another
message or to send a message.
@end defun


@defun channel-recv-end!/rbl @var{chan}
Like @func{channel-recv-end!}, but return @math{2} values:

@enumerate
@item
For binary channels: null or a list of non--empty bytevectors
representing the accumulated message data in bytevector--reverse order.
For textual channels: null or a list of non--empty strings representing
the accumulated message data in bytevector--reverse order.

@item
An exact integer representing the total number of octets or characters
in the bytevectors or strings.
@end enumerate
@end defun


@defun channel-recv-message-portion! @var{chan}
Receive a portion of input message from the given channel and accumulate
it in the internal state; it is an error if the channel is not in the
course of receiving a message.

This function performs a @strong{single} read operation from the
registered connection input port; for binary channels it uses
@func{get-bytevector-n}, for textual channels it uses
@func{get-string-n}.  When non--blocking mode is desired: the underlying
input port must be configured in non--blocking mode.

@itemize
@item
Return @true{} if a configured message terminator is read from the input
port or if the channel already read a terminator in a previous
operation.  If a message terminator is received: set @var{chan} to
``message terminated'' status.

@item
Return the @eof{} object if @eof{} is read from the input port before a
message terminator.

@item
Return the would--block object if a would--block condition is found in
the input port before a message terminator.  In this case we need to
call this function again later to receive further message portions; data
is @strong{not} immediately available on the input port.

@item
Return @false{} if neither a message terminator, nor @eof{}, nor a
would--block is read.  In this case we need to call this function again
later to receive further message portions; data may be immediately
available on the input port.

@item
If, upon entering this function, the message is not terminated and the
delivery timeout is expired or expires while receiving data: raise a
non--continuable exception with compound condition object of types:
@condition{who}, @condition{message}, @condition{channel},
@condition{delivery-timeout-expired}.

@item
If reading data causes the accumulated message to exceed the maximum
size configured for this message: raise a non--continuable exception
with compound condition object of types: @condition{who},
@condition{message}, @condition{channel},
@condition{maximum-message-size-exceeded}.
@end itemize
@end defun

@c ------------------------------------------------------------

@defun channel-recv-full-message @var{chan}
Attempt to receive a full message through @var{chan}; the channel must
be inactive.  Return a string or bytevector representing the channel or
the @eof{} object if the channel connection is closed before a message
terminator is read.

If an error occurs while receiving a message portion: @var{chan} is left
in the state it is left by @func{channel-recv-message-portion!}.
@end defun

@c page
@node net channels send
@subsection Sending a message


The following bindings are exported by the library @library{vicare net
channels}.


@defun channel-send-begin! @var{chan}
Configure a channel to start sending a message; return unspecified
values.  @var{chan} must be an output or input/output channel; it is an
error if the channel is not inactive.
@end defun


@defun channel-send-end! @var{chan}
Finish sending a message by flushing the connect port and return the
total number of octets or characters sent.  It is an error if the
channel is not in the course of sending a message.

After this function is applied to a channel: the channel itself is
configured as inactive; so it is available to start receiving another
message or to send a message.
@end defun


@defun channel-send-message-portion! @var{chan} @var{portion}
Send a portion of output message through the given channel; return
unspecified values.  It is an error if the channel is not in the course
of sending a message.

For binary channels: @var{portion} must be a bytevector representing the
message portion.  For textual channels: @var{portion} must be a string
representing the message portion.

This function does not flush the connection port.

If at the time of this function call the timeout configured for this
message is expired: a non--continuable exception is raised with compound
condition object of types: @condition{who}, @condition{message},
@condition{channel}, @condition{delivery-timeout-expired}.

If writing @var{portion} would cause the total message size to exceed
the maximum size configured for this message: a non--continuable
exception is raised with compound condition object of types:
@condition{who}, @condition{message}, @condition{channel},
@condition{maximum-message-size-exceeded}.
@end defun

@c ------------------------------------------------------------

@defun channel-send-full-message @var{chan} @var{message-portion} @dots{}
Attempt to send a full message through @var{chan}; the channel must be
inactive.  Each @var{message-portion} is sent in the given order.

Return the return value of the internal call to
@func{channel-send-end!}.  If an error occurs while sending a message
portion: @var{chan} is left in the state it is left by
@func{channel-send-message-portion!}.
@end defun

@c page
@node net channels conditions
@subsection Condition object types


Whenever an error condition happens: the functions of the library
@library{vicare net channels} react by raising non--continuable exceptions
whose raised objects are compound conditions of the following types.

The following bindings are exported by the library @library{vicare net
channels}.

@c ------------------------------------------------------------

@subsubheading Channel condition type


@deftp {Condition Type} &channel
Condition object containing an instance of @code{channel}; it is derived
from @condition{condition}.
@end deftp


@defun make-channel-condition @var{chan}
Build and return an instance of @condition{channel} wrapping the channel
@var{chan}.
@end defun


@defun channel-condition? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{channel} or a compound condition object with a component of
type @condition{channel}.
@end defun


@defun condition-channel @var{cond}
Given an instance of @condition{channel}: return the @code{channel}
instance it contains.
@end defun

@c ------------------------------------------------------------

@subsubheading Delivery timeout error


@deftp {Condition Type} &delivery-timeout-expired
Condition object used to tag exceptions as of type ``message delivery
timeout expired''; it is derived from @condition{error}.
@end deftp


@defun make-delivery-timeout-expired-condition
Build and return an instance of @condition{delivery-timeout-expired}.
@end defun


@defun delivery-timeout-expired-condition? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{delivery-timeout-expired} or a compound condition object with
a component of type @condition{delivery-timeout-expired}.
@end defun

@c ------------------------------------------------------------

@subsubheading Message size error


@deftp {Condition Type} &maximum-message-size-exceeded
Condition object used to tag exceptions as of type ``maximum message
size exceeded; it is derived from @condition{error}.
@end deftp


@defun make-maximum-message-size-exceeded-condition
Build and return an instance of
@condition{maximum-message-size-exceeded}.
@end defun


@defun maximum-message-size-exceeded-condition? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{maximum-message-size-exceeded} or a compound condition object
with a component of type @condition{maximum-message-size-exceeded}.
@end defun

@c end of file
