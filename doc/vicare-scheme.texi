\input texinfo.tex
@c %**start of header
@setfilename vicare-scheme.info
@settitle Vicare Scheme
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Vicare specific macros.
@c ------------------------------------------------------------

@macro asciiz{}
@acronym{ASCIIZ}
@end macro

@macro bub{}
@acronym{BUB}
@end macro

@macro cif{}
@acronym{CIF}
@end macro

@macro cretwo{}
@acronym{CRE2}
@end macro

@macro eol{}
@acronym{EOL}
@end macro

@macro fasl{}
@acronym{FASL}
@end macro

@macro fifo{}
@acronym{FIFO}
@end macro

@macro ikptr{}
@code{ikptr}
@end macro

@macro oob{}
@acronym{OOB}
@end macro

@macro os{}
@acronym{OS}
@end macro

@macro pcb{}
@acronym{PCB}
@end macro

@macro retwo{}
@acronym{RE2}
@end macro

@macro sel{}
@acronym{SEL}
@end macro

@macro urldate{DATE}
(@acronym{URL} last verified \DATE\)
@end macro

@macro void{}
@code{#<void>}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set PRJNAME                    Vicare

@set TITLE                      Vicare Scheme

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Vicare Scheme

@c To be used as @value{PACKAGE_NICKNAME} whenever we need to include
@c the nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           vicare-scheme

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Abdulaziz Ghuloum

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{aghuloum@@cs.indiana.edu}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2010-2012


@set TARBALLURL                 @url{http://github.com/marcomaggi/vicare/downloads}
@set REPOSITORYURL              @url{http://github.com/marcomaggi/vicare/}
@set EXECUTABLE                 @command{vicare}
@set RAWEXECUTABLE              vicare

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @value{VERSION} of @value{PACKAGE}, an
@rnrs{6} compliant native compiler for the Scheme language, producing
single threaded programs running on Intel x86 32-bit processors, with
experimental support for 64-bit machines.  @emph{Vicare} is pronounced
the etruscan way.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://code.google.com/p/vicare-scheme/}

@noindent
or:

@center @url{http://github.com/marcomaggi/vicare/downloads}

@noindent
the home page of the project is at:

@center @url{http://marcomaggi.github.com/vicare.html}

@noindent
development takes place at:

@center @url{http://github.com/marcomaggi/vicare/}

@noindent
and, as a backup, at:

@center @url{http://gitorious.org/vicare}

@noindent
this project has a mailing list:

@center @url{http://groups.google.com/group/vicare-users}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by Marco Maggi.@*
Copyright @copyright{} 2006-2010 by Abdulaziz Ghuloum.

This document is derived from the original Ikarus documentation by the
@value{PACKAGE} contributors.

@quotation
This program is free software: you can redistribute it and/or modify it
under the terms of the @gnu{} General Public License version 3 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the @gnu{} General Public License
along with this program.  If not, see
@url{http://www.gnu.org/licenses/}.
@end quotation

Trademarks used herein are the property of their respective owners.
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* vicare: (vicare).             @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore


@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of Vicare Scheme.
* using::                       Using the program.
* iklib::                       Language extensions.
* ffi::                         Foreign functions interface.
* posix::                       The @posix{} interface.
* glibc::                       The @gnu{} C Library interface.
* linux::                       The @gnu{}+Linux interface.
* syslib::                      Low level, fast, unsafe operations.
* capi::                        C language programming interface.
* libs::                        Other libraries.

Internals

* objects::                     Built in Scheme objects.
* debug int::                   Debug mode.
* compiler::                    Wild notes on the compiler internals.

Appendices

* missing::                     Missing Features.
* building::                    Building infrastructure.
* credits::                     Credits for this document.
* unicode::                     On Unicode and @utf{} encodings.
* fasl::                        Handling @fasl{} files.
* shmem::                       Interprocess shared memory.
* binfmt::                      Launching programs directly.
* cre2::                        Binding to the library @cretwo{}.
* Package License::             @gnu{} General Public License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

External documents

* libffi: (libffi).             Libffi documentation.

@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of Vicare Scheme


Scheme is a statically scoped and properly tail--recursive dialect of
the Lisp programming language invented by Guy Lewis Steele Jr.  and
Gerald Jay Sussman.  It was designed to have an exceptionally clear and
simple semantics and few different ways to form expressions.

The ``Revised^6 Report on the Algorithmic Language Scheme'' (@rnrs{6})
gives a defining description of the programming language Scheme.  The
report is the work of many people in the course of many years; revision
6 was edited by Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton
Van Straaten.

Ikarus Scheme is an almost @rnrs{6} compliant implementation of the
Scheme programming language; it is the creation of Abdulaziz Ghuloum.

Vicare Scheme is an @rnrs{6} compliant fork of Ikarus Scheme, aiming at
becoming a native compiler producing single threaded programs running on
Intel x86 32-bit processors, with experimental support for 64-bit
machines.  @emph{Vicare} is pronounced the etruscan way.

@menu
* overview original::           Original Ikarus Scheme.
* overview tech::               Technology overview.
* overview resources::          Resources.
* overview system::             System requirements.
* overview install::            Installation and uninstallation.
* overview restrictions::       Implementation restrictions.
* overview extensions::         Implementation extensions.
* overview repl::               The read-eval-print loop.
* overview foreign::            Built in interface to external
                                libraries.
@end menu

@c page
@node overview original
@section Original Ikarus Scheme


The original Ikarus Scheme package is distributed under the terms of the
@gnu{} General Public License (@gpl{}) and can be downloaded from:

@center @url{http://www.ikarus-scheme.org/}

@noindent
or:

@center @url{https://launchpad.net/ikarus}

It was developed by Abdulaziz Ghuloum until the beginning of year 2010;
at that time the Vicare fork was started.

@c page
@node overview tech
@section Technology overview


@value{PRJNAME} Scheme provides the programmer with many advantages:

@table @strong

@item Optimizing code generator
The compiler's backend employs state of the art technologies in code
generation that produce fast, efficient, machine code.  When developing
computationally intensive programs, one is not constrained by using a
slow interpreter.

@item Fast incremental compilation
Every library and script is quickly compiled to native machine code.
When developing large software, one is not constrained by how slow the
batch compiler runs.

@item Robust and fine--tuned standard libraries
The standard libraries are written such that they perform as much error
checking as required to provide a safe and fast runtime environment.

@item Multi--generational garbage collector
The BiBOP based garbage collector used in @value{PRJNAME} allows the runtime
system to expand its memory footprint as needed.  The entire 32-bit
virtual address space could be used and unneeded memory is released back
to the operating system.

@item Supports many operating systems
@value{PRJNAME} runs on the most popular and widely used operating systems for
servers and personal computers.  The supported systems include Mac OS X,
@gnu{}+Linux, FreeBSD, NetBSD, and Microsoft Windows (under Cygwin).
@end table

@c page
@node overview resources
@section Resources


The @value{PACKAGE} package is distributed under the terms of the @gnu{}
General Public License (@gpl{}) and can be downloaded from:

@center @value{TARBALLURL}

@noindent
the home page of the project is at:

@center @url{http://marcomaggi.github.com/vicare.html}

@noindent
development takes place at:

@center @value{REPOSITORYURL}

Newcomers to Scheme should refer to @url{http://@/www.schemers.org},
which contains listings of tutorials and books that are helpful in
learning the language.

This document is a supplement to the @emph{Revised^6 Report on the
Algorithmic Language Scheme}, found at @url{http://@/www.r6rs.org}.
Kent Dybvig's @emph{The Scheme Programming Language}, Fourth Edition, is
an excellent tutorial and reference for @rnrs{6}.  Some extended
features of @value{PRJNAME} have been inspired by similar features in
@emph{Chez Scheme}; the @emph{Chez Scheme User's Guide} can be found at
the same site.

@c page
@node overview system
@section System requirements


To run @value{PACKAGE}, we will need a system with a relatively recent
Intel @emph{x86} processor; @value{PRJNAME} requires a Unix/Linux
operating system (or emulation), and some prerequisite libraries.

@menu
* overview system hardware::    Hardware requirements.
* overview system software::    Software requirements.
@end menu

@c page
@node overview system hardware
@subsection Hardware requirements


@value{PACKAGE} runs on the IA-32 (@emph{x86}) architecture supporting
@acronym{SSE2} extensions.  This includes the Athlon 64, Sempron 64, and
Turion 64 processors from @acronym{AMD} and the Pentium 4, Xeon,
Celeron, Pentium M, Core, and Core2 processors from Intel.  The system
does not run on Intel Pentium III or earlier processors.

The @value{PRJNAME} compiler generates @acronym{SSE2} instructions to
handle Scheme's @acronym{IEEE} floating point representation
(@emph{flonums}) for inexact numbers.


@subsubheading Operating systems

@value{PRJNAME} is tested under the following operating systems; in
general, any later version of one of these systems should be usable:

@itemize
@item
Mac OS X version 10.4 and 10.5.

@item
Linux 2.6.18 (Debian, Fedora, Gentoo, and Ubuntu).

@item
FreeBSD version 6.2.

@item
NetBSD version 3.1.

@item
Microsoft Windows XP, using Cygwin 1.5.24 (@url{http://@/cygwin.org}).
@end itemize

@c page
@node overview system software
@subsection Software requirements


We will need some additional libraries and tools to build
@value{PACKAGE}.

@table @strong
@item GMP
@value{PRJNAME} uses the @gnu{} Multiple Precision Arithmetic Library
(@gmp{}) for some bignum arithmetic operations.  To build
@value{PRJNAME} from scratch, @gmp{} version 4.2 or better must be
installed along with the required header files.  Pre--built @gmp{}
packages are available for most operating systems.  Alternatively,
@gmp{} can be downloaded from @url{http://@/gmplib.org/}.

The @gmp{} web page points out that @gmp{} has revealed subtle bugs in
many C compilers.  Although the @gmp{} build process includes a
comprehensive self--test (which we absolutely must run if building it
ourselves), we may still prefer to obtain a prebuilt binary version for
our system, if one is available.

@quotation
@strong{NOTE} @value{PRJNAME} runs in 32-bit mode only.  To run it in
64-bit environments, we will have to obtain the 32-bit version of
@gmp{}, or compile it ourselves after adding @code{ABI=32} to its
configuration options.
@end quotation

@item libffi
We will probably need @code{libffi}, a C library that simplifies
run--time calls to arbitrary C functions.  @value{PRJNAME} will operate
without @code{libffi}, but will not be able to call foreign procedures
(those written in C).  @code{libffi} can be downloaded from
@url{http://@/sourceware.org/@/libffi}.

@item GCC
The @gnu{} C Compiler is required to build the @value{PRJNAME}
executable (e.g. the garbage collector, loader, and OS--related
runtime).  @gcc{} versions 4.1 and 4.2 were successfully used to build
@value{PRJNAME}.  It may be possible to build @value{PRJNAME} using
other C compilers.

@item Autoconf and Automake
The @gnu{} Autoconf (version 2.61) and @gnu{} Automake (version 1.10)
tools are required if one wishes to modify the @value{PRJNAME} source
base.  They are not required to build the official release of
@value{PRJNAME}.

Prebuilt packages for these tools have been created for most Unix/Linux
systems; if we prefer, we can download the source code from
@url{http://@/www.gnu.org/@/software/@/autoconf} and
@url{http://@/www.gnu.org/@/software/@/automake} respectively, and build
them ourselves.

@item Texinfo
This document is provided in Texinfo format.  Texinfo is available as an
installable package for most Unix/Linux systems.  Alternatively, we can
download the source package
@url{http://@/www.gnu.org/@/software/@/texinfo}.
@end table

@c page
@node overview install
@section Installation and uninstallation


@cindex Installing @value{PRJNAME}
@cindex Uninstalling @value{PRJNAME}
@cindex Disinstalling @value{PRJNAME}
@cindex @value{PRJNAME}, installing
@cindex @value{PRJNAME}, uninstalling
@cindex @value{PRJNAME}, disinstalling


There are two ways to install @value{PACKAGE} on our system: we can
either install a prebuilt package, if one is available for our operating
system, or we can build it from source.  There are two reasons to prefer
the ``build from source'' approach: first, not all Unix/Linux package
repositories have an @value{PACKAGE} package at all; second, prebuilt
packages often lag current revisions to the system by a considerable
amount.  Therefore, the version we install from a package repository
might not even have some of the features documented in this manual.

We will assume in this section that we are building @value{PACKAGE}
ourselves.  @value{PRJNAME} uses the standard installation method found
in most other Unix software.  Thus we will follow the usual steps.

@enumerate
@item
Download the software.

@item
Set configuration options.

@item
Build and install
@end enumerate

@menu
* overview install quick::              Quick installation guide.
* overview install prerequisites::      Installing the prerequisites.
* overview install details::            Installation details.
* overview install uninstall::          Uninstalling @value{PRJNAME}.
@end menu

@c page
@node overview install quick
@subsection Quick installation guide


If familiar with installing Unix software on our system, then all we
need to know is that @value{PRJNAME} uses the standard installation
method found in most other Unix software.  Simply run the following
commands from the shell:

@example
$ tar -xvzf vicare-n.n.n.tar.gz
$ cd vicare-n.n.n
$ ./configure [--prefix=path] [CFLAGS=-I/dir] [LDFLAGS=-L/dir]
$ make
$ make install
@end example

@noindent
@ref{overview install details} for how to enable the foreign functions
interface.

After installation, under the directory
@code{$libexecdir/vicare-scheme}, scripts with names like
@file{compile-all.sps} can be executed to precompile the installed
libraries; for example:

@example
$ sudo vicare --compile-dependencies \
   /usr/local/libexec/vicare-scheme/compile-all.sps
@end example

To uninstall @value{PACKAGE}, use the following steps:

@example
$ cd path/to/vicare-n.n.n
$ make uninstall
@end example

The rest of this section gives more detail on building, installing, and
uninstalling @value{PACKAGE}.

@c page
@node overview install prerequisites
@subsection Installing the prerequisites


The first step is to ensure that we have @gmp{} and Libffi installed; we
should generally use our system's package manager for these.  Note where
the include (@code{.h}) and library (@code{.a}) files for each of these
packages are installed.  (Typically this will be in either
@file{/usr/@/include} and @file{/usr/@/lib}, or
@file{/usr/@/local/@/include} and @file{/usr/@/local/@/lib}.)

If we choose to download these as source and build them ourselves, refer
to the installation instructions found in each package.  If we are
installing @gmp{} from source, it is @emph{essential} that we run the
self--tests after building, and verify that no errors were detected.  We
do this by issuing the command @command{make check}; see the
documentation for details.

@c page
@node overview install details
@subsection Installation details


We have two choices for downloading the @value{PACKAGE} source: we can
either download a distribution from:

@center @value{TARBALLURL}

@noindent
or we can checkout a revision from the GitHub repository:

@center @value{REPOSITORYURL}

@itemize
@item
@value{PACKAGE} source distributions are tarballs named
@file{vicare-@-@var{@var{n.n.n}}.tar.gz}, where @file{@var{n.n.n}} is a
3--component ID indicating the current revision.

If we downloaded a distribution, unpack it.  From the shell prompt:

@example
$ tar -xvzf vicare-@var{n.n.n}.tar.gz
@end example

@noindent
this creates the base directory @file{vicare-@var{n.n.n}}.

@item
If we downloaded a bleeding--edge snapshot, no unpacking is needed.
@end itemize

We configure the build system by running the @command{configure} script
located in the base directory.  To do this, type the following commands:

@example
$ cd vicare-@var{n.n.n}
$ ./configure
checking build system type... i386-apple-darwin8.10.1
checking host system type... i386-apple-darwin8.10.1
...
configure: creating ./config.status
config.status: creating Makefile
config.status: creating src/Makefile
config.status: creating scheme/Makefile
config.status: creating doc/Makefile
config.status: executing depfiles commands
@end example

This configures the system to be built then installed in the
system--wide location (binaries are normally installed in
@file{/usr/@/local/@/bin}).  To install it in another location (e.g. in
your home directory), provide a @option{--prefix} location to
@command{configure} as follows:

@example
$ ./configure --prefix=/opt/sw
@end example

@noindent
this will install the executable in @file{/opt/@/sw/@/bin}, libraries in
@file{/opt/@/sw/@/lib/@/ikarus}, and documentation in
@file{/opt/@/sw/@/share/@/doc/@/ikarus}.

To install @value{PACKAGE} for personal use (thus not requiring root
permissions to install), specify @code{--prefix=$HOME/local}, which
installs everything in a @file{local} directory of our home directory.

@command{configure} allows us to fine--tune where things are installed,
though this is rarely necessary or useful.  Do
@code{./configure@tie{}--help} for a full list of options.

The most common @command{configure} options are as follows.

@table @asis
@item @option{--prefix}
Specify the location in the file system where @value{PACKAGE} will be
installed.

@item @option{--enable-ffi}
Include @value{PACKAGE}'s Foreign Function Interface, so that
@value{PRJNAME} code can invoke C code, and vice versa; requires Libffi.

@item @option{--disable-arguments-validation}
Disable arguments validation for the functions in Vicare's boot image;
use with care: an invalid argument will cause undefined behaviour (most
likely a process crash).

@item @env{CFLAGS}
Specify options to be used while compiling @value{PRJNAME}'s C code.

@item @env{CPPFLAGS}
Specify options to be used while preprocessing @value{PRJNAME}'s C code.

@item @env{LDFLAGS}
Specify options to be used while linking @value{PRJNAME}.
@end table

@command{configure} will fail if it cannot find the location where
@gmp{} is installed.  The script will also fail if we have specified
@option{--enable-ffi} and it can't find Libffi.  If running
@command{configure} fails to locate either of these libraries, we will
need to provide their locations.  Use the @env{CPPFLAGS} and
@env{LDFLAGS} options to specify the locations of the header and library
files.

For example, assume that we have installed @gmp{} and Libffi in
subdirectories of @file{/opt/sw}, and we wish to support foreign
functions.@footnote{The @command{configure} command shown here is very
imposing, and anyone can easily make mistakes.  In general, it's a good
idea to create a shell script that has the sequence of
@command{configure} and @command{make} commands needed to configure,
build, and install a package; this not only allows us to re--install
easily, but also gives us a concrete indication of what options we used
to build the software the last time.  Of course, we should put this
script somewhere other than in the actual @value{PRJNAME} software
directory!}

@example
./configure                                                  \
  --prefix=$HOME/local                                       \
  --enable-ffi                                               \
  CPPFLAGS="-I/opt/sw/gmp/include -I/opt/sw/libffi/include"  \
  LDFLAGS="-L/opt/sw/gmp/lib -L/opt/sw/libffi/lib"
@end example

We can use the @env{CFLAGS} and @env{LDFLAGS} variables to select more
specialized compilation and linking options; refer to the compiler
documentation for more details.

We can now build the system by running the command @command{make}, with
no arguments; this performs two tasks:

@enumerate
@item
It builds the @command{vicare} executable from the C files located in
the @file{src} directory.

@item
It uses the @command{vicare} executable and the pre--built
@file{ikarus.boot.orig} boot file to rebuild the Scheme boot image file
@file{vicare.boot} from the Scheme sources located in the @file{scheme}
directory.
@end enumerate

The final stage is to install @value{PRJNAME} via the command
@command{make install}.  If we're installing @value{PRJNAME} in a
system--wide location, we probably need to have administrator privileges
(use the @command{sudo} or @command{su} commands); if that's not
feasible, then we need to reconfigure to install within a directory tree
under our home directory.

Finally, try a small session, to verify that everything installed
properly.

@example
$ vicare
Vicare Scheme version 0.1d0+ \
  (revision master/d844c006eb9ada1a047be3893d0dd40f8ae6204a, \
  build 2010-05-02)
Copyright (c) 2006-2010 Abdulaziz Ghuloum and contributors

> (display "hello, world!\n")
hello, world!
> (define twice (lambda (f) (lambda (x) (f (f x)))))
> ((twice add1) 3)
5
@end example

If we get the first @code{>} prompt, then @value{PRJNAME} was
successfully installed on the system.  We may need to update the
@env{PATH} variable in environment to contain the directory in which the
@command{vicare} executable was installed.

Finally, do @command{make clean} to get rid of executables, object
files, and other build products in the @file{vicare-@var{n.n.n}}
directory.  Do not delete the directory itself: it will be needed if we
ever want to uninstall @value{PRJNAME}.

After installation, under the directory
@code{$libexecdir/vicare-scheme}, scripts with names like
@file{compile-all.sps} can be executed to precompile the installed
libraries; for example:

@example
$ sudo vicare --compile-dependencies \
   /usr/local/libexec/vicare-scheme/compile-all.sps
@end example

@c page
@node overview install uninstall
@subsection Uninstalling @value{PRJNAME}


@cindex @value{PRJNAME}, uninstalling
@cindex @value{PRJNAME}, disinstalling
@cindex Disinstalling @value{PRJNAME}
@cindex Uninstalling @value{PRJNAME}


To uninstall @value{PACKAGE}, go to the directory we built
@value{PRJNAME} in (not the directory where you installed it), and do
@command{make uninstall}.

@example
$ cd path/to/vicare-@var{n.n.n}
$ make uninstall
@end example

@c page
@node overview restrictions
@section Implementation restrictions


Here is a list of implementation constraints which may be non--compliant
with @rnrs{6}.

@enumerate
@item
Scheme strings can hold at most @code{(greatest-fixnum)} characters; the
length of a string and all the valid indexes into strings are
representable as fixnums.

@item
Scheme bytevectors can hold at most @code{(greatest-fixnum)} bytes; the
length of a bytevector and all the valid indexes into bytevectors are
representable as fixnums.

@item
The last argument to @func{apply} can be a list of at most @math{8192}
values.  This is an artificially set limit to avoid problems with huge
values (it could be greater than this).  As comparison: LispWorks for
Unix sets this value to 300, LispWorks for Windows and LispWorks for
Linux set this value to 255 (last verified from its online documenattion
in November, 2011).
@end enumerate

@c page
@node overview extensions
@section Implementation extensions


Here is a list of implementation extensions which may be non--compliant
with @rnrs{6}.

@enumerate
@item
According to @rnrs{6}: if the parent of a record type has a custom
protocol function, the record type itself must have a custom protocol
function; that is:

@example
(import (rnrs))

(define-record-type alpha
  (fields a)
  (protocol (lambda (A) ---)))

;; this is good
(define-record-type beta
  (parent alpha)
  (fields b)
  (protocol (lambda (A B) ---)))

;; this is bad according to R6RS!!!
(define-record-type gamma
  (parent alpha)
  (fields b))
@end example

This restriction is violated by @value{PRJNAME}, which allows the
following:

@example
(import (rnrs))

(define-record-type alpha
  (fields a)
  (protocol (lambda (A) ---)))

;; this is good in Vicare!!!
(define-record-type beta
  (parent alpha)
  (fields b))
@end example

@noindent
@value{PRJNAME} just expects the parent protocol function to have the
same interface of a default protocol function.

@item
The syntax @func{define-record-type} automatically generates unsafe
field accessor and mutator syntaxes; in the following example:

@example
(define-record-type color
  (fields (mutable red)
          (mutable green)
          (mutable blue)))
@end example

@noindent
in addition to the safe accessor and mutator definitions for:

@example
color-red           color-red-set!
color-green         color-green-set!
color-blue          color-blue-set!
@end example

@noindent
unsafe accessors and mutator definitions for:

@example
$color-red          $color-red-set!
$color-green        $color-green-set!
$color-blue         $color-blue-set!
@end example

@noindent
are generated with code like:

@example
(define-syntax $color-red
  (syntax-rules ()
    ((_ x)
     ($struct-ref x 0))))

(define-syntax $color-red-set!
  (syntax-rules ()
    ((_ x v)
     ($struct-set! x 0 v))))
@end example

Notice that the name of the unsafe accessors and mutators is always
built from the field name, @strong{not} from the custom names given in
the definition; for example:

@example
(import (rnrs))

(define-record-type color
  (fields (mutable red   the-red   set-the-red!)
          (mutable green the-green set-the-green!)
          (mutable blue  the-blue  set-the-blue!)))

(define X
  (make-color 1 2 3))

(define Y
  (make-color 1 2 3))

(set-the-red!   X 10)
(set-the-green! X 20)
(set-the-blue!  X 30)
(list (the-red   X)
      (the-green X)
      (the-blue  X)))
@result{} (10 20 30)

($color-red-set!   Y 10)
($color-green-set! Y 20)
($color-blue-set!  Y 30)
(list ($color-red   Y)
      ($color-green Y)
      ($color-blue  Y)))
@result{} (10 20 30)
@end example
@end enumerate

@c page
@node overview repl
@section The read-eval-print loop


Scheme implementations compliant with @rnrs{6} live in a somewhat uneasy
tension with a standard Scheme @acronym{REPL} (read--eval--print loop),
which the Report effectively does not define.

In particular, the effect of reimporting a module, as you might do when
reloading and rerunning a program, isn't well--defined by @rnrs{6}.
This is a limitation caused by the particular design choices made in
@rnrs{6}.

Accordingly, the interactive mode is intended for quick experimenting
with the built in features.  It is intended neither for developing
applications nor for writing any substantial piece of code.

@c page
@node overview foreign
@section Built in interface to external libraries


@value{PRJNAME} comes with some interface to external libraries built
into the @value{EXECUTABLE} C language executable itself; this is done
only for some particular libraries which especially benefit from a
dedicated interface inconvenient to implement with the @ffi{}.  At the
Scheme level the @api{} is exported by libraries @strong{not} included
in @value{PRJNAME}'s boot image.

Such interfaces are excluded by default, they must be explicitly
requested at installation--time with command line options for the
@command{configure} script.

@menu
* overview foreign readline::   Interface to @gnu{} Readline.
* overview foreign cre2::       Interface to @cretwo{}.
@end menu

@c page
@node overview foreign readline
@subsection Interface to @gnu{} Readline


@gnu{} Readline is a library implementing advanced command line editing
features for programs providing a @repl{} interface.  When given the
@option{--with-readline} configuration option, the @command{configure}
script will search for @gnu{} Readline or a compatible library and, if
found, the interface will be enabled.  @ref{iklib readline} for the
@api{} documentation.

The home page of @gnu{} Readline is at:

@center @url{http://www.gnu.org/software/readline/}

@noindent
a compatible alternative is Editline:

@center @url{http://www.s11n.net/editline/}

@noindent
and another possible replacement is Libedit:

@center @url{http://sourceforge.net/projects/libedit/}

@c page
@node overview foreign cre2
@subsection Interface to @cretwo{}


@cretwo{} is a C language wrapper for the @retwo{} library, which is
implemented in C++.  @retwo{} is a fast, safe, thread--friendly
alternative to backtracking regular expression engines like those used
in PCRE, Perl, and Python; it is a Google project found at:

@center @url{http://code.google.com/p/re2/}

@noindent
while @cretwo{} is available at:

@center @url{http://github.com/marcomaggi/cre2/}

@value{PRJNAME} interface to @cretwo{} can be included at package
configuration time by giving the @option{--with-cre2} option to the
@command{configure} script.  @ref{cre2} for the @api{} documentation.

@c page
@node using
@chapter Using @value{PRJNAME}


Once @value{PACKAGE} is properly installed, we can invoke it either in
an interactive terminal session or as the interpreter for invoking a
script.

@cindex Command line
@cindex Invoking @value{PRJNAME}

@menu
* using interactive::           Interactive sessions.
* using invoking::              Command line arguments.
* using script::                Using @command{scheme-script}.
* using libraries::             @rnrs{6} libraries.
* using rlwrap::                Using @command{rlwrap}.
* using binfmt::                Launching programs on Linux.
@end menu

@c page
@node using interactive
@section Interactive sessions


If we want an interactive session, use a bare @value{EXECUTABLE}
command, with no options.

@example
$ @value{RAWEXECUTABLE}
Vicare Scheme version 0.1d0+ \
  (revision master/d844c006eb9ada1a047be3893d0dd40f8ae6204a, \
   build 2010-05-02)
Copyright (c) 2006-2010 Abdulaziz Ghuloum and contributors

> (+ 2 2)
4
@end example

@noindent
end--of--file (@key{Ctrl-D} in a typical terminal window) will terminate
the session.

@c page
@node using invoking
@section Command line arguments


The synopsis of the @value{EXECUTABLE} program is as follows:

@smallexample
@value{RAWEXECUTABLE} [@var{OPTIONS}] [PROGRAM]                      [-- [@var{PROGRAM OPTS}]]
@value{RAWEXECUTABLE} [@var{OPTIONS}] --r6rs-script PROGRAM          [-- [@var{PROGRAM OPTS}]]
@value{RAWEXECUTABLE} [@var{OPTIONS}] --r6rs-repl PROGRAM            [-- [@var{PROGRAM OPTS}]]
@value{RAWEXECUTABLE} [@var{OPTIONS}] --script CODE                  [-- [@var{PROGRAM OPTS}]]
@value{RAWEXECUTABLE} [@var{OPTIONS}] --compile-dependencies PROGRAM [-- [@var{PROGRAM OPTS}]]
@end smallexample

@noindent
the @var{OPTIONS} are interpreted by @value{EXECUTABLE}, @var{PROGRAM
OPTS} can be obtained using the @func{command-line} procedure in the
@library{rnrs programs} library; when running the @repl{}: the first
element of the returned list will be the string @samp{*interactive*},
corresponding to the script name in @rnrs{6}--script mode.

Some options cause code to be evaluated in the interaction environment:
it initially contains all the bindings exported from the
@library{ikarus} library.

The @value{EXECUTABLE} executable recognises a few command line switches
that influence how @value{PACKAGE} starts; the following are the main
options, driving the execution mode.  It is an error to put on the
command line two or more of these options.

@table @code
@item --r6rs-script @var{PROGRAM}
Start Vicare in @rnrs{6}--script mode.  The @var{PROGRAM} file is handled
as an @rnrs{6} program.  Example:

@example
$ cat test.sps
(import (rnrs))
(write (command-line))
(newline)

$ @value{RAWEXECUTABLE} --r6rs-script test.sps hi there
("test.sps" "hi" "there")
@end example

@item --r6rs-repl @var{PROGRAM}
Start Vicare in @rnrs{6}-script mode.  Act as if the
@option{--r6rs-script} option had been used but, after the program
execution, enter the @repl{} rather than exiting.  This allows
inspection of bindings and state left behind by the program.

@item --script @var{CODEFILE}
Start Vicare in evaluation mode.  The @var{CODEFILE} is handled as a
sequence of @rnrs{6} expressions: such expressions are used as first
argument for @func{eval} under the interaction environment.  Example:

@example
$ cat test.sps
(write (command-line))
(newline)

$ @value{RAWEXECUTABLE} --script test.sps hi there
("test.sps" "hi" "there")
@end example

@item --compile-dependencies @var{IMPORTS-FILE}
Load the @rnrs{6} program @var{IMPORTS-FILE}, compile all the libraries
upon which it depends and store them in the FASL repository.
@var{IMPORTS-FILE} itself is not evaluated.
@end table

When none of these options is given, but a standalone @var{PROGRAM}
argument is present on the command line: act as if the
@option{--r6rs-script} option had been used with the given file name.
If no standalone @var{PROGRAM} argument is present: enter the @repl{}.

The rest of the command line arguments are recognised by the standard
Scheme run time system.

@table @code
@item -b path/to/boot/file.boot
@itemx --boot path/to/boot/file.boot
Use the specified boot file as the initial system boot file.  The boot
file is a binary file that contains all the code and data of the Scheme
system.  In the absence of the @option{-b} flag, the executable will use
the default boot file.  Running @value{EXECUTABLE} with the @option{-h}
option shows the location where the default boot file was installed.

@item --no-rcfile
Disable loading of run--command files.

@item --rcfile @var{FILE}
Load and evaluate @var{FILE} as an @rnrs{6} program at startup, before
loading libraries, evaluating codes and running the main script.  This
option can be used multiple times.

@item -l @var{LIBFILE}
@itemx --load-library @var{LIBFILE}
Load @var{libfile} expecting it to contain one or more @rnrs{6}
libraries; after executing the RC files, load the libraries in the
internal collection, but do not add them to any environment.  This
option can be used multiple times.

@item -f @var{CODEFILE}
@itemx --eval-file @var{CODEFILE}
Load @var{CODEFILE} expecting it to contain valid @rnrs{6} expressions;
after instantiating the libraries hand the code to @func{eval} under the
interaction environment.  Bindings left behind by this code are
available if we enter the @repl{}.  This option can be used multiple
times.

@item -e @var{EXPRESSION}
@itemx --eval-expr @var{EXPRESSION}
After instantiating the libraries hand the @var{EXPRESSION} to
@func{eval} under the interaction environment.  Bindings left behind by
this code are available if we enter the @repl{}. This option can be used
multiple times.

@item -L @var{DIRECTORY}
@itemx --search-path @var{DIRECTORY}
Add @var{DIRECTORY} to the library search path.  This option can be used
multiple times.

@item --fasl-path @var{DIRECTORY}
Add @var{DIRECTORY} to the @fasl{} search path.  This option can be used
multiple times.

@item --fasl-directory @var{DIRECTORY}
Select @var{DIRECTORY} as top pathname under which @fasl{} files are
stored when libraries are compiled; @var{DIRECTORY} must exist.  When
used multiple times: the last one wins.  The selected directory is
always prepended to the @fasl{} search path.

@item --more-file-extensions
Rather than searching only libraries with extension @samp{.vicare.sls}
and @samp{.sls}, search also for @samp{.vicare.ss}, @samp{.ss},
@samp{.vicare.scm}, @samp{.scm} and the @samp{main} file.  @ref{using
libraries searching} for more details.

@item --prompt @var{STRING}
Use @var{STRING} as prompt for the @repl{}.  Defaults to @samp{vicare},
to which the character @samp{>} is appended for each nested @repl{}
level.  @ref{iklib cafe} for more details.

@item --repl-on-sigint
When this option is used an interprocess signal handler is registered at
program startup to enter a debugging @repl{} whenever a @code{SIGINT}
signal is received.

@item --raw-repl
Do not create a readline console input port even if the readline
interface is available.

@item -d
@itemx --debug
Turn on debugging mode.  With this unhandled exceptions in the program
will result in starting the debugger, which allows stack trace
inspection.

@item -nd
@itemx --no-debug
Turn off debugging mode.

@item --print-loaded-libraries
Whenever a library file is loaded print a message on the console error
port.  This is for debugging purposes.

@item --no-print-loaded-libraries
Disables the effect of @option{--print-loaded-libraries}.

@item -O0
@itemx -O1
@itemx -O2
Turn on various levels of compile optimisations (currently unsupported).

@item --print-assembly
Print to the current error port the assembly instructions generated when
compiling code.

@item --print-optimizer
@itemx --print-optimiser
Print to the current error port a symbolic expression which results from
running the optimiser.

@item -V
@itemx --version
Display the version message then exit.

@item --version-only
Display only the version number on the standard error port, followed by
a newline, then exit.

@item --license
Display the license message then exit.

@item -h
@itemx --help
Display the help message then exit.

@item --
Mark the end of @value{EXECUTABLE} options; all the arguments after this
marker can be obtained by calling the @func{command-line} procedure.
@end table

@cindex @env{VICARE_RC_FILES}
If neither the @option{--no-rcfile} nor the @option{--rcfile} options
are used: a list of run--command files is read from the environment
variable @env{VICARE_RC_FILES}, which must contain a colon separated
list of pathnames.  If the enviroment variable is empty or unset, by
default the file @file{.vicarerc} is used searching it in the directory
selected by the @env{HOME} environment variable.

@c page
@node using script
@section Using @command{scheme-script}


Scheme scripts can be executed using the following command:

@example
@value{RAWEXECUTABLE} @var{PROGRAM}
@end example

@noindent
@value{PACKAGE} does @strong{not} follow the @rnrs{6} recommendations
and does not install a wrapper program called @command{scheme-script} to
avoid conflicts with other Scheme implementations.

Here is a sample script (Pig Latin---``Igpay Atinlay''---is a code that
was at one time popular among very young North American children).

@example
(import (rnrs))

;;; Convert a string to its Pig Latin equivalent.
;;;
;;; If the first character is a vowel, append "yay".
;;; "egg" -> "eggyay"
;;;
;;; If the first character is a consonant, remove it,
;;; and append it plus "ay" to the string.
;;; "foo" -> "oofay"

(define pig-latin
  (lambda (str)
    (let ((first (string-ref str 0)))
      (if (memv first '(#\a #\e #\i #\o #\u))
	  (string-append str "yay")
	  (string-append
 	    (substring str 1 (string-length str))
	    (string first) "ay")))))

(display
 (map pig-latin
     (cdr (command-line))))
(newline)
@end example

Assuming we have stored the script in the file @file{demo.sps}, we can
invoke this script via @value{EXECUTABLE}:

@example
$ @value{RAWEXECUTABLE} --r6rs-script demo.sps ice cream after dinner
(iceyay reamcay afteryay innerday)
@end example

On Unix/Linux systems, scripts generally start with a ``shebang'' line
(@emph{sh}arp plus @emph{bang}) which names an interpreter for the
script.  All modern systems have the @command{env} command which
searches for a command in the user's path.

@example
#!/usr/bin/env @value{RAWEXECUTABLE} --r6rs-script
(import (rnrs))

...
@end example

Now we can make the file executable, and use it directly.

@example
$ chmod +x demo.sps
$ ./demo.sps ice cream after dinner
(iceyay reamcay afteryay innerday)
@end example

There are a few fine points.

@itemize
@item
If the first two bytes of a script represent the sequence @samp{#!} in
@ascii{} encoding: the first line is discarded and not parsed as Scheme
code.  This allows scripts on Unix systems to start with the command
line needed to use them; notice that this will discard valid sharp--bang
comments (like @code{#!r6rs}) if the are at the very beginning of a
file.

@item
Under Mac OS X, if a script name ends with the @code{.command}
extension, then it can be executed from the Finder by double--clicking
on it.  This brings up a terminal window in which the script is
executed.  The @code{.command} extension can be hidden from the
@emph{Get Info} item from the Finder's File menu.
@end itemize

@c page
@node using libraries
@section @rnrs{6} libraries


A library exports features that can be imported into programs; a library
is named by a list, e.g., @library{yoyodyne
block-transfer-computations}.  The core features of the language is
provided in the library @library{rnrs}.

@menu
* using libraries intro::       Introduction to @value{PRJNAME} libraries.
* using libraries searching::   How @value{PRJNAME} finds libraries.
* using libraries summary::     Library search summary.
* using libraries examples::    Examples of libraries usage.
@end menu

@c page
@node using libraries intro
@subsection Introduction to libraries


A library consists of a ``file'' (some assemblage of text) that contains
a library form, which might look like this:

@example
(library (sample)
  (export cube)
  (import (rnrs))
  (define cube
    (lambda (x)
      (* x x x))))
@end example

@noindent
notice the @func{import} clause; libraries have no predefined namespace,
and therefore at least @library{rnrs} must be imported.

We can import @library{sample} into another library, a script, or a
@value{PRJNAME} top--level session:

@example
> (import (sample))
> (cube 3)
27
@end example

Library names are lists, thus allowing the writer of one or more
libraries to group related libraries together.  For example, as well as
@library{yoyodyne block-transfer-computations}, we might also have
@library{yoyodyne tardis navigation} and @library{yoyodyne tardis
diagnostics}.  Leaving the parentheses off a single--component library
name is a common error.

@c page
@node using libraries searching
@subsection How @value{PRJNAME} finds libraries


@findex library-path


In @value{PRJNAME}, a library is a file with the same name as the last
component of the library name.  For example, the library
@library{sample} will correspond to a file named @file{sample.sls}
somewhere in the file system.  The file extension @code{.sls} stands for
``Scheme library source''; although @value{PRJNAME} will also accept the
extensions @code{.ss} and @code{.scm} when the command line option
@option{--more-file-extensions} is used, these really indicate scripts
rather than libraries.

@value{PRJNAME} has a search algorithm for libraries that is similar to
those used in other languages.  @value{PRJNAME}'s search path comprises
a series of directories; when we try to import a library whose name
contains just one component, @value{PRJNAME} will examine each directory
in the search path for a file with a matching name.  Importing a library
whose name is a list of components causes @value{PRJNAME} to match to a
series of subdirectories with matching names.

Here is an example of each case:

@itemize
@item
Importing @library{sample} causes @value{PRJNAME} to look in each
directory on the path for a file named @file{sample.sls}.

@item
Importing @library{yoyodyne sample} causes @value{PRJNAME} to look in
each directory on the path for a directory named @file{yoyodyne}, and
within that a file named @file{sample.sls}.  The @func{library} form for
this library must still specify the library name as @library{yoyodyne
sample}, not @library{sample}.
@end itemize

@cindex @env{VICARE_LIBRARY_PATH}
@value{PRJNAME}'s own Scheme libraries are installed in the directory
@code{$(libdir)/scheme}, for example on @gnu{}+Linux systems
@file{/usr@//local@//lib@//scheme}, and are under the @code{(vicare
---)} hierarchy.  Additional libraries, and the boot image, are
installed in the directory @code{$(libdir)/vicare-scheme}.  User
libraries that are meant to be usable by @value{PRJNAME} should be
installed in the @code{$(libdir)/scheme} directory.

@value{PRJNAME} always places its own library directories at the end of
the search path, so, as example, the default value of the search path on
@gnu{}+Linux systems has the following directories:

@example
/usr/local/lib/scheme
/usr/local/lib/vicare-scheme
@end example

@noindent
other library directories can be added to the search path in two ways:
by modifying an environment variable, or by setting @value{PRJNAME}'s
@func{library-path} parameter.  @value{PRJNAME} consults the environment
variable @env{VICARE_LIBRARY_PATH} at the beginning of execution, and
places each of the directories there into its search path.  The search
path is then set to the value of the parameter @func{library-path},
which can be updated as necessary.

In the following example session: the user sets
@env{VICARE_LIBRARY_PATH}; the settings are reflected in the value of
@code{(library-path)}; a further directory is then set during the
session:

@example
$ export VICARE_LIBRARY_PATH=$HOME/scheme:/tmp/library
$ echo $VICARE_LIBRARY_PATH
/home/marco/scheme:/tmp/library
$ @value{RAWEXECUTABLE}
...

> (library-path)
("/home/marco/scheme"
 "/tmp/library"
 "/usr/local/lib/scheme"
 "/usr/local/lib/vicare-scheme")
> (library-path (cons "/opt/sw/extra-libraries" (library-path)))
> (library-path)
("/opt/sw/extra-libraries"
 "/home/marco/scheme"
 "/tmp/library"
 "/usr/local/lib/scheme"
 "/usr/local/lib/vicare-scheme")
@end example

In programs intended to be distributed, you should resist the urge to
set @code{(library-path)}, as the user's file hierarchies might not
match yours.  For most libraries, simply telling the user to install the
library in one of the libraries on the search path is good enough.

There are two refinements of the library search algorithm, which are
performed when the @option{--more-file-extensions} command line option
is used.

@itemize
@item
A common pattern is to distribute a main library along with a number of
additional extensions: we might have a main library named @library{lib},
and additional optional extensions named @library{lib extras} and
@library{lib frills}.

Although the previous packaging method can be used, @value{PRJNAME}
allows you to use a simpler technique where the main library is stored
in @file{lib/main.sls}, and the extensions are stored in
@file{lib/extras.sls} and @file{lib/frills.sls}, respectively.

@item
@value{PRJNAME} will also look in @file{lib/main.vicare.sls} before
trying @file{lib/main.sls}.  This allows you to provide a
@value{PRJNAME}--specific implementation as well as a generic
implementation.
@end itemize

@c page
@node using libraries summary
@subsection Library search algorithm summary


By default, @value{PRJNAME} attempts to import the library @library{a b
c} as follows, for each directory in the search path:

@enumerate
@item
Build the rootname @file{a/b/c}.

@item
Append each of the following strings to the rootname, in order, until a
matching file is found:

@example
.vicare.sls
.sls
@end example
@end enumerate

When the the command line option @option{--more-file-extensions} is
used, for each directory in the search path:

@enumerate
@item
Build the rootname @file{a/b/c}.

@item
Append each of the following strings to the rootname, in order, until a
matching file is found:

@example
/main.vicare.sls
/main.vicare.ss
/main.vicare.scm
/main.sls
/main.ss
/main.scm
.vicare.sls
.vicare.ss
.vicare.scm
.sls
.ss
.scm
@end example
@end enumerate

If there is no match, then the import request is in error.

Whenever the library name component @code{main} appears as last and not
unique component: when building the file rootname such component is
``quoted'' by appending an underscore character; examples:

@example
(alpha beta main)       @result{} "alpha/beta/main_"
(main alpha)            @result{} "main/alpha"
(main)                  @result{} "main"
@end example

@c page
@node using libraries examples
@subsection Examples of library usage


Consider a program using @func{pretty-print} procedure to format some
code, and suppose further that pretty printing is just a nice add--on
(e.g. using @file{write} suffices, but pretty--printing is @emph{just
prettier}).

@value{PRJNAME} exports a good pretty--printing facility in its
@library{ikarus} library.  However, since @func{pretty-print} is not a
standard procedure, a program that uses it would be rendered unportable
to other @rnrs{6} Scheme implementations.

The programmer can put the @code{.vicare.*} extensions to use in this
situation, by writing two versions of a @library{pretty-printing}
library: one for use by @value{PRJNAME}, and one portable for other
implementations.

@example
;; pretty-printing.vicare.ss --
;;
;; Can be used only by @value{PRJNAME} Scheme.

(library (pretty-printing)
  (export pretty-print)
  (import (only (ikarus) pretty-print)))

;;; end of file
@end example

@example
;; pretty-printing.sls --
;;
;; For any other Scheme implementation, portable though
;; not very pretty.

(library (pretty-printing)
  (export pretty-print)
  (import (rnrs))
  (define (pretty-print x port)
    (write x port)
    (newline port)))

;;; end of file
@end example

@c page
@node using rlwrap
@section Using @command{rlwrap}


@cindex @command{rlwrap}


While @value{PRJNAME} comes with an interface to @gnu{} Readline or
compatible library, the @repl{} interaction, as of version 0.2d9, offers
only very basic editing capabilities.  For this reason it is suggested
to use @command{rlwrap}:

@center @url{http://utopia.knoware.nl/~hlub/rlwrap/}

@noindent
to run @value{PRJNAME}'s @repl{} through this shell script:

@smallexample
#!/bin/sh
#
# Vicare Scheme GNU Readline wrapper using Rlwrap.

## Configuration variables.

vicare_PROGRAM=$(type -p vicare)
rlwrap_PROGRAM=$(type -p rlwrap)

COMPLETIONS_FILE=/home/marco/.vicare_completions
COMPLETIONS_OPTION=--file=$@{COMPLETIONS_FILE@}

## Data variables.

# Do NOT include '\!' and '?' in this string.
BREAK_CHARS="\"#'(),;\`\\|[]@{@}"

## Check programs and data files existence.

function error () @{
    local MESSAGE=$@{1:?@}
    printf 'vie error: %s\n' "$@{MESSAGE@}" >&2
    exit 2
@}
function warning () @{
    local MESSAGE=$@{1:?@}
    printf 'vie warning: %s\n' "$@{MESSAGE@}" >&2
@}

test -x "$@{rlwrap_PROGRAM@}" || \
  error "cannot find program 'rlwrap'"
test -x "$@{vicare_PROGRAM@}" || \
  error "cannot find program 'vicare'"

if ! test -f "$@{COMPLETIONS_FILE@}" ; then
    warning "cannot find completions file '$@{COMPLETIONS_FILE@}'"
    COMPLETIONS_OPTION=
fi

## Run.

exec "$@{rlwrap_PROGRAM@}"                    \
    --ansi-colour-aware                     \
    --break-chars=$@{BREAK_CHARS@}            \
    --complete-filenames                    \
    --history-no-dupes=2                    \
    --multi-line                            \
    --prompt-colour='1;31'                  \
    --quote-characters='"'                  \
    --remember                              \
    $@{COMPLETIONS_OPTION@}                   \
    "$@{vicare_PROGRAM@}" --raw-repl "$@@"

### end of file
@end smallexample

@c page
@node using binfmt
@section Launching programs on Linux


When running @value{PRJNAME} on a @gnu{}+Linux system we can take
advantage of the features offered by the @code{binfmt_misc} kernel
module to launch directly executable programs without prefixing the
program name with the @command{vicare} executable.

It all comes down to this: after setting up the feature as explained in
the appendix @ref{binfmt}, we write a file containing:

@example
;;;!vicare
(import (only (program-library) main))
(main)
@end example

@noindent
where @library{program-library} is an installed library containing the
application code and @func{main} is the function that starts the
application.  If we enable executable permissions for the file and make
sure that the first bytes in the file are the sequence
@code{;;;!vicare}, we can configure the Linux kernel to start the
program handing its command line to the executable @command{vicare}.

@c page
@node iklib
@chapter Language extensions


@cindex Library @library{vicare}
@cindex @library{vicare}, library
@cindex Library @library{ikarus}
@cindex @library{ikarus}, library
@cindex Library @library{vicare language-extensions}
@cindex @library{vicare language-extensions}, library


In addition to the libraries listed in the @rnrs{6} standard,
@value{PRJNAME} offers more libraries which provide additional features:

@table @library
@item ikarus
It is a composite library, it exports a superset of all the supported
bindings of @rnrs{6}.

@item vicare
It exports the same bindings of @library{ikarus}.

@item vicare language-extensions
It exports all the bindings exported by @library{vicare} that are
@strong{not} exported by @library{rnrs (6)}.
@end table

@menu
* iklib progname::              Finding the @command{vicare} executable.
* iklib conditions::            Additional condition types.
* iklib reader::                Extensions to the reader.
* iklib expander::              Interface to the expander.
* iklib shared::                Shared structures graph notation.
* iklib environment::           Environments.
* iklib cafe::                  Cafe.
* iklib structs::               Structures and type descriptors.
* iklib keywords::              Keyword objects.
* iklib lists::                 Additional list functions.
* iklib bytevectors::           Additional bytevector functions.
* iklib strings::               Additional string functions.
* iklib vectors::               Additional vector functions.
* iklib symbols::               Additional symbol functions.
* iklib numerics::              Additional functions on numbers.
* iklib enumerations::          Additional functions on enumerations.
* iklib load::                  Loading source files.
* iklib import::                Local library imports.
* iklib modules::               Local modules.
* iklib parameters::            Parameters.
* iklib gensym::                Gensyms.
* iklib printing::              Printing.
* iklib tracing::               Tracing for debugging.
* iklib timing::                Timing.
* iklib collection::            Interfacing with garbage collection.
* iklib guardians::             Guardians and garbage collection.
* iklib io::                    Input/output library.
* iklib pointers::              Handling pointer objects.
* iklib memory::                Memory management.
* iklib cstrings::              Raw C strings.
* iklib errno::                 Interface to @code{errno}.
* iklib readline::              Readline interface.
* iklib debug::                 Debugging utilities.
* iklib misc::                  Miscellaneous functions.
@end menu

@c page
@node iklib progname
@section Finding the @command{vicare} executable


@defun vicare-argv0
Return a bytevector holding the C string in the @code{argv[0]} argument
to the @cfunc{main} function of the current @value{PRJNAME} process.
@end defun


@defun vicare-argv0-string
Return a Scheme string holding the C string in the @code{argv[0]}
argument to the @cfunc{main} function of the current @value{PRJNAME}
process.
@end defun

@c page
@node iklib conditions
@section Additional condition types


@menu
* iklib conditions spos::       Scheme source code position.
* iklib conditions eagain::     Reporting @code{EAGAIN} exceptions.
@end menu

@c page
@node iklib conditions spos
@subsection Scheme source code position


The following bindings are exported by the @library{ikarus} library.


@deftp {Condition Type} &source-position
Condition type used to represent a position in Scheme source code read
from a textual input port; it is derived from @condition{condition}.  It
has the following fields:

@table @code
@item port-id
A Scheme string representing the port identifier, for example the file
name.

@item byte
An exact non--negative zero--based integer representing the byte offset
of the position in the source.

@item character
An exact non--negative zero--based integer representing the character
offset of the position in the source.

@item line
An exact non--negative one--based integer representing the line offset
of the position in the source.

@item column
An exact non--negative one--based integer representing the column offset
of the position in the source.
@end table
@end deftp


@defun make-source-position-condition @var{port-id} @var{character}
Build and return a new condition object of type
@condition{source-position}.
@end defun


@defun source-position-condition? @var{obj}
Return true if @var{obj} is a condition object with type
@condition{source-position}.
@end defun


@defun source-position-port-id @var{spos}
@defunx source-position-character @var{spos}
Accessors for the fields of condition objects of type
@condition{source-position}.
@end defun

@c page
@node iklib conditions eagain
@subsection Reporting @code{EAGAIN} exceptions


The following bindings are exported by the @library{ikarus} library.


@deftp {Condition Type} &i/o-eagain
Used to signal that a system call returned with @code{errno} set to
@code{EAGAIN}.  It is derived from @condition{i/o}.
@end deftp


@defun make-i/o-eagain
Return a new condition object of type @condition{i/o-eagain}.
@end defun


@defun i/o-again-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{i/o-eagain}.
@end defun

@c page
@node iklib reader
@section Reader


@menu
* iklib reader mode::           Textual input port modes.
* iklib reader bv::             Additional bytevector syntaxes.
* iklib reader chars::          Custom named characters.
* iklib reader stx::            Miscellaneous additional syntaxes.
* iklib reader fun::            Additional reader functions.
@end menu

@c page
@node iklib reader mode
@subsection Textual input port modes


@deffn {Reader Syntax} {#!vicare}
@deffnx {Reader Syntax} {#!ikarus}
@value{PRJNAME} extends Scheme's lexical syntax (@rnrs{6} Chapter 4) in
a variety of ways including:

@itemize
@item
End--of--file marker, @code{#!eof}.

@item
Gensym syntax, @code{#@{gensym@}}.

@item
Shared structures graph notation: @code{#nn=}, @code{#nn#}.

@item
Special symbols are allowed: @code{++}, @code{--}.
@end itemize

The syntax extensions are made available by default on all input ports,
until the @code{#!r6rs} token is read.  Thus, reading the @code{#!r6rs}
token disables all extensions to the lexical syntax on the specific
port, and the @code{#!vicare} enables them again.

When writing code that is intended to be portable across different
Scheme implementations, we should add the @code{#!r6rs} token to the top
of every script and library that we write; this allows @value{PRJNAME}
to alert us when using non--portable features.  When writing code that's
intended to be @value{PRJNAME}--specific, we should add the
@code{#!vicare} token in order to get an immediate error when the code
is run under other implementations.

The comment @code{#!ikarus} is accepted for backwards compatibility with
Ikarus Scheme.
@end deffn


@deffn Procedure port-mode @var{input-port}
Accept an input port as argument and return a symbol among: @code{r6rs},
@code{vicare}.  All input ports start under @code{vicare} mode and thus
accept @value{PRJNAME}--specific reader extensions.  When the
@code{#!r6rs} token is read from a port, its mode changes to
@code{r6rs}.

@example
> (port-mode (current-input-port))
vicare
> #!r6rs (port-mode (current-input-port))
r6rs
> #!vicare (port-mode (current-input-port))
vicare
@end example
@end deffn


@deffn Procedure set-port-mode! @var{input-port} @var{mode}
Modifiy the lexical syntax accepted by subsequent calls to @func{read}
on the input port.  The mode is a symbol among @code{r6rs} and
@code{vicare}.  The effect of setting the port mode is similar to
that of reading the @code{#!r6rs} or @code{#!vicare} token from that
port.

@example
> (set-port-mode! (current-input-port) 'r6rs)
> (port-mode (current-input-port))
r6rs
@end example
@end deffn

@c page
@node iklib reader bv
@subsection Additional bytevector syntaxes


The following syntaxes are available only when the input port mode is
set to @code{vicare}.


@deffn {Reader Syntax} {#vs8(@var{byte} ...)}
Read a bytevector as @code{#vu8(@var{octect} ...)} would do, but allow
@var{byte} to be in the range @math{[-128, 127]}.
@end deffn


@deffn {Reader Syntax} {#vu16l(@var{word} ...)}
@deffnx {Reader Syntax} {#vu16b(@var{word} ...)}
@deffnx {Reader Syntax} {#vu16n(@var{word} ...)}
Read a bytevector of 16-bit unsigned words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vs16l(@var{word} ...)}
@deffnx {Reader Syntax} {#vs16b(@var{word} ...)}
@deffnx {Reader Syntax} {#vs16n(@var{word} ...)}
Read a bytevector of 16-bit signed words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vu32l(@var{word} ...)}
@deffnx {Reader Syntax} {#vu32b(@var{word} ...)}
@deffnx {Reader Syntax} {#vu32n(@var{word} ...)}
Read a bytevector of 32-bit unsigned words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vs32l(@var{word} ...)}
@deffnx {Reader Syntax} {#vs32b(@var{word} ...)}
@deffnx {Reader Syntax} {#vs32n(@var{word} ...)}
Read a bytevector of 32-bit signed words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vu64l(@var{word} ...)}
@deffnx {Reader Syntax} {#vu64b(@var{word} ...)}
@deffnx {Reader Syntax} {#vu64n(@var{word} ...)}
Read a bytevector of 64-bit unsigned words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vs64l(@var{word} ...)}
@deffnx {Reader Syntax} {#vs64b(@var{word} ...)}
@deffnx {Reader Syntax} {#vs64n(@var{word} ...)}
Read a bytevector of 64-bit signed words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vf4l(@var{flonum} ...)}
@deffnx {Reader Syntax} {#vf4b(@var{flonum} ...)}
@deffnx {Reader Syntax} {#vf4n(@var{flonum} ...)}
Read a bytevector of single--precision flonums stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vf8l(@var{flonum} ...)}
@deffnx {Reader Syntax} {#vf8b(@var{flonum} ...)}
@deffnx {Reader Syntax} {#vf8n(@var{flonum} ...)}
Read a bytevector of double--precision flonums stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vc4l(@var{cflonum} ...)}
@deffnx {Reader Syntax} {#vc4b(@var{cflonum} ...)}
@deffnx {Reader Syntax} {#vc4n(@var{cflonum} ...)}
Read a bytevector of single--precision cflonums stored in little, big
and native endianness, real part first.
@end deffn


@deffn {Reader Syntax} {#vc8l(@var{cflonum} ...)}
@deffnx {Reader Syntax} {#vc8b(@var{cflonum} ...)}
@deffnx {Reader Syntax} {#vc8n(@var{cflonum} ...)}
Read a bytevector of double--precision cflonums stored in little, big
and native endianness, real part first.
@end deffn


@deffn {Reader Syntax} {#ve(@var{encoding} @var{data})}
Read a bytevector in some encoding which is supposed to be easy to type
for human beings.  @var{encoding} is a symbol representing the encoding
format, @var{data} is a datum to convert to bytevector.  At present the
following encodings are supported:

@table @code
@item ascii
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->ascii}.

@item latin1
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->latin1}.

@item utf8
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->utf8}.

@item utf16be
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->utf16be}.

@item utf16le
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->utf16le}.

@item utf16n
Convert the Scheme string @var{data} to a bytevector using the function
@func{string->utf16n}.
@end table
@end deffn

@c page
@node iklib reader chars
@subsection Custom named characters


The following syntaxes are available only when the input port mode is
set to @code{vicare}.


@deffn {Reader Syntax} {#!(char-names (@meta{name} . @meta{char}) ...)}
Add new custom named characters to the internal table for the current
reading operation.  Each @meta{name} must be a Scheme identifier
starting with a @meta{constituent} character as defined by @rnrs{6};
each @meta{char} must be a Scheme character.

@example
#!(char-names
    (lambda . #\x0EBB))
@end example
@end deffn


@deffn {Reader Syntax} {#\@{@meta{name}@}}
Reader syntax for standalone custom named characters.  @meta{name} must
be an identifier previously defined with the @code{char-names} comment
list defined above.

@example
#\@{lambda@}            @result{} #\xEBB
@end example
@end deffn


@deffn {Reader Syntax} {\@{@meta{name}@}}
Reader syntax for custom named characters embedded in strings.
@meta{name} must be an identifier previously defined with the
@code{char-names} comment list defined above.

@example
"\@{lambda@}"           @result{} "\xEBB;"
@end example
@end deffn

@c page
@node iklib reader stx
@subsection Miscellaneous additional syntaxes


The following syntaxes are available only when the input port mode is
set to @code{vicare}.


@deffn {Reader Syntax} {|@var{symbol}|}
The vertical bars can be used to specify symbols whose name do not
comply with the @rnrs{6} specifications; this syntax is available only
when the port mode is @code{#!vicare}.  Examples:

@example
(define port (open-string-input-port "|123|"))
(set-port-mode! port 'vicare)
(define sym (read port))

(symbol? sym)           @result{} #t
(symbol->string sym)    @result{} "123"
@end example

@noindent
backslash sequences are allowed in bar symbols:

@example
(define port (open-string-input-port "|123-\x41;\x42;\x43;|"))
(set-port-mode! port 'vicare)
(define sym (read port))

(symbol? sym)           @result{} #t
(symbol->string sym)    @result{} "123-\x41;\x42;\x43;"
@end example

@noindent
notice that the sequence of characters @code{|ciao|hello|} is split into
@code{ciao}, @code{hello}, @code{|} and the ending vertical bar would
cause an error if read:

@example
(define port (open-string-input-port "|ciao|hello|"))
(set-port-mode! port 'vicare)

(read port)             @result{} ciao
(read port)             @result{} hello
(port-eof? port)        @result{} #f
(get-char port)         @result{} #\|
(port-eof? port)        @result{} #t
@end example
@end deffn


@deffn {Reader Syntax} {#@{unique-name@}}
@deffnx {Reader Syntax} {#@{pretty-name unique-name@}}
@c @deffnx {Reader Syntax} {#:pretty-name}
@value{PRJNAME}'s @func{read} and @func{write} procedures extend the lexical
syntax of Scheme by the ability to read and write gensyms using one of
these three forms.

@code{#@{unique-name@}} constructs, at read time, a gensym whose unique
name is the one specified.  If a gensym with the same unique name
already exists in the system's symbol table, that gensym is returned.

@example
> '#@{some-long-name@}
#@{g0 |some-long-name|@}
> (gensym? '#@{some-long-unique-name@})
#t
> (eq? '#@{another-unique-name@} '#@{another-unique-name@})
#t
@end example

The two--part @code{#@{pretty-name unique-name@}} gensym syntax is
similar to the syntax shown above with the exception that if a new
gensym is constructed (that is, if the gensym did not already exist in
the symbol table), the pretty name of the constructed gensym is set to
@code{pretty-name}.

@example
> '#@{foo unique-identifier@}
#@{foo |unique-identifier|@}
> '#@{unique-identifier@}
#@{foo |unique-identifier|@}
> '#@{bar unique-identifier@}
#@{foo |unique-identifier|@}
@end example

@ignore
The @code{#:pretty-name} form constructs, at read time, a gensym whose
pretty name is @code{pretty-name} and whose unique name is fresh.  This
form guarantees that the resulting gensym is not @func{eq?} to any other
symbol in the system.

@example
> '#:foo
#@{foo |j=qTGlEwS/Zlp2Dj|@}
> (eq? '#:foo '#:foo)
#f
@end example
@end ignore
@end deffn


@deffn {Reader Syntax} {#:@var{symbol}}
Read a keyword object using @var{symbol} as symbol.  @var{symbol} must
be a symbol object as defined by @rnrs{6}.  @ref{iklib keywords, Keyword
objects}.
@end deffn


@deffn {Reader Syntax} {#!eof}
The end--of--file marker, @code{#!eof}, is an extension to the @rnrs{6}
syntax.  The primary utility of the @code{#!eof} marker is to stop the
reader (e.g. @func{read} and @func{get-datum}) from reading the rest of
the file.

@example
(import (ikarus))
<some code>
(display "goodbye\n")

#!eof
<some junk>
@end example

The @code{#!eof} marker also serves as a datum in @value{PRJNAME}, much
like @true{} and @false{}, when it is found inside other expressions.

@example
> (eof-object)
#!eof
> (read (open-input-string ""))
#!eof
> (read (open-input-string "#!eof"))
#!eof
> (quote #!eof)
#!eof
> (eof-object? '#!eof)
#t
> #!r6rs #!eof
Unhandled exception
Condition components:
  1. &error
  2. &who: tokenize
  3. &message: "invalid syntax: #!e"
> #!vicare #!eof
$
@end example
@end deffn


@deffn {Reader Syntax} #ci @var{form}
@deffnx {Reader Syntax} #cs @var{form}
Switch between case sensitive and case insensitive identifiers; the
default for @rnrs{6} source code is case sensitive.  When @code{#ci} is
read: the next form read has case insensitive identifiers.  When
@code{#cs} is read: the next form read has case sensitive identifiers.

@example
#ci(1 2 3)              @result{} (1 2 3)
#cs(1 2 3)              @result{} (1 2 3)

#ci(1 A 3)              @result{} (1 a 3)
#cs(1 A 3)              @result{} (1 A 3)

#ci CIAO #cs CIAO       @result{} ciao CIAO
#ci CIAO CIAO           @result{} ciao CIAO

#ci(A #csB C)           @result{} (a B c)
#ci(A #cs B C)          @result{} (a B c)
@end example
@end deffn

@c page
@node iklib reader fun
@subsection Additional reader functions


The following bindings are exported by the @library{ikarus} library.


@defun get-annotated-datum @var{port}
Like @func{get-datum}, but rather than returning a datum return a
hierarchy of @code{annotation} objects with the same hierarchy of the
datum and embedding the datum itself.
@end defun


@defun annotation? @var{obj}
Return @true{} if @var{obj} is an @code{annotation} object, else return
@false{}.
@end defun


@defun annotation-expression @var{ann}
Accessor for the @code{expression} field of an @code{annotation} object.
Return a list, vector, identifier, what--have--you that may contain
further annotations.
@end defun


@defun annotation-stripped @var{ann}
Accessor for the @code{stripped} field of an @code{annotation} object.
The same symbolic expression of the @code{expression} field with no
annotations.
@end defun


@defun annotation-textual-position @var{ann}
Accessor for the @code{textual-position} field of an @code{annotation}
object.  A condition object of type @condition{source-position}
representing the position of the expression in the source code.
@end defun

@c page
@node iklib expander
@section Interface to the expander


@menu
* iklib expander syntax::       Inspecting syntax objects.
* iklib expander transformers:: Syntax transformers facilities.
* iklib expander expand::       Expander facilities.
@end menu

@c page
@node iklib expander syntax
@subsection Inspecting syntax objects


Under @value{PRJNAME}, a syntax object is the instance of a data
structure.  The following bindings are exported by the @library{ikarus}
library.


@defun syntax-object? @var{stx}
Return @true{} if @var{stx} is a syntax object, else return @false{}.
@end defun


@defun syntax-object-expression @var{stx}
@defunx syntax-object-marks @var{stx}
@defunx syntax-object-substs @var{stx}
@defunx syntax-object-source-objects @var{stx}
Field accessors for the syntax object structure type, to be used for
debugging purposes.
@end defun

@c page
@node iklib expander transformers
@subsection Syntax transformers facilities


The following bindings are exported by the @library{ikarus} library.


@defun variable-transformer?
Undocumented.
@end defun


@defun variable-transformer-procedure
Undocumented.
@end defun


@defun make-compile-time-value
Undocumented.
@end defun


@defun syntax-transpose
Undocumented.
@end defun

@c page
@node iklib expander expand
@subsection Expander facilities


The following bindings are exported by the @library{ikarus} library.


@defun expand
Undocumented.
@end defun


@defun core-expand
Undocumented.
@end defun


@defun expand/optimize
Undocumented.
@end defun


@defun expand/scc-letrec
Undocumented.
@end defun

@c page
@node iklib shared
@section Shared structures graph notation


This feature of the reader is derived from the @srfi{} 38 ``External
Representation for Data With Shared Structure'':

@center @url{http://srfi.schemers.org/srfi-38/srfi-38.html}

This graph notation allows the reader to build symbolic expressions with
graph structure including cycles.  @strong{Shared structures must always
be used inside quoted datums}; if we create a cycle in a symbolic
expression passed as code to the expander: the result will be an
infinite loop.  Graph notation is available only when the textual input
port is configured in @code{#!vicare} mode.

Graph notation extends the @rnrs{6} syntax with these additional cases:

@example
<lexeme>                -> <r6rs lexeme>
                         | <defining datum>
                         | <defined datum>
<defining datum>        -> #<indexnum>=<r6rs lexeme>
<defined datum>         -> #<indexnum>#
<indexnum>              -> <digit>+
@end example

@noindent
where @code{<r6rs lexeme>} is the lexeme definition in @rnrs{6}.


@deffn Parameter print-graph
@deffnx Parameter print-graph #t
@deffnx Parameter print-graph #f
The graph notation is a way of marking and referencing parts of a data
structure and, consequently, creating shared and cyclic data structures
at read time instead of resorting to explicit mutation at run time.  The
@code{#n=} marks the following data structure with mark @var{n}, where
@var{n} is a nonnegative integer.  The @code{#n#} references the data
structure marked @var{n}.  Marks can be assigned and referenced in any
order but each mark must be assigned to exactly once in an expression.

@example
> (let ([x '#0=(1 2 3)])
    (eq? x '#0#))
#t
> (let ([x '#0#] [y '#0=(1 2 3)])
    (eq? x y))
#t
> (eq? (cdr '(12 . #1#)) '#1=(1 2 3))
#t
> (let ([x '#1=(#1# . #1#)])
    (and (eq? x (car x))
         (eq? x (cdr x))))
#t
@end example

The @func{print-graph} parameter controls how the writers (e.g.
@func{pretty-print} and @func{write}) handle shared and cyclic data
structures.  In @value{PRJNAME}, all writers detect cyclic data structures and
they all terminate on all input, cyclic or otherwise.

If the value of @func{print-graph} is set to @false{} (the default),
then the writers do not attempt to detect shared data structures.  Any
part of the input that is shared is printed as if no sharing is present.
If the value of @func{print-graph} is set to @true{}, all sharing of
data structures is marked using the @code{#n=} and @code{#n#} notation.

@example
> (parameterize ([print-graph #f])
    (let ([x (list 1 2 3 4)])
      (pretty-print (list x x x))))
((1 2 3 4) (1 2 3 4) (1 2 3 4))

> (parameterize ([print-graph #t])
    (let ([x (list 1 2 3 4)])
      (pretty-print (list x x x))))
(#0=(1 2 3 4) #0# #0#)

> (parameterize ([print-graph #f])
    (let ([x (list 1 2)])
      (let ([y (list x x x x)])
        (set-car! (last-pair y) y)
        (pretty-print (list y y)))))
(#0=((1 2) (1 2) (1 2) #0#) #0#)

> (parameterize ([print-graph #t])
    (let ([x (list 1 2)])
      (let ([y (list x x x x)])
        (set-car! (last-pair y) y)
        (pretty-print (list y y)))))
(#0=(#1=(1 2) #1# #1# #0#) #0#)
@end example
@end deffn

@c page
@node iklib environment
@section Environments


@cindex Environment, interaction


The following bindings are exported by the @library{ikarus} library.


@defun environment?
Undocumented.
@end defun


@defun interaction-environment
Return an environment object representing the environment active at the
@repl{}.  To be used as argument for @func{eval}.
@end defun


@defun new-interaction-environment
Undocumented.
@end defun


@defun environment-symbols
Undocumented.
@end defun

@c page
@node iklib cafe
@section Cafe


The following bindings are exported by the @library{ikarus} library.


@defun new-cafe
@defunx new-cafe @var{eval}
Start a new read--eval--print loop (@repl{}) inside the current cafe (if
one exists).  It prompts the user for an expression, evaluates it,
prints the result back, and repeats the process.  If @func{new-cafe} is
called with an argument, @var{eval}, then that argument must be a
procedure that takes a single argument.  The @var{eval} procedure will
be used to evaluate the expressions.

Every time a new cafe is started, the prompt is changed to reflect the
depth of the current cafe (i.e. how many eof objects is takes to exit
the outermost cafe).

When the readline interface is not used, input and output performed by
the cafe can be changed by the @func{console-input-port} and
@func{console-output-port} parameters; when readline support is
available and used, the @repl{} input is performed through a readline
input port.

If an error occurs during reading, evaluating, or printing an
expression, then the error message is printed to the error--port and the
operations of the cafe resume as normal.

To exit from a cafe we can write the @eof{} object.
@end defun

@c page
@node iklib structs
@section Structures and type descriptors


A data structure is like a lightweight record as defined by @rnrs{6}.
@ref{objects structs} for more informations on the internals of data
structures.

@menu
* iklib structs rtd::           Structure type descriptors.
* iklib structs using::         Using data structures.
* iklib structs inspect::       Inspecting data structures.
@end menu

@c page
@node iklib structs rtd
@subsection Structure type descriptors


The following bindings are exported by the @library{ikarus} library.


@deffn Syntax define-struct @meta{name} (@meta{field} ...)
Define a new data structure type.  This macro is embedded in the
expander.

@meta{name} must be a symbol representing the name of the structure; it
is used to build names for the constructor, predicate, field accessors
and mutators.  The @meta{field} values must be symbols representing the
names of the fields; they are used to build names for the accessors and
mutators.

The following definition:

@example
(define-struct color
  (red green blue))
@end example

@noindent
expands to the definition of the following bindings:

@table @code
@item color
An identifier syntax bound to a pair whose car is the symbol @samp{$rtd}
and whose cdr is the return value of @func{make-struct-type} applied to
the name of the structure and the list of fields.

@item make-color @var{red} @var{green} @var{blue}
A structure constructor accepting as much arguments as there are fields.
The constructor makes use of the @func{$struct} low level operation.

@item color? @var{obj}
A predicate to distinguish between references to @code{color} structures
and other values.  This predicate makes use of the @func{$struct/rtd?}
low level operation.

@item color-red @var{stru}
@itemx color-green @var{stru}
@itemx color-blue @var{stru}
Accessor functions for the fields of the structure.  These accessors
make use of the @func{$struct/rtd?} low level operation to validate the
argument and if successful they use @func{$struct-ref} to extract the
value; if the argument is of invalid type: an assertion violation is
raised.

@item set-color-red! @var{stru} @var{red}
@itemx set-color-green! @var{stru} @var{green}
@itemx set-color-blue! @var{stru} @var{blue}
Mutator functions for the fields of the structure.  These mutators make
use of the @func{$struct/rtd?} low level operation to validate the
argument @var{stru} and if successful they use @func{$struct-set!} to
set the value; if the argument @var{stru} is of invalid type: an
assertion violation is raised.

@item $color-red @var{stru}
@itemx $color-green @var{stru}
@itemx $color-blue @var{stru}
Unsafe accessor syntaxes for the fields of the structure.  These
accessors do not validate the arguments and expand directly to a use of
@func{$struct-ref} to extract the value; if the argument is invalid: the
behaviour is undefined.

@item $set-color-red! @var{stru} @var{red}
@itemx $set-color-green! @var{stru} @var{green}
@itemx $set-color-blue! @var{stru} @var{blue}
Unsafe mutator syntaxes for the fields of the structure.  These mutators
do not validate the arguments and expand directly to a use of
@func{$struct-set!} to set the value; if the argument @var{stru} is
invalid: the behaviour is undefined.
@end table
@end deffn


@defun make-struct-type @var{name} @var{fields}
@defunx make-struct-type @var{name} @var{fields} @var{uid}
Build and return a new structure type descriptor.  @var{name} must be a
string representing the type name.  @var{fields} must be a list of
symbols representing the field names.

The optional @var{uid} argument must be a symbol uniquely identifying
this type; when not supplied, a symbol is automatically generated.  The
@func{$symbol-value} field of @var{uid} is set to the newly created RTD;
if @var{uid} already has a symbol value: such value must be a struct
descriptor equal to the newly created RTD.
@end defun


@deffn Syntax type-descriptor @meta{name}
Evaluate to the type descriptor of the data structure @meta{name}, which
must be the first argument to a previous use of @func{define-struct}.
@end deffn


@defun struct-type-name @var{rtd}
Return a string represnting the name of structures of type @var{rtd}.
@end defun


@defun struct-type-symbol @var{rtd}
Return a symbol uniquely identifying the data structure type @var{rtd}.
@end defun


@defun struct-type-field-names @var{rtd}
Return a list of symbols representing the names of fields in structures
of type @var{rtd}.
@end defun


@defun struct-type-destructor @var{rtd}
Return @false{} or a procedure being the destructor for instances of
@var{rtd}.  The destructor is registered in a structure type descritpor
with @func{set-rtd-destructor!}.
@end defun

@c ------------------------------------------------------------

@defun set-rtd-printer! @var{rtd} @var{printer}
Select the procedure @var{printer} as printer for data structures of
type @var{rtd}; return unspecified values.  The printer accepts as
@math{3} arguments: the structure to be printed, the port to which write
a string represention of the structure with @func{display}, a function
to be optionally applied to the field values to print them.
@end defun

@c ------------------------------------------------------------

@subsubheading Automatic finalisation of structures


@defun set-rtd-destructor! @var{rtd} @var{destructor}
Select the procedure @var{destructor} as destructor for data structures
of type @var{rtd}; return unspecified values.  The destructor accepts a
single argument being the structure instance to finalise; the destructor
can return unspecified values.

After a destructor is registered in @var{rtd}: new instances of this
structure type are registered, upon creation, into an internal guardian,
@ref{iklib guardians} for details; whenever such structures are garbage
collected: the guardian applies @var{destructor} to them.

Exceptions raised by @var{destructor} are catched with @func{guard} and
discarded: destructor functions should take care of exceptions by
themselves.
@end defun


@deffn Parameter struct-guardian-logger
Select data structure destruction logging mode for debugging purposes.
When a structure is finalised by the garbage collector, using the
destructor registered in the @rtd{}:

@itemize
@item
If this parameter is set to @false{}: no additional actions are
performed.

@item
If this parameter is set to @true{}: the function
@func{struct-guardian-log} is used to log the operations to the textual
output port returned by @code{current-error-port}.

@item
If this parameter is set to a procedure: such procedure is used to log
the operations in a user selected way.
@end itemize

See the documentation of @func{struct-guardian-log} for the calling
protocol of the logger functions.
@end deffn


@defun struct-guardian-log @var{struct} @var{exception} @var{action}
Built in logger function to be used to log data structure finalisation
operations by the garbage collector.  @var{struct} is the structure to
be finalised; @var{exception} is @false{} or an object raised by the
structure destructor; @var{action} is one of the symbols:
@code{before-destruction}, @code{after-destruction}, @code{exception}.

When this function is used as value for the parameter
@func{struct-guardian-logger}:

@itemize
@item
The function is called just before the structucture is finalised with
@var{action} set to the symbol @code{before-destruction} and
@var{exception} set to @false{}.

@item
The function is called right after the structucture has been finalised
with @var{action} set to the symbol @code{after-destruction} and
@var{exception} set to @false{}.

@item
If an exception is raised by the destructor: such exception is catched
and this function is called with @var{action} set to @code{exception}
and @var{exception} set to the raised object.
@end itemize

The current implementation is the following:

@smallexample
(define (struct-guardian-log S E action)
  (case action
    ((before-destruction)
     (fprintf (current-error-port)
       "*** Vicare debug: struct guardian: before destruction:\n\
        ***\t~s\n" S))
    ((after-destruction)
     (fprintf (current-error-port)
       "*** Vicare debug: struct guardian: after destruction:\n\
        ***\t~s\n" S))
    ((exception)
     (fprintf (current-error-port)
       "*** Vicare debug: struct guardian: exception:\n\
        ***\t~s\n\
        ***\t~s\n" S E))
    (else
     (assertion-violation 'struct-guardian-log
       "invalid action in struct destruction process" S action))))
@end smallexample
@end defun

@c page
@node iklib structs using
@subsection Using data structures


The following bindings are exported by the @library{ikarus} library.


@defun struct-constructor @var{rtd}
Return a constructor function for data structures of type @var{rtd}.
The constructor accepts as many arguments as fields defined by @var{rtd}
and returns a new structure instance.
@end defun


@defun struct-predicate @var{rtd}
Return a predicate function for structures of type @var{rtd}.
@end defun


@defun struct-field-accessor @var{rtd} @var{index}
Return an accessor function for the field at @var{index} of data
structures of type @var{rtd}.
@end defun


@defun struct-field-mutator @var{rtd} @var{index}
Return a mutator function for the field at @var{index} of data
structures of type @var{rtd}.
@end defun

@c page
@node iklib structs inspect
@subsection Inspecting data structures


The following bindings are exported by the @library{ikarus} library.


@defun struct? @var{stru}
@defunx struct? @var{stru} @var{rtd}
When no @var{rtd} argument is given return true if @var{stru} is a data
structure.  When @var{rtd} is given: return true if @var{stru} is a data
structure and it is of type @var{rtd}.
@end defun


@defun struct-rtd @var{stru}
@defunx struct-type-descriptor @var{stru}
Return the @var{rtd} of the data structure @var{stru}.  Notice that this
function works with both Vicare's structs and @rnrs{6} records.
@end defun


@defun struct-length @var{stru}
Return the number of fields in the data structure @var{stru}.  Notice
that this function works with both Vicare's structs and @rnrs{6}
records.
@end defun


@defun struct-name @var{stru}
Return a string representing the name of the data structure @var{stru}.
Notice that this function works with both Vicare's structs and @rnrs{6}
records.
@end defun


@defun struct-printer @var{stru}
Return the procedure being the printer function for the data structure
@var{stru}.
@end defun


@defun struct-ref @var{stru} @var{index}
Return the value of field at @var{index} in the data structure
@var{stru}.
@end defun


@defun struct-set! @var{stru} @var{index} @var{value}
Store @var{value} in the field at @var{index} in the data structure
@var{stru}.
@end defun


@defun struct=? @vari{obj} @varii{obj}
Return true if @vari{obj} and @varii{obj} are two structures having the
same @rtd{} and equal field values according to @func{eqv?}.
@end defun


@defun struct-reset @var{stru}
Reset to void all the fields of a structure.
@end defun

@c page
@node iklib keywords
@section Keyword objects


Keyword objects are struct instances embedding a Scheme symbol; keyword
objects are a disjoint type; keyword objects are @strong{not} interned.

Keyword objects can be compared with @func{eq?}, @func{eqv?} and
@func{equal?}; a keyword object is @func{eq?} only to itself.  Keyword
objects can also be compared with the @func{keyword=?} predicate which
is faster than @func{eqv?} and @func{equal?} and slower than @func{eq?}
for symbols.

The reader supports a special syntax to read keyword objects, @ref{iklib
reader stx, Miscellaneous additional syntaxes}.

The following bindings are exported by the @library{ikarus} library.


@defun symbol->keyword @var{symbol}
@defunx keyword->symbol @var{keyword}
Convert between a symbol and a keyword.
@end defun


@defun keyword? @var{obj}
Return @true{} if @var{obj} is a keyword object, else return @false{}.
@end defun


@defun keyword=? @vari{keyword} @varii{keyword}
Return @true{} if both @vari{keyword} and @varii{keyword} are keyword
objects and they are equal.  A keyword object is equal to itself; two
distinct keyword objects are equal if they have the same symbol.
@end defun


@defun keyword-hash @var{keyword}
Return an exact integer suitable to be used as hash value for
@var{keyword} used as key for hashtables.
@end defun

@c page
@node iklib lists
@section Additional list functions


@menu
* iklib lists weak::            Weak pairs.
@end menu

@c page
@node iklib lists weak
@subsection Weak pairs


Weak references do not cause the referenced value to be considered used
by the garbage collector.  The following bindings are exported by the
@library{ikarus} library.


@defun weak-cons @var{A} @var{D}
Like @func{cons} build and return a new pair, but holding weak
references to @var{A}; notice that the reference to @var{D} is not weak.
This function allows to build a non--weak list spine holding weak
references to values.
@end defun


@defun weak-pair? @var{obj}
Return true if @var{obj} is a weak pair.
@end defun


@defun bwp-obejct? @var{obj}
Return true if @var{obj} is a weak reference to a value which has been
already garbage collected.  Example:

@example
vicare> (define x (weak-cons (cons 1 2) #f))
vicare> x
((1 . 2) . #f)
vicare> (bwp-object? (car x))
#f
vicare> (collect)
vicare> x
 (#!bwp . #f)
vicare> (bwp-object? (car x))
#t
@end example
@end defun

@c page
@node iklib bytevectors
@section Additional bytevector functions


The description of bytevectors uses the term @emph{byte} for an exact
integer object in the interval @math{(-128, @dots{}, 127)} and the term
@emph{octet} for an exact integer object in the interval @math{(0,
@dots{}, 255)}.  A byte corresponds to its two's complement
representation as an octet.

@menu
* iklib bytevectors sub::       Building subbytevectors.
* iklib bytevectors conv::      Converting bytevectors.
* iklib bytevectors generic::   Generic bytevectors operations.
@end menu

@c page
@node iklib bytevectors sub
@subsection Building subbytevectors


The following bindings are exported by the @library{ikarus} library.


@defun subbytevector-u8 @var{bv} @var{start}
@defunx subbytevector-u8 @var{bv} @var{start} @var{end}
Build and return a new bytevector holding the bytes in @var{bv} from
index @var{start} (inclusive) to index @var{end} (exclusive).  The start
and end indexes must be such that:

@example
0 <= @var{start} <= @var{end} <= (bytevector-length @var{bv})
@end example
@end defun


@defun subbytevector-u8/count @var{bv} @var{start} @var{count}
Build and return a new bytevector holding @var{count} bytes in @var{bv}
from index @var{start} (inclusive).  The start index and the byte count
must be such that:

@example
0 <= @var{start} <= @var{start} + @var{count} <= (bytevector-length @var{bv})
@end example
@end defun


@defun subbytevector-s8 @var{bv} @var{start}
@defunx subbytevector-s8 @var{bv} @var{start} @var{end}
Build and return a new bytevector holding the bytes in @var{bv} from
index @var{start} (inclusive) to index @var{end} (exclusive).  The start
and end indexes must be such that:

@example
0 <= @var{start} <= @var{end} <= (bytevector-length @var{bv})
@end example
@end defun


@defun subbytevector-s8/count @var{bv} @var{start} @var{count}
Build and return a new bytevector holding @var{count} bytes in @var{bv}
from index @var{start} (inclusive).  The start index and the byte count
must be such that:

@example
0 <= @var{start} <= @var{start} + @var{count} <= (bytevector-length @var{bv})
@end example
@end defun

@c page
@node iklib bytevectors conv
@subsection Converting bytevectors


These conversion functions work like @func{bytevector->u8-list} and
@func{u8-list->bytevector}.  The following bindings are exported by the
@library{ikarus} library.


@defun {bytevector->s8-list} @var{bytevector}
@defunx {s8-list->bytevector} @var{list}
Convert between a list of signed bytes and a bytevector.
@end defun


@defun s16l-list->bytevector @var{list}
@defunx s16b-list->bytevector @var{list}
@defunx s16n-list->bytevector @var{list}
@defunx u16l-list->bytevector @var{list}
@defunx u16b-list->bytevector @var{list}
@defunx u16n-list->bytevector @var{list}
@defunx bytevector->s16l-list @var{bytevector}
@defunx bytevector->s16b-list @var{bytevector}
@defunx bytevector->s16n-list @var{bytevector}
@defunx bytevector->u16l-list @var{bytevector}
@defunx bytevector->u16b-list @var{bytevector}
@defunx bytevector->u16n-list @var{bytevector}
Convert between a list of signed or unsigned 16-bit words and a
bytevector in which the words are stored in little, big or native
endianness.
@end defun


@defun s32l-list->bytevector @var{list}
@defunx s32b-list->bytevector @var{list}
@defunx s32n-list->bytevector @var{list}
@defunx u32l-list->bytevector @var{list}
@defunx u32b-list->bytevector @var{list}
@defunx u32n-list->bytevector @var{list}
@defunx bytevector->s32l-list @var{bytevector}
@defunx bytevector->s32b-list @var{bytevector}
@defunx bytevector->s32n-list @var{bytevector}
@defunx bytevector->u32l-list @var{bytevector}
@defunx bytevector->u32b-list @var{bytevector}
@defunx bytevector->u32n-list @var{bytevector}
Convert between a list of signed or unsigned 32-bit words and a
bytevector in which the words are stored in little, big or native
endianness.
@end defun


@defun s64l-list->bytevector @var{list}
@defunx s64b-list->bytevector @var{list}
@defunx s64n-list->bytevector @var{list}
@defunx u64l-list->bytevector @var{list}
@defunx u64b-list->bytevector @var{list}
@defunx u64n-list->bytevector @var{list}
@defunx bytevector->s64l-list @var{bytevector}
@defunx bytevector->s64b-list @var{bytevector}
@defunx bytevector->s64n-list @var{bytevector}
@defunx bytevector->u64l-list @var{bytevector}
@defunx bytevector->u64b-list @var{bytevector}
@defunx bytevector->u64n-list @var{bytevector}
Convert between a list of signed or unsigned 64-bit words and a
bytevector in which the words are stored in little, big or native
endianness.
@end defun


@defun f4l-list->bytevector @var{list}
@defunx f4b-list->bytevector @var{list}
@defunx f4n-list->bytevector @var{list}
@defunx bytevector->f4l-list @var{bytevector}
@defunx bytevector->f4b-list @var{bytevector}
@defunx bytevector->f4n-list @var{bytevector}
Convert between a list of single--precision flonums and a bytevector in
which the flonums are stored in little, big or native endianness.
@end defun


@defun f8l-list->bytevector @var{list}
@defunx f8b-list->bytevector @var{list}
@defunx f8n-list->bytevector @var{list}
@defunx bytevector->f8l-list @var{bytevector}
@defunx bytevector->f8b-list @var{bytevector}
@defunx bytevector->f8n-list @var{bytevector}
Convert between a list of double--precision flonums and a bytevector in
which the flonums are stored in little, big or native endianness.
@end defun


@defun c4l-list->bytevector @var{list}
@defunx c4b-list->bytevector @var{list}
@defunx c4n-list->bytevector @var{list}
@defunx bytevector->c4l-list @var{bytevector}
@defunx bytevector->c4b-list @var{bytevector}
@defunx bytevector->c4n-list @var{bytevector}
Convert between a list of single--precision cflonums and a bytevector in
which the cflonums are stored in little, big or native endianness, real
part first.
@end defun


@defun c8l-list->bytevector @var{list}
@defunx c8b-list->bytevector @var{list}
@defunx c8n-list->bytevector @var{list}
@defunx bytevector->c8l-list @var{bytevector}
@defunx bytevector->c8b-list @var{bytevector}
@defunx bytevector->c8n-list @var{bytevector}
Convert between a list of double--precision cflonums and a bytevector in
which the flonums are stored in little, big or native endianness, real
part first.
@end defun

@c page
@node iklib bytevectors generic
@subsection Generic bytevectors operations


The following bindings are exported by the @library{ikarus} library.


@defun bytevector-append @var{bytevector} ...
Concatenate the bytevector arguments and return the result.  If no
arguments are given: return the empty bytevector.
@end defun

@c page
@node iklib strings
@section Additional string functions


The following bindings are exported by the @library{ikarus} library.


@defun string-copy! @var{src.str} @var{src.start} @var{dst.str} @var{dst.start} @var{count}
Copy @var{count} characters from @var{src.str} starting at
@var{src.start} (inclusive) to @var{dst.str} starting at
@var{dst.start}.  Return unspecified values.
@end defun


@defun string->latin1 @var{string}
@defunx latin1->string @var{bytevevctor}
Convert to and from a Scheme string and a Scheme bytevector holding the
Latin-1 encoding of the characters.
@end defun


@defun string->ascii @var{string}
@defunx ascii->string @var{bytevevctor}
Convert to and from a Scheme string and a Scheme bytevector holding the
@ascii{} encoding of the characters.
@end defun


@defun string->utf16le @var{string}
@defunx string->utf16be @var{string}
@defunx string->utf16n @var{string}
@defunx utf16le->string @var{bytevector}
@defunx utf16be->string @var{bytevector}
@defunx utf16n->string @var{bytevector}
Convert to and from a Scheme string and a Scheme bytevector holding the
@utf{}-16 encoding of the characters under little, big or native
endianness respectively.
@end defun


@defun uuid
Attempt to build a unique string and return it.  If an internal error
occurs because of impossible generation: raise an error.
@end defun

@c page
@node iklib vectors
@section Additional vector functions


The following bindings are exported by the @library{ikarus} library.


@defun subvector @var{vec} @var{start} @var{end}
@var{vec} must be a vector, and @var{start} and @var{end} must be exact
integer objects satisfying:

@example
0 <= @var{start} <= @var{end} <= (vector-length @var{vec})
@end example

Return a newly allocated vector formed from the items of @var{vec}
beginning with index @var{start} (inclusive) and ending with index
@var{end} (exclusive).
@end defun


@defun vector-append @var{vec} ...
Return a newly allocated vector whose items form the concatenation of
the given vectors.
@end defun


@defun vector-copy @var{vec}
Return a newly allocated copy of the given vector.
@end defun


@defun vector-copy! @var{src.vec} @var{src.start} @var{dst.vec} @var{dst.start} @var{count}
Copy @var{count} items from @var{src.vec} starting at @var{src.start}
(inclusive) to @var{dst.vec} starting at @var{dst.start}.  Return
unspecified values.
@end defun


@deffn Procedure vector-for-all @var{proc} @vari{vec} @varii{vec} @dots{} @varn{vec}
@deffnx Procedure vector-exists @var{proc} @vari{vec} @varii{vec} @dots{} @varn{vec}
The @var{vec}s should all have the same length, and @var{proc} should
accept @math{N} arguments and return a single value.  @var{proc} should
not mutate the @var{vec} arguments.

For natural numbers @math{i = 0, 1, @dots{}}, the @func{vector-for-all}
procedure successively applies @var{proc} to arguments @math{x_i^1
@dots{} x_i^N}, where @math{x_i^j} is the @math{i}-th element of
@var{vecj}, until @false{} is returned.

If @var{proc} returns true values for all but the last element of
@vari{vec}, @func{vector-for-all} performs a tail call of @var{proc} on
the @math{k}-th elements, where @math{k} is the length of @vari{vec}.
If @var{proc} returns @false{} on any set of elements,
@func{vector-for-all} returns @false{} after the first such application
of @var{proc}.  If the @var{vec}s are all empty, @func{vector-for-all}
returns @true{}.

For natural numbers @math{i = 0, 1, @dots{}}, the @func{vector-exists}
procedure applies @var{proc} successively to arguments @math{x_i^1
@dots{} x_i^n}, where @math{x_i^j} is the @math{i}-th element of
@var{vecj}, until a true value is returned.

If @var{proc} returns @false{} for all but the last elements of the
@var{vec}s, @func{vector-exists} performs a tail call of @var{proc} on
the @math{k}-th elements, where @math{k} is the length of @vari{vec}.
If @var{proc} returns a true value on any set of elements,
@func{vector-exists} returns that value after the first such application
of @var{proc}.  If the @var{vec}s are all empty, @func{vector-exists}
returns @false{}.

@var{proc} is always called in the same dynamic environment as
@func{vector-for-all} or, respectively, @func{vector-exists} itself.
@end deffn

@c page
@node iklib symbols
@section Additional symbol functions


@menu
* iklib symbols value::         Symbol values.
* iklib symbols plists::        Property lists.
@end menu

@c page
@node iklib symbols value
@subsection Symbol values


Symbol values have miscellaneous uses: when a symbol is the unique
identifier for a data structure, its symbol value field is set to the
type descriptor of the data structure; when a symbol is the unique label
of a binding in the expander, its symbol value is a reference to the
binding.  @ref{syslib symbols} for more details on symbol values.

The following bindings are exported by the @library{ikarus} and the
@library{ikarus symbols} libraries.


@defun set-symbol-value! @var{sym} @var{value}
Store @var{value} in the @func{$symbol-value} field of the symbol
@var{sym}.
@end defun


@defun symbol-value @var{sym}
Return the value in the @func{$symbol-value} field of the symbol
@var{sym}.
@end defun


@defun symbol-bound? @var{sym}
Return true if @var{sym} is a symbol and its @func{$symbol-value} field
is set to the special ``unbound'' machine word value.
@end defun

@c page
@node iklib symbols plists
@subsection Property lists


Property lists are associations key/value that can be attached to any
Scheme symbol.  The following bindings are exported by the
@library{ikarus} and the @library{ikarus symbols} libraries.

@example
#!ikarus
(import (ikarus))

(putprop 'ciao 'british 'hello)
(putprop 'ciao 'spanish 'hola)

(getprop 'ciao 'british)        @result{} hello
(getprop 'ciao 'spanish)        @result{} hola

(remprop 'ciao 'british)
(getprop 'ciao 'british)        @result{} #f

(property-list 'ciao)           @result{} ((spanish . hola))
@end example


@defun putprop @var{symbol} @var{key} @var{value}
Add a new property @var{key} with @var{value} to the property list of
@var{symbol}.  @var{key} must be a symbol, @var{value} can be any value.

If @var{key} is already set: the old entry is mutated to reference the
new @var{value}.
@end defun


@defun getprop @var{symbol} @var{key}
Return the value of the property @var{key} in the property list of
@var{symbol}; if @var{key} is not set return false.  @var{key} must be a
symbol.
@end defun


@defun remprop @var{symbol} @var{key}
Remove property @var{key} from the list associated to @var{symbol}.
@end defun


@defun property-list @var{symbol}
Return a new association list representing the property list of
@var{symbol}.  The order of the entries is the same as the property
creation order.
@end defun

@c page
@node iklib numerics
@section Additional functions on numbers


@menu
* iklib numerics preds::        Additional numeric predicates.
* iklib numerics flonums::      Additional flonum functions.
* iklib numerics math::         Additional math functions.
@end menu

@c page
@node iklib numerics preds
@subsection Additional numeric predicates


The following bindings are exported by the @library{ikarus} and
@library{vicare} libraries.


@defun bignum? @var{obj}
Return true if @var{obj} is an exact integer represented by a big
number.
@end defun


@defun ratnum? @var{obj}
Return true if @var{obj} is an exact rational number.
@end defun


@defun cflonum? @var{obj}
Return true if @var{obj} is a complex number having flonums as both real
and imaginary parts.
@end defun


@defun compnum? @var{obj}
Return true if @var{obj} is a complex number having any possible
combination of number representations as real and imaginary parts, but
not both flonums.
@end defun

@c page
@node iklib numerics flonums
@subsection Additional flonum functions


The following bindings are exported by the @library{ikarus} and
@library{vicare} libraries.

@c ------------------------------------------------------------

@subsubheading Exponents and logarithms


@defun fllog1p @var{fl}
Return a flonum equivalent to @math{log(1 + @var{fl})}.
@end defun


@defun flexpm1 @var{fl}
Return a flonum equivalent to @math{exp(@var{fl}) - 1}.
@end defun


@c page
@node iklib numerics math
@subsection Additional math functions


The following bindings are exported by the @library{ikarus} and
@library{vicare} libraries.

@c ------------------------------------------------------------

@subsubheading Hyperbolic functions

The @var{num} operand must be a real or complex number.


@defun sinh @var{num}
@defunx cosh @var{num}
@defunx tanh @var{num}
Hyperbolic functions.
@end defun


@defun asinh @var{num}
@defunx acosh @var{num}
@defunx atanh @var{num}
Inverse hyperbolic functions.
@end defun

@c page
@node iklib enumerations
@section Additional functions on enumerations


The following bindings are exported by the @library{ikarus} and
@library{vicare} libraries.


@defun enum-set? @var{obj}
Return @true{} if @var{obj} is an enumeration set object, else return
@false{}.
@end defun

@c page
@node iklib load
@section Loading source files


Loading of source files can be done explicitly or by requesting a
library with the @func{import} form.  Here we see how to load files by
specifying their pathname on the file system.


@defun load @var{pathname}
@defunx load @var{pathname} @var{eval-proc}
Read and evaluate the file selected by the string @var{pathname}.

If @var{eval-proc} is given: it must be a procedure that takes a single
argument, an annotated form, and evaluates it.  The default
@var{eval-proc} looks like this:

@example
(define (load-handler x)
  (eval x (interaction-environment)))
@end example

The format of the annotated source is the one which is comprehensible by
@func{eval}.
@end defun

@c page
@node iklib import
@section Local library imports


@deffn Syntax import import-spec* ...
The @func{import} keyword which is exported from the @library{ikarus}
library can be used anywhere definitions can occur: at a script body,
library's top--level, or in internal definitions context.  The syntax of
the local @func{import} form is similar to the @func{import} that
appears at the top of a library or a script form, and carries with it
the same restrictions: no identifier name may be imported twice unless
it denotes the same identifier; no identifier may be both imported and
defined; and imported identifiers are immutable.

Local @func{import} forms are useful for two reasons: (1) they minimize
the namespace clutter that usually occurs when many libraries are
imported at the top level, and (2) they limit the scope of the import
and thus help modularize a library's dependencies.

Suppose you are constructing a large library and at some point you
realize that one of your procedures needs to make use of some other
library for performing a specific task.  Importing that library at top
level makes it available for the entire library.  Consequently, even if
that library is no longer used anywhere in the code (say when the code
that uses it is deleted), it becomes very hard to delete the import
without first examiniming the entire library body for potential usage
leaks.  By locally importing a library into the appropriate scope, we
gain the ability to delete the @func{import} form when the procedure
that was using it is deleted.
@end deffn

@c page
@node iklib modules
@section Local modules


Modules are somewhat like libraries in that they define a set of
bindings in a ``private namespace''; bindings can be exported from a
module and imported into other modules and libraries.  The main
difference between modules and @rnrs{6} libraries is that modules are
defined in a single form nested into a library; so, in a way, they are
sub--libraries.

@quotation
@strong{NOTE} In the official documentation of @value{PRJNAME} 0.0.3+
(revision 1648) modules are yet not documented.  Please refer to Section
10.5 of Chez Scheme User's Guide, Chapter 3 of Oscar Waddel's Ph.D
Thesis, and its POPL99 paper for details on using the @func{module} and
@func{import} keywords.  @value{PRJNAME}'s internal module system is
similar in spirit to that of Chez Scheme.
@end quotation

@menu
* iklib modules examples::      Usage example for modules.
* iklib modules api::           Modules programming interface.
@end menu

@c page
@node iklib modules examples
@subsection Usage example for modules


@menu
* iklib modules examples anonymous:: Anonymous modules.
* iklib modules examples named::     Named modules.
* iklib modules examples utils::     Utilities examples.
@end menu

@c page
@node iklib modules examples anonymous
@subsubsection Anonymous modules


The following example defines an anonymous module, without expressions,
and invokes its functions from the enclosing environment (which is the
top level):

@example
(import (ikarus))

(module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (cons 'three (hidden)))
    (define (hidden)    'hidden))

(printf "calling anonymous: ~s ~s ~s~%" (one) (two) (three))
@end example

@noindent
notice that the @func{hidden} function is visible inside the module but
not in the enclosing environment.

The following example defines a module, with expressions, and invokes
its functions from the enclosing environment (which is the top level):

@example
(import (ikarus))

(module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (cons 'three (hidden)))
    (define (hidden)    'hidden)

    (printf "defining an anonymous module~%"))

(printf "calling anonymous: ~s ~s ~s~%" (one) (two) (three))
@end example

@noindent
notice that when the enclosing environment is the top level: the
expressions at the end of a module are evaluated @strong{after} the
expressions at the top level; so the output from the example is:

@example
calling anonymous: one two (three . hidden)
defining an anonymous module
@end example

@noindent
this can lead to undesired results if the module's expressions are meant
to initialise the state of the module, and the expressions at the top
level invoke the module's functions (before initialisation).  On the
other hand: this behaviour allows the module to access definitions from
the enclosing environment and the top level environment despite their
placement in the file; see below for an example.  The same behaviour is
shown by named modules.

The following example defines a module, with expressions, and invokes
its functions from the enclosing environment (which is a @func{let}
form):

@example
(import (ikarus))

(let ()
  (module (one two three)
      (define (one)       'one)
      (define (two)       'two)
      (define (three)     (cons 'three (hidden)))
      (define (hidden)    'hidden)

      (printf "defining an anonymous module~%"))

  (printf "calling anonymous: ~s ~s ~s~%" (one) (two) (three)))
@end example

@noindent
notice that when the enclosing environment is @strong{not} the top
level: the expressions at the end of a module are evaluated
@strong{before} the expressions in the body of the enclosing
environment; so the output from the example is:

@example
defining an anonymous module
calling anonymous: one two (three . hidden)
@end example

@noindent
so the state of the module can be correctly initialised before its
functions are invoked.  The same behaviour is shown by named modules.

The following example shows that bindings from the enclosing environment
and the top level environment are accessible from the modules:

@example
(import (ikarus))

(define (top-level-before) 'top-level-before)

(let ()

  (define (outer-before) 'outer-before)

  (module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (list 'three
                              (outer-before)
                              (outer-after)
                              (top-level-before)
                              (top-level-after))))

  (define (outer-after) 'outer-after)

  (printf "calling anonymous: ~s ~s ~s~%" (one) (two) (three)))

(define (top-level-after) 'top-level-after)
@end example

@noindent
this happens both when the enclosing environment is the top level and
when the enclosing environment is not the top level.  The same behaviour
is shown by named modules.

@c page
@node iklib modules examples named
@subsubsection Named modules


The following example defines a module named @code{blue} and invokes
functions from it in the top level environment:

@example
(import (ikarus))

[module blue (blue-one blue-two blue-three)
    (define (blue-one)          'blue-one)
    (define (blue-two)          'blue-two)
    (define (blue-three)        (cons 'blue-three (hidden)))
    (define (hidden)            'blue-hidden)]

(import blue)
(printf "calling blue: ~s ~s ~s~%"
        (blue-one) (blue-two) (blue-three))
@end example

@noindent
notice that bindings from a named module are accessible only if imported
in the enclosing environment.

The following example defines two modules named @code{green} and
@code{red}, then it imports their bindings in different environments:

@example
(import (ikarus))

(let ()

  [module green (one two three)
    (define (one)       'green-one)
    (define (two)       'green-two)
    (define (three)     (cons 'green-three (hidden)))
    (define (hidden)    'green-hidden)]

  [module red (one two three)
    (define (one)       'red-one)
    (define (two)       'red-two)
    (define (three)     (cons 'red-three (hidden)))
    (define (hidden)    'red-hidden)]

  (import green)

  [let ()
    (import red)
    (printf "calling red: ~s ~s ~s~%" (one) (two) (three))]

  (printf "calling green: ~s ~s ~s~%" (one) (two) (three)))
@end example

The following example shows that modules in the same enclosing
environment can import their bindings:

@example
(import (ikarus))

(let ()

  [module green (one two)
    (define (one)       'one)
    (define (two)       'two)]

  [module red (f g)
    (import green)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two)))]

  (import red)
  (printf "calling red: ~s ~s~%" (f) (g)))
@end example

@noindent
while the following example shows that bindings from an anonymous module
are automatically available in modules defined in the same enclosing
environment:

@example
(import (ikarus))

(let ()

  [module (one two)
    (define (one)       'one)
    (define (two)       'two)]

  [module red (f g)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two)))]

  (import red)
  (printf "calling red: ~s ~s~%" (f) (g)))
@end example

@noindent
and the following example shows that the order of module definitions
does not matter in determining visibility of bindings from
@strong{anonymous} modules:

@example
(import (ikarus))

(let ()

  [module red (f g)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two)))]

  [module (one two)
    (define (one)       'one)
    (define (two)       'two)]

  (import red)
  (printf "calling red: ~s ~s~%" (f) (g)))
@end example

@noindent
the following is an @strong{error} because it tries to import bindings
from a @strong{named} module before its definition:

@example
(import (ikarus))

(let ()

  [module red (f g)
    (import green)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two)))]

  [module green (one two)
    (define (one)       'one)
    (define (two)       'two)]

  (import red)
  (printf "calling red: ~s ~s~%" (f) (g)))
@end example

@c page
@node iklib modules examples utils
@subsubsection Utilities examples


The following example shows how syntactic abstractions can be used to
access definitions in a module without using the @func{import} form:

@example
(import (ikarus))

(let ()

  (define-syntax in-module
    (syntax-rules ()
      [(_ ?module ?expr ...)
       (let () (import ?module) ?expr ...)]))

  [module red (one two)
    (define (one arg)   (cons 'red-one arg))
    (define (two arg)   (cons 'red-two arg))]

  [module green (one two)
    (define (one arg)   (cons 'green-one arg))
    (define (two arg)   (cons 'green-two arg))]

  (printf "calling ones: ~s ~s~%"
          [(in-module red one)   123]
          [(in-module green one) 456]))
@end example

@c page
@node iklib modules api
@subsection Modules programming interface


@deffn Syntax module @var{interface} @var{definitions} ... @var{expressions} ...
@deffnx Syntax module @var{name} @var{interface} @var{definitions} ... @var{expressions} ...
Define a new local module.  The first form defines an @emph{anonymous}
module, while the second form defines a @emph{named} module called
@var{name}, which must be a symbol.

@var{interface} is a list of symbols that select bindings from this
module to be exported.  Every listed symbol must be bound in this
module's @var{definitions}, otherwise an error is raised.

@var{definitions} is a set of bindings like the one that may appear at
the beginning of a @func{let} body, with the addition of @func{import}
forms that may import bindings from libraries and other modules.

@var{expressions} is a set of expressions that is evaluated at module's
definition time.

Modules ``exist'' only in the enclosing region, bindings exported from a
module are not accessible outside of the enclosing region.  Modules can
be nested and import/export relations are possible according to the
regions nesting hierarchy.

Bindings in the @var{interface} declared by anonymous modules are
imported by default in the enclosing region: there is no need to use
@func{import}.  Bindings in the @var{interface} declared by named
modules are visible only in regions that @func{import} the module.

@var{definitions} and @var{expressions} have no default access to the
bindings in the enclosing region; only imported bindings are visible
from the module.
@end deffn

@c page
@node iklib parameters
@section Parameters


Parameters in @value{PRJNAME} are intended for customizing the behavior
of a procedure during the dynamic execution of some piece of code.
Parameters are first class entities (represented as procedures) that
hold the parameter value.  We can think of a parameter functions as:

@example
(let ((the-value @meta{init-value})
      (guard     @meta{guard-func}))
  (case-lambda
    (()
     the-value)
    ((new-value)
     (set! the-value (guard new-value)))
    ((new-value guard?)
     (if guard?
         (set! the-value (guard new-value))
       (set! the-value new-value)))))
@end example

@noindent
where @meta{init-value} is the parameter's initialisation value and
@meta{guard-func} is a function accepting one argument and returning one
value.  The behaviour is as follows:

@itemize
@item
When given no arguments: it returns the current value of the parameter.

@item
When given a single argument: it sets the current value of the parameter
to the return value of the guard function applied to the argument.

@item
When given two arguments: it sets the current value of the parameter to
either the return value of the guard function applied to the first
argument or directly to the first argument.
@end itemize

As of @value{PRJNAME} version 0.2d7 the parameter's initialisation value
is @strong{not} automatically passed through the guard function.  About
guarding or not the initialisation value there are pros and cons for
both the choices; @value{PRJNAME} does not guard the initialisation
value because a parameter can be used to hold ``complex'' objects and it
is not always desirable to create one of those at program start time.
When needed it is possible to validate the value by explicitly writing
the required predicate.

@quotation
As example, consider a parameter used to hold the ``current database
connection''; we may not want to connect to a database right at program
start time.  With a validating parameter: we should create a ``null''
connection object for the only purpose of initialising the parameter and
then test for it; with a non--validating parameter: we just initialise
the parameter to @false{} and test for it.
@end quotation

Parameters replace the older concept of using starred @code{*global*}
customization variables.  For example, instead of writing:

@example
(define *screen-width* 72)
@end example

@noindent
and then mutating the variable @code{*screen-width*} with @code{set!},
we could wrap the variable @code{*screen-width*} with a
@code{screen-width} parameter as follows:

@example
(define *screen-width* 72)
(define screen-width
   (case-lambda
     (()  *screen-width*)
     ((x) (set! *screen-width* x))))
@end example

@noindent
the value of @code{screen-width} can now be passed as argument, returned
as a value, and exported from libraries.  With parameters we can write
this code succinctly as:

@example
(define screen-width (make-parameter 72))
@end example

Typical uses of the guard function include checking some constraints on
the passed argument or converting it to a different data type.  The
@code{screen-width} parameter may be constructed more robustly as:

@example
(define screen-width
  (make-parameter 72
    (lambda (w)
      (assert (and (integer? w) (exact? w)))
      (max w 1))))
@end example

@noindent
this definition ensures, through @func{assert}, that the argument passed
is an exact integer; it also ensures, through @func{max} that the
assigned value is always positive.


@deffn Procedure make-parameter @var{init}
@deffnx Procedure make-parameter @var{init} @var{guard}
Build and return a new parameter function using @var{init} as
initialisation value and @var{guard} as guard function.
@end deffn


@deffn Syntax parameterize ((lhs* rhs*) ...) body body* ...
@deffnx Syntax parametrise ((lhs* rhs*) ...) body body* ...
Parameters can be assigned to by simply calling the parameter procedure
with a single argument.  The @func{parameterize} syntax is used to set
the value of a parameter within the dynamic extent of the @code{body
body* ...} expressions.

The @code{lhs* ...} are expressions, each of which must evaluate to a
parameter.  Such parameters are not necessarily constructed by
@func{make-parameter}---any procedure that follows the parameters
protocol works.

The advantage of using @func{parameterize} over explicitly assigning to
parameters (same argument applies to global variables) is that you're
guaranteed that whenever control exits the body of a @func{parameterize}
expression, the value of the parameter is reset back to what it was
before the body expressions were entered.  This is true even in the
presence of @func{call/cc}, errors, and exceptions.

The following example shows how to set the text property of a terminal
window.  The parameter @code{terminal-property} sends an @ansi{} escape
sequence to the terminal whenever the parameter value is changed.  The
use of @code{terminal-property} within @func{parameterize} changes the
property before @code{(display "RED!")} is called and resets it back to
normal when the body returns.

@example
(define terminal-property
  (make-parameter "0"
    (lambda (x)
      (display "\x1b;[")
      (display x)
      (display "m")
      x)))

(display "Normal and ")
(parameterize ((terminal-property "41;37"))
  (display "RED!"))
(newline)
@end example

Notice that this syntax applies the parameters' guard functions when
setting new values, but does @strong{not} apply them when restoring the
original value.
@end deffn

@c page
@node iklib gensym
@section Gensyms


Gensym stands for @emph{generated symbol}---a fresh symbol that is
generated at run time and is guaranteed to be @emph{not} @func{eq?} to
any other symbol present in the system.  Gensyms are useful in many
applications including expanders, compilers, and interpreters when
generating an arbitrary number of unique names is needed.

@value{PRJNAME} is similar to Chez Scheme in that the readers (including the
@func{read} procedure) and writers (including @func{write} and
@func{pretty-print}) maintain the read/write invariance on gensyms.
When a gensym is written to an output port, the system automatically
generates a random unique identifier for the gensym.  When the gensym is
read back though the @code{#@{gensym@}} read syntax, a new gensym is
@emph{not} regenerated, but instead, it is looked up in the global
symbol table.

A gensym's name is composed of two parts: a @emph{pretty} string and a
@emph{unique} string.  The Scheme procedure @func{symbol->string}
returns the pretty string of the gensym and not its unique string.
Gensyms are printed by default as @code{#@{pretty-string unique-string@}}.

The reader supports special syntaxes to generate symbols, @ref{iklib
reader stx}.


@deffn Procedure gensym
@deffnx Procedure gensym @var{string}
@deffnx Procedure gensym @var{symbol}
Construct a new gensym.  If passed no arguments, construct a gensym with
no pretty name.  The pretty name is constructed when and if the pretty
name of the resulting gensym is needed.  If @func{gensym} is passed a
string, that string is used as the pretty name.  If @func{gensym} is
passed a symbol, the pretty name of the symbol is used as the pretty
name of the returned gensym.  See @func{gensym-prefix} and
@func{gensym-count} for details.

@example
> (gensym)
#@{g0 |y0zf>GlFvcTJE0xw|@}
> (gensym)
#@{g1 |U%X&sF6kX!YC8LW=|@}
> (eq? (gensym) (gensym))
#f
@end example

@code{(gensym string)} constructs a new gensym with @var{string} as its
pretty name.  Similarly, @code{(gensym symbol)} constructs a new gensym
with the pretty name of @var{symbol}, if it has one, as its pretty name.

@example
> (gensym "foo")
#@{foo |>VgOllCM&$dSvRN=|@}
> (gensym 'foo)
#@{foo |!TqQLmtw2hoEYfU>|@}
> (gensym (gensym 'foo))
#@{foo |N2C>5O0>C?OROUBU|@}
@end example
@end deffn


@deffn Procedure gensym? @var{x}
Return @true{} if its argument is a gensym, return @false{} otherwise.

@example
> (gensym? (gensym))
#t
> (gensym? 'foo)
#f
> (gensym? 12)
#f
@end example
@end deffn


@deffn Procedure gensym->unique-string @var{gensym}
Return the unique name associated with the gensym argument.

@example
> (gensym->unique-string (gensym))
"YukrolLMgP?%ElcR"
@end example
@end deffn

@c ------------------------------------------------------------

@subsubheading An example

The @library{rnrs syntax-case} library provides a
@func{generate-temporaries} procedure, which takes a syntax object
(representing a list of things) and returns a list of fresh identifiers.
Using @func{gensym}, that procedure can be defined as follows:

@example
(define (generate-temporaries* stx)
  (syntax-case stx ()
    [(x* ...)
     (map (lambda (x)
            (datum->syntax #'unimportant
              (gensym
                (if (identifier? x)
                    (syntax->datum x)
                    't))))
          #'(x* ...))]))
@end example

The above definition works by taking the input @var{stx} and
destructuring it into the list of syntax objects @code{x* ...}.  The
inner procedure maps each @var{x} into a new syntax object (constructed
with @func{datum->syntax}).  The datum is a gensym, whose name is the
same name as @var{x} if @var{x} is an identifier, or the symbol @code{t}
if @var{x} is not an identifier.  The output of
@func{generate-temporaries*} generates names similar to their input
counterpart:

@example
> (print-gensym #f)
> (generate-temporaries* #'(x y z 1 2))
(#<syntax x> #<syntax y> #<syntax z> #<syntax t> #<syntax t>)
@end example

@c page
@node iklib printing
@section Printing


@deffn Procedure pretty-print @var{datum}
@deffnx Procedure pretty-print @var{datum} @var{output-port}
The procedure @func{pretty-print} is intended for printing Scheme data,
typically Scheme programs, in a format close to how a Scheme programmer
would write it.  Unlike @func{write}, which writes its input all in one
line, @func{pretty-print} inserts spaces and new lines in order to
produce more pleasant output.

@example
(define fact-code
  '(letrec ([fact (lambda (n)
                    (if (zero? n)
                        1
                      (* n (fact (- n 1)))))])
     (fact 5)))

> (pretty-print fact-code)
(letrec ((fact
          (lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))))
  (fact 5))
@end example

The second argument to @func{pretty-print}, if supplied, must be an
output port.  If not supplied, the @func{current-output-port} is used.

@quotation
@strong{LIMITATIONS} As shown in the output above, the current
implementation of @func{pretty-print} does not handle printing of square
brackets properly.
@end quotation
@end deffn


@defun pretty-print* @var{datum} @var{output-port} @var{start-column} @var{ending-newline?}
Like @func{pretty-print} but accepts the additional arguments:

@table @var
@item start-column
A non--negative fixnum.  The zero--based column offset at which the
first line is displayed.  When printing a multiline symbolic expression,
the column offset of the first line depends upon what has been already
printed on such line; this argument allows us to correctly align the
second and subsequent lines.  For example the following program:

@example
#!r6rs
(import (vicare))

(pretty-width 10)
(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))

(display "01234")
(pretty-print  '("56789" "8 7 6 5"))

(newline)

(display "01234")
(pretty-print* '("56789" "8 7 6 5")
               (current-output-port) 5 #t)
@end example

@noindent
prints:

@example
01234("56789"
  "8 7 6 5")

01234("56789"
       "8 7 6 5")
@end example

@item ending-newline?
Interpreted as boolean value.  If true: a newline character is output
after the symbolic expression.
@end table
@end defun


@deffn Parameter pretty-width
@deffnx Parameter pretty-width @var{n}
The parameter @func{pretty-width} controls the number of characters
after which the @func{pretty-print} starts breaking long lines into
multiple lines.  The initial value of @func{pretty-width} is set to 60
characters, which is suitable for most terminals and printed material.

@example
> (parameterize ([pretty-width 40])
     (pretty-print fact-code))
(letrec ((fact
          (lambda (n)
            (if (zero? n)
                1
                (* n (fact (- n 1)))))))
  (fact 5))
@end example

Note that @func{pretty-width} does not guarantee that the output will
not extend beyond the specified number.  Very long symbols, for
examples, cannot be split into multiple lines and may force the printer
to go beyond the value of @func{pretty-width}.
@end deffn


@deffn Procedure format @var{fmt-string} @var{args} ...
The procedure @func{format} produces a string formatted according to
@func{fmt-string} and the supplied arguments.  The format string
contains markers in which the string representation of each argument is
placed.  The markers include:

@table @code
@item ~s
instructs the formatter to place the next argument as if the procedure
@func{write} has printed it; if the argument contains a string, the
string will be quoted and all quotes and backslashes in the string will
be escaped; similarly, characters will be printed using the @code{#\x}
notation;

@item ~a
instructs the formatter to place the next argument as if the procedure
@func{display} has printed it; strings and characters are placed as they
are in the output;

@item ~b
instructs the formatter to convert the next argument to its binary (base
2) representation; the argument must be an exact number;

@item ~o
is similar to @code{~b} except that the number is printed in octal (base
8);

@item ~x
is similar to @code{~b} except that the number is printed in hexadecimal
(base 16);

@item ~d
outputs the next argument, which can be an exact or inexact number, in
its decimal (base 10) representation;

@item ~~
instructs the formatter to place a tilde character, @code{~}, in the
output without consuming an argument;

@item ~%
instructs the formatter to place a newline character in the output
without consuming an argument.
@end table

Note that the @code{#b}, @code{#o}, and @code{#x} numeric prefixes are
not added to the output when @code{~b}, @code{~o}, and @code{~x} are
used.

@example
> (format "message: ~s, ~s, and ~s" 'symbol "string" #\c)
"message: symbol, \"string\", and #\\c"

> (format "message: ~a, ~a, and ~a" 'symbol "string" #\c)
"message: symbol, string, and c"
@end example
@end deffn


@deffn Procedure printf @var{fmt-string} @var{args} ...
The procedure @func{printf} is similar to @func{format} except that the
output is sent to the @code{current-output-port} instead of being
collected in a string.

@example
> (let ([n (+ (expt 2 32) #b11001)])
    (printf "~d = #b~b = #x~x\n" n n n))
4294967321 = #b100000000000000000000000000011001 = #x100000019
@end example
@end deffn


@deffn Procedure fprintf @var{output-port} @var{fmt-string} @var{args} ...
The procedure @func{fprintf} is similar to @func{printf} except that the
output port to which the output is sent is specified as the first
argument.
@end deffn


@deffn Parameter print-unicode
@deffnx Parameter print-unicode #t
@deffnx Parameter print-unicode #f
If set to true: print Scheme Unicode characters outside of the printable
@ascii{} range in hex format, else print them using the encoding of the
output port.  The default is false.
@end deffn


@deffn Parameter print-gensym
@deffnx Parameter print-gensym #t
@deffnx Parameter print-gensym #f
@deffnx Parameter print-gensym 'pretty
The parameter @code{print-gensym} controls how gensyms are printed by
the various writers.

If the value of @code{print-gensym} is @false{}, then gensym syntax is
suppressed by the writers and only the gensyms' pretty names are
printed.  If the value of @code{print-gensym} is @true{}, then the full
@code{#@{pretty unique@}} syntax is printed.  Finally, if the value of
@code{print-gensym} is the symbol @code{pretty}, then gensyms are
printed using the @code{#:pretty} notation.

@example
> (parameterize ([print-gensym #f])
    (pretty-print (list (gensym) (gensym))))
(g0 g1)

> (parameterize ([print-gensym #t])
    (pretty-print (list (gensym) (gensym))))
(#@{g2 |KR1M2&CTt1<B0n/m|@} #@{g3 |FBAb&7NC6&=c82!O|@})

> (parameterize ([print-gensym 'pretty])
    (pretty-print (list (gensym) (gensym))))
(#:g4 #:g5)
@end example

The initial value of @code{print-gensym} is @true{}.

@end deffn


@deffn Parameter gensym-prefix
@deffnx Parameter gensym-prefix @var{string}
The parameter @code{gensym-prefix} specifies the string to be used as
the prefix to generated pretty names.  The default value of
@code{gensym-prefix} is the string @code{g}, which causes generated
strings to have pretty names in the sequence @code{g0}, @code{g1},
@code{g2}, etc.

@example
> (parameterize ([gensym-prefix "var"]
                 [print-gensym #f])
     (pretty-print (list (gensym) (gensym) (gensym))))
(var0 var1 var2)
@end example

Beware that the @code{gensym-prefix} controls how pretty names are
generated, and has nothing to do with how @func{gensym} constructs a new
gensym.  In particular, notice the difference between the output in the
first example with the output of the examples below:

@example
> (pretty-print
    (parameterize ([gensym-prefix "var"] [print-gensym #f])
      (list (gensym) (gensym) (gensym))))
(g3 g4 g5)

> (let ([ls (list (gensym) (gensym) (gensym))])
    (parameterize ([gensym-prefix "var"] [print-gensym #f])
      (pretty-print ls)))
(var5 var6 var7)
@end example
@end deffn


@deffn Parameter gensym-count
@deffnx Parameter gensym-count @var{n}
The parameter @code{gensym-count} determines the number which is
attached to the @code{gensym-prefix} when gensyms' pretty names are
generated.  The initial value of @code{gensym-count} is 0 and is
incremented every time a pretty name is generated.  It might be set to
any non-negative integer value.

@example
> (let ([x (gensym)])
    (parameterize ([gensym-count 100] [print-gensym #f])
      (pretty-print (list (gensym) x (gensym)))))
(g100 g101 g102)
@end example
@end deffn

Notice from all the examples so far that pretty names are generated in
the order at which the gensyms are printed, not in the order in which
gensyms were created.

@c page
@node iklib tracing
@section Tracing for debugging


@deffn Syntax trace-define (name . args) body body* ...
@deffnx Syntax trace-define name expression
The @func{trace-define} syntax is similar to @func{define} except that
the bound value, which must be a procedure, becomes a traced procedure.
A traced procedure prints its arguments when it is called and prints its
values when it returns.

@example
> (trace-define (fact n)
    (if (zero? n) 1 (* n (fact (- n 1)))))
> (fact 5)
|(fact 5)
| (fact 4)
| |(fact 3)
| | (fact 2)
| | |(fact 1)
| | | (fact 0)
| | | 1
| | |1
| | 2
| |6
| 24
|120
120
@end example

The tracing facility in @value{PRJNAME} preserves and shows tail recursion and
distinguishes it from non--tail recursion by showing tail calls starting
at the same line in which their parent was called.

@example
> (trace-define (fact n)
    (trace-define (fact-aux n m)
      (if (zero? n) m (fact-aux (- n 1) (* n m))))
    (fact-aux n 1))
> (fact 5)
|(fact 5)
|(fact-aux 5 1)
|(fact-aux 4 5)
|(fact-aux 3 20)
|(fact-aux 2 60)
|(fact-aux 1 120)
|(fact-aux 0 120)
|120
120
@end example

Moreover, the tracing facility interacts well with continuations and
exceptions.

@example
> (call/cc
    (lambda (k)
      (trace-define (loop n)
        (if (zero? n)
            (k 'done)
            (+ (loop (- n 1)) 1)))
      (loop 5)))
|(loop 5)
| (loop 4)
| |(loop 3)
| | (loop 2)
| | |(loop 1)
| | | (loop 0)
done
@end example
@end deffn


@deffn Syntax trace-lambda name args body body* ...
The @func{trace-lambda} macro is similar to @func{lambda} except that
the resulting procedure is traced: it prints the arguments it receives
and the results it returns.
@end deffn


@deffn Procedure make-traced-procedure @var{name} @var{proc}
The procedure @func{make-traced-procedure} takes a name (typically a
symbol) and a procedure.  It returns a procedure similar to @var{proc}
except that it traces its arguments and values.

@example
> (define (fact n)
    (if (zero? n)
        (lambda (k) (k 1))
        (lambda (k)
          ((fact (- n 1))
           (make-traced-procedure `(k ,n)
             (lambda (v)
               (k (* v n))))))))
> (call/cc
    (lambda (k)
      ((fact 5) (make-traced-procedure 'K k))))
|((k 1) 1)
|((k 2) 1)
|((k 3) 2)
|((k 4) 6)
|((k 5) 24)
|(K 120)
120
@end example
@end deffn


@deffn Syntax trace-define-syntax @meta{keyword} @meta{expression}
Like @func{define-syntax} but create a tracing transformer function.
Whenever the macro is expanded the transformer function will print its
argument (the input form) and its return value (the output form).
Example:

@example
(trace-define-syntax ciao
  (syntax-rules ()
    ((_ ?a)
     (list 1 ?a 3))))

(ciao 2)
@print{} |(ciao (ciao 2))
@print{} |(list 1 2 3)
@end example

@noindent
the first printed symbolic expression @code{(ciao (ciao 2))} shows the
called tranformer function @code{(ciao ---)} and its argument being the
input form @code{(ciao 2)}, filtered through @func{syntax->datum}.
@end deffn


@deffn Syntax trace-let-syntax @meta{bindings} @meta{form} ...
@deffnx Syntax trace-letrec-syntax @meta{bindings} @meta{form} ...
Like @func{let-syntax} and @func{letrec-syntax} but define tracing
transformer functions.
@end deffn

@c page
@node iklib timing
@section Timing


This section describes some of @value{PRJNAME}'s timing facilities which may be
useful for benchmarking and performance tuning.


@deffn Syntax time @var{expression}
The @func{time} macro performs the following: it evaluates
@var{expression}, then prints a summary of the run time statistics, then
returns the values returned by @var{expression}.  The run--time summary
includes the number of bytes allocated, the number of garbage collection
runs, and the time spent in both the mutator and the collector.

@example
> (let ()                                   ;;; 10 million
    (define ls (time (vector->list (make-vector 10000000))))
    (time (append ls ls))
    (values))
running stats for (vector->list (make-vector 10000000)):
    3 collections
    672 ms elapsed cpu time, including 547 ms collecting
    674 ms elapsed real time, including 549 ms collecting
    120012328 bytes allocated
running stats for (append ls ls):
    4 collections
    1536 ms elapsed cpu time, including 1336 ms collecting
    1538 ms elapsed real time, including 1337 ms collecting
    160000040 bytes allocated
@end example

@quotation
@emph{Note:} The output listed above is @emph{just a sample} that was
taken at some point on some machine.  The output on your machine at the
time you read this may vary.
@end quotation
@end deffn


@deffn Procedure time-it @var{who} @var{thunk}
The procedure @func{time-it} takes a datum denoting the name of the
computation and a thunk (i.e. a procedure with no arguments), invokes
the thunk, prints the stats, and returns the values obtained from
invoking the thunk.  If the value of @var{who} is non--false, @var{who}
is used when displaying the run--time statistics.  If the value of
@var{who} is @false{}, then no name for the computation is displayed.

@example
> (time-it "a very fast computation"
    (lambda () (values 1 2 3)))
running stats for a very fast computation:
    no collections
    0 ms elapsed cpu time, including 0 ms collecting
    0 ms elapsed real time, including 0 ms collecting
    24 bytes allocated
1
2
3

> (time-it #f (lambda () 12))
running stats:
    no collections
    0 ms elapsed cpu time, including 0 ms collecting
    0 ms elapsed real time, including 0 ms collecting
    0 bytes allocated
12
@end example
@end deffn


@defun time-and-gather @var{gather} @var{thunk}
Like @func{time-it} evaluate the procedure @var{thunk} timing its
execution; return the return values of @var{thunk}.  Build two objects
of type @code{stats} and apply the procedure @var{gather} to them: the
first represents the statistics before @var{thunk} evaluation, the
second represents the statistics after @var{thunk} evaluation.
@end defun


@defun stats? @var{obj}
Return true if @var{obj} is an object of type @code{stats}.
@end defun


All the fields of a @code{stats} object hold fixnums.


@defun stats-user-secs @var{stats}
Return the user seconds field of @var{stats}.
@end defun


@defun stats-user-usecs @var{stats}
Return the user microseconds field of @var{stats}.
@end defun


@defun stats-sys-secs @var{stats}
Return the system seconds field of @var{stats}.
@end defun


@defun stats-sys-usecs @var{stats}
Return the system microseconds field of @var{stats}.
@end defun


@defun stats-real-secs @var{stats}
Return the real seconds field of @var{stats}.
@end defun


@defun stats-real-usecs @var{stats}
Return the real microseconds field of @var{stats}.
@end defun


@defun stats-collection-id @var{stats}
Return the collection identifier field of @var{stats}.
@end defun

@defun stats-gc-user-secs @var{stats}
Return the garbage collection user seconds field of @var{stats}.
@end defun


@defun stats-gc-user-usecs @var{stats}
Return the garbage collection user microseconds field of @var{stats}.
@end defun


@defun stats-gc-sys-secs @var{stats}
Return the garbage collection system seconds field of @var{stats}.
@end defun


@defun stats-gc-sys-usecs @var{stats}
Return the garbage collection system microseconds field of @var{stats}.
@end defun


@defun stats-gc-real-secs @var{stats}
Return the garbage collection real seconds field of @var{stats}.
@end defun


@defun stats-gc-real-usecs @var{stats}
Return the garbage collection real microseconds field of @var{stats}.
@end defun


@defun stats-bytes-minor @var{stats}
Return the garbage collection bytes minor field of @var{stats}.
@end defun


@defun stats-bytes-major @var{stats}
Return the garbage collection bytes major field of @var{stats}.
@end defun

@c page
@node iklib collection
@section Interfacing with garbage collection


@defun collect
Run the garbage collector.  If post--garbage collection hooks are
registered, they are run.  This binding is exported by the
@library{ikarus} library.
@end defun

@c ------------------------------------------------------------

@subsubheading Avoiding garbage collection of objects


The following @api{} allows us to register objects in the internal state
of Vicare so that they are not garbage collected even though we may
loose all the Scheme references to them.

This mechanism is useful when we create a Scheme object and register it
in a data structure controlled by a foreign library (for example when
interfacing with C language libraries); we can loose the Scheme
references to such object without having it garbage collected, and later
we retrieve the object reference and use it.

@center @strong{This @api{} is to be considered experimental.}


@defun register-to-avoid-collecting @var{obj}
Register @var{obj} in the internal state of Vicare so that it is not
garbage collected even when we loose all the Scheme references to it;
constant values (@false{}, @true{}, @dots{}) and fixnums cannot be
registered in this way.  Return @var{obj} itself.
@end defun


@defun forget-to-avoid-collecting @var{obj}
Remove @var{obj} from the internal state of Vicare so that it is garbage
collected when we loose all the Scheme references to it.  If @var{obj}
was previously registered: return @var{obj} itself, else return
@false{}.
@end defun


@defun collection-avoidance-list
Return the very list of object that where registered to avoid collection
by @func{register-to-avoid-collecting}; it can be the empty list.  We
must be very careful in handling and modifying this list.
@end defun


@defun purge-collection-avoidance-list
Reset to empty the list of objects registered to avoid collection with
@func{register-to-avoid-collecting}.  Use with care.
@end defun

@c page
@node iklib guardians
@section Guardians and garbage collection


Guardians are available in the @library{ikarus} library; quoting
@bibref{DYBGUA}:

@quotation
Guardians provide a means to protect objects from destruction by the
garbage collector.  A guardian is an object with which objects can be
registered for preservation and from which objects actually saved from
destruction can be retrieved, one at a time, at the convenience of the
program.
@end quotation

@menu
* iklib guardians examples::    Usage examples for guardians.
* iklib guardians api::         Guardians programming interface.
@end menu

@c page
@node iklib guardians examples
@subsection Usage examples for guardians


Let's say that we use the @value{PRJNAME} @ffi{} to handle some memory
block (@ref{ffi} for details on the @ffi{}); memory blocks allocated
with @func{malloc} are not released by the @value{PRJNAME} garbage
collector: we have to explicitly apply @func{free} to the pointer value
referencing them.

If we use the blocks synchronously with the evaluation of forms, we do
(assuming we do not use continuations, so this use of
@func{dynamic-wind} is fine):

@example
(import (ikarus)
  (vicare ffi))

(define (do-something-with . args)
  (display args)
  (newline))

(let ((p        #f)
      (size     4096))
  (dynamic-wind
      (lambda ()
        (set! p (malloc size))
        (unless p (error #f "memory allocation")))
      (lambda ()
        (do-something-with p))
      (lambda ()
        (free p))))
@end example

@noindent
and we can define a syntax for it:

@example
(import (ikarus)
  (vicare ffi))

(define (do-something-with . args)
  (display args)
  (newline))

(define-syntax with-block
  (syntax-rules ()
    ((_ ?pointer ?size ?body ...)
     (let ((?pointer    #f))
       (dynamic-wind
           (lambda ()
             (set! ?pointer (malloc ?size))
             (unless ?pointer (error #f "memory allocation")))
           (lambda ()
             ?body ...)
           (lambda ()
             (free ?pointer)))))))

(with-block p 2048
  (do-something-with p))

(with-block p 4096
  (do-something-with p))

(with-block p 8192
  (do-something-with p))
@end example

If we need the block in an event driven program: we will probably need
to use it asynchronously with the evaluation of forms.  For example, we
store the pointer value that references a block in a thunk (a closure
that takes no arguments):

@example
(import (ikarus)
  (vicare ffi))

(define *event-source* '())

(define (enqueue-event event)
  (set! *event-source*
        (reverse (cons event (reverse *event-source*)))))

(define (pop-event)
  (if (null? *event-source*)
      #f
    (let ((event (car *event-source*)))
      (set! *event-source* (cdr *event-source*))
      event)))

;; Usage:

(define (do-something-with . args)
  (display args)
  (newline))

(let ((p (malloc 4096)))
  (unless p (error #f "memory allocation"))
  (enqueue-event (lambda ()
                   (do-something-with p)))
  (enqueue-event (lambda ()
                   (do-something-with 123)))
  (enqueue-event (lambda ()
                   (do-something-with p))))

(do ((event (pop-event) (pop-event)))
    ((not event))
  (event))
@end example

@noindent
once the thunks have been evaluated, the pointer value is garbage
collected, but the allocated memory block becomes leaked memory.  We
need a way to be notified of the pointer value garbage collection, so
that we can apply @func{free} to it; this is the job for guardians.

The following script shows the usage of a guardian to free a memory
block:

@example
(import (ikarus)
  (vicare ffi))

(define g (make-guardian))

(let ((a (malloc (expt 2 20))))
  (unless p (error #f "memory allocation"))
  (g a)
  (printf "value ~s~%" a))

(printf "value from guardian ~s~%" (g))

;; This triggers a garbage collection.
(collect)

(let ((p (g)))
  (printf "value from guardian ~s~%" p)
  (free p))
@end example

In an event driven program what we have to do is to register the pointer
into the guardian, and then periodically enqueue as event a call to the
guardian:

@example
(import (ikarus)
  (vicare ffi))

;; Event source handling.

(define *event-source* '())

(define (enqueue-event event)
  (set! *event-source*
        (reverse (cons event (reverse *event-source*)))))

(define (pop-event)
  (if (null? *event-source*)
      #f
    (let ((event (car *event-source*)))
      (set! *event-source* (cdr *event-source*))
      event)))

;; Block guardian.

(define block-guardian (make-guardian))

(define (run-block-guardian)
  (do ((p (block-guardian) (block-guardian)))
      ((not p))
    (printf "collecting ~s~%" p)
    (free p)))

;; Application follows.

(define (do-something-with . args)
  (display args)
  (newline))

(let ((p (malloc (expt 2 20))))
  (unless p (error #f "memory allocation"))
  (block-guardian p)
  (enqueue-event (lambda () (do-something-with p)))
  (enqueue-event (lambda () (do-something-with 123)))
  (enqueue-event (lambda () (do-something-with p)))
  (enqueue-event (lambda () (do-something-with 456))))

(do ((event (pop-event) (pop-event))
     (i 1 (+ i 1)))
    ((= i 20))
  (when event
    (event))
  (when (= 0 (modulo i 10))
    (collect)
    (enqueue-event run-block-guardian)))
@end example

@c page
@node iklib guardians api
@subsection Guardians programming interface


@defun make-guardian
Build and return a new guardian object: a closure that can be called
with one or zero arguments, and that is interfaced with the garbage
collector of @value{PRJNAME} in a non--portable way.

The guardian work like this:

@itemize
@item
When the closure is called with one argument: it adds the argument to an
internal set of ``guarded values'', accessible to the garbage collector;
the return value if the argument itself.

@item
When the garbage collector detects no other references to a value in the
set of guarded values: the guardian removes it from the set and appends
it to an internal queue (@acronym{FIFO}).

@item
When the closure is called with zero arguments: it removes the first
value from the internal queue and returns it; if no values are in the
queue it returns @false{}.
@end itemize

After an object has been returned by the guardian, it is no more
``guarded'' so it will be garbage collected when it will become
inaccessible (unless it is again registered in a guardian).

@quotation
@strong{NOTE} It is possible to register an object in more than one
guardian; when the object is found inaccessible all the guardian
closures that have it will return it to the caller.  This may lead to
invalid finalisation operations, it is the responsibility of the
programmer to avoid this.
@end quotation

@quotation
@strong{NOTE} It is possible to register an object multiple times in the
same guardian; when the object is found inaccessible the guardian
closure that has it will return it to the caller multiple times.  This
may lead to invalid finalisation operations, it is the responsibility of
the programmer to avoid this.
@end quotation
@end defun


@deffn Parameter post-gc-hooks
Hold a list of thunks evaluated after each garbage collection run.  It
can be used to run a guardian cleanup function like this (using the
example in the previous section):

@example
(define (run-block-guardian)
  (do ((p (block-guardian) (block-guardian)))
      ((not p))
    (free p)))

(post-gc-hooks
 (cons run-block-guardian
  (post-gc-hooks)))
@end example
@end deffn

@c page
@node iklib io
@section Input/output library


@value{PRJNAME} extends the input/output facilities defined by @rnrs{6}.

@menu
* iklib io pathnames::          Pathnames handling.
* iklib io codecs::             Transcoders and additional codecs.
* iklib io binary::             Additional binary port features.
* iklib io textual::            Additional textual port features.
* iklib io buffer::             Buffer size customisation.
* iklib io misc::               Miscellaneous port functions.
@end menu

@c page
@node iklib io pathnames
@subsection Pathnames handling


All the file--related functions defined by @rnrs{6} accept a Scheme
string as representing a file pathname; internally such string is
converted to a bytevector to be handed to the underlying operating
system.  The following bindings are exported by the @library{ikarus}
library.


@deffn Parameter string->filename-func
In @value{PRJNAME} the string--to--filename conversion is performed by
the function returned by @func{string->filename-func}, which defaults to
@func{string->utf8}.
@end deffn


@deffn Parameter filename->string-func
In @value{PRJNAME} the filename--to--string conversion is performed by
the function returned by @func{filename->string-func}, which defaults to
@func{utf8->string}.
@end deffn


@defun split-search-path @var{path}
@defunx split-search-path-bytevector @var{bytevector-path}
@defunx split-search-path-string @var{string-path}
Split a file search path into its components and return a list of
pathnames.  A search path is meant to be a list of directory pathnames
separated by a colon character; @var{bytevector-path} must be a
bytevector, @var{string-path} must be a Scheme string, @var{path} must
be a Scheme string or bytevector.  Empty pathnames are discarded.

@example
#!vicare
(import (vicare))

(split-search-path-bytevector '#vu8())
@result{} ()

(split-search-path-bytevector #ve(ascii "ciao:hello"))
@result{} (#ve(ascii "ciao") #ve(ascii "hello"))

(split-search-path-bytevector '#ve(ascii "::::"))
@result{} ()

(split-search-path-string "")
@result{} ()

(split-search-path-string "ciao:hello:salut")
@result{} ("ciao" "hello" "salut")

(split-search-path-string "::::")
@result{} ()

(split-search-path "ciao:hello:salut")
@result{} ("ciao" "hello" "salut")

(split-search-path '#ve(ascii "ciao:hello:salut"))
@result{} (#ve(ascii "ciao") #ve(ascii "hello") #ve(ascii "salut"))
@end example
@end defun


@defun split-pathname @var{pathname}
@defunx split-pathname-bytevector @var{bytevector-pathname}
@defunx split-pathname-string @var{string-pathname}
Split a file pathname into its components and return two values: a
boolean, true if the pathname starts with a slash characters; the list
of components which can be empty.

A pathname is meant to be a file or directory name with components
separated by a slash character; @var{bytevector-pathname} must be a
bytevector, @var{string-pathname} must be a Scheme string, @var{path}
must be a Scheme string or bytevector.

Empty components are discarded.

@example
#!vicare
(import (vicare))

(split-pathname-bytevector '#vu8())
@result{} #f ()

(split-pathname-bytevector '#ve(ascii "ciao/hello"))
@result{} #f (#ve(ascii "ciao") #ve(ascii "hello"))

(split-pathname-bytevector '#ve(ascii "////"))
@result{} #t ()

(split-pathname-string "")
@result{} #f ()

(split-pathname-string "ciao/hello/salut")
@result{} #f ("ciao" "hello" "salut")

(split-pathname-string "////")
@result{} #t ()

(split-pathname "ciao/hello/salut")
@result{} #f ("ciao" "hello" "salut")

(split-pathname '#ve(ascii "/ciao/hello/salut"))
@result{} #t (#ve(ascii "ciao") #ve(ascii "hello") #ve(ascii "salut"))
@end example
@end defun


@c page
@node iklib io codecs
@subsection Transcoders and additional codecs


The following bindings are exported by the @library{ikarus} library.


@deffn Parameter native-transcoder
@findex open-input-file
@findex with-input-from-file
@findex call-with-input-file
@findex open-output-file
@findex with-output-to-file
@findex call-with-output-file
The function @func{native-transcoder} defined by @rnrs{6} returns a
transcoder representing acceptable defaults for the platform on which
the Scheme implementation is running.  Under @value{PRJNAME} such
default is:

@example
(make-transcoder (utf-8-codec) 'none 'replace)
@end example

@noindent
and additionally the function is a parameter, so the default can be
configured.  Notice that the following functions create Scheme ports
using the transcoder returned by @func{native-transcoder}:

@example
open-input-file         open-output-file
with-input-from-file    with-output-to-file
call-with-input-file    call-with-output-file
@end example
@end deffn


The codec returned by @func{utf-16-codec}, defined by @rnrs{6}, has
different semantics depending upon the type of the port:

@itemize
@item
For output and input/output ports it defaults to @utf{}-16 big endian
(which seems mandated by the Unicode Consortium).

@item
For input ports the endianness is left unspecified until the first bytes
are read: such bytes must be a valid @utf{}-16 Byte Order Mark which
dynamically configures the port.@footnote{The big endian @acronym{BOM}
for @utf{}-16 is the sequence of bytes @code{#xFE #xFF}; the little
endian @acronym{BOM} for @utf{}-16 is the sequence of bytes @code{#xFF
#xFE}.}
@end itemize


@deffn Procedure utf-16le-codec
@deffnx Procedure utf-16be-codec
Codecs for the @utf{}-16 encoding schemes, little endian and big endian.
A call to any of these procedures returns a value that is equal in the
sense of @func{eqv?} to the result of any other call to the same
procedure.
@end deffn


@deffn Procedure utf-16n-codec
Return a codec for the @utf{}-16 encoding scheme, with endianness equal
to the one returned by @func{(native-endianness)}.  A call to this
procedure returns a value that is equal in the sense of @func{eqv?} to
the result of any other call to the same procedure.
@end deffn


@deffn Procedure utf-bom-codec
Codec for @utf{} encoding schemes whose data open with a Byte Order
Mark.  A call to this procedure returns a value that is equal in the
sense of @func{eqv?} to the result of any other call to the same
procedure.

At present this codec is supported only by input ports.
@end deffn

@c page
@node iklib io binary
@subsection Additional binary port features


The following bindings are exported by the @library{ikarus} library.


@defun lookahead-two-u8 @var{port}
Like @func{lookahead-u8} but peeks at @math{2} octets and return two
values: the @eof{} object or a fixnum representing first octet, the
@eof{} object or a fixnum representing the second octet.
@end defun


@defun console-input-port
Return the default value of the @func{current-input-port} parameter.
When the readline interface is not used, this port is used by the
@repl{} and the debugger.
@end defun


@defun console-output-port
Return the default value of the @func{current-outptu-port} parameter.
It is used by the @repl{} and the debugger.
@end defun


@defun console-error-port
Return the default value of the @func{current-error-port} parameter.  It
is used by the @repl{} and the debugger.
@end defun


@defun make-binary-file-descriptor-input-port @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-output-port @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-input/output-port @var{fd} @var{identifier}
Build and return binary Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  Closing the Scheme ports will close the file
descriptors too.

File descriptor ports do support port position operations.
@end defun


@defun make-binary-file-descriptor-input-port* @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-output-port* @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-input/output-port* @var{fd} @var{identifier}
Build and return binary Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  Closing the Scheme ports will @strong{not} close the
file descriptors.

File descriptor ports do support port position operations.
@end defun


@defun make-binary-socket-input/output-port @var{sock} @var{identifier}
Build and return a binary Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  Closing the Scheme port will close the
socket descriptor too.

Socket ports do @strong{not} support port position operations.
@end defun


@defun make-binary-socket-input/output-port* @var{sock} @var{identifier}
Build and return a binary Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  Closing the Scheme port will @strong{not}
close the socket descriptor.

Socket ports do @strong{not} support port position operations.
@end defun

@c page
@node iklib io textual
@subsection Additional textual port features


The following bindings are exported by the @library{ikarus} library.


@defun open-string-input-port @var{string}
@defunx open-string-input-port @var{string} @var{eol-style}
As defined by @rnrs{6}: return a textual input port whose characters are
drawn from @var{string}.  When @var{eol-style} is given: it must be a
symbol selecting an end--of--line style conversion, as accepted by
@func{eol-style}; such conversion is applied to the characters drawn
from @var{string}.

If @var{string} is modified after @func{open-string-input-port} has been
called, the effect on the returned port is unspecified.
@end defun


@defun open-string-input-port/id @var{string} @var{id}
@defunx open-string-input-port/id @var{string} @var{id} @var{eol-style}
Like @func{open-string-input-port} but allows the specification of a
customised port identifier @var{id}, which must be a Scheme string.
@end defun


@defun open-string-output-port
@defunx open-string-output-port @var{eol-style}
As defined by @rnrs{6}, return two values: a textual output port and an
extraction procedure; the output port accumulates the characters written
to it for later extraction by the procedure.

As a @value{PRJNAME} extension, when @var{eol-style} is given: it must
be a symbol selecting an end--of--line style conversion, as accepted by
@func{eol-style}; such conversion is applied to the characters written
to the port.
@end defun


@defun get-output-string @var{port}
Return the string accumulated in the @var{port} opened by
@func{open-string-output-port}.  This function can be called also when
the port has been closed.
@end defun


@defun get-char-and-track-textual-position @var{port}
Like @func{get-char} but track the textual position.  Recognise only
linefeed characters as line-ending.
@end defun


@defun port-textual-position @var{port}
Given a textual port, return the current textual position as a condition
object of type @condition{source-position}.
@end defun


@defun make-textual-file-descriptor-input-port @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-output-port @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-input/output-port @var{fd} @var{identifier} @var{transcoder}
Build and return textual Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  @var{transcoder} must be a transcoder object.  Closing
the Scheme ports will close the file descriptors too.

File descriptor ports do support port position operations.
@end defun


@defun make-textual-file-descriptor-input-port* @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-output-port* @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-input/output-port* @var{fd} @var{identifier} @var{transcoder}
Build and return textual Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  @var{transcoder} must be a transcoder object.  Closing
the Scheme ports will @strong{not} close the file descriptors.

File descriptor ports do support port position operations.
@end defun


@defun make-textual-socket-input/output-port @var{sock} @var{identifier} @var{transcoder}
Build and return a textual Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  @var{transcoder} must be a transcoder
object.  Closing the Scheme port will close the socket descriptor too.

Socket ports do @strong{not} support port position operations.
@end defun


@defun make-textual-socket-input/output-port* @var{sock} @var{identifier} @var{transcoder}
Build and return a textual Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  @var{transcoder} must be a transcoder
object.  Closing the Scheme port will @strong{not} close the socket
descriptor.

Socket ports do @strong{not} support port position operations.
@end defun


@defun read-line
@defunx read-line @var{port}
Read from the textual input @var{port} up to and including the linefeed
character or end of file, decoding characters in the same manner as
@func{get-string-n} and @func{get-string-n!}.  This function is exactly
like @func{get-line}, defined by @rsixlibrary{io ports}, but it uses the
return value of @func{current-input-port} if no @var{port} argument is
used.
@end defun

@c page
@node iklib io buffer
@subsection Buffer size customisation


The following bindings are exported by the @library{ikarus} library.


@deffn Parameter bytevector-port-buffer-size
@deffnx Parameter bytevector-port-buffer-size @var{fixnum}
Hold the buffer size for bytevector ports, like the one returned by
@func{open-bytevector-output-port}.  It is initialised to @math{16384}.
@end deffn


@deffn Parameter string-port-buffer-size
@deffnx Parameter string-port-buffer-size @var{fixnum}
Hold the buffer size for string ports, like the one returned by
@func{open-string-output-port}.  It is initialised to @math{256}.
@end deffn


@deffn Parameter input-file-buffer-size
@deffnx Parameter input-file-buffer-size @var{fixnum}
Hold the buffer size for input file ports, like the one returned by
@func{open-input-file}.  It is initialised to @math{16384}.
@end deffn


@deffn Parameter output-file-buffer-size
@deffnx Parameter output-file-buffer-size @var{fixnum}
Hold the buffer size for output file ports, like the one returned by
@func{open-output-file}.  It is initialised to @math{16384}.
@end deffn


@deffn Parameter input/output-file-buffer-size
@deffnx Parameter input/output-file-buffer-size @var{fixnum}
Hold the buffer size for input/output file ports, like the one returned
by @func{open-file-input/output-prot}.  It is initialised to
@math{16384}.
@end deffn


@deffn Parameter input/output-socket-buffer-size
@deffnx Parameter input/output-socket-buffer-size @var{fixnum}
Hold the buffer size for socket ports.  It is initialised to
@math{16384}.
@end deffn

@c page
@node iklib io misc
@subsection Miscellaneous port functions


The following bindings are exported by the @library{ikarus} library.


@defun input/output-port? @var{port}
Return a boolean, @true{} if @var{port} is an input and output port.
@end defun


@defun port-fd @var{port}
If @var{port} is a port with a file descriptor as device: return a
fixnum representing the device, else return @false{}.
@end defun


@defun port-id @var{port}
Return a Scheme string representing the identifier of @var{port}.
@end defun


@defun set-port-buffer-mode! @var{port} @var{buffer-mode}
Reset the port buffer mode to @var{buffer-mode}, which must be one of
the arguments accepted by @func{buffer-mode}.  It is an error to select
@code{line} mode if @var{port} is a binary port.
@end defun


@defun port-dump-status @var{port}
To be used for debugging purposes.  Write to the current error port some
informations on the internals of @var{port}.
@end defun

@c page
@node iklib pointers
@section Handling pointer objects


@menu
* iklib pointers objects::      Handling pointer values.
* iklib pointers poke::         Poking values.
* iklib pointers peek::         Peeking values.
* iklib arrays poke::           Poking values into arrays.
* iklib arrays peek::           Peeking values from arrays.
@end menu

@c page
@node iklib pointers objects
@subsection Handling pointer values


Pointer objects are a disjoint type identified by the @func{pointer?}
predicate.  When applied to pointer objects:

@itemize
@item
The result of calling @func{eq?} is true only if the two arguments are
both pointers and they refer to the same Scheme storage location.

@item
The result of calling @func{eqv?} and @func{equal?} is true only if the
two arguments are both pointers and they reference the same raw memory
location.
@end itemize

@noindent
pointers also have @func{pointer=?} as specialised comparison predicate.

The following bindings are exported by the libraries @library{vicare},
@library{ikarus} and @library{ikarus system $foreign} and reexported by
the library @library{vicare ffi}.


@defun pointer? @var{obj}
Return @true{} if @var{obj} is a pointer object, return @false{}
otherwise.
@end defun


@defun pointer->integer @var{pointer}
Convert the value of @var{pointer} to an exact integer value.  The
result may be a fixnum or a bignum depending on the pointer.
@end defun


@defun integer->pointer @var{exact-integer}
Convert @var{exact-integer} to a pointer value.  The argument must be
non--negative and in the appropriate range for 32-bit or 64-bit
platforms.  It is guaranteed that:

@example
(integer->pointer (pointer->integer p))
@end example

@noindent
points to the same address as @var{p}.
@end defun


@defun null-pointer
Return a newly allocated pointer object representing @cnull{}.
@end defun


@defun pointer-null? @var{obj}
Return true if @var{obj} is a pointer object and it represents @cnull{}.
@end defun


@defun pointer-diff @vari{ptr} @varii{ptr}
Return an exact integer representing the difference between the two
pointer objects @vari{ptr} and @varii{ptr}.  The returned value is such
that:

@example
(pointer=? P (pointer-add Q (pointer-diff P Q)))
@result{} #t
@end example
@end defun


@defun pointer-add @var{ptr} @var{diff}
Return a new pointer object holding the memory reference resulting from
adding @var{diff}, which must be an exact integer, to @var{ptr}.  If the
addition would cause an overflow or underflow in machine words: raise an
assertion violation.
@end defun


@defun pointer-and-offset? @var{ptr} @var{diff}
Return true if the exact integer @var{diff} can be added to @var{ptr}
without causing a pointer overflow or underflow.
@end defun


@defun pointer=? @vari{ptr} @varii{ptr}
@defunx pointer<>? @vari{ptr} @varii{ptr}
@defunx pointer<? @vari{ptr} @varii{ptr}
@defunx pointer>? @vari{ptr} @varii{ptr}
@defunx pointer<=? @vari{ptr} @varii{ptr}
@defunx pointer>=? @vari{ptr} @varii{ptr}
Comparison functions for pointers.  Return @true{} if the arguments
satisfy the predicate, else return @false{}.
@end defun


@defun pointer->scheme-object @var{pointer}
@defunx scheme-object->pointer @var{obj}
One of the assumptions of @value{PRJNAME}, regarding the hosting
platform, is that a machine word has the same dimension of a pointer;
immediate Scheme objects and references to Scheme objects are
represented as machine words.

These functions convert between Scheme objects and pointer objects, so
that a Scheme object can be handed, as opaque value, to a function
written and compiled in a foreign language (typically the C language).

To prevent garbage collection of objects converted to pointer objects,
we must use the garbage collection avoiding @api{}.  @ref{iklib
collection, Avoiding garbage collection of objects}
@end defun


@defun pointer-clone @var{pointer}
Return a new pointer object being a copy of @var{pointer}.  This is
useful when we need a pointer that might be reset to another value in
the future.
@end defun

@c page
@node iklib pointers poke
@subsection Poking values


With all the following functions: the @var{memory} argument must be a
valid pointer object or @code{memory-block} instance; the @var{offset}
argument must be an exact integer in the range of the C language type
@code{ptrdiff_t}.  When adding an offset to a pointer: all the following
functions @strong{do not} scale the offset to the size of the poked
value; pointer arithmetics is performed with byte offsets.

The following bindings are exported by the libraries @library{vicare},
@library{ikarus} and @library{ikarus system $foreign} and reexported by
the library @library{vicare ffi}.

@macro bitpoker{BYTENUM,BITNUM}
Set to @var{value} the \BYTENUM\ of memory located at @var{offset} from
@var{memory}.  @var{VALUE} must be an exact integer in the range
representable by \BITNUM\ bits.
@end macro

@macro cpoker{TYPE}
Set to @var{value} a number of bytes corresponding to the @code{signed
\TYPE\} or @code{unsigned \TYPE\} type located at @var{offset} from
@var{memory}.
@end macro

@c ------------------------------------------------------------

@subsubheading Poking bitwise sized exact integers

The following functions store signed and unsigned exact integers in raw
memory location selecting the size with the number of bits required to
represent the value.


@defun pointer-set-c-sint8! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-uint8! @var{memory} @var{offset} @var{value}
@bitpoker{single byte,8}
@end defun


@defun pointer-set-c-sint16! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-uint16! @var{memory} @var{offset} @var{value}
@bitpoker{two bytes,16}
@end defun


@defun pointer-set-c-sint32! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-uint32! @var{memory} @var{offset} @var{value}
@bitpoker{two bytes,32}
@end defun


@defun pointer-set-c-sint64! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-uint64! @var{memory} @var{offset} @var{value}
@bitpoker{two bytes,64}
@end defun

@c ------------------------------------------------------------

@subsubheading Poking C language exact integers

The following functions store signed and unsigned exact integers in raw
memory locations selecting the size according to the one used by the C
language implementation.


@defun pointer-set-c-signed-char! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-char! @var{memory} @var{offset} @var{value}
@cpoker{char}
@end defun


@defun pointer-set-c-signed-short! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-short! @var{memory} @var{offset} @var{value}
@cpoker{short int}
@end defun


@defun pointer-set-c-signed-int! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-int! @var{memory} @var{offset} @var{value}
@cpoker{int}
@end defun



@defun pointer-set-c-signed-long! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-long! @var{memory} @var{offset} @var{value}
@cpoker{long}
@end defun


@defun pointer-set-c-signed-long-long! @var{memory} @var{offset} @var{value}
@defunx pointer-set-c-unsigned-long-long! @var{memory} @var{offset} @var{value}
@cpoker{long long}
@end defun


@defun pointer-set-c-size_t! @var{memory} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{size_t}
type located at @var{offset} from @var{memory}.
@end defun


@defun pointer-set-c-ssize_t! @var{memory} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{ssize_t}
type located at @var{offset} from @var{memory}.
@end defun


@defun pointer-set-c-off_t! @var{memory} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{off_t}
type located at @var{offset} from @var{memory}.
@end defun


@defun pointer-set-c-ptrdiff_t! @var{memory} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the
@code{ptrdiff_t} type located at @var{offset} from @var{memory}.
@end defun

@c ------------------------------------------------------------

@subsubheading Poking floating point numbers


@defun pointer-set-c-float! @var{memory} @var{offset} @var{flonum}
Convert the Scheme floating point number @var{flonum} (represented in
@value{PRJNAME} as an @ieee{} 754 double precision floating point number) to a
float (an @ieee{} 754 single precision floating point number) and store
the result in the four bytes at @var{offset} from @var{memory}.
@end defun


@defun pointer-set-c-double! @var{memory} @var{offset} @var{flonum}
Store the double precision @ieee{} 754 floating point value of the
Scheme @var{flonum} in the eight bytes at @var{offset} from
@var{memory}.
@end defun


@c ------------------------------------------------------------

@subsubheading Poking pointers


@defun pointer-set-c-pointer! @var{memory} @var{offset} @var{value}
Store address of the raw memory location referenced by the pointer
@var{value} at @var{offset} from @var{memory}.
@end defun

@c page
@node iklib pointers peek
@subsection Peeking values


With all the following functions: the @var{memory} argument must be a
valid pointer object; the @var{offset} argument must be an exact integer
in the range of the C language type @code{ptrdiff_t}.  When adding an
offset to a pointer: all the following functions @strong{do not} scale
the offset to the size of the peeked value; pointer arithmetics is
performed with byte offsets.

The following bindings are exported by the libraries @library{vicare},
@library{ikarus} and @library{ikarus system $foreign} and reexported by
the library @library{vicare ffi}.

@macro bitpeeker{BITNUM}
Peek the \BITNUM\ bits located at @var{offset} from @var{memory} and
return them as signed or unsigned exact integer.
@end macro

@macro cpeeker{TYPE}
Peek the @code{signed \TYPE\} or @code{unsigned \TYPE\} integer located
at @var{offset} from @var{memory} and return it as signed or unsigned
exact integer.
@end macro

@c ------------------------------------------------------------

@subsubheading Peeking bitwise sized exact integers

The following functions retrieve signed and unsigned exact integers from
raw memory location selecting the size with the number of bits required
to represent the value.


@defun pointer-ref-c-sint8 @var{memory} @var{offset}
@defunx pointer-ref-c-uint8 @var{memory} @var{offset}
@bitpeeker{8}
@end defun


@defun pointer-ref-c-sint16 @var{memory} @var{offset}
@defunx pointer-ref-c-uint16 @var{memory} @var{offset}
@bitpeeker{16}
@end defun


@defun pointer-ref-c-sint32 @var{memory} @var{offset}
@defunx pointer-ref-c-uint32 @var{memory} @var{offset}
@bitpeeker{32}
@end defun


@defun pointer-ref-c-sint64 @var{memory} @var{offset}
@defunx pointer-ref-c-uint64 @var{memory} @var{offset}
@bitpeeker{64}
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking C language exact integers

The following functions store signed and unsigned exact integers from
raw memory locations selecting the size according to the one used by the
C language implementation.


@defun pointer-ref-c-signed-char @var{memory} @var{offset}
@defunx pointer-ref-c-signed-char @var{memory} @var{offset}
@cpeeker{char}
@end defun


@defun pointer-ref-c-signed-short @var{memory} @var{offset}
@defunx pointer-ref-c-unsigned-short @var{memory} @var{offset}
@cpeeker{short int}
@end defun


@defun pointer-ref-c-signed-int @var{memory} @var{offset}
@defunx pointer-ref-c-unsigned-int @var{memory} @var{offset}
@cpeeker{int}
@end defun


@defun pointer-ref-c-signed-long @var{memory} @var{offset}
@defunx pointer-ref-c-unsigned-long @var{memory} @var{offset}
@cpeeker{long}
@end defun


@defun pointer-ref-c-signed-long-long @var{memory} @var{offset}
@defunx pointer-ref-c-unsigned-long-long @var{memory} @var{offset}
@cpeeker{long long}
@end defun


@defun pointer-ref-c-size_t @var{memory} @var{offset}
Peek the @code{size_t} integer located at @var{offset} from @var{memory}
and return it as exact integer.
@end defun


@defun pointer-ref-c-ssize_t @var{memory} @var{offset}
Peek the @code{ssize_t} integer located at @var{offset} from @var{memory}
and return it as exact integer.
@end defun


@defun pointer-ref-c-off_t @var{memory} @var{offset}
Peek the @code{off_t} integer located at @var{offset} from @var{memory}
and return it as exact integer.
@end defun


@defun pointer-ref-c-ptrdiff_t @var{memory} @var{offset}
Peek the @code{ptrdiff_t} integer located at @var{offset} from
@var{memory} and return it as exact integer.
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking floating point numbers


@defun pointer-ref-c-float @var{memory} @var{offset}
Return the four--byte float (represented as @ieee{} 754 single precision
floating point number) stored at @var{offset} from @var{memory}.  The
value is extended to an @ieee{} 754 double precision floating point
number that @value{PRJNAME} uses to represent inexact numbers.
@end defun


@defun pointer-ref-c-double @var{memory} @var{offset}
Return the eight--byte float (represented as @ieee{} 754 double
precision floating point number) stored at @var{offset} from
@var{memory}.
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking pointers


@defun pointer-ref-c-pointer @var{memory} @var{offset}
Return the pointer stored at @var{offset} from @var{memory}.  The size
of the pointer (also the number of bytes loaded) depends on the
architecture: it is 4 bytes on 32-bit systems and 8 bytes on 64-bit
systems.
@end defun

@c page
@node iklib arrays poke
@subsection Poking values into arrays


With all the following functions: the @var{memory} argument must be a
valid pointer object or @code{memory-block} instance; the @var{index}
argument must be an exact integer in the range of the C language type
@code{ptrdiff_t}.  When adding an offset to a pointer: all the following
functions @strong{do} scale the index to the size of the poked value.

The following bindings are exported by the libraries @library{vicare},
@library{ikarus} and @library{ikarus system $foreign} and reexported by
the library @library{vicare ffi}.

@macro abitpoker{BYTENUM,BITNUM}
Set to @var{value} the \BYTENUM\ of memory located at @var{index} from
@var{memory}.  @var{VALUE} must be an exact integer in the range
representable by \BITNUM\ bits.
@end macro

@macro acpoker{TYPE}
Set to @var{value} a number of bytes corresponding to the @code{signed
\TYPE\} or @code{unsigned \TYPE\} type located at @var{index} from
@var{memory}.
@end macro

@c ------------------------------------------------------------

@subsubheading Poking bitwise sized exact integers

The following functions store signed and unsigned exact integers in raw
memory location selecting the size with the number of bits required to
represent the value.


@defun array-set-c-sint8! @var{memory} @var{index} @var{value}
@defunx array-set-c-uint8! @var{memory} @var{index} @var{value}
@abitpoker{single byte,8}
@end defun


@defun array-set-c-sint16! @var{memory} @var{index} @var{value}
@defunx array-set-c-uint16! @var{memory} @var{index} @var{value}
@abitpoker{two bytes,16}
@end defun


@defun array-set-c-sint32! @var{memory} @var{index} @var{value}
@defunx array-set-c-uint32! @var{memory} @var{index} @var{value}
@abitpoker{two bytes,32}
@end defun


@defun array-set-c-sint64! @var{memory} @var{index} @var{value}
@defunx array-set-c-uint64! @var{memory} @var{index} @var{value}
@abitpoker{two bytes,64}
@end defun

@c ------------------------------------------------------------

@subsubheading Poking C language exact integers

The following functions store signed and unsigned exact integers in raw
memory locations selecting the size according to the one used by the C
language implementation.


@defun array-set-c-signed-char! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-char! @var{memory} @var{index} @var{value}
@acpoker{char}
@end defun


@defun array-set-c-signed-short! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-short! @var{memory} @var{index} @var{value}
@acpoker{short int}
@end defun


@defun array-set-c-signed-int! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-int! @var{memory} @var{index} @var{value}
@acpoker{int}
@end defun


@defun array-set-c-signed-long! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-long! @var{memory} @var{index} @var{value}
@acpoker{long}
@end defun


@defun array-set-c-signed-long-long! @var{memory} @var{index} @var{value}
@defunx array-set-c-unsigned-long-long! @var{memory} @var{index} @var{value}
@acpoker{long long}
@end defun


@defun array-set-c-size_t! @var{memory} @var{index} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{size_t}
type located at @var{index} from @var{memory}.
@end defun


@defun array-set-c-ssize_t! @var{memory} @var{index} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{ssize_t}
type located at @var{index} from @var{memory}.
@end defun


@defun array-set-c-off_t! @var{memory} @var{index} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{off_t}
type located at @var{index} from @var{memory}.
@end defun


@defun array-set-c-ptrdiff_t! @var{memory} @var{index} @var{value}
Set to @var{value} a number of bytes corresponding to the
@code{ptrdiff_t} type located at @var{index} from @var{memory}.
@end defun

@c ------------------------------------------------------------

@subsubheading Poking floating point numbers


@defun array-set-c-float! @var{memory} @var{index} @var{flonum}
Convert the Scheme floating point number @var{flonum} (represented in
@value{PRJNAME} as an @ieee{} 754 double precision floating point number) to a
float (an @ieee{} 754 single precision floating point number) and store
the result in the four bytes at @var{index} from @var{memory}.
@end defun


@defun array-set-c-double! @var{memory} @var{index} @var{flonum}
Store the double precision @ieee{} 754 floating point value of the
Scheme @var{flonum} in the eight bytes at @var{index} from
@var{memory}.
@end defun


@c ------------------------------------------------------------

@subsubheading Poking pointers


@defun array-set-c-pointer! @var{memory} @var{index} @var{value}
Store address of the raw memory location referenced by the pointer
@var{value} at @var{index} from @var{memory}.
@end defun

@c page
@node iklib arrays peek
@subsection Peeking values from arrays


With all the following functions: the @var{memory} argument must be a
valid pointer object; the @var{index} argument must be an exact integer
in the range of the C language type @code{ptrdiff_t}.  When adding an
offset to a pointer: all the following functions @strong{do} scale the
index to the size of the peeked value.

The following bindings are exported by the libraries @library{vicare},
@library{ikarus} and @library{ikarus system $foreign} and reexported by
the library @library{vicare ffi}.

@macro abitpeeker{BITNUM}
Peek the \BITNUM\ bits located at @var{index} from @var{memory} and
return them as signed or unsigned exact integer.
@end macro

@macro acpeeker{TYPE}
Peek the @code{signed \TYPE\} or @code{unsigned \TYPE\} integer located
at @var{index} from @var{memory} and return it as signed or unsigned
exact integer.
@end macro

@c ------------------------------------------------------------

@subsubheading Peeking bitwise sized exact integers

The following functions retrieve signed and unsigned exact integers from
raw memory location selecting the size with the number of bits required
to represent the value.


@defun array-ref-c-sint8 @var{memory} @var{index}
@defunx array-ref-c-uint8 @var{memory} @var{index}
@abitpeeker{8}
@end defun


@defun array-ref-c-sint16 @var{memory} @var{index}
@defunx array-ref-c-uint16 @var{memory} @var{index}
@abitpeeker{16}
@end defun


@defun array-ref-c-sint32 @var{memory} @var{index}
@defunx array-ref-c-uint32 @var{memory} @var{index}
@abitpeeker{32}
@end defun


@defun array-ref-c-sint64 @var{memory} @var{index}
@defunx array-ref-c-uint64 @var{memory} @var{index}
@abitpeeker{64}
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking C language exact integers

The following functions store signed and unsigned exact integers from
raw memory locations selecting the size according to the one used by the
C language implementation.


@defun array-ref-c-signed-char @var{memory} @var{index}
@defunx array-ref-c-signed-char @var{memory} @var{index}
@acpeeker{char}
@end defun


@defun array-ref-c-signed-short @var{memory} @var{index}
@defunx array-ref-c-unsigned-short @var{memory} @var{index}
@acpeeker{short int}
@end defun


@defun array-ref-c-signed-int @var{memory} @var{index}
@defunx array-ref-c-unsigned-int @var{memory} @var{index}
@acpeeker{int}
@end defun


@defun array-ref-c-signed-long @var{memory} @var{index}
@defunx array-ref-c-unsigned-long @var{memory} @var{index}
@acpeeker{long}
@end defun


@defun array-ref-c-signed-long-long @var{memory} @var{index}
@defunx array-ref-c-unsigned-long-long @var{memory} @var{index}
@acpeeker{long long}
@end defun


@defun array-ref-c-size_t @var{memory} @var{index}
Peek the @code{size_t} integer located at @var{index} from @var{memory}
and return it as signed or unsigned exact integer.
@end defun


@defun array-ref-c-ssize_t @var{memory} @var{index}
Peek the @code{ssize_t} integer located at @var{index} from @var{memory}
and return it as signed or unsigned exact integer.
@end defun


@defun array-ref-c-off_t @var{memory} @var{index}
Peek the @code{off_t} integer located at @var{index} from @var{memory}
and return it as signed or unsigned exact integer.
@end defun


@defun array-ref-c-ptrdiff_t @var{memory} @var{index}
Peek the @code{ptrdiff_t} integer located at @var{index} from
@var{memory} and return it as signed or unsigned exact integer.
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking floating point numbers


@defun array-ref-c-float @var{memory} @var{index}
Return the four--byte float (represented as @ieee{} 754 single precision
floating point number) stored at @var{index} from @var{memory}.  The
value is extended to an @ieee{} 754 double precision floating point
number that @value{PRJNAME} uses to represent inexact numbers.
@end defun


@defun array-ref-c-double @var{memory} @var{index}
Return the eight--byte float (represented as @ieee{} 754 double
precision floating point number) stored at @var{index} from
@var{memory}.
@end defun

@c ------------------------------------------------------------

@subsubheading Peeking pointers


@defun array-ref-c-pointer @var{memory} @var{index}
Return the pointer stored at @var{index} from @var{memory}.  The size
of the pointer (also the number of bytes loaded) depends on the
architecture: it is 4 bytes on 32-bit systems and 8 bytes on 64-bit
systems.
@end defun

@c page
@node iklib memory
@section Memory management


@menu
* iklib memory intro::          Introduction to managing memory.
* iklib memory alloc::          Allocating and freeing memory.
* iklib memory ops::            Memory operations.
* iklib memory blocks::         Memory blocks.
* iklib memory condition::      Memory allocation condition objects.
@end menu

@c page
@node iklib memory intro
@subsection Introduction to managing memory


@value{PRJNAME} Scheme is a managed environment: Scheme objects are
allocated in a special memory region (the Scheme heap) and have
type--specific object layouts; this allows the run time system to
distinguish object types and the garbage collector to locate all
potentially live objects, and reclaim the memory of dead objects.

Scheme objects are also @emph{opaque} in the sense that the data
structures used to represent Scheme objects are not exposed, at the
Scheme level, to the programmer who can only interact with objects
through an interface.

Unmanaged environments, such as the operating system on which
@value{PRJNAME} runs, require that the programmer manages the allocation
and deallocation of system resources herself.  Memory regions, file
handles, external devices, the screen, etc., are all examples of
resources whose management must be coordinated among the different parts
of the system, and this becomes the responsibility of the programmer who
is wiring the different subsystems together.

The procedures acting on pointer objects are meant to provide a way to
interface with the low level memory operations such as setting and
getting bytes from specific locations in memory.

@c page
@node iklib memory alloc
@subsection Allocating and freeing memory


The following bindings are exported by the libraries @library{vicare},
@library{ikarus} and @library{ikarus system $foreign} and reexported by
the library @library{vicare ffi}.


@defun malloc @var{number-of-bytes}
@defunx guarded-malloc @var{number-of-bytes}
Interface to the C function @cfunc{malloc}, @glibcref{Basic Allocation,
malloc}.  Allocate a block of memory @var{number-of-bytes} wide;
@var{number-of-bytes} must be an exact integer in the range of the C
language type @code{size_t}.  If successful return a pointer object,
else return @false{}.

Memory allocated by @func{malloc} must be released by @func{free};
memory allocated by @func{guarded-malloc} is automatically released
whenever the returned pointer object is garbage collected.
@end defun


@defun malloc* @var{number-of-bytes}
@defunx guarded-malloc* @var{number-of-bytes}
Like @func{malloc} and @func{guarded-malloc}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun realloc @var{memory} @var{number-of-bytes}
@defunx guarded-realloc @var{memory} @var{number-of-bytes}
Interface to the C function @cfunc{realloc}, @glibcref{Changing Block
Size, realloc}.  Reallocate the block of memory referenced by
@var{memory} to the new size @var{number-of-bytes}.

@var{memory} must be a pointer object or @code{memory-block} instance.

@var{number-of-bytes} must be an exact integer in the range of the C
language type @code{size_t}.

If successful: mutate the pointer in @var{memory} to reference the new
memory block and return @var{memory} itself; when @var{memory} is a
@code{memory-block}: mutate the size field to @var{number-of-bytes}.  If
an error occurs: return @false{} and leave untouched both @var{memory}
and its referenced memory.

Memory allocated by @func{realloc} must be released by @func{free},
unless @var{memory} was already scheduled to be removed by the garbage
collector; when @func{guarded-realloc} is used:

@itemize
@item
When @var{memory} is a pointer object: the allocated memory is
automatically released whenever the returned pointer object is garbage
collected.  If @var{memory} was already scheduled to be removed by the
garbage collector: we should use @func{realloc} not
@func{guarded-realloc}.

@item
When @var{memory} is an instance of @code{memory-block}: the allocated
memory is automatically released by the garbage collector only if
@code{memory-block} was built by @func{make-memory-block/guarded}.
@end itemize
@end defun


@defun realloc* @var{pointer} @var{number-of-bytes}
@defunx guarded-realloc* @var{pointer} @var{number-of-bytes}
Like @func{realloc} and @func{guarded-realloc}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun calloc @var{number-of-elements} @var{element-size}
@defunx guarded-calloc @var{number-of-elements} @var{element-size}
Interface to the C function @cfunc{calloc}, @glibcref{Allocating Cleared
Space, calloc}.  Allocate and clear to zero a block of memory capable of
holding @var{number-of-elements} each @var{element-size} wide; both the
arguments must be exact integers in the range of the C language type
@code{size_t}.  If successful return a pointer object, else return
@false{}.

Memory allocated by @func{calloc} must be released by @func{free};
memory allocated by @func{guarded-calloc} is automatically released
whenever the returned pointer object is garbage collected.
@end defun


@defun calloc @var{number-of-elements} @var{element-size}
@defunx guarded-calloc @var{number-of-elements} @var{element-size}
Like @func{calloc} and @func{guarded-calloc}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun free @var{memory}
Release the memory referenced by @var{memory}, which must be either a
pointer object returned by @cfunc{malloc}, @cfunc{realloc},
@cfunc{calloc} or a similar system procedure or an instance of
@code{memory-block}.  The pointer object in @var{memory} is mutated to
reference the @cnull{} pointer; when @var{memory} is a
@code{memory-block}: the @code{size} field is also reset to zero.

If memory allocated by a guarding function is released by @func{free}:
@value{PRJNAME} will @strong{not} try to automatically release the old
memory again.

If the pointer in @var{memory} is @cnull{} nothing happens.
@end defun


@defun with-local-storage @var{lengths} @var{proc}
Call @var{proc} with arguments being pointers to memory blocks allocated
just for the dynamic extent of @var{proc}.  The number and size of the
memory blocks is determined by @var{lengths}, which must be a vector of
non--negative fixnums.

@ignore
@c This is not clear, so far letting the flow go through with an
@c exception seems to work (Marco Maggi; Dec  7, 2011)

We must not let control flow go through a call to
@func{with-local-storage} by raising an exception.  @var{proc}
@strong{must} return to the caller.
@end ignore

@strong{NOTE} We must not let control flow go through a call to
@func{with-local-storage} with an escaping continuation.

@example
#!r6rs
(import (rnrs)
  (prefix (vicare ffi) ffi.))

;; no allocated memory
(let ((a 1) (b 2))
  (ffi.with-local-storage '#()
    (lambda ()
      (+ a b 4))))
@result{} 7

;; allocate a single block of 4 bytes
(let ((a 1) (b 2))
  (ffi.with-local-storage '#(4)
    (lambda (&int32)
      (ffi.pointer-set-c-sint32! &int32 0 4)
      (+ a b (ffi.pointer-ref-c-sint32 &int32 0)))))
@result{} 7

;; allocate two blocks of 4 and 8 bytes
(let ((a 1) (b 2))
  (ffi.with-local-storage '#(4 8)
    (lambda (&int32 &int64)
      (ffi.pointer-set-c-sint32! &int32 0 4)
      (ffi.pointer-set-c-sint64! &int64 0 8)
      (+ a b
         (ffi.pointer-ref-c-sint32 &int32 0)
         (ffi.pointer-ref-c-sint64 &int64 0)))))
@result{} 15
@end example

The memory blocks are actually allocated on the stack of
@value{PRJNAME}'s runtime.
@end defun

@c page
@node iklib memory ops
@subsection Memory operations


The following bindings are exported by the libraries @library{vicare},
@library{ikarus} and @library{ikarus system $foreign} and reexported by
the library @library{vicare ffi}.


@defun memcpy @var{dst} @var{src} @var{count}
Interface to the C function @cfunc{memcpy}, @glibcref{Copying and
Concatenation, memcpy}.  Copy @var{count} bytes from the memory
referenced by the pointer @var{src} to the memory referenced by the
pointer @var{dst}; @var{count} must be an exact integer in the range of
the C language type @code{size_t}.  The two memory regions must not
overlap.  Return unspecified values.
@end defun


@defun memmove @var{dst} @var{src} @var{count}
Interface to the C function @cfunc{memmove}, @glibcref{Copying and
Concatenation, memmove}.  Copy @var{count} bytes from the memory
referenced by the pointer @var{src} to the memory referenced by the
pointer @var{dst}; @var{count} must be an exact integer in the range of
the C language type @code{size_t}.  The two memory regions can be
overlapping.  Return unspecified values.
@end defun


@defun memset @var{ptr} @var{value} @var{count}
Interface to the C function @cfunc{memset}, @glibcref{Copying and
Concatenation, memset}.Set to @var{value} @var{count} bytes of the
memory referenced by the pointer @var{ptr}.  @var{count} must be an
exact integer in the range of the C language type @code{size_t},
@var{value} must be an exact fixnum in the range @math{[-128, 255]}.
Return unspecified values.
@end defun


@defun memcmp @vari{pointer} @varii{pointer} @var{count}
Interface to the C function @cfunc{memcmp}, @glibcref{String/Array
Comparison, memcmp}.  Compare @var{count} bytes in the memory blocks
referenced by @vari{pointer} and @varii{pointer}, return a fixnum
representing the classic comparison ternary result.  @var{count} must be
an exact integer in the range of the C language type @code{size_t}.
@end defun


@defun memory-copy dst dst.start src src.start count
Copy @var{count} bytes from @var{src} starting at offset @var{src.start}
to @var{dst} starting at offset @var{dst.start}.  @var{src} and
@var{dst} can be pointers or bytevectors; @var{dst.start},
@var{src.start} and @var{count} must be non--negative fixnums.  The two
memory regions must not overlap.  Return unspecified values.
@end defun


@defun memory->bytevector @var{pointer} @var{number-of-bytes}
Build and return a new bytevector object holding @var{number-of-bytes}
from the memory region starting at @var{pointer}.  @var{number-of-bytes}
must be a non--negative fixnum.
@end defun


@defun bytevector->memory @var{bv}
@defunx bytevector->guarded-memory @var{bv}
Allocate a new raw memory block and copy into it the contents of
@var{bv}.  If successful return two values being the pointer object
referencing the memory and a fixnum representing the length of the
memory block; if allocating memory fails return @false{} and @false{}.

Memory allocated by @func{bytevector->memory} must be released by
@func{free}; memory allocated by @func{bytevector->guarded-malloc} is
automatically released whenever the returned pointer object is garbage
collected.
@end defun


@defun bytevector->memory* @var{bv}
@defunx bytevector->guarded-memory* @var{bv}
Like @func{bytevector->memory*} and @func{bytevector->guarded-memory*},
but if allocation fails raise a non--continuable exception with
components: @condition{who}, @condition{message},
@condition{out-of-memory-error}.
@end defun

@c page
@node iklib memory blocks
@subsection Memory blocks


The following bindings are exported by the libraries @library{vicare},
@library{ikarus} and @library{ikarus system $foreign} and reexported by
the library @library{vicare ffi}.


@deftp {Struct Type} memory-block
Data structure used to reference a raw memory block through a pointer
and number of bytes.  It has the following public fields:

@table @code
@item pointer
A pointer object referencing the first byte of memory.

@item size
The number of bytes in the memory block; it is an exact integer in the
range of the C language type @code{size_t}.
@end table
@end deftp


@defun make-memory-block @var{pointer} @var{size}
@defunx make-memory-block/guarded @var{pointer} @var{size}
Build and return a new instance of @code{memory-block} referencing a
memory block pointed to by @var{pointer} and of @var{size} number of
bytes.

When a @code{memory-block} built by @func{make-memory-block} is garbage
collected: nothing happens.

When a @code{memory-block} built by @func{make-memory-block/guarded} is
garbage collected: the referenced memory block is released with
@func{free} from @library{vicare}.
@end defun


@defun memory-block? @var{obj}
Return @true{} if @var{obj} is an instance of @code{memory-block}.
@end defun


@defun memory-block?/non-null @var{obj}
@defunx memory-block?/not-null @var{obj}
Return @true{} if @var{obj} is an instance of @code{memory-block} and
the pointer is not @cnull{}.
@end defun


@defun memory-block-pointer @var{mblock}
@defunx memory-block-size @var{mblock}
Accessors for the fields of @code{memory-block} instances.  The pointer
object returned by @func{memory-block-pointer} is a copy of the pointer
object in @var{mblock}.
@end defun


@defun memory-block-reset @var{mblock}
Reset an instance of @code{memory-block} to a @cnull{} pointer and zero
size.  Return unspecified values.
@end defun

@c page
@node iklib memory condition
@subsection Memory allocation condition objects


The following bindings are exported by the libraries @library{vicare},
@library{ikarus} and @library{ikarus system $foreign} and reexported by
the library @library{vicare ffi}.


@deftp {Condition Type} &out-of-memory-error
Condition object type used to tag conditions representing memory
allocation errors; it is derived from @condition{error}.  It has no
fields.
@end deftp


@defun make-out-of-memory-error
@defunx out-of-memory-error? @var{obj}
Maker and predicate for condition objects of type
@condition{out-of-memory-error}.
@end defun

@c page
@node iklib cstrings
@section Raw C strings


The following functions perform operations on raw @ascii{} coded strings
terminated by a zero byte, for short @asciiz{} strings; some functions
act upon raw @utf{}-16 strings.  The following bindings are exported by
the libraries @library{vicare}, @library{ikarus} and @library{ikarus
system $foreign} and reexported by the library @library{vicare ffi}.


@defun bytevector->cstring @var{bv}
@defunx bytevector->guarded-cstring @var{bv}
Convert from a Scheme bytevector to an @asciiz{} string.  If successful
return a pointer object referencing the string, else return @false{}.

Memory allocated by @func{bytevector->cstring} must be explicitly
released by @func{free}; memory allocated by
@func{bytevector->guarded-cstring} is automatically released by the
garbage collector whenever the returned pointer is garbage collected.
@end defun


@defun bytevector->cstring* @var{bv}
@defunx bytevector->guarded-cstring* @var{bv}
Like @func{bytevector->cstring*} and @func{bytevector->guarded-cstring},
but if allocation fails raise a non--continuable exception with
components: @condition{who}, @condition{message},
@condition{out-of-memory-error}.
@end defun


@defun cstring->bytevector @var{pointer}
@defunx cstring->bytevector @var{pointer} @var{count}
Convert between an @asciiz{} string and a Scheme bytevector.  When used,
@var{count} must be a fixnum representing the number of bytes to include
in the bytevector.
@end defun


@defun string->cstring @var{str}
@defunx string->guarded-cstring @var{str}
Convert from a Scheme string to an @asciiz{} string.  If successful
return a pointer object referencing the string, else return @false{}.

The string argument must contain only characters with Unicode code
points in the range @math{[0, 255]}.

Memory allocated by @func{string->cstring} must be explicitly
released by @func{free}; memory allocated by
@func{string->guarded-cstring} is automatically released by the
garbage collector whenever the returned pointer is garbage collected.
@end defun


@defun cstring16->bytevector @var{pointer}
Convert between an @utf{}-16 string and a Scheme bytevector; this
function works with all the possible encodings of the string.  The end
of the string is determined by searching for a sequence of two
consecutive zero bytes, starting at even offset.
@end defun


@defun cstring16n->string @var{pointer}
@defunx cstring16le->string @var{pointer}
@defunx cstring16be->string @var{pointer}
Like @func{cstring16->bytevector}, but convert the result to a Scheme
string assuming the specified byte order (native, little endian, big
endian).
@end defun


@defun string->cstring* @var{str}
@defunx string->guarded-cstring* @var{str}
Like @func{string->cstring} and @func{string->guarded-cstring}, but if
allocation fails raise a non--continuable exception with components:
@condition{who}, @condition{message}, @condition{out-of-memory-error}.
@end defun


@defun cstring->string @var{pointer}
@defunx cstring->string @var{pointer} @var{count}
Convert between an @asciiz{} string and a Scheme string.  When used,
@var{count} must be a fixnum representing the number of bytes to include
in the string.
@end defun


@defun strlen @var{pointer}
Interface to the C function @cfunc{strlen}, @glibcref{String Length,
strlen}.  Return an exact integer representing the length of the
@asciiz{} string referenced by @var{pointer}.
@end defun


@defun strcmp @vari{pointer} @varii{pointer}
Interface to the C function @cfunc{strcmp}, @glibcref{String/Array
Comparison, strcmp}.  Return a fixnum representing the classic
comparison ternary result of comparing the @asciiz{} strings referenced
by @vari{pointer} and @varii{pointer}.
@end defun


@defun strncmp @vari{pointer} @varii{pointer} @var{count}
Interface to the C function @cfunc{strncmp}, @glibcref{String/Array
Comparison, strncmp}.  Return a fixnum representing the classic
comparison ternary result of comparing the first @var{count} bytes in
the @asciiz{} strings referenced by @vari{pointer} and @varii{pointer}.
@var{count} must be an exact integer in the range of the C language type
@code{size_t}.
@end defun


@defun strdup @var{pointer}
@defunx guarded-strdup @var{pointer}
Interface to the C function @cfunc{strdup}, @glibcref{Copying and
Concatenation, strdup}.  Duplicate the @asciiz{} string referenced by
@var{pointer}; if successful return a new pointer object, else return
@false{}.

Memory allocated by @func{strdup} must be explicitly released by
@func{free}; memory allocated by @func{guarded-strdup} is automatically
released by the garbage collector whenever the returned pointer is
garbage collected.
@end defun


@defun strdup* @var{pointer}
@defunx guarded-strdup* @var{pointer}
Like @func{strdup} and @func{guarded-strdup}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun strndup @var{pointer} @var{count}
@defunx guarded-strndup @var{pointer} @var{count}
Interface to the C function @cfunc{strndup}, @glibcref{Copying and
Concatenation, strndup}.  Duplicate the first @var{count} bytes in the
@asciiz{} string referenced by @var{pointer}; if successful return a new
pointer object, else return @false{}.  @var{count} must be an exact
integer in the range of the C language type @code{size_t}.

Memory allocated by @func{strdup} must be explicitly released by
@func{free}; memory allocated by @func{guarded-strdup} is automatically
released by the garbage collector whenever the returned pointer is
garbage collected.
@end defun


@defun strndup* @var{pointer} @var{count}
@defunx guarded-strndup* @var{pointer} @var{count}
Like @func{strndup} and @func{guarded-strndup}, but if allocation fails
raise a non--continuable exception with components: @condition{who},
@condition{message}, @condition{out-of-memory-error}.
@end defun


@defun bytevectors->argv @var{list-of-bytevectors}
@defunx bytevectors->guarded-argv @var{list-of-bytevectors}
Given a list of bytevectors: convert them into @asciiz{} strings and
build a @cnull{} terminated array of C pointers referencing the strings.
Return a pointer to the array.  The strings and the array are stored in
a single memory block.

Memory allocated by @func{bytevectors->argv} must be explicitly released
by @func{free}; memory allocated by @func{bytevectors->guarded-argv} is
automatically released by the garbage collector whenever the returned
pointer is garbage collected.
@end defun


@defun bytevectors->argv* @var{list-of-bytevectors}
@defunx bytevectors->guarded-argv* @var{list-of-bytevectors}
Like @func{bytevectors->argv*} and @func{bytevectors->guarded-argv*},
but if allocation fails raise a non--continuable exception with
components: @condition{who}, @condition{message},
@condition{out-of-memory-error}.
@end defun


@defun argv->bytevectors @var{pointer}
Given a pointer to a @cnull{} terminated array of C pointers referencing
@asciiz{} strings: build and return a list of bytevectors holding the
same bytes of the strings.
@end defun


@defun strings->argv @var{list-of-strings}
@defunx strings->guarded-argv @var{list-of-strings}
Given a list of Scheme strings: convert them into @asciiz{} strings and
build a @cnull{} terminated array of C pointers referencing the strings.
Return a pointer to the array.  The strings and the array are stored in
a single memory block.

The string arguments must contain only characters with Unicode code
points in the range @math{[0, 255]}.

Memory allocated by @func{strings->argv} must be explicitly released
by @func{free}; memory allocated by @func{strings->guarded-argv} is
automatically released by the garbage collector whenever the returned
pointer is garbage collected.
@end defun


@defun strings->argv* @var{list-of-strings}
@defunx strings->guarded-argv* @var{list-of-strings}
Like @func{strings->argv} and @func{strings->guarded-argv}, but if
allocation fails raise a non--continuable exception with components:
@condition{who}, @condition{message}, @condition{out-of-memory-error}.
@end defun

@defun argv->strings @var{pointer}
Given a pointer to a @cnull{} terminated array of C pointers referencing
@asciiz{} strings: build and return a list of strings holding the same
bytes of the strings.
@end defun


@defun argv-length @var{argv}
Return the number of strings in the @cnull{}--terminated array of
strings referenced by the @var{argv} pointer.
@end defun

@c page
@node iklib errno
@section Interface to @code{errno}


Most C language system functions report errors by setting a the special
variable @code{errno} to some predefined integer constant,
@glibcref{Checking for Errors, errno}.  The Scheme code accessing
@code{errno} values should be agnostic with respect to the actual error
codes; for this to happen we should use the following facilities along
with bindings from @library{vicare errno}, @ref{errno} for details.

Values for the C language variable @code{errno} are encoded as negated
fixnum values: if @code{EPERM} is defined to @code{1} at the C language
level, @value{PRJNAME} defines it as the fixnum @code{-1}; at present
all the known error codes fit into fixnums range.  One syntax identifier
binding for each known @code{errno} value is exported by the library
@library{vicare errno} and reexported by the library @library{vicare
platform-constants}.

If some error codes are not defined on a platform: the corresponding
binding evaluates to @true{}.  Notice that if no error occurred
@code{errno} is set to the fixnum zero.

The following bindings are exported by the libraries @library{vicare},
@library{ikarus} and @library{ikarus system $foreign} and reexported by
the library @library{vicare ffi}.


@defun errno
@defunx errno @var{code}
Interface to the C language level @code{errno} variable to be used with
the foreign--functions interface (@ffi{}).

When called with no values return the value of the C variable
@code{errno} right after the last call to a C function performed by the
current process through the @ffi{}.  When called with one argument: set
the C variable @code{errno} of the current process to @var{code},
appropriately handling the coding of the value.

Notice that bindings exported by @library{vicare posix}, @library{vicare
glibc} and @library{vicare linux} do @strong{not} use this mechanism;
rather they raise an exception whenever an error happen.

As special cases: when the C variable @code{errno} is set to zero,
@func{errno} returns @false{}; when @var{code} is @false{}, the C
variable @code{errno} is set to zero; when @var{code} is @true{}, the C
variable @code{errno} is set to @code{EFAULT}.

The mechanism is such that the following form:

@example
(let ((rv (call-foreign-function)))
  (values rv (errno)))
@end example

@noindent
performs a foreign--function call and evaluates to two values: the
return value from the foreign function and the value of the C variable
@code{errno} right after the foreign call.
@end defun

@c page
@node iklib readline
@section Readline interface


The following bindings are exported by the libraries @library{vicare},
@library{ikarus}.  An extended @api{} for @gnu{} Readline is available
through the @library{vicare readline} library; @ref{readline} for
details.


@defun readline-enabled?
Return @true{} is support for readline is enabled, return @false{}
otherwise.  When this function returns @false{}: no other readline
functions must be called, lest the process be aborted.
@end defun


@defun readline
@defunx readline @var{prompt}
Read a single line and return it as a Scheme string @strong{not}
terminated by a newline character.  @var{prompt} must be @false{}, a
bytevector or a string to be used as input prompt; when @false{} or not
present: no prompt will be displayed.
@end defun


@defun make-readline-input-port
@defunx make-readline-input-port @var{prompt-maker}
Return a custom textual input port reading character through
@func{readline}.

@var{prompt-maker} must be a @false{} or a thunk, when not used it
defaults to @false{}; the thunk, when evaluated, must return a string or
bytevector representing the input prompt in @ascii{} characters; if the
return value is @false{} or @var{prompt-maker} is not used: no prompt
will be displayed.
@end defun

@c page
@node iklib debug
@section Debugging utilities


@defun integer->machine-word @var{exact-integer}
@defunx machine-word->integer @var{word}
Convert between an exact integer and a machine word.  This operation
shows at the Scheme level the internal representation of values.  Care
must be taken when using these functions because it is very easy to
cause undefined behaviour.

@example
;; on 32-bit platforms
(integer->machine-word #b11100) @result{} #b111

;; on 64-bit platforms
(integer->machine-word #b111000) @result{} #b111

(integer->machine-word #x3F)    @result{} #t
(integer->machine-word #x2F)    @result{} #f

(machine-word->integer #t)      @result{} #x3F
(machine-word->integer #f)      @result{} #x2F
@end example
@end defun

@c page
@node iklib misc
@section Miscellaneous functions


@defun void
Return the void value.  It is the value returned by forms that do not
return a meaningful value.
@end defun


@defun host-info
Return a string being the value @gnu{} Autoconf assigned to the
@code{target} variable.  Example: @code{i686-pc-linux-gnu}.
@end defun


@defun apropos @var{key}
Given a string or symbol @var{key}, search among the internally
installed libraries all the exported bindings having @var{key} as
substring of their name and print a report to the standard output port.
Useful when using the @repl{}.  Example:

@example
vicare> (apropos "-length")
*** in library (ikarus):
(bitwise-length bytevector-length string-length
  struct-length vector-length)

*** in library (rnrs):
(bitwise-length bytevector-length string-length
  vector-length)

*** in library (rnrs arithmetic bitwise):
(bitwise-length)

*** in library (rnrs base):
(string-length vector-length)

*** in library (rnrs bytevectors):
(bytevector-length)

*** in library (vicare):
(bitwise-length bytevector-length string-length
  struct-length vector-length)

vicare>
@end example
@end defun


@defun getenv @var{varname}
Interface to the C function @cfunc{getenv}, @glibcref{Environment
Access, getenv}.  Retrieve the value of environment variables.
@var{variable} must reference a string object representing the name of
the environment variable.  If the environment variable is set: return a
string representing its value; else return false.

@example
(getenv "PATH")
@result{} "/usr/local/bin:/usr/bin:/bin"
@end example

The Scheme level representation of environment variables names and
values is a string, but internally it is a bytevector; strings are
internally converted to bytevectors using @func{string->utf8}.
@end defun


@defun strerror @var{errno}
Return a string describing the @code{errno} code @var{errno}.  Makes use
of the system function @cfunc{strerror}.  If @var{errno} is not a valid
@code{errno} value: return a string telling it.  As special cases
@var{errno} can be also @true{}, meaning ``unknown error'', and
@false{}, meaning ``no error''.

@glibcref{Error Messages, Error Messages}
@end defun

@c page
@node ffi
@chapter Foreign functions interface


The library @library{vicare ffi} interfaces with the host operating
system and other external libraries exposing a C language interface; it
is suggested to import the @ffi{} library with the prefix @code{ffi.},
as in the following prelude:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare ffi) ffi.))
@end example

The facilities of the @library{vicare ffi} give the Scheme program
unrestricted access to the computer memory, allowing one to allocate,
access, modify, and free memory as needed.  The facilities also allow
the Scheme program to @dfn{call out} to system procedures as well as
allow the native procedures to @dfn{call back} into Scheme.

Additionally, @library{vicare ffi} reexports all the bindings from the
library @library{ikarus system $foreign}.

@menu
* ffi libffi::                  Installing and using Libffi.
* ffi dl::                      Accessing shared libraries.
* ffi shared::                  System-agnostic shared libraries @api{}.
* ffi call::                    Callouts and callbacks.
@end menu

@c page
@node ffi libffi
@section Installing and using Libffi


Currently @value{PRJNAME} implements the foreign--functions interface
(@ffi{}) using an extenal library: Libffi, originally by Anthony Green.
Libffi can be found at:

@center @url{http://sourceware.org/libffi/}

@noindent
and it is distributed under a liberal license (look for it at the site,
basically we can do everything but remove the original copyright
notice).

On Unix--like systems, we can install Libffi with the traditional
sequence:

@example
$ ./configure [options]
$ make
$ make install
@end example

@noindent
and the makefile supports the @env{DESTDIR} environment variable for
installation under a different directory prefix.

@quotation
@strong{NOTE} Libffi version 3.0.10 installs its header files under:

@example
$@{prefix@}/lib/libffi-3.0.10/include
@end example

@noindent
and trying to use the @option{--includedir} option to
@command{configure} will @strong{not} work in changing this.  It means
that when configuring @value{PRJNAME} for installation we have to specify where
the Libffi headers are to be found; @ref{overview install} for details.
@end quotation

@c page
@node ffi dl
@section Accessing foreign objects from Scheme


Most system implementations of dynamic loading employ reference counting
for @func{dlopen} and @func{dlclose} in that library resources are not
freed until the number of calls to @func{dlclose} matches the number of
calls to @func{dlopen}.  The following bindings are exported by
@library{vicare ffi}.


@defun dlopen
@defunx dlopen @var{library-name}
@defunx dlopen @var{library-name} @var{lazy?} @var{global?}
Interface to the C function @cfunc{dlopen}, see the manual page
@code{dlopen(3)}.  Load a platform shared library and return a pointer
object representing a handler for the library, which can be used as
argument for @func{dlsym} and @func{dlclose}.  If the library cannot be
loaded: return @false{} and the procedure @func{dlerror} can be used to
obtain the cause of the failure.

When no arguments are present: the returned pointer handler references
the current process and it can be used to retrieve pointers to functions
already loaded, for example the functions exported by the standard C
library.  The @var{lazy?} and @var{global?} arguments are meaningless in
this case.

When given: @var{library-name} must be a string or a bytevector
representing the name of the library; if it is a string: it is converted
to bytevector using the function referenced by
@func{filename->string-func}.

Library names are system--dependent and must include the appropriate
suffix (for exapmle @code{*.so} on Linux, @code{*.dylib} on Darwin and
@code{*.dll} on Cygwin).  @var{library-name} may include a full path
which identifies the location of the library, or it may just be the name
of the library in which case the system will lookup the library name
using the @env{LD_LIBRARY_PATH} environment variable.

The argument @var{lazy?} specifies how library dependencies are loaded.
If true, @func{dlopen} delays the resolution and loading of dependent
libraries until they are actually used.  If false, all library
dependencies are loaded before the call to @func{dlopen} returns.
@var{lazy?} defaults to @false{}.

The argument @var{global?} specifies the scope of the symbols exported
from the loaded library.  If true, all exported symbols become part of
the running image, and subsequent @func{dlsym} calls may not need to
specify the library from which the symbol is loaded.  If false, the
exported symbols are not global and the library pointer needs to be
specified for @func{dlsym}.  @var{global?} defaults to @false{}.
@end defun


@defun dlclose @var{handle}
Interface to the C function @cfunc{dlclose}, see the manual page
@code{dlclose(3)}.  Release the resources loaded from the library
referenced by the pointer handler @var{handle}.  If successful return
@true{}, else return @false{} and @func{dlerror} can be used to obtain
the cause of the error.

Closing a library renders all symbols and static data structures that
the library exports invalid and the program may crash or corrupt its
memory if such symbols are used after a library is closed.
@end defun


@defun dlsym @var{handle} @var{name}
Interface to the C function @cfunc{dlsym}, see the manual page
@code{dlsym(3)}.  Search the loaded library referenced by the pointer
@var{handle} for an exported symbol whose name is represented by the
string @var{name}.  If successful return a pointer object, else return
@false{} and @code{dlerror} can be used to obtain the cause of the
error.

If the returned value references a function: it can be used as argument
to the callout generators built by @func{make-c-callout-maker}.
@end defun


@defun dlerror
Interface to the C function @cfunc{dlerror}, see the manual page
@code{dlerror(3)}.  If any of the dynamic loading operations fails, the
cause of the error can be obtained by calling @func{dlerror} which
returns a string describing the error; return @false{} if there was no
dynamic loading error.
@end defun

@c page
@node ffi shared
@section System--agnostic shared libraries @api{}


This @api{} to load shared libraries is more system--agnostic with
respect to the functions described in @ref{ffi dl}.  The following
bindings are exported by @library{vicare ffi}.


@defun open-shared-object
@defunx open-shared-object @var{so-name}
Load a platform shared library and return a pointer object representing
a handler for the library.  If the library cannot be loaded: raise a
non--continuable exception with condition types @condition{who},
@condition{message}, @condition{shared-object-opening-error}.

When no arguments are present: the returned pointer handler references
the current process and it can be used to retrieve pointers to functions
already loaded, for example the functions exported by the standard C
library.

When given: @var{so-name} must be a string representing the name of the
library; library names are system--dependent and must include the
appropriate suffix (for exapmle @code{*.so} on Linux, @code{*.dylib} on
Darwin and @code{*.dll} on Cygwin).  @var{so-name} may include a full
path which identifies the location of the library, or it may just be the
name of the library.

@quotation
@strong{For Unix} We can find documentation about the search path of
shared objects in the manual page of @cfunc{dlopen}.  The system will
lookup the library name using the @env{LD_LIBRARY_PATH} environment
variable.
@end quotation
@end defun


@defun close-shared-object @var{so-handle}
Release the resources loaded from the library referenced by the
@var{so-handle}.  If the library cannot be closed: raise a
non--continuable exception with condition types @condition{who},
@condition{message}, @condition{shared-object-closing-error}.

Closing a library renders all symbols and static data structures that
the library exports invalid and the program may crash or corrupt its
memory if such symbols are used after a library is closed.
@end defun


@defun lookup-shared-object @var{so-handle} @var{name}
Search the loaded library referenced by the @var{so-handle} for an
exported symbol whose name is represented by the Scheme string
@var{name}.  If successful return a pointer object, else raise a
non--continuable exception with condition types @condition{who},
@condition{message}, @condition{shared-object-lookup-error}.

If the returned value references a function: it can be used as argument
to the callout generators built by @func{make-c-callout-maker}.
@end defun


@c ------------------------------------------------------------

@subsubheading Shared object errors

@deftp {Condition Type} &shared-object-error
Base condition type for all the exceptions associated to a shared
object; it is derived from @condition{error}.  It has no fields.
@end deftp


@defun make-shared-object-error
Build and return a new instance of @condition{shared-object-error}.
@end defun


@defun shared-object-error? @var{obj}
Return @true{} if @var{obj} is an instance of
@condition{shared-object-error}, else return @false{}.
@end defun

@c ------------------------------------------------------------

@subsubheading Opening shared objects

@deftp {Condition Type} &shared-object-opening-error
Condition type tagging exceptions associated to opening a shared object;
it is derived from @condition{shared-object-error}.  It has the
following fields:

@table @code
@item name
Scheme string representing the file name of the shared object.
@end table
@end deftp


@defun make-shared-object-opening-error @var{so-name}
Build and return a new instance of
@condition{shared-object-opening-error}.
@end defun


@defun shared-object-opening-error? @var{obj}
Return @true{} if @var{obj} is an instance of
@condition{shared-object-opening-error}, else return @false{}.
@end defun


@defun condition-shared-object-opening-name @var{so-opening}
Accessor for the field of @condition{shared-object-opening-error}.
@end defun

@c ------------------------------------------------------------

@subsubheading Closing shared objects

@deftp {Condition Type} &shared-object-closing-error
Condition type tagging exceptions associated to closing a shared object;
it is derived from @condition{shared-object-error}.  It has the
following fields:

@table @code
@item so-handle
Pointer object referencing the shared object; it is the value returned
by @func{open-shared-object}.
@end table
@end deftp


@defun make-shared-object-closing-error @var{so-handle}
Build and return a new instance of
@condition{shared-object-closing-error}.
@end defun


@defun shared-object-closing-error? @var{obj}
Return @true{} if @var{obj} is an instance of
@condition{shared-object-closing-error}, else return @false{}.
@end defun


@defun condition-shared-object-closing-so-handle @var{so-closing}
Accessor for the field of @condition{shared-object-closing-error}.
@end defun

@c ------------------------------------------------------------

@subsubheading Inspecting shared objects

@deftp {Condition Type} &shared-object-lookup-error
Condition type tagging exceptions associated to looking up a symbol in a
shared object; it is derived from @condition{shared-object-error}.  It
has the following fields:

@table @code
@item so-handle
Pointer object referencing the shared object; it is the value returned
by @func{open-shared-object}.

@item foreign-symbol
Scheme string representing the shared object exported symbol whose
address was requested.
@end table
@end deftp


@defun make-shared-object-lookup-error @var{so-handle} @var{symbol}
Build and return a new instance of
@condition{shared-object-lookup-error}.
@end defun


@defun shared-object-lookup-error? @var{obj}
Return @true{} if @var{obj} is an instance of
@condition{shared-object-lookup-error}, else return @false{}.
@end defun


@defun condition-shared-object-lookup-so-handle @var{so-lookup}
@defunx condition-shared-object-lookup-foreign-symbol @var{so-lookup}
Accessors for the fields of @condition{shared-object-lookup-error}.
@end defun

@c page
@node ffi call
@section Callouts and callbacks


Callouts allow Scheme code to invoke C functions in a foreign library;
callbacks allow foreign C code to call a Scheme function.  The following
example shows how Scheme code can call a callout which in turns calls a
callback:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare ffi) ffi.))

(define callout-maker
  (ffi.make-c-callout-maker  'unsigned-int '(unsigned-int)))

(define callback-maker
  (ffi.make-c-callback-maker 'unsigned-int '(unsigned-int)))

(define callback
  (callback-maker values))

(define callout
  (callout-maker callback))

(callout 123)   @result{} 123

(ffi.free-c-callback callback)
@end example

@menu
* ffi call intro::              Overview of @ffi{} function calls.
* ffi call out::                Calling out to foreign procedures.
* ffi call back::               Calling back to Scheme.
* ffi call types::              Specifying native types.
@end menu

@c page
@node ffi call intro
@subsection Overview of @ffi{} function calls


Both callouts and callbacks are built on top of function signatures
specifying the type of function arguments and returned value.  Libffi
allows us to specify such signatures through a Call InterFace (@cif{})
data structure; @value{PRJNAME} internally extends such a structure with
additional data to speed up marshaling of values from Scheme to native
representation and back.

At present, @cif{} data structures are allocated with @cfunc{malloc} and
never released.  Callouts and callbacks make use of @cif{} structures of
the same format, so such structures are internally cached; a single
@cif{} associated to a given function signature is used by all the
callouts and callbacks having the same signature.

@c ------------------------------------------------------------

@subsubheading Calling out to foreign functions

Callouts require only a @cif{} structure and the address of the foreign
C function; no additional structure needs to be allocated and then
released.

@value{PRJNAME} organises the callout @api{} by creating a callout maker
function, closed upon a @cif{} structure, which can build any number of
callout functions associating the @cif{} to foreign function pointers.
Maker functions are cached internally, so only one maker function for a
given signature is created in a running process.

@c ------------------------------------------------------------

@subsubheading Calling back to Scheme functions

Callbacks require an additional data structure, because they must
generate at runtime callable machine code referenced by a pointer; such
additional data structure cannot be automatically released by the
garbage collector, but it can be explicitly freed by the program when
the callback is no longer needed.

We can think of the code handling a callback as organised like the
following pseudo--code:

@example
cif_t  call_interface;

int
specific_callback (int a, long b, double c)
@{
  void *  args[3] = @{ &a, &b, &c @};
  int     result;
  generic_callback(&call_interface, &result, args);
  return result;
@}

void
generic_callback (cif_t * call_interface,
                  void * result, void * args)
@{
  scheme_value  s_a, s_b, s_c;
  scheme_value  s_result;
  s_a = native_to_scheme(call_interface, 0, args);
  s_b = native_to_scheme(call_interface, 1, args);
  s_c = native_to_scheme(call_interface, 2, args);
  s_result = scheme_callback(s_a, s_b, s_c);
  scheme_to_native(call_interface, result, s_result);
@}

scheme_value
scheme_callback (scheme_value s_a,
                 scheme_value s_b,
                 scheme_value s_c)
@{
  /* process arguments, return result */
@}
@end example

@noindent
where: @code{specific_callback} is generated at runtime by Libffi;
@code{generic_callback}, @code{scheme_to_native} and
@code{native_to_scheme} are implemented by @value{PRJNAME}'s runtime
(using generic operations); @code{scheme callback} is implemented by the
Scheme program.  A pointer to @code{specific_callback} is the one we
need to acquire when creating a callback from Scheme.

@value{PRJNAME} organises the callback @api{} by creating a callback
maker function, closed upon a @cif{} structure, which can build any
number of callback functions associating the @cif{} to Scheme functions.
Maker functions are cached internally, so only one maker function for
each given signature is created in a running process.

@c page
@node ffi call out
@subsection Calling out to foreign procedures


In order to call out to a foreign procedure, we must provide two pieces
of information: the signature of the foreign procedure and the address
of the procedure in memory.  The signature must usually be hard--coded
into the program; the address is obtained using @func{dlsym}.

Using the signature, the @ffi{} determines how Scheme values are
converted to and from native values; a signature is composed of two
parts: a Scheme symbol specifying the return type, a list of Scheme
symbols specifying the argument types.

Here is a simple example, without error checking, showing how to
interface to the C function @cfunc{sinh}:

@example
#!r6rs
(import (vicare)
  (prefix (vicare ffi) ffi.))

(define libc
  (ffi.dlopen))

(define sinh-address
  (ffi.dlsym libc "sinh"))

(define callout-maker
  (ffi.make-c-callout-maker 'double '(double)))

(define sinh
  (callout-maker sinh-address))

(sinh 1.2)      @result{} 1.5094613554121725
@end example

@noindent
using the @ffi{} we build a callout function generator which can be used
to create any number of callout functions having the same signature.
Generated callout functions are garbage collected like any other Scheme
value.


@defun make-c-callout-maker @var{ret-type} @var{arg-types}
Build and return a function to be used to generate callout Scheme
functions wrapping foreign functions which follow the C language
conventions for calling, arguments and return values.

The returned generator function accepts as single argument a pointer
object representing the address of a foreign function; the value
returned by the generator function is a Scheme closure wrapping the
foreign function.  The wrapper Scheme closure takes care of marshaling
Scheme values as appropriate for the underlying platform.

@var{ret-type} must be a Scheme symbol specifying the type of the
returned value; if the foreign function returns no value: @var{ret-type}
must be the symbol @code{void}.

@var{arg-types} must be a list of Scheme symbols specifying the type of
the arguments; if the foreign function accepts no arguments:
@var{arg-types} must be nil or the list @code{(void)}.

@ref{ffi call types} for the specification of accepted type symbols.
@end defun


@defun make-c-callout-maker/with-errno @var{ret-type} @var{arg-types}
Like @func{make-c-callout-maker}, but the generated callout closures
will return two values: the return value from the foreign function call
and the value of the C language variable @code{errno} right after the
foreign function call.
@end defun

@c page
@node ffi call back
@subsection Calling back to Scheme


In order to arrange for a foreign library to callback to a Scheme
function we need a suitable Scheme function and the signature of the
procedure the foreign library expects.  The signature must usually be
hard--coded in the program.

Using the signature, the @ffi{} determines how native values are
converted to and from Scheme values; a signature is composed of two
parts: a Scheme symbol specifying the return type, a list of Scheme
symbols specifying the argument types.  The signature format is the same
as the one used for callouts; @ref{ffi call out} for details.

Note that a callback function is indistinguishable from other native
procedures whose address is obtained using @func{dlsym} or similar
means.  In particular, such native pointers can be passed to callout
generators resulting in a Scheme procedure that calls out to the native
procedure that in turn calls back into Scheme.

The following example shows how to create an identity function for
native integers composed by a Scheme function calling out to a foreign
function, calling back to the Scheme function @func{values}:

@example
#!r6rs
(import (vicare)
  (prefix (vicare ffi) ffi.))

(define callout-maker
  (ffi.make-c-callout-maker  'unsigned-int '(unsigned-int)))

(define callback-maker
  (ffi.make-c-callback-maker 'unsigned-int '(unsigned-int)))

(define identity
  (callout-maker (callback-maker values)))

(identity 123)  @result{} 123
@end example

@noindent
using the @ffi{} we build a callback function generator which can be
used to create any number of callback functions having the same
signature.  Generated callback functions are @strong{not} garbage
collected like the other Scheme values.


@defun make-c-callback-maker @var{ret-type} @var{arg-types}
Build and return a function to be used to generate callback functions
following the C language conventions for calling, arguments and return
values and wrapping Scheme functions.

The returned generator function accepts as single argument the Scheme
function to be wrapped; the value returned by the generator function is
a pointer object referencing a native function.  The wrapper native
function takes care of marshaling Scheme values as appropriate for the
underlying platform.

@var{ret-type} must be a Scheme symbol specifying the type of the
returned value; if the callback function must return no value:
@var{ret-type} must be the symbol @code{void}.

@var{arg-types} must be a list of Scheme symbols specifying the type of
the arguments; if the callback function must accept no arguments:
@var{arg-types} must be nil or the list @code{(void)}.

@ref{ffi call types} for the specification of accepted type symbols.
@end defun


@defun free-c-callback @var{c-callback-pointer}
Release the resources associated to the given C pointer referencing a
callback function.  If the pointer is not a callback pointer: raise an
assertion violation.
@end defun

@c page
@node ffi call types
@subsection Specifying native types


The following is a list of Scheme symbols used to specify native types
for both callouts and callbacks.  If a type is not available on a
platform: the callout and callback generators will raise an error if the
associated type specifier is used.

@table @code
@item signed-char
@itemx unsigned-char
Exact integers in the range for @code{char} and @code{unsigned char}.

@item signed-short
@itemx unsigned-short
Exact integers in the range for @code{short int} and @code{unsigned short
int}.

@item signed-int
@itemx unsigned-int
Exact integers in the range for @code{int} and @code{unsigned int}.

@item signed-long
@itemx unsigned-long
Exact integers in the range for @code{long} and @code{unsigned long}.

@item signed-long-long
@itemx unsigned-long-long
Exact integers in the range for @code{long long} and @code{unsigned long
long}.

@item float
@itemx double
Flonum.

@item pointer
@itemx callback
Pointer object.  The symbol @code{callback} can be used to specify a
pointer to a callback, but it is a full synonym of @code{pointer}.

@item int8_t
@itemx uint8_t
Exact integers in the range for @code{int8_t} and @code{uint8_t}.

@item int16_t
@itemx uint16_t
Exact integers in the range for @code{int16_t} and @code{uint16_t}.

@item int32_t
@itemx uint32_t
Exact integers in the range for @code{int32_t} and @code{uint32_t}.

@item int64_t
@itemx uint64_t
Exact integers in the range for @code{int64_t} and @code{uint64_t}.

@item size_t
@itemx ssize_t
Exact integers in the range for @code{size_t} and @code{ssize_t}.

@item off_t
Exact integers in the range for @code{off_t}.

@item ptrdiff_t
Exact integers in the range for @code{ptrdiff_t}.
@end table

@c page
@node posix
@chapter The @posix{} interface


The @posix{} functions are exported by the library @library{vicare
posix}.  The @api{} attempts to create a one--to--one Scheme functions
mapping towards @posix{} functions, keeping the same semantics as much
as possible; the platform's own documentation is relevant at the Scheme
level.  @ref{posix not} for a list of @posix{} functions not interfaced
in this library, and reasons for not doing it.

To avoid name collisions with bindings exported by @library{ikarus} and
@library{vicare}, when importing @library{vicare posix} it is mandatory
to assign it a prefix as follows:

@example
(import (vicare)
  (prefix (vicare posix) px.))
@end example

All the constants needed to use the interface are available as
identifier syntaxes exported by the @library{vicare platform-constants}
library; if a constant value is not exported file a feature request for
the project.  If a constant is not defined on a platform: its value is
set to @false{}.

The library @library{vicare platform features} exports one identifier
syntax for each @code{HAVE_} symbol defined by @value{PRJNAME}
@command{configure} script, expanding to @true{} or @false{}.

@menu
* posix conventions::           Conventions about the @posix{} @api{}.
* posix conditions::            Condition object types.
* posix env::                   Operating system environment variables.
* posix pid::                   Process identifier functions.
* posix process::               Spawning processes and the like.
* posix status::                Process termination status.
* posix signal::                Delivering signals to processes.
* posix stat::                  File system inspection.
* posix file::                  Interfacing with the file system.
* posix link::                  Hard and symbolic links.
* posix dir::                   File system directories.
* posix fd::                    File descriptors.
* posix mmap::                  Memory-mapped input/output.
* posix socket::                Network sockets.
* posix users::                 Users and groups.
* posix job::                   Job control.
* posix time::                  Time related functions.
* posix timers::                @posix{} per--process timers.
* posix config::                System configuration.
* posix resources::             Resources usage.
* posix mq::                    Message queues.
* posix shm::                   Shared memory.
* posix sem::                   Semaphores.
* posix misc::                  Miscellaneous functions.
* posix not::                   @posix{} functions not interfaced.
@end menu

@c page
@node posix conventions
@section Conventions about the @posix{} @api{}


The following common arguments are specified:

@table @var
@item fd
It must be a non--negative fixnum repsesenting a platform's file
descriptor.

@item pathname
@itemx filename
@itemx dirname
It must be a string or bytevector representing a file system entry.

@item stat
It must be an instance of @code{struct-stat} data structure, @ref{posix
stat} for details.
@end table

The proper data type for file system pathnames is the bytevector; all
the functions requiring a pathname as argument accept both a bytevector
and a string for convenience.  String pathnames are converted to and
from bytevectors using the functions referenced by the parameters
@func{string->filename-func} and @func{filename->string-func}.

Whenever a system call returns a file system pathname: two functions are
provided by the @posix{} @api{}, one returning a bytevector and one
returning a string; the one returning a string has name ending with the
suffix @samp{/string}.

Whenever a function in the @posix{} @api{} fails: it raises an exception
with compound condition type @condition{error}, @condition{who},
@condition{message}, @condition{irritants}; if the error is described by
an @code{errno} value, an additional @condition{errno} component is
present; if the function involves a file, an additional type
@condition{i/o-filename} is present.

Values of the @code{errno} C language variable are negated and encoded
as fixnums.  Values of the @code{h_errno} C language variable are
negated and encoded as fixnums.

@c page
@node posix conditions
@section Condition object types


@deftp {Condition Type} &errno
Condition object type representing system errors described by an encoded
@code{errno} value; it is derived from @condition{condition}.
@end deftp


@defun make-errno-condition @var{errno}
Build and return a new @condition{errno} condition object holding the
given encoded @code{errno} value.
@end defun


@defun errno-condition? @var{obj}
Return @true{} if @var{obj} is an instance of @condition{errno}.
@end defun


@defun condition-errno @var{obj}
Accessor for the encoded @code{errno} value in @var{obj}, which must be
an instance of @condition{errno}.
@end defun


@deftp {Condition Type} &h_errno
Condition object type representing system errors described by an encoded
@code{h_errno} value; it is derived from @condition{condition}.
@end deftp


@defun make-h_errno-condition @var{h_errno}
Build and return a new @condition{h_errno} condition object holding the
given encoded @code{h_errno} value.
@end defun


@defun h_errno-condition? @var{obj}
Return @true{} if @var{obj} is an instance of @condition{h_errno}.
@end defun


@defun condition-h_errno @var{obj}
Accessor for the encoded @code{h_errno} value in @var{obj}, which must be
an instance of @condition{h_errno}.
@end defun

@c page
@node posix env
@section Interfacing with the execution environment


The Scheme level representation of environment variables names and
values is a string, but internally it is a bytevector; strings are
internally converted to bytevectors using @func{string->utf8}.


@defun getenv @var{varname}
Interface to the C function @cfunc{getenv}, @glibcref{Environment
Access, getenv}.  Retrieve the value of environment variables.
@var{variable} must reference a string object representing the name of
the environment variable.  If the environment variable is set: return a
string representing its value; else return false.

@example
(getenv "PATH")
@result{} "/usr/local/bin:/usr/bin:/bin"
@end example
@end defun


@defun setenv @var{variable} @var{value} @var{overwrite}
Interface to the C function @cfunc{setenv}, @glibcref{Environment
Access, setenv}.  Set a new value for an environment variable.

@var{variable} must reference a string object representing the name of
the environment variable; @var{value} must reference a string object
representing the new value.  If @var{overwrite} is false and the
environment variable already exists: the environment variable is left
untouched; else the new value is set, either creating a new environment
variable or replacing the old value.

If successful return true, if an error occurs in @cfunc{setenv} return
false.
@end defun


@defun unsetenv @var{variable}
Interface to the C function @cfunc{unsetenv}, @glibcref{Environment
Access, unsetenv}.  Unset an environment variable.  @var{variable} must
reference a string object representing the name of the environment
variable.  Return true if @var{variable} has the correct format, else
return false; there is no way to know if a variable was actually unset.
@end defun


@defun environ
Interface to the global C variable @code{environ}, @glibcref{Environment
Access, unsetenv}.  Retrieve the full environment.  Return a list of
strings representing the contents of the @code{environ} array; if the
environment is empty (no environment variables set) return nil.
@end defun


@defun environ-table
Internally invoke @func{environ} and convert the alist of strings into a
hashtable; return the hashtable.  Both keys and values are strings.
@end defun


@defun environ->table @var{environ}
@defunx table->environ @var{table}
Convert between an alist in ``environ'' format and a hashtable.
@end defun

@c page
@node posix pid
@section Process identifier functions


@defun getpid
Return the process identifier as a fixnum.
@end defun


@defun getppid
Return the process identifier of the parent as a fixnum.
@end defun

@c page
@node posix process
@section Spawning processes and the like


@defun system @var{command}
Interface to the C function @cfunc{system}, @glibcref{Running a Command,
system}.  Execute a command through the system shell; @var{command} must
be a string holding the command to execute.  If successful return the
termination status of the executed process, @ref{posix status} for
details; if an error occurs: an exception is raised.

@example
(system "ls -l")
@end example
@end defun


@defun fork
@defunx fork @var{parent-proc} @var{child-thunk}
@cindex Forking processes
@cindex Processes, forking
Interface to the C function @cfunc{fork}, @glibcref{Creating a Process,
fork}.

When called with no arguments: create a new process by forking the
current one; if successful return a non--negative fixnum representing
the the return value of @cfunc{fork}, else raise an exception.

When called with two arguments: create a new process by forking the
current one; if successful the parent process applies @var{parent-proc}
to a fixnum representing the child process pid and return its return
value; if successful: the child process evaluates the @var{child-thunk}
and returns its return value; if an error occurs: an exception is
raised.

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.))

(px.fork
 (lambda (child-pid)
   (printf "in parent pid = ~a, child pid = ~s\n"
	   (px.getpid) child-pid)
   (flush-output-port (current-output-port)))
 (lambda ()
   (printf "in child, pid = ~a\n" (px.getpid))
   (flush-output-port (current-output-port))
   (exit)))

(printf "here we are in the parent\n")
(flush-output-port (current-output-port))
@end example
@end defun


@defun execv @var{filename} @var{argv}
@cindex Executing processes
@cindex Processes, executing
Interface to the C function @cfunc{execv}, @glibcref{Executing a File,
execv}.  @var{filename} must be the pathname of an executable file;
@var{argv} must be a list of strings representing command line
arguments.  Execute the command; if the function returns: an error has
occurred, an exception is raised.
@end defun


@defun execve @var{filename} @var{argv} @var{env}
Interface to the C function @cfunc{execve}, @glibcref{Executing a File,
execve}.  @var{filename} must be the pathname of an executable file;
@var{argv} must be a list of strings representing command line
arguments; @var{env} must be a list of strings representing environment
variables assignments.  Execute the command; if the function returns: an
error has occurred, an exception is raised.
@end defun


@defun execvp @var{filename} @var{argv}
Interface to the C function @cfunc{execvp}, @glibcref{Executing a File,
execvp}.  @var{filename} must be the pathname of an executable file
reachable in the current @env{PATH}; @var{argv} must be a list of
strings representing command line arguments.  Execute the command; if
the function returns: an error has occurred, an exception is raised.
@end defun


@defun execl @var{filename} @varo{arg} @var{arg} ...
Like @func{execv} but allows the arguments to be given expliticly.
@end defun


@defun execle @var{filename} @var{argv} @var{env} ...
Like @func{execve} but allows the environment to be given expliticly.
@end defun


@defun execlp @var{filename} @varo{arg} @var{arg} ...
Like @func{execvp} but allows the arguments to be given expliticly.
@end defun


@defun find-executable-as-bytevector @var{bv-pathname}
@defunx find-executable-as-string @var{str-pathname}
Given an absolute or relative file pathname or just the name of a file,
search the file system for a matching executable file; when found return
its absolute pathname as bytevector or Scheme string, else return
@false{}.  If an error occurs while inspecting the file system: raise an
exception.

@var{bv-pathname} must be a bytevector, @var{str-pathname} must be a
string.

@example
#!vicare
(import (vicare)
  (prefix (vicare posix) px.))

(px.find-executable-as-string "/usr/local/bin/vicare")
@result{} "/usr/local/bin/vicare"

(px.find-executable-as-string "vicare")
@result{} "/usr/local/bin/vicare"

(px.find-executable-as-string "this-cannot-exist")
@result{} #f

(px.find-executable-as-string "ls")
@result{} "/usr/bin/ls"
@end example
@end defun


@defun vicare-executable-as-bytevector
@defunx vicare-executable-as-string
Acquire the return value of @func{vicare-argv0} and search the file
system for a matching executable file; when found return its absolute
pathname as bytevector or Scheme string, else return @false{}.  If an
error occurs while inspecting the file system: raise an exception.

Upon starting a @value{PRJNAME} process:

@itemize
@item
If the executable @command{vicare} is specified as pathname relative to
the current working directory: these functions will return the wrong
absolute path when the current working directory is changed before a
call to them.

@item
If the executable @command{vicare} is specified as file name with no
directory part: these functions may return the wrong absolute path when
the environment variable @env{PATH} is changed before a call to them.
@end itemize

For these reasons: these functions are both invoked upon loading the
library @library{vicare posix} and they cache the result internally.
Beware of neither change the current working directory nor change the
@env{PATH} before loading @library{vicare posix}.
@end defun

@c page
@node posix status
@section Process termination status.


@defun waitpid @var{pid} @var{options}
Interface to the C function @cfunc{waitpid}, @glibcref{Process
Completion, waitpid}.  Request status informations on a process or group
of processes knowing the identifier.  If successful return a fixnum
representing the status; if an error occurs: an exception is raised.

The fixnum @var{pid} selects the target of the request; the fixnum
@var{options} must be the logical OR (@func{fxior}) of platform specific
constants specifying how to wait for the availability of the status.
@end defun


@defun wait
Interface to the C function @cfunc{wait}, @glibcref{Process Completion,
wait}.  Request status informations on any process or group of
processes.  If successful return a fixnum representing the status; if an
error occurs: an exception is raised.
@end defun


The following functions accept as argument a fixnum representing the
process termination status, for example the return value of
@func{system} or the status acquired by @func{waitpid}.


@defun WIFEXITED @var{status}
Interface to the C macro @cfunc{WIFEXITED}, @glibcref{Process Completion
Status, WIFEXITED}.  Return true if the process terminated normally with
@cfunc{exit}.
@end defun


@defun WEXITSTATUS @var{status}
Interface to the C macro @cfunc{WEXITSTATUS}, @glibcref{Process
Completion Status, WEXITSTATUS}.  If @func{WIFEXITED} applied to
@var{status} would return true: return the low--order @math{8} bits from
the exit status, which is the process exit status selected with
@cfunc{exit}.
@end defun


@defun WIFSIGNALED @var{status}
Interface to the C macro @cfunc{WIFSIGNALED}, @glibcref{Process
Completion Status, WIFSIGNALED}.  Return true if the process terminated
because it received an interprocess signal which was not handled.
@end defun


@defun WTERMSIG @var{status}
Interface to the C macro @cfunc{WTERMSIG}, @glibcref{Process Completion
Status, WTERMSIG}.  If @func{WIFSIGNALED} applied to @var{status} would
return true: return the number of the interprocess signal that
terminated the process.
@end defun


@defun WCOREDUMP @var{status}
Interface to the C macro @cfunc{WCOREDUMP}, @glibcref{Process Completion
Status, WCOREDUMP}.  Return true if the process terminated and produced
a core dump.
@end defun


@defun WIFSTOPPED @var{status}
Interface to the C macro @cfunc{WIFSTOPPED}, @glibcref{Process
Completion Status, WIFSTOPPED}.  Return true if the process is stopped.
@end defun


@defun WSTOPSIG @var{status}
Interface to the C macro @cfunc{WSTOPSIG}, @glibcref{Process Completion
Status, WSTOPSIG}.  If @func{WIFSTOPPED} applied to @var{status} would
return true: return the number of the interprocess signal that caused
the process to stop.
@end defun

@c page
@node posix signal
@section Delivering signals to processes


@defun raise @var{signum}
Interface to the C function @cfunc{raise}, @glibcref{Signaling Yourself,
raise}.  Send the selected signal to the calling process.  If successful
return zero, else raise an exception.
@end defun


@defun kill @var{pid} @var{signum}
Interface to the C function @cfunc{kill}, @glibcref{Signaling Another
Process, kill}.  Send the selected signal to selected process.  If
successful return zero, else raise an exception.
@end defun


@defun pause
Interface to the C function @cfunc{pause}, @glibcref{Using Pause,
pause}.  Suspend the process until a signal is received; return the void
object.
@end defun

@c ------------------------------------------------------------

@subsubheading Block/unblock signals handling


@cindex @bub{} interprocess signals @api{}
@cindex @bub{} signals @api{}
@cindex Block/unblock interprocess signals @api{}
@cindex Interprocess signals, block/unblock @api{}
@cindex Signals, block/unblock @api{}


The block/unblock (@bub{}) @api{} is a simplified interface to detect
the arrival of interprocess signals; if it does not suit the
application's model, we should just ignore it.  It is impossible to use
the @bub{} @api{} along with other interprocess signal @api{}s.  Here is
a meaningless usage example:

@example
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(px.signal-bub-init)

(px.raise SIGUSR1)
(px.signal-bub-acquire)

(px.signal-bub-delivered? SIGUSR1) @result{} #t
(px.signal-bub-delivered? SIGUSR2) @result{} #f

(signal-bub-final)
@end example


@defun signal-bub-init
Block all the signals and initialise the @bub{} interface.
@end defun


@defun signal-bub-final
Set all the signal handlers to @code{SIG_IGN}, then unblock all the
signals and finalise the @bub{} interface.
@end defun


@defun signal-bub-acquire
Unblock all the signals, then block them again.  This should allow all
the pending signals to be delivered to the process.
@end defun


@defun signal-bub-delivered? @var{signum}
Return @true{} if the signal @var{signum} has been delivered at least
once @strong{before} the last call to @func{signal-bub-acquire}.
Calling this function with @var{signum} clears the internal flag for
this signal, so calling it again without acquiring new signals always
returns @false{}.

This function interferes with @func{signal-bub-all-delivered}.
@end defun


@defun signal-bub-all-delivered
Return a list of fixnums representing the signals delivered before the
last call to @func{signal-bub-acquire}.  Calling this function clears
the internal flags for all the signals, so calling it again without
acquiring new signals always returns the empty list.

This function interferes with @func{signal-bub-delivered?}.
@end defun

@c ------------------------------------------------------------

@subsubheading Synchronously waiting for signals


@deftp {Struct Type} struct-siginfo_t
Scheme representation of the C language type @code{siginfo_t} which is a
structure typedef.  It has the following fields (some of them are not
present on all the architectures):

@table @code
@item si_signo
Signal number.

@item si_errno
An @code{errno} value.

@item si_code
Signal code.

@item si_trapno
Trap number that caused hardware--generated signal (unused on most
architectures).

@item si_pid
Sending process ID.

@item si_uid
Real user ID of sending process.

@item si_status
Exit value or signal.

@item si_utime
User time consumed.

@item si_stime
System time consumed.

@item si_value.sival_int
@itemx si_value.sival_ptr
Signal value.  The C language type @code{sigval_t} is a union with
fields @code{int sival_int} and @code{void *sival_ptr}.

@item si_int
POSIX.1b signal.

@item si_ptr
POSIX.1b signal.

@item si_overrun
Timer overrun count; POSIX.1b timers.

@item si_timerid
Timer ID; POSIX.1b timers.

@item si_addr
Memory location which caused fault.

@item si_band
Band event.

@item si_fd
File descriptor.

@item si_addr_lsb
Least significant bit of address.
@end table

@quotation
@strong{NOTE} On @gnu{}+Linux: for details on the @code{struct
siginfo_t} type see the manual page @code{sigaction(2)}.
@end quotation
@end deftp


@defun make-struct-siginfo_t
@defunx make-struct-siginfo_t @var{signo} @var{errno} @var{code} @var{trapno} @var{pid} @var{uid} @var{status} @var{utime} @var{stime} @var{value-int} @var{value-ptr} @var{int} @var{ptr} @var{overrun} @var{timerid} @var{addr} @var{band} @var{fd} @var{addr_lsb}
Build and return a new instance of @code{struct-siginfo_t}.  If no
arguments are given: all the fields are initialised to @false{}.
@end defun


@defun struct-siginfo_t? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-siginfo_t}.
@end defun


@defun struct-siginfo_t-si_signo @var{info}
@defunx struct-siginfo_t-si_errno @var{info}
@defunx struct-siginfo_t-si_code @var{info}
@defunx struct-siginfo_t-si_trapno @var{info}
@defunx struct-siginfo_t-si_pid @var{info}
@defunx struct-siginfo_t-si_uid @var{info}
@defunx struct-siginfo_t-si_status @var{info}
@defunx struct-siginfo_t-si_utime @var{info}
@defunx struct-siginfo_t-si_stime @var{info}
@defunx struct-siginfo_t-si_value.sival_int @var{info}
@defunx struct-siginfo_t-si_value.sival_ptr @var{info}
@defunx struct-siginfo_t-si_int @var{info}
@defunx struct-siginfo_t-si_ptr @var{info}
@defunx struct-siginfo_t-si_overrun @var{info}
@defunx struct-siginfo_t-si_timerid @var{info}
@defunx struct-siginfo_t-si_addr @var{info}
@defunx struct-siginfo_t-si_band @var{info}
@defunx struct-siginfo_t-si_fd @var{info}
@defunx struct-siginfo_t-si_addr_lsb @var{info}
Accessors for the fields of @code{struct-siginfo_t}.
@end defun


@defun set-struct-siginfo_t-si_signo! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_errno! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_code! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_trapno! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_pid! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_uid! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_status! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_utime! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_stime! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_value.sival_int! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_value.sival_ptr! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_int! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_ptr! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_overrun! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_timerid! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_addr! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_band! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_fd! @var{info} @var{value}
@defunx set-struct-siginfo_t-si_addr_lsb! @var{info} @var{value}
Mutators for the fields of @code{struct-siginfo_t}.
@end defun


@defun sigwaitinfo @var{signo}
@defunx sigwaitinfo @var{signo} @var{siginfo}
Interface to the C function @cfunc{sigwaitinfo}, see the manual page
@code{sigwaitinfo(2)}.  Synchronously wait for a queued signal; if
successful return two values: a fixnum representing a signal number and
@var{siginfo}; else raise an exception.

@var{signo} must be a fixnum representing an interprocess signal code.

The optional @var{siginfo} must be an instance of
@code{struct-siginfo_t}, which is filled with the informations attached
to the signal; when not given a new instance is allocated internally.

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants)
  (vicare syntactic-extensions))

(px.signal-bub-init)
(px.raise SIGALRM)
(let-values
    (((signo info) (px.sigwaitinfo SIGALRM)))
  signo @result{} SIGALRM
  (px.struct-siginfo_t-si_signo info)) @result{} SIGALRM
@end example
@end defun


@defun sigtimedwait @var{signo} @var{timeout}
@defunx sigtimedwait @var{signo} @var{siginfo} @var{timeout}
Interface to the C function @cfunc{sigtimedwait}, see the manual page
@code{sigtimedwait(2)}.  Synchronously wait for a queued signal, with a
timeout; if successful return two values: a fixnum representing a signal
number and @var{siginfo}; else raise an exception.

@var{signo} must be a fixnum representing an interprocess signal code.

@var{siginfo} must be an instance of @code{struct-siginfo_t}, which is
filled with the informations attached to the signal; when not given a
new instance is allocated internally.

@var{timeout} must be an instance of @code{struct-timespec}: it
represents the maximum interval of time to wait for the signal;
@ref{posix time timespec} for details.

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants)
  (vicare syntactic-extensions))

(px.signal-bub-init)
(px.raise SIGUSR1)
(let-values
    (((signo info)
      (px.sigtimedwait SIGUSR1
                       (px.make-struct-timespec 1 0))))
  signo @result{} SIGUSR1
  (px.struct-siginfo_t-si_signo info)) @result{} SIGUSR1
@end example
@end defun



@c page
@node posix stat
@section File system inspection


@deftp {Data Structure} struct-stat
Data structure type representing at the Scheme level the C structure
@code{struct stat}, @glibcref{Attribute Meanings, stat}.
@end deftp


@defun make-struct-stat @var{mode} @var{ino} @var{dev} @var{nlink} @var{uid} @var{gid} @var{size} @var{atime} @var{atime_usec} @var{mtime} @var{mtime_usec} @var{ctime} @var{ctime_usec} @var{blocks} @var{blksize}
Build and return a new @code{struct-stat} instance.
@end defun



@defun struct-stat? @var{obj}
Return true if @var{obj} is an instance of @code{struct-stat}.
@end defun


@defun struct-stat-st_mode @var{stat}
@defunx struct-stat-st_ino @var{stat}
@defunx struct-stat-st_dev @var{stat}
@defunx struct-stat-st_nlink @var{stat}
@defunx struct-stat-st_uid @var{stat}
@defunx struct-stat-st_gid @var{stat}
@defunx struct-stat-st_size @var{stat}
@defunx struct-stat-st_atime @var{stat}
@defunx struct-stat-st_atime_usec @var{stat}
@defunx struct-stat-st_mtime @var{stat}
@defunx struct-stat-st_mtime_usec @var{stat}
@defunx struct-stat-st_ctime @var{stat}
@defunx struct-stat-st_ctime_usec @var{stat}
@defunx struct-stat-st_blocks @var{stat}
@defunx struct-stat-st_blksize @var{stat}
Accessors for the field of @code{struct-stat} instances.
@end defun


@defun stat @var{pathname}
@defunx lstat @var{pathname}
Interfaces to the C functions @cfunc{stat} and @cfunc{lstat},
@glibcref{Reading Attributes, stat}.  Inspect the file system entry
selected by @var{pathname} and return an instance of @code{struct-stat}.
If an error occurs: an exception is raised.
@end defun


@defun fstat @var{fd}
Interface to the C function @cfunc{fstat}, @glibcref{Reading Attributes,
fstat}.  Inspect the file system entry associated to the file descriptor
@var{fd}, which must be a fixnum, and return an instance of
@code{struct-stat}.  If an error occurs: an exception is raised.
@end defun


@defun file-is-directory? @var{pathname}
@defunx file-is-char-device? @var{pathname}
@defunx file-is-block-device? @var{pathname}
@defunx file-is-regular-file? @var{pathname}
@defunx file-is-symbolic-link? @var{pathname}
@defunx file-is-socket? @var{pathname}
@defunx file-is-fifo? @var{pathname}
@defunx file-is-message-queue? @var{pathname}
@defunx file-is-semaphore? @var{pathname}
@defunx file-is-shared-memory? @var{pathname}
@defunx file-is-directory? @var{pathname} @var{follow-symlinks?}
@defunx file-is-char-device? @var{pathname} @var{follow-symlinks?}
@defunx file-is-block-device? @var{pathname} @var{follow-symlinks?}
@defunx file-is-regular-file? @var{pathname} @var{follow-symlinks?}
@defunx file-is-symbolic-link? @var{pathname} @var{follow-symlinks?}
@defunx file-is-socket? @var{pathname} @var{follow-symlinks?}
@defunx file-is-fifo? @var{pathname} @var{follow-symlinks?}
@defunx file-is-message-queue? @var{pathname} @var{follow-symlinks?}
@defunx file-is-semaphore? @var{pathname} @var{follow-symlinks?}
@defunx file-is-shared-memory? @var{pathname} @var{follow-symlinks?}
Return @true{} or @false{} if the file system entry selected by
@var{pathname} is of the specified type; if an error occurs: an
exception is raised.  When @var{follow-symlinks?} is true: @cfunc{stat}
is used to inspect the entry, else @cfunc{lstat} is used.
@var{follow-symlinks?} defaults to @false{}.
@end defun


@defun S_ISDIR @var{st_mode}
@defunx S_ISCHR @var{st_mode}
@defunx S_ISBLK @var{st_mode}
@defunx S_ISREG @var{st_mode}
@defunx S_ISLNK @var{st_mode}
@defunx S_ISSOCK @var{st_mode}
@defunx S_ISFIFO @var{st_mode}
Return @true{} or @false{} if the argument is associated to a file
system entry of the specified type.  @var{st_mode} must be the value of
the @code{st_mode} field of a @code{struct-stat} instance.
@end defun


@defun access @var{pathname} @var{how}
Interface to the C function @cfunc{access}, @glibcref{Testing File
Access, access}.  Test the access mode selected by @var{how}, which must
be a fixnum, for the file system entry selected by @var{pathname}.
Return @true{} or @false{} if the access is possible or not; if an error
occurs: an exception is raised.
@end defun


@defun file-readable? @var{pathname}
@defunx file-writable? @var{pathname}
@defunx file-executable? @var{pathname}
Return @true{} or @false{} if the file system entry selected by
@var{pathname} is accessible in the specified mode.  These functions are
equivalent but slower, respectively, to the following calls:

@example
(access pathname R_OK)
(access pathname W_OK)
(access pathname X_OK)
@end example
@end defun


@defun file-size @var{filename}
Determine the size of the file selected by @var{filename} relying on a
call to @cfunc{stat}.  If successful: return an exact integer
representing the size, else raise an exception.
@end defun


@defun file-atime @var{pathname}
@defunx file-mtime @var{pathname}
@defunx file-ctime @var{pathname}
Return an exact integer representing the access, modification and
creation times for @var{pathname}.  If an error occurs: raise an
exception.
@end defun

@c page
@node posix file
@section Interfacing with the file system


@defun chown @var{pathname} @var{owner} @var{group}
Interface to the C function @cfunc{chown}, @glibcref{File Owner, chown}.
Changes the owner and group of the file system entry selected by
@var{pathname}.  @var{owner} and @var{group} must be fixnums.  If
successful return zero, else raise an exception.
@end defun


@defun fchown @var{fd} @var{owner} @var{group}
Interface to the C function @cfunc{fchown}, @glibcref{File Owner,
fchown}.  Changes the owner and group of the file system entry selected
by @var{fd}, which must be a fixnum representing a platform file
descriptor.  @var{owner} and @var{group} must be fixnums.  If successful
return zero, else raise an exception.
@end defun


@defun chmod @var{pathname} @var{mode}
Interface to the C function @cfunc{chmod}, @glibcref{Setting
Permissions, chmod}.  Change to @var{mode}, which must be a fixnum, the
access permissions for the file system entry selected by @var{pathname}.
If successful return zero, else raise an exception.
@end defun


@defun fchmod @var{fd} @var{mode}
Interface to the C function @cfunc{fchmod}, @glibcref{Setting
Permissions, fchmod}.  Change to @var{mode}, which must be a fixnum, the
access permissions for the file system entry associated to @var{fd},
which must be a fixnum representing a platform file descriptor.  If
successful return zero, else raise an exception.
@end defun


@defun umask @var{mask}
Interface to the C function @cfunc{umask}, @glibcref{Setting
Permissions, umask}.  Set the current file creation mask to @var{mask},
which must be a fixnum, and return the previous mask as a fixnum.
@end defun


@defun getumask
Interface to the C function @cfunc{getumask}, @glibcref{Setting
Permissions, getumask}.  Return the current file creation mask as a
fixnum.
@end defun


@defun utime @var{pathname} @var{atime_sec} @var{mtime_sec}
Interface to the C function @cfunc{utime}, @glibcref{File Times, utime}.
Set the access and modification times of the file system entry selected
by @var{pathname} to the specified counts of seconds; both
@var{atime_sec} and @var{mtime_sec} must be fixnums.  If successful
return zero, else raise an exception.
@end defun


@defun utimes @var{pathname} @var{atime_sec} @var{atime_usec} @var{mtime_sec} @var{mtime_usec}
@defunx lutimes @var{pathname} @var{atime_sec} @var{atime_usec} @var{mtime_sec} @var{mtime_usec}
Interface to the C functions @cfunc{utimes} and @cfunc{lutimes},
@glibcref{File Times, utimes}.  Set the access and modification times of
the file system entry selected by @var{pathname} to the specified counts
of seconds and microseconds; all the numeric arguments must be fixnums.
If successful return zero, else raise an exception.
@end defun


@defun futimes @var{fd} @var{atime_sec} @var{atime_usec} @var{mtime_sec} @var{mtime_usec}
Interface to the C function @cfunc{futimes}, @glibcref{File Times,
futimes}.  Set the access and modification times of the file system
entry associated to @var{fd} to the specified counts of seconds and
microseconds; all the numeric arguments must be fixnums.  If successful
return zero, else raise an exception.
@end defun

@c page
@node posix link
@section Hard and symbolic links


@defun link @var{old_pathname} @var{new_pathname}
Interface to the C function @cfunc{link}, @glibcref{Hard Links, link}.
Create a hard link @var{new_pathname} to the source file system entry
@var{old_pathname}.  If successful return zero, else raise an exception.
@end defun


@defun symlink @var{file_pathname} @var{link_pathname}
Interface to the C function @cfunc{symlink}, @glibcref{Symbolic Links,
symlink}.  Create a symbolic link @var{link_pathname} to the source file
system entry @var{file_pathname}.  If successful return zero, else raise
an exception.
@end defun


@defun readlink @var{link_pathname}
@defunx readlink/string @var{link_pathname}
Interface to the C function @cfunc{readlink}, @glibcref{Symbolic Links,
readlink}.  If @var{pathname} references a symbolic link: follow it once
and return the referenced pathname; if an error occurs raise an
exception.  @func{readlink} returns a bytevector; @func{readlink/string}
returns a string.
@end defun


@defun realpath @var{pathname}
@defunx realpath/string @var{pathname}
Interface to the C function @cfunc{realpath}, @glibcref{Symbolic Links,
realpath}.  If @var{pathname} references a symbolic link: follow it and
return the real canonicalised pathname; if an error occurs: an exception
is raised.  @func{realpath} returns a bytevector; @func{realpath/string}
returns a string.
@end defun


@defun unlink @var{pathname}
Interface to the C function @cfunc{unlink}, @glibcref{Deleting Files,
unlink}.  Delete the file system entry referenced by @var{pathname},
which must reference a file.  If successful return unspecified values,
else raise an exception.

This function is the same of @func{delete-file} defined by @rnrs{6}.
@end defun


@defun remove @var{pathname}
Interface to the C function @cfunc{remove}, @glibcref{Deleting Files,
remove}.  Delete the file system entry referenced by @var{pathname},
which can reference a file or directory.  If successful return
unspecified values, else raise an exception.
@end defun


@defun rename @var{old-pathname} @var{new-pathname}
Interface to the C function @cfunc{rename}, @glibcref{Renaming Files,
rename}.  Rename the file system entry @var{old-pathname} to
@var{new-pathname}.  If successful return unspecified values, else
return an encoded @code{errno} value.
@end defun

@c page
@node posix dir
@section File system directories


@defun mkdir @var{pathname} @var{mode}
@cindex Creating directories
@cindex Making directories
@cindex Directories, creating
@cindex Directories, making
Interface to the C function @cfunc{mkdir}, @glibcref{Creating
Directories, mkdir}.  Create a new directory file system entry with name
@var{pathname}; @var{mode} must be a fixnum specifying access
permissions.  If successful return unspecified values, else raise an
exception.
@end defun


@defun mkdir/parents @var{pathname} @var{mode}
Create a new directory file system entry with name @var{pathname} and
all its parents if they do not exist; @var{mode} must be a fixnum
specifying access permissions for all the components.  If successful
return unspecified values, else raise an exception.
@end defun


@defun rmdir @var{pathname}
@cindex Removing directories
@cindex Directories, removing
Interface to the C function @cfunc{rmdir}, @glibcref{Creating
Directories, rmdir}.  Remove the directory file system entry selected by
@var{pathname}.  If successful return unspecified values, else raise an
exception.
@end defun


@defun getcwd
@defunx getcwd/string
@cindex Current working directory
@cindex Process working directory
@cindex Directories, current working
Interface to the C function @cfunc{getcwd}, @glibcref{Working Directory,
getcwd}.  Acquire the pathname of the current working directory.  If
successful @func{getcwd} returns a bytevector holding the pathname,
@func{getcwd/string} returns a string holding the pathname; else an
exception is raised.
@end defun


@defun chdir @var{pathname}
@cindex Changing current directory
@cindex Directories, changing current
Interface to the C function @cfunc{chdir}, @glibcref{Working Directory,
chdir}.  Change the current working directory to the file system entry
selected by @var{pathname}.  If successful return unspecified values,
else raise an exception.
@end defun


@defun fchdir @var{fd}
Interface to the C function @cfunc{fchdir}, @glibcref{Working Directory,
fchdir}.  Change the current working directory to the file system entry
associated to @var{fd}, which must be a fixnum representing a file
descriptor.  If successful return unspecified values, else raise an
exception.
@end defun


@deftp {Structure Type} directory-stream
Opaque data structure type used in the inspection of file system
directory entries.  Instances of this type can be destroyed by
@func{closedir}, but they are also automatically and correctly destroyed
by the garbage collector.  It has the following fields:

@table @code
@item pathname
False or a string representing the pathname.

@item pointer
A pointer object referencing the directory.

@item fd
False or a fixnum representing the file descriptor associated to the
directory.

@item closed?
A boolean, true if this stream has already been closed.
@end table
@end deftp


@defun make-directory-stream @var{pathname} @var{pointer} @var{fd} @var{closed?}
Constructor for @code{directory-stream}.
@end defun


@defun directory-stream? @var{obj}
Return true if @var{obj} is an instance of @code{directory-stream}.
@end defun


@defun directory-stream-pathname @var{stream}
@defunx directory-stream-pointer @var{stream}
@defunx directory-stream-fd @var{stream}
@defunx directory-stream-closed? @var{stream}
Accessors for the fields of @code{directory-stream}.
@end defun


@defun opendir @var{pathname}
@cindex Opening a directory stream
@cindex Directories, opening a stream
Interface to the C function @cfunc{opendir}, @glibcref{Opening a
Directory, opendir}.  Open a directory stream for the inspection of the
file system entry @var{pathname}.  If successful return an instance of
@code{directory-stream}, else raise an exception.
@end defun


@defun fdopendir @var{fd}
Interface to the C function @cfunc{fdopendir}, @glibcref{Opening a
Directory, fdopendir}.  Open a directory stream for the inspection of
the file system entry associated to @var{fd}, which must be a fixnum
representing a file descriptor.  If successful return an instance of
@code{directory-stream}, else raise an exception.
@end defun


@defun readdir @var{stream}
@defunx readdir/string @var{stream}
@cindex Reading a directory stream
@cindex Directories, reading a stream
Interface to the C function @cfunc{readdir}, @glibcref{Reading/Closing
Directory, readdir}.  Acquire the next entry from a directory stream
referenced by @var{stream}, which must be an instance of
@code{directory-stream}.  If successful and an entry is available:
@func{readdir} returns a pathname as a bytevector, @func{readdir/string}
returns a pathname as a string; if successful and no more entries are
available: return @false{}; else raise an exception.

When no more entries are available or an error occurs: the directory
stream is closed.
@end defun


@defun closedir @var{stream}
@cindex Closing a directory stream
@cindex Directories, closing a stream
Interface to the C function @cfunc{closedir}, @glibcref{Reading/Closing
Directory, closedir}.  Close the directory stream referenced by
@var{stream}, which must be an instance of @code{directory-stream}.  If
successful return unspecified values, else raise an exception.

This function has no effect if @var{stream} has been already closed.
@end defun


@defun rewinddir @var{stream}
@cindex Rewinding a directory stream
@cindex Directories, rewinding a stream
Interface to the C function @cfunc{rewinddir}, @glibcref{Random Access
Directory, rewinddir}.  Rewind to the beginning the directory stream
referenced by @var{stream}, which must be an instance of
@code{directory-stream}.  Return unspecified values.
@end defun


@defun telldir @var{stream}
@cindex Inspecting a directory stream
@cindex Directories, inspecting a stream
Interface to the C function @cfunc{telldir}, @glibcref{Random Access
Directory, telldir}.  Return an exact integer representing the current
position in the directory stream referenced by @var{stream}, which must
be an instance of @code{directory-stream}.
@end defun


@defun seekdir @var{pointer} @var{pos}
@cindex Seeking a directory stream
@cindex Directories, seeking a stream
Interface to the C function @cfunc{seekdir}, @glibcref{Random Access
Directory, seekdir}.  Set to @var{pos} the position of the directory
stream referenced by @var{stream}, which must be an instance of
@code{directory-stream}; @var{pos} must be the return value of a
previous call to @func{telldir}.  Return unspecified values.
@end defun

@c page
@node posix fd
@section File descriptors


@menu
* posix fd open::               Opening and closing.
* posix fd read::               Reading from file descriptors.
* posix fd write::              Writing to file descriptors.
* posix fd seek::               Moving the current position.
* posix fd scatter::            Scatter--gather operations.
* posix fd select::             Waiting for events with @func{select}.
* posix fd poll::               Polling for events.
* posix fd device::             Special device operations.
* posix fd dup::                Duplicating file descriptors.
* posix fd pipe::               File descriptor pipes.
* posix fd fifo::               File descriptor fifos.
* posix fd trunc::              Truncating files.
@end menu

@c page
@node posix fd open
@subsection Opening and closing


@defun open @var{pathname} @var{flags} @var{mode}
Interface to the C function @cfunc{open}, @glibcref{Opening and Closing
Files, open}.  Open a file descriptor for the file system entry
@var{pathname}; @var{flags} and @var{mode} must be fixnums.  If
successful return a fixnum representing the file descriptor, else raise
an exception.

Example:

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(define fd
  (px.open "name.ext"
           (fxior O_CREAT O_EXCL O_RDWR)
           (fxior S_IRUSR S_IWUSR)))
@end example
@end defun


@defun close @var{fd}
Interface to the C function @cfunc{close}, @glibcref{Opening and Closing
Files, close}.  Close a file descriptor represented by @var{fd}, which
must be a fixnum.  If successful return unspecified values, else raise
an exception.
@end defun

@c page
@node posix fd read
@subsection Reading from file descriptors


@defun read @var{fd} @var{buffer}
@defunx read @var{fd} @var{buffer} @var{size}
Interface to the C function @cfunc{read}, @glibcref{I/O Primitives,
read}.  Read bytes from the file descriptor @var{fd} and store them in
the bytevector @var{buffer}; if @var{size} is a fixnum, read @var{size}
bytes; if @var{size} is false or not given, read a number of bytes equal
to the length of @var{buffer}.  If successful return a non--negative
fixnum representing the number of bytes read, else raise an exception.
@end defun


@defun pread @var{fd} @var{buffer} @var{size} @var{off}
Interface to the C function @cfunc{pread}, @glibcref{I/O Primitives,
pread}.  Like @func{read}, but start reading at offset @var{off} from
the start of the file; @var{off} must be a non--negative exact integer.
@end defun

@c page
@node posix fd write
@subsection Writing to file descriptors


@defun write @var{fd} @var{buffer}
@defunx write @var{fd} @var{buffer} @var{size}
Interface to the C function @cfunc{write}, @glibcref{I/O Primitives,
write}.  Write bytes to the file descriptor @var{fd} from the bytevector
@var{buffer}; if @var{size} is a fixnum, read @var{size} bytes; if
@var{size} is false or not given, read a number of bytes equal to the
length of @var{buffer}.  If successful return a non--negative fixnum
representing the number of written bytes, else raise an exception.
@end defun


@defun pwrite @var{fd} @var{buffer} @var{size} @var{off}
Interface to the C function @cfunc{pwrite}, @glibcref{I/O Primitives,
pwrite}.  Like @func{write}, but start writing at offset @var{off} from
the start of the file; @var{off} must be a non--negative exact integer.
@end defun

@c page
@node posix fd seek
@subsection Moving the current position


@defun lseek @var{fd} @var{off} @var{whence}
Interface to the C function @cfunc{lseek}, @glibcref{File Position
Primitive, lseek}.  Change the file position of the file descriptor
@var{fd} to @var{off} from @var{whence}; @var{whence} must a fixnum,
@var{off} must be an exact integer.  If successful return a
non--negative exact integer representing the number of bytes from the
beginning of the file, else raise an exception.
@end defun

@c page
@node posix fd scatter
@subsection Scatter--gather operations


@defun readv @var{fd} @var{buffers}
Interface to the C function @cfunc{readv}, @glibcref{Scatter-Gather,
readv}.  Read bytes from the file descriptor @var{fd} and store them
into the list of bytevectors referenced by @var{buffers}.  If successful
return a non--negative exact integer representing the number of bytes
actually read, else raise an exception.
@end defun


@defun writev @var{fd} @var{buffers}
Interface to the C function @cfunc{writev}, @glibcref{Scatter-Gather,
writev}.  Write bytes to the file descriptor @var{fd} from the list of
bytevectors referenced by @var{buffers}.  If successful return a
non--negative exact integer representing the number of bytes actually
written, else raise an exception.
@end defun

@c page
@node posix fd select
@subsection Waiting for events with @func{select}


@menu
* posix fd select fdset::       Allocating and accessing
                                file descriptor sets.
* posix fd select select::      Selecting events to wait for.
* posix fd select special::     Selecting special events to wait for.
@end menu

@c page
@node posix fd select fdset
@subsubsection Allocating and accessing file descriptor sets


At low level, the @posix{} function @cfunc{select} keeps track of file
descriptors organised in sets, represented by instances of the C
language type @code{fd_set}; we can think of such data structures as
arrays of integers, holding @code{FD_SETSIZE} bits, in which each bit
represents a file descriptor: @code{1} for inclusion, @code{0} for
exclusion.


@defun sizeof-fd-set
@defunx sizeof-fd-set @var{count}
Return an exact integer representing the number of bytes needed to hold
@var{count} instances of the C language type @code{fd_set}.  The
optional @var{count} must be a positive fixnum; when not given: it
defaults to @code{1}.
@end defun


@defun make-fd-set-bytevector
@defunx make-fd-set-bytevector @var{count}
Build and return a new bytevector capable of holding @var{count}
instances of the C language type @code{fd_set} defined in
@file{sys/types.h}; every allocated @code{fd_set} is initialised with
@cfunc{FD_ZERO}.  The optional @var{count} must be a positive fixnum;
when not given: allocate enough room for a single instance of
@code{fd_set}.
@end defun


@defun make-fd-set-pointer
@defunx make-fd-set-pointer @var{count}
Use @cfunc{malloc} to allocate a memory block capable of holding
@var{count} instances of the C language type @code{fd_set} defined in
@file{sys/types.h}; every allocated @code{fd_set} is initialised with
@cfunc{FD_ZERO}.

The optional @var{count} must be a positive fixnum; when not given:
allocate enough room for a single instance of @code{fd_set}.

If successful: return a pointer object referencing the memory block;
else return @false{}.
@end defun


@defun make-fd-set-memory-block
@defunx make-fd-set-memory-block @var{count}
Use @cfunc{malloc} to allocate a memory block capable of holding
@var{count} instances of the C language type @code{fd_set} defined in
@file{sys/types.h}; every allocated @code{fd_set} is initialised with
@cfunc{FD_ZERO}.

The optional @var{count} must be a positive fixnum; when not given:
allocate enough room for a single instance of @code{fd_set}.

If successful: return an instance of @code{memory-block} referencing the
memory block; else return @false{}.
@end defun

@c ------------------------------------------------------------

@defun FD_ZERO @var{fdsets}
@defunx FD_ZERO @var{fdsets} @var{idx}
Reset to empty the given file descriptor set; return unspecified values;
@glibcref{Waiting for I/O, FD_ZERO}.

@var{fdsets} must be a bytevector, pointer object or @code{memory-block}
instance holding or referencing one or more instances of the C language
type @code{fd_set}.

@var{idx} must be a non--negative fixnum representing the index of the
selected @code{fd_set} in @var{fdsets}; when not given: it defaults to
zero.
@end defun


@defun FD_SET @var{fd} @var{fdsets}
@defunx FD_SET @var{fd} @var{fdsets} @var{idx}
Add the file descriptor @var{fd} to the given set; return unspecified
values; @glibcref{Waiting for I/O, FD_SET}.

@var{fdsets} must be a bytevector, pointer object or @code{memory-block}
instance holding or referencing one or more instances of the C language
type @code{fd_set}.

The optional @var{idx} must be a non--negative fixnum representing the
index of the selected @code{fd_set} in @var{fdsets}; when not given: it
defaults to zero.
@end defun


@defun FD_CLR @var{fd} @var{fdsets}
@defunx FD_CLR @var{fd} @var{fdsets} @var{idx}
Remove the file descriptor @var{fd} from the given set; return
unspecified values; @glibcref{Waiting for I/O, FD_CLR}.

@var{fdsets} must be a bytevector, pointer object or @code{memory-block}
instance holding or referencing one or more instances of the C language
type @code{fd_set}.

The optional @var{idx} must be a non--negative fixnum representing the
index of the selected @code{fd_set} in @var{fdsets}; when not given: it
defaults to zero.
@end defun


@defun FD_ISSET @var{fd} @var{fdsets}
@defunx FD_ISSET @var{fd} @var{fdsets} @var{idx}
Return a boolean specifying if the file descriptor @var{fd} is contained
in the given set; return unspecified values; @glibcref{Waiting for I/O,
FD_ISSET}.

@var{fdsets} must be a bytevector, pointer object or @code{memory-block}
instance holding or referencing one or more instances of the C language
type @code{fd_set}.

The optional @var{idx} must be a non--negative fixnum representing the
index of the selected @code{fd_set} in @var{fdsets}; when not given: it
defaults to zero.
@end defun


@c page
@node posix fd select select
@subsubsection Selecting events to wait for


@defun select @var{nfds} @var{read-fds} @var{write-fds} @var{except-fds} @var{sec} @var{usec}
Interface to the C function @cfunc{select}, @glibcref{Waiting for I/O,
select}.  Wait for read, write or exceptional events on selected lists
of file descriptors.

@var{nfds} must be false or a non--negative fixnum, when false it
defaults to the maximum file descriptor value in the given lists; it is
the maximum file descriptor number in the sets to be checked for events,
plus one.  @var{read-fds}, @var{write-fds} and @var{except-fds} must be
nil or lists of file descriptors to be checked for events.  @var{sec}
and @var{usec} must be fixnums representing timeout seconds and
microseconds.

If the timeout expires before any event arrives: return @math{3} values
all being nil.  If an error occurs: raise an exception.  Else return
@math{3} values being lists of file descriptors, respectively, ready for
reading, writing or an exceptional condition.
@end defun


@defun select-fd @var{fd} @var{sec} @var{usec}
Interface to the C function @cfunc{select}, @glibcref{Waiting for I/O,
select}.  Wait for read, write or exceptional events on the single file
descriptor @var{fd}.  @var{sec} and @var{usec} must be fixnums
representing timeout seconds and microseconds.

If the timeout expires before any event arrives: return @math{3} values
all being false.  If an error occurs: raise an exception.  Else return
@math{3} values being false or @var{fd}, respectively, if @var{fd} is
ready for reading, writing or an exceptional condition.
@end defun


@defun select-from-sets @var{nfds} @var{read-fds} @var{write-fds} @var{except-fds} @var{sec} @var{usec}
Interface to the C function @cfunc{select}, @glibcref{Waiting for I/O,
select}.  Wait for read, write or exceptional events on selected lists
of file descriptors.

@var{nfds} must be false or a non--negative fixnum, when false it
defaults to @code{FD_SETSIZE}; it must be the maximum file descriptor
number in the sets to be checked for events, plus one.

@var{read-fds}, @var{write-fds} and @var{except-fds} must be @false{} or
bytevectors, pointer objects or instances of @code{memory-block} holding
an instance of the C language type @code{fd_set}; when @false{} or a
@cnull{} pointer: an empty @code{fd_set} is internally allocated and
used.

@var{sec} and @var{usec} must be fixnums representing timeout seconds
and microseconds.

If the timeout expires before any event arrives: return @math{3} values
all being @false{}; if an error occurs: raise an exception; else return
@math{3} values being @var{read-fds}, @var{write-fds}, @var{except-fds}.
@end defun


@defun select-from-sets-array @var{nfds} @var{fdsets} @var{sec} @var{usec}
Interface to the C function @cfunc{select}, @glibcref{Waiting for I/O,
select}.  Wait for read, write or exceptional events on selected lists
of file descriptors.

@var{nfds} must be false or a non--negative fixnum, when false it
defaults to @code{FD_SETSIZE}; it must be the maximum file descriptor
number in the sets to be checked for events, plus one.  @var{fdsets}
must be a bytevector, pointer object or instance of @code{memory-block}
holding @math{3} contiguous instances of the C language type
@code{fd_set}.  @var{sec} and @var{usec} must be fixnums representing
timeout seconds and microseconds.

If the timeout expires before any event arrives: return @false{}; if an
error occurs: raise an exception; else return @var{fdsets} itself.
@end defun

@c page
@node posix fd select special
@subsubsection Selecting special events to wait for


@defun select-fd-readable? @var{fd} @var{sec} @var{usec}
Interface to the C function @cfunc{select}, @glibcref{Waiting for I/O,
select}.  Wait for a readable event on the single file descriptor
@var{fd}.  @var{sec} and @var{usec} must be fixnums representing timeout
seconds and microseconds.

If the timeout expires before any event arrives: return @false{}.  If an
error occurs: raise an exception.  Else return @true{} if the file
descriptor becomes readable.
@end defun


@defun select-fd-writable? @var{fd} @var{sec} @var{usec}
Interface to the C function @cfunc{select}, @glibcref{Waiting for I/O,
select}.  Wait for a writable event on the single file descriptor
@var{fd}.  @var{sec} and @var{usec} must be fixnums representing timeout
seconds and microseconds.

If the timeout expires before any event arrives: return @false{}.  If an
error occurs: raise an exception.  Else return @true{} if the file
descriptor becomes writable.
@end defun


@defun select-fd-exceptional? @var{fd} @var{sec} @var{usec}
Interface to the C function @cfunc{select}, @glibcref{Waiting for I/O,
select}.  Wait for an exceptional event on the single file descriptor
@var{fd}.  @var{sec} and @var{usec} must be fixnums representing timeout
seconds and microseconds.

If the timeout expires before any event arrives: return @false{}.  If an
error occurs: raise an exception.  Else return @true{} if the file
descriptor receives an exceptional notification.
@end defun

@c page
@node posix fd poll
@subsection Polling for events


@defun poll @var{fds} @var{timeout}
Interface to the C function @cfunc{poll}, see the manual page
@code{poll(2)}.  Poll for events the file descriptors selected by
@var{fds}; @var{timeout} must be an exact integer representing the
timeout in milliseconds.  If successful: return the number of file
descriptors ready for an event, else raise an exception.

@var{fds} must be a vector of vectors each having @math{3} elements: a
fixnum representing the file descriptor, a fixnum representing the
@code{events} field of a @code{struct pollfd}, a fixnum representing the
@code{revents} field of a @code{struct pollfd}.  On successful return:
the third element of the subvectors is mutated to represent the events
for which the file descriptor is ready.
@end defun

@c page
@node posix fd device
@subsection Special device operations


@defun fcntl @var{fd} @var{command}
@defunx fcntl @var{fd} @var{command} @var{arg}
Interface to the C function @cfunc{fcntl}, @glibcref{Control Operations,
fcntl}.  Perform the operation specified by @var{command} on the file
descriptor @var{fd} using @var{arg}; @var{fd} and @var{command} must be
fixnums; @var{arg} must be @false{}, a fixnum, a bytevector or a
pointer, if it is @false{} or not given no argument is handed to
@cfunc{fcntl}.  If successful return a fixnum representing the return
value of @cfunc{fcntl}, else raise an exception.
@end defun


@defun ioctl @var{fd} @var{command}
@defunx ioctl @var{fd} @var{command} @var{arg}
Interface to the C function @cfunc{ioctl}, @glibcref{IOCTLs, ioctl}.
Perform the operation specified by @var{command} on the file descriptor
@var{fd} using @var{arg}; @var{fd} and @var{command} must be fixnums;
@var{arg} must be @false{}, a fixnum, a bytevector or a pointer, if it
is @false{} or not given no argument is handed to @cfunc{ioctl}.  If
successful return a fixnum representing the return value of
@cfunc{ioctl}, else raise an exception.
@end defun

@c page
@node posix fd dup
@subsection Duplicating file descriptors


@defun dup @var{fd}
Interface to the C function @cfunc{dup}, @glibcref{Duplicating
Descriptors, dup}.  Duplicate the file descriptor @var{fd}.  If
successful return a non--negative fixnum representing the new
descriptor, else raise an exception.
@end defun


@defun dup2 @var{old} @var{new}
Interface to the C function @cfunc{dup2}, @glibcref{Duplicating
Descriptors, dup}.  Duplicate the file descriptor @var{old} to
@var{new}.  If successful return unspecified values, else raise an
exception.
@end defun

@c page
@node posix fd pipe
@subsection File descriptor pipes


@defun pipe
Interface to the C function @cfunc{pipe}, @glibcref{Creating a Pipe,
pipe}.  Create a pair of file descriptors connected through a pipe.  If
successful return two values being fixnums representing the file
descriptors, else raise an exception.

Simple example of process writing to itself through a pipe:

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.))

(let-values (((in ou) (px.pipe)))
  (px.write ou '#vu8(1 2 3 4) 4)
  (let ((bv (make-bytevector 4)))
    (px.read in bv 4)
    bv))
@result{} #vu8(1 2 3 4)
@end example

@noindent
here is how to fork a process and setup stdin and stdout in the children
to use newly created pipe file descriptors to communicate with the
parent:

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.))

(let-values
    (((child-stdin       parent-to-child) (px.pipe))
     ((parent-from-child child-stdout)    (px.pipe)))
  (fork

    (lambda (pid) ;parent
      (let ((buf (make-bytevector 1)))
        (px.read  parent-from-child buf 1)
        (px.write parent-to-child '#vu8(2) 1)
        buf))

    (lambda () ;child
      (begin ;setup stdin
        (close-input-port (current-input-port))
        (px.dup2 child-stdin 0)
        (px.close child-stdin))

      (begin ;setup stdout
        (close-output-port (current-output-port))
        (px.dup2 child-stdout 1)
        (px.close child-stdout))

      (let ((buf (make-bytevector 1)))
        (px.write 1 '#vu8(1) 1)
        (px.read  0 buf 1)
        (exit 0)))))
@result{} #vu8(1)
@end example

@noindent
here is how to fork a process and setup stdin and stdout in the children
to use newly created pipe file descriptors, through Scheme ports, to
communicate with the parent:

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.))

(let-values (((child-stdin       parent-to-child) (px.pipe))
             ((parent-from-child child-stdout)    (px.pipe)))
  (fork
   (lambda (pid)        ;parent
     (let* ((inp (make-textual-file-descriptor-input-port
                  parent-from-child "in" (native-transcoder)))
            (oup (make-textual-file-descriptor-output-port
                  parent-to-child "out" (native-transcoder)))
            (buf (get-string-n inp 4)))
       (display "hello" oup)
       (flush-output-port oup)
       buf))

   (lambda ()           ;child

     (begin      ;setup stdin
       (close-input-port (current-input-port))
       (current-input-port
        (make-textual-file-descriptor-input-port
         child-stdin "*stdin*" (native-transcoder))))

     (begin ;setup stdout
       (close-output-port (current-output-port))
       (current-output-port
        (make-textual-file-descriptor-output-port
         child-stdout "*stdout*" (native-transcoder))))

     (display "ciao")
     (flush-output-port (current-output-port))
     (get-string-n (current-input-port) 5)
     (exit 0))))
@result{} "ciao"
@end example
@end defun

@c page
@node posix fd fifo
@subsection File descriptor fifos


@defun mkfifo @var{pathname} @var{mode}
Interface to the C function @cfunc{mkfifo}, @glibcref{FIFO Special
Files, mkfifo}.  Create a FIFO special file with name @var{pathname} and
mode @var{mode}, which must be a fixnum.  If successful return
unspecified values, else raise an exception.
@end defun

@c page
@node posix fd trunc
@subsection Truncating files


@defun truncate @var{pathname} @var{length}
Interface to the C function @cfunc{truncate}, @glibcref{File Size,
truncate}.  Change the size of the file selected by @var{pathname} to
@var{length}; if successful return unspecified values, else raise an
exception.

@var{length} must be non--negative exact integer in the range of the C
language type @code{off_t}.
@end defun


@defun ftruncate @var{fd} @var{length}
Interface to the C function @cfunc{ftruncate}, @glibcref{File Size,
ftruncate}.  Changes the size of the file selected by the file
descriptor @var{fd} to @var{length}; if successful return unspecified
values, else raise an exception.

@var{length} must be non--negative exact integer in the range of the C
language type @code{off_t}.
@end defun

@c page
@node posix mmap
@section Memory--mapped input/output


@ref{shmem mmap} for a description of shared memory through @func{mmap}.


@defun mmap @var{address} @var{length} @var{protect} @var{flags} @var{fd} @var{offset}
Interface to the C function @cfunc{mmap}, @glibcref{Memory-mapped I/O,
mmap}.  Create a new mapping and return a pointer object referencing the
region of memory.

@var{address} can be @false{} or a pointer object; @false{} is
interpreted as a @cnull{} pointer.  @var{length} must be an exact
integer in the range of the C language type @code{size_t}.
@var{protect} and @var{flags} must fixnums of flags.  @var{fd} must be a
fixnum representing a file descriptor.  @var{offset} must be an exact
integer in the range of the C language type @code{off_t}.
@end defun


@defun munmap @var{address} @var{length}
Interface to the C function @cfunc{munmap}, @glibcref{Memory-mapped I/O,
munmap}.  Remove memory mapping.  Return unspecified values.

@var{address} is a pointer object referencing the mapping.  @var{length}
must be an exact integer in the range of the C language type
@code{size_t}.
@end defun


@defun msync @var{address} @var{length} @var{flags}
Interface to the C function @cfunc{msync}, @glibcref{Memory-mapped I/O,
msync}.  Synchronise the mapping with the underlying file.  Return
unspecified values.

@var{address} is a pointer object referencing the mapping.  @var{length}
must be an exact integer in the range of the C language type
@code{size_t}.  @var{flags} is a fixnum of flags.
@end defun


@defun mremap @var{address} @var{length} @var{new-length} @var{flags}
Interface to the C function @cfunc{mremap}, @glibcref{Memory-mapped I/O,
mremap}.  Change the size of an existing memory mapping; return a
pointer object referencing the new mapping.

@var{address} is a pointer object referencing the mapping.  @var{length}
and @var{new-length} must be exact integers in the range of the C
language type @code{size_t}.  @var{flags} is a fixnum of flags.
@end defun


@defun madvise @var{address} @var{length} @var{advice}
Interface to the C function @cfunc{madvise}, @glibcref{Memory-mapped
I/O, madvise}.  Synchronise the mapping with the underlying file.
Return unspecified values.

@var{address} is a pointer object referencing the mapping.  @var{length}
must be an exact integer in the range of the C language type
@code{size_t}.  @var{advice} is a fixnum of flags.
@end defun


@defun mlock @var{address} @var{length}
@defunx munlock @var{address} @var{length}
Interface to the C functions @cfunc{mlock} and @cfunc{munlock}, see the
manual page @code{mlock(2)}.  Lock or unlock a segment of virtual
address space, preventing the memory from begin paged to the swap area.
If successful return unspecified values, else raise an exception.
@end defun


@defun mlockall @var{flags}
@defunx munlockall
Interface to the C functions @cfunc{mlockall} and @cfunc{munlockall},
see the manual page @code{mlock(2)}.  Lock or unlock all pages.  If
successful return unspecified values, else raise an exception.
@var{flags} must be a fixnum being an OR combination of the constants:
@code{MCL_CURRENT}, @code{MCL_FUTURE}.
@end defun

@c page
@node posix socket
@section Network sockets


With the purpose of keeping at the Scheme level the same semantics of
the C level @posix{} @api{}, socket--related data structures are stored
in bytevectors; such raw manipulation can cause the process to crash if
we mishandle the values.

@menu
* posix socket addresses::      Network address structures.
* posix socket hosts::          Network hosts database.
* posix socket protocols::      Network protocols database.
* posix socket services::       Network services database.
* posix socket networks::       Networks database.
* posix socket socket::         Network sockets operations.
* posix socket misc::           Error and miscellaneous functions.
* posix socket examples::       Examples of clients and servers.
* posix socket oob::            Notes on transmission of @oob{} data.
@end menu

@c page
@node posix socket addresses
@subsection Network address structures


@menu
* posix socket addresses local:: Local addresses.
* posix socket addresses in::    @ip{}v4 addresses.
* posix socket addresses in6::   @ip{}v6 addresses.
* posix socket addresses rep::   @ascii{} address representations.
* posix socket addresses info::  Host address informations.
@end menu

@c page
@node posix socket addresses local
@subsubsection Local addresses


Instances of @code{struct sockaddr_un} can be handled at the Scheme
level as follows:

@example
(import (vicare)
  (prefix (vicare posix) px.))

(define sockaddr
  (px.make-sockaddr_un "/tmp/the-unix-socket"))

(px.sockaddr_un.pathname/string sockaddr)
@result{} "/tmp/the-unix-socket"
@end example

@noindent
care must be taken when handling such raw values.


@defun make-sockaddr_un @var{pathname}
Given a @var{pathname} representing the pathname of a local socket,
build and return a bytevector holding the @code{struct sockaddr_un}
representing it.
@end defun


@defun sockaddr_un.pathname @var{socket_address}
@defunx sockaddr_un.pathname/string @var{socket_address}
Given a bytevector @var{socket_address}, which must be the return value
of a previous call to @func{make-sockaddr_un}, holding a @code{struct
sockaddr_un}: @func{sockaddr_un.pathname} builds and returns a
bytevector holding the corresponding socket pathname,
@func{sockaddr_un.pathname/string} builds and returns a string holding
the corresponding socket pathname.  If the data in @var{socket_address}
is invalid: an exception is raised.
@end defun

@c page
@node posix socket addresses in
@subsubsection @ip{}v4 addresses


Instances of @code{struct sockaddr_in} can be handled at the Scheme
level as follows:

@example
(import (vicare)
  (prefix (vicare posix) px.))

(define sockaddr
  (px.make-sockaddr_in '#vu8(1 2 3 4) 88))

(px.sockaddr_in.in_addr sockaddr)  @result{} #vu8(1 2 3 4)
(px.sockaddr_in.in_port sockaddr)  @result{} 88
@end example

@noindent
and we can use constant values to initialise the fields:

@example
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(define addr (make-bytevector 4))
(bytevector-u32-set! bv 0 INADDR_LOOPBACK (endianness big))

(define sockaddr (px.make-sockaddr_in addr 88))

(px.sockaddr_in.in_addr sockaddr)  @result{} #vu8(127 0 0 1)
(px.sockaddr_in.in_port sockaddr)  @result{} 88
@end example

@noindent
care must be taken when handling such raw values.


@defun make-sockaddr_in @var{host-address} @var{port}
Given a bytevector @var{host-address} holding a @code{struct in_addr}
and a fixnum @var{port} representing a network port number, build and
return a bytevector holding a @code{struct sockaddr_in} initialised with
this data.
@end defun


@defun sockaddr_in.in_addr @var{socket-address}
@defunx sockaddr_in.in_port @var{socket-address}
Given a bytevector @var{socket-address} holding a @code{struct
sockaddr_in}, extract the @code{in_addr} and @code{in_port} fields and
return them as bytevector holding the corresponding @code{struct
in_addr} and as fixnum.  If the data in @var{socket_address} is invalid:
an exception is raised.
@end defun

@c page
@node posix socket addresses in6
@subsubsection @ip{}v6 addresses


Instances of @code{struct sockaddr_in6} can be handled at the Scheme
level as follows:

@example
#!vicare
(import (vicare)
  (prefix (vicare posix) px.))

(define sockaddr
  (px.make-sockaddr_in6 '#vu16b(1 2 3 4  5 6 7 8) 88))

(px.sockaddr_in6.in6_addr sockaddr) @result{} #vu16b(1 2 3 4  5 6 7 8)
(px.sockaddr_in6.in6_port sockaddr) @result{} 88
@end example

@noindent
care must be taken when handling such raw values.


@defun make-sockaddr_in6 @var{host-address} @var{port}
Given a bytevector @var{host-address} holding a @code{struct in6_addr}
and a fixnum @var{port} representing a network port number, build and
return a bytevector holding a @code{struct sockaddr_in6} initialised
with this data.
@end defun


@defun sockaddr_in6.in6_addr @var{socket-address}
@defunx sockaddr_in6.in6_port @var{socket-address}
Given a bytevector @var{socket-address} holding a @code{struct
sockaddr_in6}, extract the @code{in6_addr} and @code{in6_port} fields
and return them as bytevector holding the corresponding @code{struct
in6_addr} and as fixnum.  If the data in @var{socket_address} is
invalid: an exception is raised.
@end defun

@c ------------------------------------------------------------

@defun in6addr_loopback
@defunx in6addr_any
Build and return a bytevector holding the constant structures of type
@code{struct in6_addr} defined by @code{in6addr_loopback} and
@code{in6addr_any}.
@end defun

@c page
@node posix socket addresses rep
@subsubsection @ascii{} address representations


Dotted quad address representations can be handled as follows:

@example
(import (vicare)
  (prefix (vicare posix) px.))

(px.inet-aton "127.0.0.1") @result{} #vu8(127 0 0 1)
(px.inet-aton "ciao")      @error{} invalid argument

(px.inet-ntoa/string '#vu8(127 0 0 1))
@result{} "127.0.0.1"
@end example

@noindent
care must be taken when handling such raw values.


@defun inet-aton @var{dotted-quad}
@ascii{} to number.  Given the bytevector @var{dotted-quad} holding the
@ascii{} dotted quad representation of a host address, build and return
a bytevector holding the corresponding @code{struct in_addr}.  If
@var{dotted-quad} is invalid: an exception is raised.
@end defun


@defun inet-ntoa @var{host-address}
@defunx inet-ntoa/string @var{host-address}
Number to @ascii{}.  Given the bytevector @var{host-address} holding a
@code{struct in_addr}: @func{inet-ntoa} builds and returns a bytevector
holding the corresponding @ascii{} dotted quad representation,
@func{inet-ntoa/string} builds and returns a string holding the
corresponding @ascii{} dotted quad representation.
@end defun

@c ------------------------------------------------------------

Addresses in presentation format can be handled as follows:

@example
#!vicare
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(px.inet-pton AF_INET "127.0.0.1") @result{} #vu8(127 0 0 1)
(px.inet-pton AF_INET "ciao")      @error{} invalid arguments

(px.inet-pton AF_INET6 "1:2:3:4:5:6:7:8")
@result{} #vu16b(1 2 3 4 5 6 7 8)

(px.inet-ntop/string AF_INET '#vu8(127 0 0 1))
@result{} "127.0.0.1"

(px.inet-ntop/string AF_INET6 '#vu16b(1 2 3 4 5 6 7 8))
@result{} "1:2:3:4:5:6:7:8"
@end example

@noindent
care must be taken when handling such raw values.


@defun inet-pton @var{af} @var{presentation}
Given the fixnum @var{af}, being @code{AF_INET} or @code{AF_INET6}, and
the string or bytevector @var{presentation} holding the @ascii{}
presentation of an Internet address, build and return a bytevector
holding the corresponding @code{struct in_addr} or @code{struct
in6_addr}.  If either @var{af} or @var{presentation} is invalid: raise
an exception.
@end defun


@defun inet-ntop @var{af} @var{host-address}
@defunx inet-ntop/string @var{af} @var{host-address}
Given the fixnum @var{af}, being @code{AF_INET} or @code{AF_INET6}, and
the bytevector @var{host-address} holding a @code{struct in_addr} or
@code{struct in6_addr}: @func{inet-ntop} builds and returns a bytevector
holding the corresponding @ascii{} presentation of the Internet address,
@func{inet-ntop/string} builds and returns a string holding the
corresponding @ascii{} presentation of the Internet address.  If the
arguments are invalid: an exception is raised.
@end defun

@c page
@node posix socket addresses info
@subsubsection Host address informations


@deftp {Structure Type} struct-addrinfo
Scheme level representation of @code{struct addrinfo}.  It has the
following fields:

@table @code
@item ai_flags
Fixnum.

@item ai_family
Fixnum, specifies the Internet address family; @code{AF_INET},
@code{AF_INET6} of @code{AF_UNSPEC}.

@item ai_socktype
Fixnum, specifies the socket type; @code{SOCK_STREAM}, @code{SOCK_DGRAM}
or other @code{SOCK_} value.

@item ai_protocol
Fixnum, specifies the protocol of the socket address.

@item ai_addrlen
Fixnum, the number of bytes in the bytevector referenced by
@code{ai_addr}.

@item ai_addr
Bytevector, holds an instance of @code{struct sockaddr} of
@code{ai_addrlen} bytes.

@item ai_canonname
False or bytevector, represents the canoncal name of the host when
available.
@end table
@end deftp


@defun make-struct-addrinfo @var{flags} @var{family} @var{socktype} @var{protocol} @var{addrlen} @var{addr} @var{canonname}
Build and return an instance of @code{struct-addrinfo}.
@end defun


@defun struct-addrinfo? @var{obj}
Return true if @var{obj} is an instance of @code{struct-addrinfo}.
@end defun


@defun struct-addrinfo-ai_flags @var{addrinfo}
@defunx struct-addrinfo-ai_family @var{addrinfo}
@defunx struct-addrinfo-ai_socktype @var{addrinfo}
@defunx struct-addrinfo-ai_protocol @var{addrinfo}
@defunx struct-addrinfo-ai_addrlen @var{addrinfo}
@defunx struct-addrinfo-ai_addr @var{addrinfo}
@defunx struct-addrinfo-ai_canonname @var{addrinfo}
Accessors for the fields of @code{struct-addrinfo}.
@end defun


@defun getaddrinfo @var{node} @var{service} @var{hints}
Interface to the C function @cfunc{getaddrinfo}, see the manual page
@code{getaddrinfo(3)}.  Given the strings or bytevectors @var{node} and
@var{service} identifying an Internet host and a service, build a list
of @code{struct-addrinfo} instances representing addresses to which
sockets can be bound or connected.

Both @var{node} and @var{service} can be false, in which case the
corresponding arguments handed to the C function are @code{NULL}.
@var{hints} must be an instance of @code{struct-addrinfo} used to select
matching hosts.

If successful: return the list of data structures, else raise an
exception.

@example
(px.getaddrinfo "github.com" "smtp" #f)
@result{} (#["struct-addrinfo"
        ai_flags=40             ai_family=AF_INET
        ai_socktype=SOCK_DGRAM  ai_protocol=17
        ai_addrlen=16
        ai_addr=#vu8(2 0 0 25 207 97 227 239 0 0 0 0 0 0 0 0)
        ai_canonname=#f]
    #["struct-addrinfo"
        ai_flags=40             ai_family=AF_INET
        ai_socktype=SOCK_STREAM ai_protocol=6
        ai_addrlen=16
        ai_addr=#vu8(2 0 0 25 207 97 227 239 0 0 0 0 0 0 0 0)
        ai_canonname=#f])
@end example
@end defun

@c page
@node posix socket hosts
@subsection Network hosts database


@deftp {Struct Type} struct-hostent
Data structure type used to represent at the Scheme level @code{struct
hostent} values.  It has the following fields:

@table @code
@item h_name
Bytevector, the official host name.

@item h_aliases
List of bytevectors, host name aliases.

@item h_addrtype
Fixnum, @code{AF_INET} or @code{AF_INET6}.

@item h_length
Fixnum, number of bytes in each host address bytevector.

@item h_addr_list
List of bytevectors each holding @code{struct in_addr} or @code{struct
in6_addr}.

@item h_addr
Bytevector, it is the first in the list @code{h_addr_list}.
@end table
@end deftp


@defun gethostbyname @var{hostname}
Interface to the C function @cfunc{gethostbyname}, @glibcref{Host Names,
gethostbyname}.  Given the string or bytevector @var{hostname} holding
the @ascii{} representation of a host name, build and return an instance
of @code{struct-hostent}.  If an error occurs, return an encoded
@code{h_errno} value.

@example
(import (vicare)
  (prefix (vicare posix) px.))

(px.gethostbyname "github.com")
@result{} #["struct-hostent"
       h_name="github.com"
       h_aliases=()
       h_addrtype=AF_INET
       h_length=4
       h_addr_list=(#vu8(207 97 227 239))
       h_addr=#vu8(207 97 227 239)]

(px.gethostbyname "google.com")
@result{} #["struct-hostent"
       h_name="google.com"
       h_aliases=()
       h_addrtype=AF_INET
       h_length=4
       h_addr_list=(#vu8(209 85 148 103)
                    #vu8(209 85 148 99)
                    #vu8(209 85 148 104)
                    #vu8(209 85 148 105)
                    #vu8(209 85 148 106)
                    #vu8(209 85 148 147))
       h_addr=#vu8(209 85 148 103)]
@end example
@end defun


@defun gethostbyaddr @var{addr}
Interface to the C function @cfunc{gethostbyaddr}, @glibcref{Host Names,
gethostbyaddr}.  Given the bytevector @var{addr} holding a @code{struct
in_addr} or a @code{struct in6_addr}, build and return an instance of
@code{struct-hostent}; the type of address is automatically inferred
from the length of the bytevector.  If an error occurs: an exception is
raised.
@end defun


@defun host-entries
Interface to the C functions @cfunc{sethostent}, @cfunc{gethostent} and
@cfunc{endhostent}, @glibcref{Host Names, gethostbyaddr}.  Build and
return a list of @code{struct-hostent} representing the entries in the
hosts database.
@end defun

@c page
@node posix socket protocols
@subsection Network protocols database


@deftp {Structure Type} struct-protoent
Scheme level representation of @code{struct protoent}.  It has the
following fields:

@table @code
@item p_name
Bytevector, the @ascii{} coding of the official protocol name.

@item p_aliases
Null or list of bytevectors, the @ascii{} codings of protocol name
aliases.

@item p_proto
Fixnum, the protocol number.
@end table
@end deftp


@defun make-struct-protoent @var{name} @var{aliases} @var{proto}
Build and return an instance of @code{struct-protoent}.
@end defun


@defun struct-protoent-p_name @var{protoent}
@defunx struct-protoent-p_aliases @var{protoent}
@defunx struct-protoent-p_proto @var{protoent}
Accessors for the fields of @code{struct-protoent}.
@end defun


@defun getprotobyname @var{name}
Interface to the C function @cfunc{getprotobyname}, @glibcref{Protocols
Database, getprotobyname}.  Given a string or bytevector @var{name}
holding the @ascii{} coding of a network protocol name, query the
network protocols database and build an instance of
@code{struct-protoent} mirroring the resulting @code{struct protoent}
entry.  If successful return the data structure, else raise an
exception.

@example
(px.getprotobyname "udp")
@result{} #["struct-protoent"
        p_name="udp"
        p_aliases=(UDP)
        p_proto=17]
@end example
@end defun


@defun getprotobynumber @var{proto_num}
Interface to the C function @cfunc{getprotobynumber},
@glibcref{Protocols Database, getprotobynumber}.  Given a fixnum
@var{proto_num} being the number of a network protocol, query the
network protocols database and build an instance of
@code{struct-protoent} mirroring the resulting @code{struct protoent}
entry.  If successful return the data structure, else raise an
exception.

@example
(px.getprotobynumber 17)
@result{} #["struct-protoent"
        p_name="udp"
        p_aliases=(UDP)
        p_proto=17]
@end example
@end defun


@defun protocol-entries
Interface to the C functions @cfunc{setprotoent}, @cfunc{getprotoent}
and @cfunc{endprotoent}, @glibcref{Protocols Database, setprotoent}.
Scan the network protocol database and build a list of
@code{struct-protoent} mirroring the resulting @code{struct protoent}
entries.  Return the list of structures.
@end defun

@c page
@node posix socket services
@subsection Network services database


@deftp {Structure Type} struct-servent
Scheme level representation of @code{struct servent}.  It has the
following fields:

@table @code
@item s_name
Bytevector, the @ascii{} coding of the official service name.

@item s_aliases
Null or list of bytevectors, the @ascii{} codings of service name
aliases.

@item s_port
Fixnum, the port number.

@item s_proto
Bytevector, @ascii{} coding of the associated protocol name.
@end table
@end deftp


@defun make-struct-servent @var{name} @var{aliases} @var{port} @var{proto}
Build and return an instance of @code{struct-servent}.
@end defun


@defun struct-servent-s_name @var{servent}
@defunx struct-servent-s_aliases @var{servent}
@defunx struct-servent-s_proto @var{servent}
@defunx struct-servent-s_port @var{servent}
Accessors for the fields of @code{struct-servent}.
@end defun


@defun getservbyname @var{name} @var{protocol}
Interface to the C function @cfunc{getservbyname}, @glibcref{Services
Database, getservbyname}.  Given the strings or bytevectors @var{name}
and @var{protocol} holding the @ascii{} coding of a network service name
and protocol, query the network services database and build an instance
of @code{struct-servent} mirroring the resulting @code{struct servent}
entry.  If successful return the data structure, else raise an
exception.

@example
(px.getservbyname "smtp" "tcp")
@result{} #["struct-servent"
        s_name="smtp"
        s_aliases=(mail)
        s_port=25
        s_proto=tcp]

(px.getservbyname "ntp" "udp")
@result{} #["struct-servent"
        s_name="ntp"
        s_aliases=()
        s_port=123
        s_proto=udp]
@end example
@end defun


@defun getservbynumber @var{port} @var{protocol}
Interface to the C function @cfunc{getservbynumber}, @glibcref{Services
Database, getservbynumber}.  Given a fixnum @var{port} and a string or
bytevector @var{protocol} being the port number and protocol name of a
network service, query the network services database and build an
instance of @code{struct-servent} mirroring the resulting @code{struct
servent} entry.  If successful return the data structure, else raise an
exception.

@example
(px.getservbyport 80 "tcp")
@result{} #["struct-servent"
        s_name="http"
        s_aliases=(www-http www)
        s_port=80
        s_proto=tcp]
@end example
@end defun


@defun service-entries
Interface to the C functions @cfunc{setservent}, @cfunc{getservent} and
@cfunc{endservent}, @glibcref{Services Database, setservent}.  Scan the
network service database and build a list of @code{struct-servent}
mirroring the resulting @code{struct servent} entries.  Return the list
of structures.
@end defun

@c page
@node posix socket networks
@subsection Networks database


@deftp {Structure Type} struct-netent
Scheme level representation of @code{struct netent}.  It has the
following fields:

@table @code
@item n_name
Bytevector, @ascii{} coding of the official network name.

@item n_aliases
List of bytevectors, alias names for the network.

@item n_addrtype
Fixnum, the network type.

@item n_net
32-bit bytevector, the network number in network byte order.
@end table
@end deftp


@defun make-struct-netent @var{name} @var{aliases} @var{addrtype} @var{net}
Build and return a new instance of @code{struct-netent}.
@end defun


@defun struct-netent-n_name @var{netent}
@defunx struct-netent-n_aliases @var{netent}
@defunx struct-netent-n_addrtype @var{netent}
@defunx struct-netent-n_net @var{netent}
Accessors for the fields of @code{struct-netent}.
@end defun


@defun struct-netent? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-netent}.
@end defun


@defun getnetbyname @var{name}
Interface to the C function @cfunc{getnetbyname}, @glibcref{Networks
Database, getnetbyname}.  Given the bytevector @var{name} holding the
@ascii{} coding of a network name, query the networks database and build
an instance of @code{struct-netent} mirroring the resulting @code{struct
netent} entry.  If successful return the data structure, else raise an
exception.

@example
(px.getnetbyname "loopback")
@result{} #["struct-netent"
        n_name="loopback"
        n_aliases=()
        n_addrtype=AF_INET
        n_net=#vu8(127 0 0 0)]
@end example
@end defun


@defun getnetbyaddr @var{net} @var{type}
Interface to the C function @cfunc{getnetbyaddr}, @glibcref{Networks
Database, getnetbyaddr}.  Given an exact integer or bytevector @var{net}
representing a network number and the fixnum @var{type} representing a
network type, query the networks database and build an instance of
@code{struct-netent} mirroring the resulting @code{struct netent} entry.
If successful return the data structure, else raise an exception.

@example
(px.getnetbyaddr '#vu8(127 0 0 0) AF_INET)
@result{} #["struct-netent"
        n_name="loopback"
        n_aliases=()
        n_addrtype=AF_INET
        n_net=#vu8(127 0 0 0)]
@end example
@end defun


@defun network-entries
Interface to the C functions @cfunc{setnetent}, @cfunc{getnetent} and
@cfunc{endnetent}, @glibcref{Networks Database, setnetent}.  Scan the
networks database and build a list of @code{struct-netent} mirroring the
resulting @code{struct netent} entries.  Return the list of structures.
@end defun

@c page
@node posix socket socket
@subsection Network sockets operations


@defun socket @var{namespace} @var{style} @var{protocol}
Interface to the C function @cfunc{socket}, @glibcref{Creating a Socket,
socket}.  Create a new socket descriptor and return it as non--negative
fixnum; if an error occurs raise an exception.  All the arguments must
be fixnums.
@end defun


@defun shutdown @var{sock} @var{how}
Interface to the C function @cfunc{shutdown}, @glibcref{Closing a
Socket, shutdown}.  Close the socket @var{sock} according to @var{how},
which can be one of the constants @code{SHUT_RD}, @code{SHUT_WR} or
@code{SHUT_RDWR}.  If successful return unspecified values, else raise
an exception.
@end defun


@defun socketpair @var{namespace} @var{style} @var{protocol}
Interface to the C function @cfunc{socketpair}, @glibcref{Socket Pairs,
socketpair}.  Create a pairs of connected sockets and return two values
being the descriptors as non--negative fixnums; if an error occurs raise
an exception.  All the arguments must be fixnums; @var{namespace} must
be @code{AF_LOCAL}.

@example
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let-values (((a b) (px.socketpair AF_LOCAL SOCK_DGRAM 0)))
  (px.write a '#vu8(1 2 3 4) 4)
  (let ((buf (make-bytevector 4)))
    (px.read b buf 4)
    (px.shutdown a SHUT_RDWR)
    (px.shutdown b SHUT_RDWR)
    buf))
@result{} #vu8(1 2 3 4)
@end example
@end defun

@c ------------------------------------------------------------

@defun connect @var{sock} @var{addr}
Interface to the C function @cfunc{connect}, @glibcref{Connecting,
connect}.  Connect the socket @var{sock} to the address specified by the
bytevector @var{addr} which must hold a concrete instance of
@code{struct sockaddr}.  If successful return unspecified values, else
raise an exception.
@end defun


@defun listen @var{sock} @var{pending_conns}
Interface to the C function @cfunc{listen}, @glibcref{Listening,
listen}.  Enable the socket @var{sock} to accept connections; the fixnum
@var{pending_conns} specifies the maximum length of the pending
connection requests queue.  If successful return unspecified values,
else raise an exception.
@end defun


@defun accept @var{sock}
Interface to the C function @cfunc{accept}, @glibcref{Accepting
Connections, accept}.  Accept an incoming connection to the server
socket @var{sock}.

If successful and a connection is accepted return two values: a
non--negative fixnum representing the socket, a bytevector representing
the client address as @code{struct sockaddr}.

If successful and no connection is accepted return two values both being
false; this is the case of @cfunc{accept} returning @code{EWOULDBLOCK}
which means that @var{sock} is in non--blocking mode and no pending
connections exist.

If an error occurs raise an exception.
@end defun


@defun bind @var{sock} @var{sockaddr}
Interface to the C function @cfunc{bind}, @glibcref{Setting Address,
bind}.  Bind the socket descriptor @var{sock} to the address specified
by the @code{struct sockaddr} in the bytevector @var{sockaddr}.  If
successful return unspecified values, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun getpeername @var{sock}
Interface to the C function @cfunc{getpeername}, @glibcref{Who is
Connected, getpeername}.  Retrieve informations about the address of the
socket to which the @var{sock} socket is connected to.  If successful
return a bytevector holding a @code{struct sockaddr}, else raise an
exception.
@end defun


@defun getsockname @var{sock}
Interface to the C function @cfunc{getsockanme}, @glibcref{Setting
Address, getsockname}.  Retrieve informations about the address bound to
the socket descriptor @var{sock}.  If successful return a bytevector
holding the @code{struct sockaddr}, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun send @var{sock} @var{buffer} @var{size} @var{flags}
Interface to the C function @cfunc{send}, @glibcref{Sending Data, send}.
Like @cfunc{write} but with the additional argument @var{flags} which
must be a fixnum: write data from the bytevector @var{buffer} to the
socket @var{sock}; if @var{size} is a fixnum, write @var{size} bytes; if
@var{size} is false, write a number of bytes equal to the length of
@var{buffer}.  If successful return a non--negative fixnum representing
the number of bytes actually sent, else raise an exception.
@end defun


@defun recv @var{sock} @var{buffer} @var{size} @var{flags}
Interface to the C function @cfunc{recv}, @glibcref{Receiving Data,
recv}.  Like @cfunc{read} but with the additional argument @var{flags}
which must be a fixnum: read data from @var{sock} and store it in the
bytevector @var{buffer}; if @var{size} is a fixnum, read @var{size}
bytes; if @var{size} is false, read a number of bytes equal to the
length of @var{buffer}.  If successful return a non--negative fixnum
representing the number of bytes actually received, else raise an
exception.
@end defun

@c ------------------------------------------------------------

@defun sendto @var{sock} @var{buffer} @var{size} @var{flags} @var{addr}
Interface to the C function @cfunc{sendto}, @glibcref{Sending Datagrams,
sendto}.  Like @cfunc{send} but with the additional argument @var{addr}
which must be a bytevector holding a @code{struct sockaddr}: write data
from the bytevector @var{buffer} to the socket @var{sock} to the
destination specified by @var{addr}.

If @var{size} is a fixnum, write @var{size} bytes; if @var{size} is
false, write a number of bytes equal to the length of @var{buffer}.

If successful return a non--negative fixnum representing the number of
bytes actually sent, else raise an exception.
@end defun


@defun recvfrom @var{sock} @var{buffer} @var{size} @var{flags}
Interface to the C function @cfunc{recvfrom}, @glibcref{Receiving
Datagrams, recvfrom}.  Like @cfunc{recv} but additionally retrieve
informations about the address of the sender: read data from @var{sock}
and store it in the bytevector @var{buffer}.

If @var{size} is a fixnum, read @var{size} bytes; if @var{size} is
false, read a number of bytes equal to the length of @var{buffer}.

If successful return two values: a non--negative fixnum representing the
number of bytes actually received, a bytevector holding a @code{struct
sockaddr} representing the address of the sender; else raise an
exception.
@end defun

@c ------------------------------------------------------------

@defun getsockopt @var{sock} @var{level} @var{option} @var{optval}
Interface to the C function @cfunc{getsockopt}, @glibcref{Socket Option
Function, getsockopt}.  Retrieve the value of @var{option} of socket
@var{sock} at @var{level} and store it in the bytevector @var{optval}.
@var{option} and @var{level} must be fixnums.  If successful return
unspecified values, else raise an exception.
@end defun


@defun setsockopt @var{sock} @var{level} @var{option} @var{optval}
Interface to the C function @cfunc{setsockopt}, @glibcref{Socket Option
Function, setsockopt}.  Set a new value for @var{option} of socket
@var{sock} at @var{level} reading it from the bytevector @var{optval}.
@var{option} and @var{level} must be fixnums.  If successful return
unspecified values, else raise an exception.
@end defun


@defun getsockopt/int @var{sock} @var{level} @var{option}
@defunx setsockopt/int @var{sock} @var{level} @var{option} @var{optval}
Like @func{getsockopt} and @func{setsockopt} but specially handle the
case of an option with value represented by a C language @code{int}.
@var{optval} must appropriately be a boolean or an exact integer
representable as a platform's C language @code{int}.
@end defun


@defun getsockopt/size_t @var{sock} @var{level} @var{option}
@defunx setsockopt/size_t @var{sock} @var{level} @var{option} @var{optval}
Like @func{getsockopt} and @func{setsockopt} but specially handle the
case of an option with value represented by a C language @code{size_t}.
@var{optval} must be an exact integer representable as a platform's C
language @code{size_t}.
@end defun

@c page
@node posix socket misc
@subsection Error and miscellaneous functions


@defun h_errno->string @var{h_errno-code}
Convert an encoded @code{h_errno} value to the corresponding symbolic
string.
@end defun


@defun h_strerror @var{h_errno-code}
Convert an encoded @code{h_errno} value to the corresponding descriptive
error message string.
@end defun


@defun gai-strerror @var{error-code}
Interface to the C function @cfunc{gai_strerror}, see the manual page
@code{gai_strerror(3)}.  Convert an @code{EAI_} error code into the
corresponding error message, return a string holding such message.
@end defun

@c page
@node posix socket examples
@subsection Examples of clients and servers


Basically a @tcp{}/@ip{} server should do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let ((sockaddr    (px.make-sockaddr_in '#vu8(127 0 0 1) 8080))
      (server-sock (px.socket PF_INET SOCK_STREAM 0)))
  (px.bind   server-sock sockaddr)
  (px.listen server-sock 2)
  (let-values (((sock client-address)
                (px.accept server-sock)))
    ;; ... talk with the client through SOCK ...
    (px.close sock))
  (px.close server-sock))
@end example

@noindent
while a @tcp{}/@ip{} client should to:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let ((sockaddr (px.make-sockaddr_in '#vu8(127 0 0 1) 8080))
      (sock     (px.socket PF_INET SOCK_STREAM 0)))
  (px.connect sock sockaddr)
  ;; ... talk to the server through SOCK ...
  (px.close sock))
@end example

A @udp{}/@ip{} ``server'' should do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let ((sockaddr   (px.make-sockaddr_in '#vu8(127 0 0 1) 8080))
      (sock       (px.socket PF_INET SOCK_DGRAM 0))
      (in-buffer  (make-bytevector 1024))
      (out-buffer (make-bytevector 1024)))
  (px.bind sock sockaddr)
  (let-values (((len sockaddr)
                (px.recvfrom sock in-buffer #f 0)))
    ;; ... process the received packet ...
    ;; ... prepare the answer ...
    (px.sendto sock out-buffer #f 0 sockaddr))
  (px.close sock))
@end example

@noindent
while a @udp{}/@ip{} ``client'' should do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let ((sockaddr   (px.make-sockaddr_in '#vu8(127 0 0 1) 8081))
      (sock       (px.socket PF_INET SOCK_DGRAM 0))
      (out-buffer (make-bytevector 1024))
      (in-buffer  (make-bytevector 1024)))
  (px.bind sock sockaddr)
  ;; ... prepare the request ...
  (px.sendto sock out-buffer #f 0 sockaddr)
  (let-values (((len sockaddr)
                (px.recvfrom sock in-buffer #f 0)))
    ;; ... process the received packet ...
    )
  (px.close sock))
@end example

A Unix--domain socket server should do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let* ((tmpdir       (px.getenv "TMPDIR"))
       (pathname     (string-append tmpdir "/use-me"))
       (sockaddr     (px.make-sockaddr_un pathname))
       (server-sock  (px.socket PF_LOCAL SOCK_STREAM 0)))
  (px.bind   server-sock sockaddr)
  (px.listen server-sock 2)
  (let-values (((sock client-address)
                (px.accept server-sock)))
    ;; ... talk to the client through SOCK ...
    (px.close sock))
  (px.close server-sock))
@end example

@noindent
while a Unix--domain socket client should do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let* ((tmpdir    (px.getenv "TMPDIR"))
       (pathname  (string-append tmpdir "/use-me"))
       (sockaddr  (px.make-sockaddr_un pathname))
       (sock      (px.socket PF_LOCAL SOCK_STREAM 0)))
  (px.connect sock sockaddr)
  ;; ... talk to the server through SOCK ...
  (px.close sock))
@end example

To receive incoming data and Out Of Band data, a @tcp{}/@ip{} server
should do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let ((sockaddr    (px.make-sockaddr_in '#vu8(127 0 0 1) 8080))
      (server-sock (px.socket PF_INET SOCK_STREAM 0)))
  (px.bind   server-sock sockaddr)
  (px.listen server-sock 2)
  (let*-values
      (((sock client-address) (px.accept server-sock))
       ((bv)                  (make-bytevector 10)))
    (let loop ()
      (let-values (((rd wr ex) (px.select-fd sock 2 0)))
        (cond (ex ;process exceptional conditions first!!!
               ;; block until OOB data arrives
               (let ((len (px.recv sock bv #f MSG_OOB)))
                 ;; process data in BV between 0 and LEN,
                 ;; which should be 1
                 (loop)))
              (rd
               (let ((len (px.recv sock bv #f 0)))
                 (when (positive? len)
                   ;; process data in BV between 0
                   ;; and LEN
                   (loop))))
              (else (loop)))))
    (px.close sock))
  (px.close server-sock))
@end example

@noindent
to send outgoing data and Out Of Band data, a @tcp{}/@ip{} client should
do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let ((sockaddr  (px.make-sockaddr_in '#vu8(127 0 0 1) 8080))
      (sock      (px.socket PF_INET SOCK_STREAM 0)))
  (px.connect sock sockaddr)
  (px.send sock '#vu8(1 2 3) #f 0)
  ;; only the single byte 6 (the last) is sent as
  ;; OOB data, 4 and 5 are sent as ordinary data
  (px.send sock '#vu8(4 5 6) #f MSG_OOB)
  (px.send sock '#vu8(7 8 9) #f 0)
  (px.close sock))
@end example

@c page
@node posix socket oob
@subsection Notes on transmission of @oob{} data


In a @tcp{}/@ip{} stream--oriented client/server architecture, the
scenario is the following:

@example
 --------------------        ------------
| sending appication |----->| sending OS |
 --------------------        ------------
                                  |
                                  v
 -----------------------     -------------
| receiving application |<--| receving OS |
 -----------------------     -------------
@end example

@noindent
sending ordinary data works as follows:

@enumerate
@item
The sending application calls (for example) the @func{send} function
asking the sending @os{} to send data to the remote host.

@item
The sending @os{} enqueues the data in a @fifo{} buffer, which it
progressively fragments in packets for delivery.

@item
The receiving @os{} orders and enqueues data from received packets in a
@fifo{} buffer.

@item
The receiving application calls (for example) the @cfunc{recv} function
to consume chunks of the input data.
@end enumerate

@noindent
sending a single byte of @oob{} data works as follows:

@enumerate
@item
The sending application calls the function @func{send} specifying the
@code{MSG_OOB} flag, asking the sending @os{} to deliver a single byte
of @oob{} data.

@item
The sending @os{} enqueues the single byte in its @fifo{} buffer and
tags the next outgoing packet to announce future delivery of the @oob{}
byte.

@item
The receiving @os{} orders and enqueues data from received packets in a
@fifo{} buffer; when it detects a tagged packet announcing the @oob{}
byte: it optionally informs the receiving application of its future
arrival, signaling an exceptional condition on the socket descriptor, if
requested.

@item
The sending @os{} proceeds in sending ordinary data from its @fifo{}
buffer and whenever it reaches the @oob{} byte: it sends it in a
specially tagged packet.

@item
The receiving @os{} orders and enqueues data from received packets in a
@fifo{} buffer; when it detects a tagged packet holding the @oob{} byte:
it makes it available to the receiving application.

@item
The receving application calls the function @func{recv} specifying the
@code{MSG_OOB} flag and retrieves the single @oob{} byte.
@end enumerate

If we send the @oob{} byte with the form:

@example
(px.send sock '#vu8(8) #f MSG_OOB)
@end example

@noindent
the byte @code{8} will be the @oob{} byte; if we send the @oob{} byte
with the form:

@example
(px.send sock '#vu8(1 2 3) #f MSG_OOB)
@end example

@noindent
the byte @code{3}, the last in the memory block, will be the @oob{} byte
and the bytes @code{1} and @code{2} will be sent as ordinary data; the
receiving application must @strong{not} assume that bytes @code{1} and
@code{2} will be made available before the @oob{} byte @code{3}.

When using @func{select} to be notified of incoming @oob{} data: the
receiving application must assume that the exceptional condition is
notified @strong{only once} and not persist in further calls to
@func{select}; for this reason the exceptional condition must be
recognised and registered by the application as soon as it is notified
by @func{select}.

The socket option @code{SO_OOBINLINE} allows the @oob{} byte to be
places in the ordinary data @fifo{} buffer, so that it can be
transparently consumed by a call to @func{read} or @func{recv} without
the @code{MSG_OOB} flag.

Notice that the single @oob{} byte, although limited, can represent
@math{256} symbols in an appropriate alphabet of commands.

@c page
@node posix users
@section Users and groups


@defun getuid
Interface to the C function @cfunc{getuid}, @glibcref{Reading Persona,
getuid}.  Return a fixnum representing the real user ID of the process.
@end defun


@defun getgid
Interface to the C function @cfunc{getgid}, @glibcref{Reading Persona,
getgid}.  Return a fixnum representing the real group ID of the process.
@end defun


@defun geteuid
Interface to the C function @cfunc{geteuid}, @glibcref{Reading Persona,
geteuid}.  Return a fixnum representing the effective user ID of the
process.
@end defun


@defun getegid
Interface to the C function @cfunc{getegid}, @glibcref{Reading Persona,
getegid}.  Return a fixnum representing the effective group ID of the
process.
@end defun


@defun getgroups
Interface to the C function @cfunc{getgroups}, @glibcref{Reading
Persona, getgroups}.  Return a list of fixnums representing the
supplementary group IDs of the process; if an error occurs an exception
is raised.
@end defun

@c ------------------------------------------------------------

@defun seteuid @var{new-uid}
Interface to the C function @cfunc{seteuid}, @glibcref{Setting User ID,
seteuid}.  Set the effective user ID to @var{new-uid}, which must be a
fixnum.  If successful return unspecified values, else raise an
exception.
@end defun


@defun setuid @var{new-uid}
Interface to the C function @cfunc{setuid}, @glibcref{Setting User ID,
setuid}.  Set both the real and effective user IDs to @var{new-uid},
which must be a fixnum.  If successful return unspecified values, else
raise an exception.
@end defun


@defun setreuid @var{real-uid} @var{effective-uid}
Interface to the C function @cfunc{setreuid}, @glibcref{Setting User ID,
setreuid}.  Set the real user ID to @var{real_uid} and the effective
user ID to @var{effective_uid}, both the arguments must be fixnums.  If
successful return unspecified values, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun setegid @var{new-gid}
Interface to the C function @cfunc{setegid}, @glibcref{Setting Group,
setegid}.  Set the effective group ID to @var{new-gid}, which must be a
fixnum.  If successful return unspecified values, else raise an
exception.
@end defun


@defun setgid @var{new-gid}
Interface to the C function @cfunc{setgid}, @glibcref{Setting Groups,
setgid}.  Set both the real and effective group IDs to @var{new-gid},
which must be a fixnum.  If successful return unspecified values, else
raise an exception.
@end defun


@defun setregid @var{real-gid} @var{effective-gid}
Interface to the C function @cfunc{setregid}, @glibcref{Setting Group,
setregid}.  Set the real group ID to @var{real_gid} and the effective
group ID to @var{effective_gid}, both the arguments must be fixnums.  If
successful return unspecified values, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun getlogin
@defunx getlogin/string
Interface to the C function @cfunc{getlogin}, @glibcref{Who Logged In,
getlogin}.  @func{getlogin} returns a bytevector holding the @ascii{}
coding of the name of the user logged in on the controlling terminal of
the process; @func{getlogin/string} returns a string; if the name cannot
be determined: return false.
@end defun

@c ------------------------------------------------------------

@deftp {Structure Type} struct-passwd
Scheme level representation of @code{struct passwd}.  It has the
following fields:

@table @code
@item pw_name
Bytevector, user login name.

@item pw_passwd
Bytevector, encrypted password.

@item pw_uid
Fixnum, user ID.

@item pw_gid
Fixnum, group ID.

@item pw_gecos
Bytevector, user data.

@item pw_dir
Bytevector, user's home directory.

@item pw_shell
Bytevector, user's default shell.
@end table
@end deftp


@defun make-struct-passwd @var{name} @var{passwd} @var{uid} @var{gid} @var{gecos} @var{dir} @var{shell}
Build and return a new instance of @code{struct-passwd}.
@end defun


@defun struct-passwd? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-passwd}.
@end defun


@defun struct-passwd-pw_name @var{passwd}
@defunx struct-passwd-pw_passwd @var{passwd}
@defunx struct-passwd-pw_uid @var{passwd}
@defunx struct-passwd-pw_gid @var{passwd}
@defunx struct-passwd-pw_gecos @var{passwd}
@defunx struct-passwd-pw_dir @var{passwd}
@defunx struct-passwd-pw_shell @var{passwd}
Accessors for the fields of @code{struct-passwd}.
@end defun


@defun getpwuid @var{uid}
Interface to the C function @cfunc{getpwuid}, @glibcref{Lookup User,
getpwuid}.  Retrieve informations on the user with identifier @var{uid},
which must be a fixnum.  If successful return an instance of
@code{struct-passwd}; if a user with such an ID does not exists: return
false.
@end defun


@defun getpwnam @var{name}
Interface to the C function @cfunc{getpwnam}, @glibcref{Lookup User,
getpwnam}.  Retrieve informations on the user with name represented in
@ascii{} coding in the string or bytevector @var{name}.  If successful
return an instance of @code{struct-passwd}; if a user with such an ID
does not exists: return false.
@end defun


@defun user-entries
Interface to the C functions @cfunc{setpwent}, @cfunc{getpwent} and
@cfunc{endpwent}, @glibcref{Scanning All Users, setpwent}.  Iterate the
database of users and return a list of @code{struct-passwd} representing
the entries.
@end defun

@c ------------------------------------------------------------

@deftp {Structure Type} struct-group
Scheme level representation of @code{struct group}.  It has the
following fields:

@table @code
@item gr_name
Bytevector, group name.

@item gr_gid
Fixnum, group ID.

@item gr_mem
List of bytevectors, user names.
@end table
@end deftp


@defun make-struct-group @var{name} @var{gid} @var{mem}
Build and return a new instance of @code{struct-group}.
@end defun


@defun struct-group-gr_name @var{group}
@defunx struct-group-gr_gid @var{group}
@defunx struct-group-gr_mem @var{group}
Accessors for the fields of @code{struct-group}.
@end defun


@defun getgrgid @var{gid}
Interface to the C function @cfunc{getgrgid}, @glibcref{Lookup Group,
getgrgid}.  Retrieve informations on the group with identifier
@var{gid}, which must be a fixnum.  If successful return an instance of
@code{struct-group}; if a group with such an ID does not exists: return
false.
@end defun


@defun getgrnam @var{name}
Interface to the C function @cfunc{getgrnam}, @glibcref{Lookup Group,
getgrnam}.  Retrieve informations on the group with name represented in
@ascii{} coding in the string or bytevector @var{name}.  If successful
return an instance of @code{struct-group}; if a group with such an ID
does not exists: return false.
@end defun


@defun group-entries
Interface to the C functions @cfunc{setgrent}, @cfunc{getgrent} and
@cfunc{endgrent}, @glibcref{Scanning All Groups, setgrent}.  Iterate the
database of groups and return a list of @code{struct-group} representing
the entries.
@end defun

@c page
@node posix job
@section Job control


@defun ctermid
@defunx ctermid/string
Interface to the C function @cfunc{ctermid}, @glibcref{Identifying the
Terminal, ctermid}.  Return a bytevector or string holding the @ascii{}
coded pathname of the controlling terminal of the current process; the
returned value may be the empty bytevector or string.
@end defun

@c ------------------------------------------------------------

@defun setsid
Interface to the C function @cfunc{setsid}, @glibcref{Process Group
Functions, setsid}.  Create a new session, making the current process
the group leader with no controlling terminal.  If successful return a
fixnum representing the new process groups ID, else raise an exception.
@end defun


@defun getsid @var{pid}
Interface to the C function @cfunc{getsid}, @glibcref{Process Group
Functions, getsid}.  If successful return a fixnum representing the
session ID of the process with process ID @var{pid}, which must be a
fixnum; else raise an exception.
@end defun


@defun getpgrp
Interface to the C function @cfunc{getpgrp}, @glibcref{Process Group
Functions, getpgrp}.  Return a fixnum representing the process group ID
of the calling process.
@end defun


@defun setpgid @var{pid} @var{pgid}
Interface to the C function @cfunc{setpgid}, @glibcref{Process Group
Functions, setpgid}.  Put the process @var{pid} in the process group
@var{pgid}; both the arguments must be fixnums.  If successful return
unspecified values, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun tcgetpgrp @var{fd}
Interface to the C function @cfunc{tcgetpgrp}, @glibcref{Terminal Access
Functions, tcgetpgrp}.  If successful return a fixnum representing the
process group ID of the foreground process group associated with the
terminal open on descriptor @var{fd}, which must be a fixnum; else raise
an exception.
@end defun


@defun tcsetpgrp @var{fd} @var{pgid}
Interface to the C function @cfunc{tcsetpgrp}, @glibcref{Terminal Access
Functions, tcsetpgrp}.  Set to process group ID @var{pgid} the
foreground process group for the terminal open on descriptor @var{fd};
both the arguments must be fixnums.  If successful return the fixnum
zero, else raise an exception.
@end defun


@defun tcgetsid @var{fd}
Interface to the C function @cfunc{tcgetsid}, @glibcref{Terminal Access
Functions, tcgetsid}.  If successful return a fixnum representing the
process group ID of the session for which the terminal open on
descriptor @var{fd} is the controlling terminal; else raise an
exception.
@end defun


@c page
@node posix time
@section Date and time


@menu
* posix time timeval::          Data structure @code{struct-timeval}.
* posix time timespec::         Data structure @code{struct-timespec}.
* posix time tms::              Data structure @code{struct-tms}.
* posix time tm::               Data structure @code{struct-tm}.
* posix time itimerval::        Data structure @code{struct-itimerval}.
* posix time itimerspec::       Data structure @code{struct-itimerspec}.
* posix time functions::        Date and time functions.
@end menu

@c page
@node posix time timeval
@subsection Data structure @code{struct-timeval}


@deftp {Structure Type} struct-timeval
Scheme level representation of @code{struct timeval}, @glibcref{Elapsed
Time, struct timeval}.  It has the
following fields:

@table @code
@item tv_sec
Exact integer, represents a count of seconds.

@item tv_usec
Exact integer, represents a count of microseconds.
@end table
@end deftp


@defun make-struct-timeval @var{sec} @var{usec}
Build and return a new instance of @code{struct-timeval}.
@end defun


@defun struct-timeval? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-timeval}.
@end defun


@defun struct-timeval-tv_sec @var{timeval}
@defunx struct-timeval-tv_usec @var{timeval}
Accessors for the fields of @code{struct-timeval}.
@end defun

@c page
@node posix time timespec
@subsection Data structure @code{struct-timespec}


@deftp {Structure Type} struct-timespec
Scheme level representation of @code{struct timespec}, @glibcref{Elapsed
Time, struct timeval}.  It has the following fields:

@table @code
@item tv_sec
Exact integer, represents a count of seconds.

@item tv_nsec
Exact integer, represents a count of nanoseconds.
@end table
@end deftp


@defun make-struct-timespec @var{sec} @var{usec}
Build and return a new instance of @code{struct-timespec}.
@end defun


@defun struct-timespec? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-timespec}.
@end defun


@defun struct-timespec-tv_sec @var{timespec}
@defunx struct-timespec-tv_nsec @var{timespec}
Accessors for the fields of @code{struct-timespec}.
@end defun

@c page
@node posix time tms
@subsection Data structure @code{struct-tms}


@deftp {Structure Type} struct-tms
Scheme level representation of @code{struct tms}, @glibcref{Processor
Time, struct tms}.  It has the following fields:

@table @code
@item tms_utime
Exact integer.

@item tms_stime
Exact integer.

@item tms_cutime
Exact integer.

@item tms_cstime
Exact integer.
@end table
@end deftp


@defun make-struct-tms @var{utime} @var{stime} @var{cutime} @var{cstime}
Build and return a new instance of @code{struct-tms}.
@end defun


@defun struct-tms? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-tms}.
@end defun


@defun struct-tms-tms_utime @var{tms}
@defunx struct-tms-tms_stime @var{tms}
@defunx struct-tms-tms_cutime @var{tms}
@defunx struct-tms-tms_cstime @var{tms}
Accessors for the fields of @code{struct-tms}.
@end defun

@c page
@node posix time tm
@subsection Data structure @code{struct-tm}


@deftp {Structure Type} struct-tm
Scheme level representation of @code{struct tm}, @glibcref{Broken-down
Time, struct tm}.  It has the following fields:

@table @code
@item tm_sec
Exact integer.

@item tm_min
Exact integer.

@item tm_hour
Exact integer.

@item tm_mday
Exact integer.

@item tm_mon
Exact integer.

@item tm_year
Exact integer.

@item tm_wday
Exact integer.

@item tm_yday
Exact integer.

@item tm_isdst
Boolean.

@item tm_gmtoff
Exact integer.

@item tm_zone
Bytevector.
@end table
@end deftp


@defun make-struct-tm @var{tm_sec} @var{tm_min} @var{tm_hour} @var{tm_mday} @var{tm_mon} @var{tm_year} @var{tm_wday} @var{tm_yday} @var{tm_isdst} @var{tm_gmtoff} @var{tm_zone}
Build and return a new instance of @code{struct-tm}.
@end defun


@defun struct-tm? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-tm}.
@end defun


@defun struct-tm-tm_sec @var{tm}
@defunx struct-tm-tm_min @var{tm}
@defunx struct-tm-tm_hour @var{tm}
@defunx struct-tm-tm_mday @var{tm}
@defunx struct-tm-tm_mon @var{tm}
@defunx struct-tm-tm_year @var{tm}
@defunx struct-tm-tm_wday @var{tm}
@defunx struct-tm-tm_yday @var{tm}
@defunx struct-tm-tm_isdst @var{tm}
@defunx struct-tm-tm_gmtoff @var{tm}
@defunx struct-tm-tm_zone @var{tm}
Accessors for instances of @var{struct-tm}
@end defun

@c page
@node posix time itimerval
@subsection Data structure @code{struct-itimerval}


Structure representing interval timer values (ITimerVal).


@deftp {Structure Type} struct-itimerval
Scheme level representation of @code{struct itimerval},
@glibcref{Setting an Alarm, struct itimerval}.  It has the following
fields:

@table @code
@item it_interval
An instance of @code{struct-timeval} representing the period between
successive timer interrupts.

@item it_value
An instance of @code{struct-timeval} representing the time interval
between now and the first timer interrupt.
@end table
@end deftp


@defun make-struct-itimerval
@defunx make-struct-itimerval @var{interval} @var{value}
Build and return a new instance of @code{struct-itimerval}.  When called
with no arguments: two new instances of @code{struct-timeval} are
allocated and initialised to zero values, then used as field values.
@end defun


@defun struct-itimerval? @var{obj}
Return true if @var{obj} is an instance of @code{struct-itimerval}.
@end defun


@defun struct-itimerval-it_interval @var{itimerval}
@defunx struct-itimerval-it_value @var{itimerval}
Accessors for the fields of @code{struct-itimerval}.
@end defun

@c page
@node posix time itimerspec
@subsection Data structure @code{struct-itimerspec}


Structure representing interval timer specifications (ITimerSpec).


@deftp {Structure Type} struct-itimerspec
Scheme level representation of @code{struct itimerspec}, see the manual
pages @code{timer_create(2)} and @code{timerfd_create(2)}.  It has the
following fields:

@table @code
@item it_interval
An instance of @code{struct-timespec} representing the period between
successive timer interrupts, in seconds and nanoseconds.  @ref{posix
time timespec} for details on @code{struct-timespec}.

@item it_value
An instance of @code{struct-timespec} representing the time interval
between now and the first timer interrupt, in seconds and nanoseconds.
@ref{posix time timespec} for details on @code{struct-timespec}.
@end table
@end deftp


@defun make-struct-itimerspec
@defunx make-struct-itimerspec @var{interval} @var{value}
Build and return a new instance of @code{struct-itimerspec}.  When
called with no arguments: two new instances of @code{struct-timespec}
are allocated and initialised to zero values, then used as field values.
@end defun


@defun struct-itimerspec? @var{obj}
Return true if @var{obj} is an instance of @code{struct-itimerspec}.
@end defun


@defun struct-itimerspec-it_interval @var{itimerspec}
@defunx struct-itimerspec-it_value @var{itimerspec}
Accessors for the fields of @code{struct-itimerspec}.
@end defun

@c page
@node posix time functions
@subsection Date and time functions


@defun clock
Interface to the C function @cfunc{clock}, @glibcref{CPU Time, clock}.
If successful return an exact integer representing the CPU time for the
calling process expressed in clock ticks; if the clock time is not
available return false.
@end defun

@c ------------------------------------------------------------

@defun times
Interface to the C function @cfunc{times}, @glibcref{Processor Time,
times}.  If successful return an instance of @code{struct-tms}
representing the current processor time, else return false.
@end defun

@c ------------------------------------------------------------

@defun time
Interface to the C function @cfunc{time}, @glibcref{Simple Calendar
Time, time}.  If successful return the calendar time as an exact
integer, else return false.
@end defun


@defun gettimeofday
Interface to the C function @cfunc{gettimeofday},
@glibcref{High-Resolution Calendar, gettimeofday}.  Acquire the current
time.  If successful return an instance of @code{struct-timeval}, else
raise an exception.
@end defun


@defun localtime @var{time}
Interface to the C function @cfunc{localtime}, @glibcref{Broken-down
Time, localtime}.  Given an exact integer @var{time} representing the
local time as returned by the @func{time} function: build and return an
instance of @code{struct-tm} representing the same time in human
readable form; if an error occurs raise an exception.
@end defun


@defun gmtime @var{time}
Interface to the C function @cfunc{gmtime}, @glibcref{Broken-down Time,
gmtime}.  Given an exact integer @var{time} representing the @utc{} time
as returned by the @func{time} function: build and return an instance of
@code{struct-tm} representing the same time in human readable form; if
an error occurs raise an exception.
@end defun


@defun timelocal @var{tm}
Interface to the C function @cfunc{timelocal}, @glibcref{Broken-down
Time, timelocal}.  Given a reference to a @code{struct-rm}, @var{tm},
representing a local broken time, convert it into a time value as
returned by @cfunc{time}.  If successful return an exact integer
representing the time value, else raise an exception.
@end defun


@defun timegm @var{tm}
Interface to the C function @cfunc{timegm}, @glibcref{Broken-down Time,
timegm}.  Given a reference to a @code{struct-rm}, @var{tm},
representing a @utc{} broken time, convert it into a time value as
returned by @cfunc{time}.  If successful return an exact integer
representing the time value, else raise an exception.
@end defun


@defun strftime @var{template} @var{tm}
@defunx strftime/string @var{template} @var{tm}
Interface to the C function @cfunc{strftime}, @glibcref{Formatting
Calendar Time, strftime}.  Given a bytevector @var{template} holding an
@ascii{} coded format string and a @code{struct-tm} instance @var{tm}:
build a formatted time string; the resulting time string can be at most
@math{4096} bytes wide.  If successful @func{strftime} returns a
bytevector holding the time string in @ascii{} coding and
@func{strftime/string} returns a Scheme string, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun nanosleep @var{secs} @var{nsecs}
Interface to the C function @cfunc{nanosleep}, @glibcref{Sleeping,
nanosleep}.  Halt the current process for the specified amount of time.

The count of seconds @var{secs} must be an exact integer in the range
@math{[0, 2^32)}; the count of nanoseconds @var{nsecs} must be an exact
integer in the range @math{[0, 999999999]}.

If successful and the requested time is elapsed: return a pair whose car
is false and whose cdr is false.  If successful and the sleeping was
interrupted by an interprocess signal: return a pair whose car is an
exact integer representing the count of remaining seconds and whose cdr
is an exact integer representing the count of remaining nanoseconds.  If
an error occurs an exception is raised.
@end defun

@c ------------------------------------------------------------

@defun setitimer @var{which} @var{itimerval}
Interface to the C function @cfunc{setitimer}, @glibcref{Setting an
Alarm, setitimer}.  Set the timer specified by @var{which} according to
@var{itimerval}.  If successful return unspecified values, else raise an
exception.

@var{which} must be a fixnum representing one of the constants:
@code{ITIMER_REAL}, @code{ITIMER_VIRTUAL}, @code{ITIMER_PROF}.

@var{itimerval} must be an instance of @code{struct-itimerval}.
@end defun


@defun getitimer @var{which}
Interface to the C function @cfunc{getitimer}, @glibcref{Setting an
Alarm, getitimer}.  Build and return a new @code{struct-itimerval}
representing the current timer.
@end defun


@defun alarm @var{seconds}
Interface to the C function @cfunc{alarm}, @glibcref{Setting an Alarm,
alarm}.  Set the real--time timer to expire in @var{seconds}.  Return an
exact integer representing how many seconds remain before the previous
alarm would have been sent.
@end defun

@c ------------------------------------------------------------

The following are the real--time clock functions.  They are available
when @value{PRJNAME} is linked with the @code{rt} library.

@quotation
@strong{NOTE} On @gnu{}+Linux systems the argument @var{clock-id} to the
@code{clock-*} functions can be one among:

@example
CLOCK_REALTIME
CLOCK_MONOTONIC                 CLOCK_MONOTONIC_RAW
CLOCK_PROCESS_CPUTIME_ID        CLOCK_THREAD_CPUTIME_ID
@end example

@noindent
or a value returned by @func{clock-getcpuclockid}.  The code assumes
that clock identifiers of type @code{clockid_t} can be safely converted
to C language @code{long} values.
@end quotation


@defun clock-getres @var{clock-id} @var{time}
Interface to the C function @cfunc{clock-getres}, see the manual page
@code{clock-getres(2)}.  Find the resolution of the clock selected by
the fixnum @var{clock-id} and store it in @var{time}, which must be an
instance of @code{struct-timespec}.  If successful return @var{time}
itself, else raise an exception.
@end defun


@defun clock-gettime @var{clock-id} @var{time}
Interface to the C function @cfunc{clock-gettime}, see the manual page
@code{clock-gettime(2)}.  Retrieve the time of the clock selected by the
fixnum @var{clock-id} and store it in @var{time}, which must be an
instance of @code{struct-timespec}.  If successful return @var{time}
itself, else raise an exception.
@end defun


@defun clock-settime @var{clock-id} @var{time}
Interface to the C function @cfunc{clock-settime}, see the manual page
@code{clock-settime(2)}.  Set the time of the clock selected by the
fixnum @var{clock-id} acquiring it from @var{time}, which must be an
instance of @code{struct-timespec}.  If successful return @var{time}
itself, else raise an exception.
@end defun


@defun clock-getcpuclockid @var{pid}
Interface to the C function @cfunc{clock_getcpuclockid}, see the manual
page @code{clock_getcpuclockid(3)}.  Obtain the identifier of a process'
@acronym{CPU}--time clock; if successful return an exact integer
representing the clock identifier, else raise an exception.  @var{pid}
must be a fixnum representing the process identifier (@acronym{PID}).
@end defun

@c page
@node posix timers
@section @posix{} per--process timers


@cindex @posix{} timers
@cindex @posix{} per--process timers
@cindex Timer, @posix{} per--process timers
@cindex Per--process timers


The @posix{} timer @api{} allows the creation of per--process timers
triggering time--periodic events by specification of two time intervals:

@enumerate
@item
Initial expiration: how much time before the first event.

@item
Period: how much time between two time--adjacent events.  When the
period is zero: only one event notification is delivered.
@end enumerate

@example
    time before the
    first event       period      period      period
   |               |           |           |           |
---+---------------+-----------+-----------+-----------+----
   ^               ^           ^           ^           ^
  now          1st event   2nd event   3rd event   4th event
@end example

Each timer can be started, stopped, reconfigured and queried for how
much time until the next event.


@defun timer-create @var{clock-id}
Interface to the C function @cfunc{timer_create}, see the manual page
@code{timer_create(2)}.  Create a new per--process interval timer,
initially disarmed; if successful return an exact integer representing
the timer identifier, else raise an exception.

@var{clock-id} must be an exact integer representing the identifier of a
clock to be used to measure time; it can be one of the constants:

@example
CLOCK_REALTIME                  CLOCK_MONOTONIC
CLOCK_PROCESS_CPUTIME_ID        CLOCK_THREAD_CPUTIME_ID
@end example

@noindent
or the return value of @func{clock-getcpuclockid}.

The call sets up the notification as with a C language @code{struct
sigevent} having: @code{sigev_notify} set to @code{SIGEV_SIGNAL},
@code{sigev_signo} set to @code{SIGALRM}, @code{sigev.sival_int} set to
the timer identifier.  This means the timer expirations are notified to
the process by delivering @code{SIGALRM} signals.

@quotation
@strong{NOTE} On @gnu{}+Linux systems: for details on @code{struct
sigevent} see the manual page @code{sigevent(7)}.
@end quotation
@end defun


@defun timer-delete @var{timer-id}
Interface to the C function @cfunc{timer_delete}, see the manual page
@code{timer_delete(2)}.  Delete the timer referenced by @var{timer-id};
if successful return unspecified values, else raise an exception.
@end defun


@defun timer-settime @var{timer-id} @var{flags} @var{new}
@defunx timer-settime @var{timer-id} @var{flags} @var{new} @var{old}
Interface to the C function @cfunc{timer_settime}, see the manual page
@code{timer_settime(2)}.  Arm or disarm the timer referenced by
@var{timer-id}.  If successful return @var{old} or @false{} when
@var{old} is not given; if an error occurs raise an exception.

@var{flags} can be either the fixnum zero or @code{TIMER_ABSTIME}.
@var{new} must be a valid instance of @code{struct-itimerspec}, which is
used to set the timer.  The optional @var{old} can be @false{} or a
valid instance of @code{struct-itimerspec}; when given: it is filled
with the old timer specification.
@end defun


@defun timer-gettime @var{timer-id}
@defunx timer-gettime @var{timer-id} @var{curr}
Interface to the C function @cfunc{timer_gettime}, see the manual page
@code{timer_gettime(2)}.  Retrieve the current timer specification
associated to the timer identifier @var{timer-id}.  If successful return
@var{curr} or a newly built instance of @code{struct-itimerspec}; if an
error occurs: raise an exception.

The optional @var{curr} must be a valid instance of
@code{struct-itimerspec}, when not given a new instance of this
structure type is internally built: it is filled with the current timer
specification.
@end defun


@defun timer-getoverrun @var{timer-id}
Interface to the C function @cfunc{timer_getoverrun}, see the manual
page @code{timer_getoverrun(2)}.  Get overrun count for the timer
referenced by @var{timer-id}; if successful return a non--negative exact
integer representing the overrun count of the specified timer, else
raise an exception.
@end defun


In the following example program:

@enumerate
@item
We use the @bub{} @api{} to block all the signals, so including
@code{SIGALRM}.

@item
Then we create a @posix{} timer whose expirations are notified by
delivering @code{SIGALRM} signals.

@item
Then we use @func{sigtimedwait} to count the expirations.
@end enumerate

Note very well that to recognise that a @code{SIGALRM} signal is
delivered by the expiration of the timer, we have to check the
@code{si_value.sival_int} field of the @code{struct-siginfo_t},
@strong{not} the @code{si_timerid} field.

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants)
  (vicare syntactic-extensions))

(px.signal-bub-init)

(define timer-id
  (px.timer-create CLOCK_REALTIME))
(px.timer-settime timer-id 0
      (px.make-struct-itimerspec
         ;;one event every 1 seconds
         (px.make-struct-timespec 1 0)
         ;;the first event after 1 nanosecond
         (px.make-struct-timespec 0 1)))

(unwind-protect
    (let next ((count 0))
      (if (fx= count 3)
          count
        (let-values
            (((signo info)
              (px.sigtimedwait SIGALRM
                 (px.make-struct-timespec 2 0))))
          (define was-sigalrm?
            (= signo SIGALRM))
          (define right-timer?
            (= timer-id
               (px.struct-siginfo_t-si_value.sival_int info)))
          (next (if (and was-sigalrm? right-timer?)
                    (+ 1 count)
                  count)))))
  (px.timer-delete timer-id)
  (px.signal-bub-final))
@result{} 3
@end example

@c page
@node posix config
@section System configuration


The following bindings are exported by the @library{vicare posix}
library.  If an error occurs: all the following functions raise an
exception with condition components @condition{errno},
@condition{error}, @condition{who}, @condition{message},
@condition{irritants}.


@defun sysconf @var{parameter}
Interface to the C function @cfunc{sysconf}, @glibcref{Sysconf
Definition, sysconf}.  Query the system for a configuration value
selected by the exact integer @var{parameter} among the @code{_SC_}
constants.  If successful and a value is available: return a positive
exact integer; if successful but no value is available return false; if
@var{parameter} is invalid raise an exception.

@strong{NOTE} This function assumes that all the validly returnable
values are non--negative.  If a value is negative, the behaviour is
unspecified.
@end defun


@defun pathconf @var{pathname} @var{parameter}
Interface to the C function @cfunc{pathconf}, @glibcref{Pathconf,
pathconf}.  Query the system for a configuration value associated to the
file @var{pathname} selected by the exact integer @var{parameter} among
the @code{_PC_} constants.

@var{pathname} must be a string or bytevector; if it is a string: it is
converted to bytevector with the function referenced by
@func{string->filename-func}.

If successful and a value is available: return a positive exact integer;
if successful but no value is available return false; if @var{parameter}
is invalid raise an exception.

@strong{NOTE} This function assumes that all the validly returnable
values are non--negative.  If a value is negative, the behaviour is
unspecified.
@end defun


@defun fpathconf @var{fd} @var{parameter}
Interface to the C function @cfunc{fpathconf}, @glibcref{Pathconf,
fpathconf}.  Query the system for a configuration value associated to
the file descriptor @var{fd} selected by the exact integer
@var{parameter} among the @code{_PC_} constants.

If successful and a value is available: return a positive exact integer;
if successful but no value is available return false; if @var{parameter}
is invalid raise an exception.

@strong{NOTE} This function assumes that all the validly returnable
values are non--negative.  If a value is negative, the behaviour is
unspecified.
@end defun


@defun confstr @var{parameter}
@defunx confstr/string @var{parameter}
Interface to the C function @cfunc{confstr}, @glibcref{String
Parameters, confstr}.  Query the system for a configuration value
selected by the exact integer @var{parameter} among the @code{_CS_}
constants.  If successful @func{confstr} returns a bytevector
representing the value, @func{confstr/string} returns a string
representing the value; else an exception is raised.

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(px.confstr/string _CS_PATH)
@result{} "/bin:/usr/bin"
@end example
@end defun

@c page
@node posix resources
@section Resources usage


@menu
* posix resources rlimit::      Data structure @code{struct-rlimit}.
* posix resources rusage::      Data structure @code{struct-rusage}.
* posix resources funcs::       System resources functions.
@end menu

@c page
@node posix resources rlimit
@subsection Data structure @code{struct-rlimit}


@deftp {Struct Type} struct-rlimit
Scheme level representation of the C language type @code{struct rlimit},
@glibcref{Limits on Resources, struct rlimit}.  Hold the soft and hard
limits of a resource.

@table @code
@item rlim_cur
An exact integer representing the soft limit.

@item rlim_max
An exact integer representing the hard limit.
@end table
@end deftp


@defun make-struct-rlimit
@defunx make-struct-rlimit @var{cur} @var{max}
Build and return a new instance of @code{struct-rlimit}.  When no
arguments are given: the fields are initialised with the fixnum zero.
@end defun


@defun struct-rlimit? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-rlimit}.
@end defun


@defun struct-rlimit-rlim_cur @var{rlim}
@defunx struct-rlimit-rlim_max @var{rlim}
Accessors for the fields of @code{struct-rlimit}.
@end defun


@defun set-struct-rlimit-rlim_cur! @var{rlim} @var{value}
@defunx set-struct-rlimit-rlim_max! @var{rlim} @var{value}
Mutators for the fields of @code{struct-rlimit}.
@end defun

@c page
@node posix resources rusage
@subsection Data structure @code{struct-rusage}


@deftp {Struct Type} struct-rusage
Scheme level representation of the C language type @code{struct rusage},
@glibcref{Resource Usage, struct rusage}.  It has the following fields:

@table @code
@item ru_utime
An instance of @code{struct-timeval}.

@item ru_stime
An instance of @code{struct-timeval}.

@item ru_maxrss
An exact integer in the range of the C language type @code{long int}.

@item ru_ixrss
An exact integer in the range of the C language type @code{long int}.

@item ru_idrss
An exact integer in the range of the C language type @code{long int}.

@item ru_isrss
An exact integer in the range of the C language type @code{long int}.

@item ru_minflt
An exact integer in the range of the C language type @code{long int}.

@item ru_majflt
An exact integer in the range of the C language type @code{long int}.

@item ru_nswap
An exact integer in the range of the C language type @code{long int}.

@item ru_inblock
An exact integer in the range of the C language type @code{long int}.

@item ru_oublock
An exact integer in the range of the C language type @code{long int}.

@item ru_msgsnd
An exact integer in the range of the C language type @code{long int}.

@item ru_msgrcv
An exact integer in the range of the C language type @code{long int}.

@item ru_nsignals
An exact integer in the range of the C language type @code{long int}.

@item ru_nvcsw
An exact integer in the range of the C language type @code{long int}.

@item ru_nivcsw
An exact integer in the range of the C language type @code{long int}.
@end table

Notice some of the fields may be meaningless on some platforms, in which
case they are set to @false{}.
@end deftp


@defun make-struct-rusage
@defunx make-struct-rusage
Build and return a new instance of @code{struct-rusage}.  When no
arguments are given: the fields @code{ru_utime} and @code{ru_stime} are
set to instance of @code{struct-timeval} with fields set to zero, all
the other fields are set to @false{}.
@end defun


@defun struct-rusage? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-rusage}.
@end defun


@defun struct-rusage-ru_utime @var{rusage}
@defunx struct-rusage-ru_stime @var{rusage}
@defunx struct-rusage-ru_maxrss @var{rusage}
@defunx struct-rusage-ru_ixrss @var{rusage}
@defunx struct-rusage-ru_idrss @var{rusage}
@defunx struct-rusage-ru_isrss @var{rusage}
@defunx struct-rusage-ru_minflt @var{rusage}
@defunx struct-rusage-ru_majflt @var{rusage}
@defunx struct-rusage-ru_nswap @var{rusage}
@defunx struct-rusage-ru_inblock @var{rusage}
@defunx struct-rusage-ru_oublock @var{rusage}
@defunx struct-rusage-ru_msgsnd @var{rusage}
@defunx struct-rusage-ru_msgrcv @var{rusage}
@defunx struct-rusage-ru_nsignals @var{rusage}
@defunx struct-rusage-ru_nvcsw @var{rusage}
@defunx struct-rusage-ru_nivcsw @var{rusage}
Accessors for the fields of @code{struct-rusage}.
@end defun


@defun set-struct-rusage-ru_utime! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_stime! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_maxrss! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_ixrss! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_idrss! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_isrss! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_minflt! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_majflt! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_nswap! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_inblock! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_oublock! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_msgsnd! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_msgrcv! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_nsignals! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_nvcsw! @var{rusage} @var{value}
@defunx set-struct-rusage-ru_nivcsw! @var{rusage} @var{value}
Mutators for the fields of @code{struct-rusage}.
@end defun

@c page
@node posix resources funcs
@subsection System resources functions


@deffn {Identifier Syntax} RLIM_INFINITY
The value of the corresponding @posix{} constant.  If the constant is
defined: this identifier expands to an unsigned integer, else it expands
to @false{}.
@end deffn


@defun getrlimit @var{resource}
@defunx getrlimit @var{resource} @var{rlimit}
Interface to the C function @cfunc{getrlimit}, @glibcref{Limits on
Resources, getrlimit}.  Retrieve the soft and hard limits of a system
resource; if successful return @var{rlimit}, else raise an exception.

@var{resource} must be an exact integer representing the value of a
@code{RLIMIT_} constant.

The optional @var{rlimit} must be an instance of @code{struct-rlimit}:
it is filled with the requested values and returned; when not given: a
new instance is allocated, filled and returned.

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(px.getrlimit RLIMIT_STACK)
@result{} #["struct-rlimit" rlim_cur=8388608 rlim_max=4294967295]
@end example
@end defun


@defun setrlimit @var{resource} @var{rlimit}
Interface to the C function @cfunc{setrlimit}, @glibcref{Limits on
Resources, setrlimit}.  Set the soft and hard limits of a system
resource; if successful return unspecified values, else raise an
exception.

@var{resource} must be an exact integer representing the value of a
@code{RLIMIT_} constant.  @var{rlimit} must be an instance of
@code{struct-rlimit} filled with the selected values.
@end defun


@defun getrusage @var{processes}
@defunx getrusage @var{processes} @var{rusage}
Interface to the C function @cfunc{getrusage}, @glibcref{Resource Usage,
getrusage}.  Reports resource usage totals for processes specified by
@var{processes}; if successful return @var{rusage}, else raise an
exception.

@var{processes} must be an exact integer in the range of the C language
type @code{int}; it should be one of the @code{RUSAGE_} platform
constants.

The optional @var{rusage} must be an instance of @code{struct-rusage}
and it is filled with the usage values; when not given: a new instance
of @code{struct-rusage} is internally allocated, filled and returned.
@end defun

@c page
@node posix mq
@section Message queues


@posix{} message queues allow processes to exchange messages composed of
arrays of bytes.

@quotation
@strong{NOTE} On @gnu{}+Linux systems, for an introduction to the @api{}
we must refer to the manual page @code{mq_overview(7)}.
@end quotation

@menu
* posix mq attr::               Structure type @code{struct-mq-attr}.
* posix mq api::                Message queues @api{}.
* posix mq examples::           Simple examples of message queues usage.
@end menu

@c page
@node posix mq attr
@subsection Structure type @code{struct-mq-attr}


The following bindings are exported by the @library{vicare posix}
library.


@deftp {Struct Type} struct-mq-attr
Data structure type used to represent at the Scheme level @code{struct
mq_attr} values, see the manual page @code{mq_getattr(3)}.  It has the
following fields:

@table @code
@item mq_flags
The fixnum zero or the constant @code{O_NONBLOCK}.

@item mq_maxmsg
Maximum number of messages on the queue.

@item mq_msgsize
Maximum message size in bytes.

@item mq_curmsgs
Number of messages currently on the queue.
@end table
@end deftp


@defun make-struct-mq-attr @var{flags} @var{maxmsg} @var{msgsize} @var{curmsgs}
Build and return a new instance of @code{struct-mq-attr}.
@end defun


@defun struct-mq-attr? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-mq-attr} and
its field values are valid, return @false{} otherwise.
@end defun


@defun struct-mq-attr-mq_flags @var{attr}
@defunx struct-mq-attr-mq_maxmsg @var{attr}
@defunx struct-mq-attr-mq_msgsize @var{attr}
@defunx struct-mq-attr-mq_curmsgs @var{attr}
Accessors for the fields of @code{struct-mq-attr}.
@end defun


@defun set-struct-mq-attr-mq_flags! @var{attr} @var{value}
@defunx set-struct-mq-attr-mq_maxmsg! @var{attr} @var{value}
@defunx set-struct-mq-attr-mq_msgsize! @var{attr} @var{value}
@defunx set-struct-mq-attr-mq_curmsgs! @var{attr} @var{value}
Mutators for the fields of @code{struct-mq-attr}.
@end defun

@c page
@node posix mq api
@subsection Message queues @api{}.


The following bindings are exported by the @library{vicare posix}
library.  On @gnu{}+Linux systems, for an introduction to the @api{} we
must refer to the manual page @code{mq_overview(7)} and for the full
documentation of each function we must refer to the manual pages.
Notice that @code{mq_notify(3)} at present is not interfaced.

@quotation
@strong{NOTE} The code implementing the interface to @posix{} message
queues assumes that the descriptor @code{mqd_t} is a fixnum.  On
@gnu{}+Linux systems this value is known to be a file descriptor.
@end quotation


@defun mq-open @var{name} @var{oflag} @var{mode}
@defunx mq-open @var{name} @var{oflag} @var{mode} @var{attr}
Interface to the C function @cfunc{mq_open}, see the manual page
@code{mq_open(3)}.  Create a new message queue or open an existing one.
If successful return a message queue descriptor, else raise an
exception.

@var{name} must be a Scheme string or bytevector holding a pathname in
@ascii{} encoding.

@var{oflag} must be a fixnum representing the inclusive OR composition
of some of the following flags:

@example
O_RDONLY    O_WRONLY  O_RDWR
O_NONBLOCK  O_CREAT   O_EXCL
@end example

@var{mode} must be a fixnum representing access permissions for the
message queue pathname; it should be an inclusive OR composition of some
of the flags:

@example
S_IRUSR   S_IWUSR   S_IXUSR
S_IRGRP   S_IWGRP   S_IXGRP
S_IROTH   S_IWOTH   S_IXOTH
@end example

The optional @var{attr} must be false or an instance of
@code{struct-mq-attr}; when false or not given: the queue is created
with platform--dependent default attributes.  The fields @code{mq_flags}
and @code{mq_curmsgs} are ignored in call to this function.
@end defun


@defun mq-close @var{mqd}
Interface to the C function @cfunc{mq_close}, see the manual page
@code{mq_close(3)}.  Close the message queue referenced by the
descriptor @var{mqd}, which must be a descriptor returned by a previous
call to @func{mq-open}; notice that the message queue will still exist
until it is deleted with @cfunc{mq_unlink}.  If successful return
unspecified values, else raise an exception.
@end defun


@defun mq-unlink @var{name}
Interface to the C function @cfunc{mq_unlink}, see the manual page
@code{mq_unlink(3)}.  Remove the message queue whose name is @var{name},
which must be a Scheme string or bytevector representing a pathname in
ASCII encoding; the message queue name is removed immediately, while the
message queue is removed when all the processes referencing it close
their descriptors.  If successful return unspecified values, else raise
an exception.
@end defun


@defun mq-send @var{mqd} @var{message} @var{priority}
Interface to the C function @cfunc{mq_send}, see the manual page
@code{mq_send(3)}.  Add a message to the queue referenced by the
descriptor @var{mqd}, which must be a descriptor returned by a previous
call to @func{mq-open}.  If successful return unspecified values, else
raise an exception.

@var{message} must be a Scheme bytevector representing the message data.
@var{priority} must be an exact integer, in the range of the C language
type @code{unsigned int}, representing the priority of the message.
@end defun


@defun mq-timedsend @var{mqd} @var{message} @var{priority} @var{epoch-timeout}
Interface to the C function @cfunc{mq_timedsend}, see the manual page
@code{mq_timedsend(3)}.  Add a message to the queue referenced by the
descriptor @var{mqd}, which must be a descriptor returned by a previous
call to @func{mq-open}.  If successful return unspecified values, else
raise an exception.

@var{message} must be a Scheme bytevector representing the message data.

@var{priority} must be an exact integer, in the range of the C language
type @code{unsigned int}, representing the priority of the message.

@var{epoch-timeout} must be an instance of @code{struct-timespec}
representing an absolute time since the Epoch: if the queue is in
blocking mode, a call to this function will block until the timeout
expires waiting to deliver the message.  @ref{posix time timespec,
struct-timespec}
@end defun


@defun mq-receive @var{mqd} @var{message}
Interface to the C function @cfunc{mq_receive}, see the manual page
@code{mq_receive(3)}.  Remove the oldest message with the highest
priority from the message queue referenced by @var{mqd}, which must be a
descriptor returned by a previous call to @func{mq-open}.  If successful
return two values: an exact integer representing the number of bytes in
the message, a non--negative exact integer representing the priority of
the message; else raise an exception.

@var{message} must be a Scheme bytevector providing the buffer in which
the function will write the received message; its length must be greater
than the maximum message length specified in the queue attributes.
@end defun


@defun mq-timedreceive @var{mqd} @var{message} @var{epoch-timeout}
Interface to the C function @cfunc{mq_timedreceive}, see the manual page
@code{mq_timedreceive(3)}.  Remove the oldest message with the highest
priority from the message queue referenced by @var{mqd}, which must be a
descriptor returned by a previous call to @func{mq-open}.  If successful
return two values: an exact integer representing the number of bytes in
the message, a non--negative exact integer representing the priority of
the message; else raise an exception.

@var{message} must be a Scheme bytevector providing the buffer in which
the function will write the received message; its length must be greater
than the maximum message length specified in the queue attributes.

@var{epoch-timeout} must be an instance of @code{struct-timespec}
representing an absolute time since the Epoch: if the queue is in
blocking mode, a call to this function will block until the timeout
expires waiting to receive the message.  @ref{posix time timespec,
struct-timespec}
@end defun


@defun mq-setattr @var{mqd} @var{new-attr}
@defunx mq-setattr @var{mqd} @var{new-attr} @var{old-attr}
Interface to the C function @cfunc{mq_setattr}, see the manual page
@code{mq_setattr(3)}.  Modify the attributes of the message queue
referenced by @var{mqd}, which must be a descriptor returned by a
previous call to @func{mq-open}.  If successful return an instance of
@code{struct-mq-attr} representing the old attributes, else raise an
exception.

The new values are read from @var{new-attr}, which must be an instance
of @code{struct-mq-attr}.  On @gnu{}+Linux: the only attribute that can
be modified is @code{mq_flags}, all the other values are ignored (last
verified on Jul 7, 2012).

The old values are stored in @var{old-attr}, which must be an instance
of @code{struct-mq-attr}; when @var{old-attr} is not given: a new
instance of @code{struct-mq-attr} is internally created.  @var{old-attr}
or the new instance are the return value of this function.
@end defun


@defun mq-getattr @var{mqd}
@defunx mq-getattr @var{mqd} @var{attr}
Interface to the C function @cfunc{mq_getattr}, see the manual page
@code{mq_getattr(3)}.  Retrieve the attributes of the message queue
referenced by @var{mqd}, which must be a descriptor returned by a
previous call to @func{mq-open}.  If successful return an instance of
@code{struct-mq-attr} representing the old attributes, else raise an
exception.

The values are stored in @var{attr}, which must be an instance of
@code{struct-mq-attr}; when @var{attr} is not given: a new instance of
@code{struct-mq-attr} is internally created.  @var{attr} or the new
instance are the return value of this function.
@end defun


@ignore
@defun mq-notify
Interface to the C function @cfunc{mq_notify}.
@end defun
@end ignore

@c page
@node posix mq examples
@subsection Simple examples of message queues usage


The following example shows how to create and close a message queue and
how to send and receive a message:

@example
#!vicare
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants)
  (vicare syntactic-extensions))

(define name "/vicare-test")

(define (parent child-pid)
  ;; Create a message queue and block until a message
  ;; is received from the child.
  ;;
  (let ((mqd (px.mq-open name
                         (bitwise-ior O_CREAT O_EXCL O_RDWR)
                         (bitwise-ior S_IRUSR S_IWUSR)
                         (px.make-struct-mq-attr 0 3 16 0)))
        (buf (make-bytevector 16)))
    (unwind-protect
        (let-values (((len priority)
                      (px.mq-receive mqd buf)))
          (px.waitpid child-pid 0)
          (list (subbytevector-u8 buf 0 len)
                priority))
      (px.mq-close mqd)
      (px.mq-unlink name))))

(define (child)
  ;; Wait for the parent to create the queue, then
  ;; send a message and exit.
  ;;
  (px.nanosleep 0 900000)
  (let ((mqd (px.mq-open name O_RDWR
                         (bitwise-ior S_IRUSR S_IWUSR)
                         (px.make-struct-mq-attr 0 3 16 0))))
    (unwind-protect
        (px.mq-send mqd '#ve(ascii "ciao") 1)
      (px.mq-close mqd)))
  (exit 0))

(px.fork parent child)
@end example

The following example shows how to create and close a message queue and
how to send and receive a message with timeout:

@example
#!vicare
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants)
  (vicare syntactic-extensions))

(define name "/vicare-test")

(define timeout
  (let ((T (px.clock-gettime CLOCK_REALTIME
              (px.make-struct-timespec 0 0))))
    (px.set-struct-timespec-tv_sec! T
       (+ 5 (px.struct-timespec-tv_sec T)))
    T))

(define (parent child-pid)
  ;; Create a message queue and block with timeout
  ;; until a message is received from the child.
  ;;
  (let ((mqd (px.mq-open name
                         (bitwise-ior O_CREAT O_EXCL O_RDWR)
                         (bitwise-ior S_IRUSR S_IWUSR)
                         (px.make-struct-mq-attr 0 3 16 0)))
        (buf (make-bytevector 16)))
    (unwind-protect
        (let-values (((len priority)
                      (px.mq-timedreceive mqd buf timeout)))
          (px.waitpid child-pid 0)
          (list (subbytevector-u8 buf 0 len)
                priority))
      (px.mq-close mqd)
      (px.mq-unlink name))))

(define (child)
  ;; Wait for the parent to create the queue, then
  ;; send a message with timeout and exit.
  ;;
  (px.nanosleep 0 900000)
  (let ((mqd (px.mq-open name
                         O_RDWR
                         (bitwise-ior S_IRUSR S_IWUSR)
                         (px.make-struct-mq-attr 0 3 16 0))))
    (unwind-protect
        (px.mq-timedsend mqd '#ve(ascii "ciao") 1 timeout)
      (px.mq-close mqd)))
  (exit 0))

(px.fork parent child)
@end example

@c page
@node posix shm
@section Shared memory


The @posix{} shared memory @api{} allow processes to communicate
informations by sharing a region of memory.

@quotation
@strong{NOTE} On @gnu{}+Linux systems, for an introduction to the @api{}
we must refer to the manual page @code{shm_overview(7)}.
@end quotation


@defun shm-open @var{name} @var{oflag} @var{mode}
Interface to the C function @cfunc{shm_open}, see the manual page
@code{shm_open(3)}.  Open, and optionally create, a shared memory object
and return a file descriptor referencing it.  If successful return a
fixnum representing the file descriptor, else raise an exception.

@var{name} must be the pathname representing the shared memory object.
@var{oflag} must be the bitwise inclusive OR combination of some of the
following values:

@example
O_RDONLY                O_RDWR
O_CREAT                 O_EXCL
O_TRUNC
@end example

@noindent
@var{mode} must be the bitwise inclusive OR combination of some of the
following values:

@example
S_IRUSR   S_IWUSR   S_IXUSR
S_IRGRP   S_IWGRP   S_IXGRP
S_IROTH   S_IWOTH   S_IXOTH
@end example
@end defun


@defun shm-unlink @var{name}
Interface to the C function @cfunc{shm_unlink}, see the manual page
@code{shm_unlink(3)}.  Remove the shared memory object selected by the
pathname @var{name}.  If successful return unspecified values, else
raise an exception.
@end defun


The following example shows how two processes can exchange a signed
integer; notice how the only information shared at the beginning is the
pathname of the shared memory object and the dimension of the mapped
memory.  Also notice that the correct way of synchronising two processes
for shared memory access is with @posix{} semaphores, @ref{posix sem}
for details.

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants)
  (only (vicare syntactic-extensions)
        unwind-protect
        callet)

(define shm.pathname
  "/vicare-posix-shm.test")
(define shm.dim
  (px.sysconf _SC_PAGESIZE))

(define (parent child-pid)
  (let ((shm.fd (callet px.shm-open shm.pathname
                        (oflags (fxior O_CREAT O_RDWR))
                        (mode   (fxior S_IRUSR S_IWUSR)))))
    (px.ftruncate shm.fd shm.dim)
    (unwind-protect
        (unwind-protect
            (let ((shm.base (callet px.mmap
                              (address #f)
                              (size    shm.dim)
                              (prot    (fxior PROT_READ
                                              PROT_WRITE))
                              (flags   MAP_SHARED)
                              (fd      shm.fd)
                              (offset  0))))
              (unwind-protect
                  (begin
                    (px.waitpid child-pid 0)
                    (pointer-ref-c-signed-int shm.base 0))
                (px.munmap shm.base shm.dim)))
          (px.close shm.fd))
      (px.shm-unlink shm.pathname))))

(define (child)
  ;; Give the parent some time to create and open the
  ;; shared memory object.
  (px.nanosleep 1 0)
  (let ((shm.fd (callet px.shm-open shm.pathname
                        (oflags (fxior O_CREAT O_RDWR))
                        (mode   (fxior S_IRUSR S_IWUSR)))))
    (unwind-protect
        (let ((shm.base (callet px.mmap
                          (address #f)
                          (size    shm.dim)
                          (prot    (fxior PROT_READ
                                          PROT_WRITE))
                          (flags   MAP_SHARED)
                          (fd      shm.fd)
                          (offset  0))))
          (unwind-protect
              (pointer-set-c-signed-int! shm.base 0 123)
            (px.munmap shm.base shm.dim)))
      (px.close shm.fd)))
  (exit 0))

(px.fork parent child)
@result{} 123
@end example

@c page
@node posix sem
@section @posix{} semaphores


The @posix{} semaphores @api{} allow processes to synchronise their
actions.

@quotation
@strong{NOTE} On @gnu{}+Linux systems, for an introduction to the @api{}
we must refer to the manual page @code{sem_overview(7)}.
@end quotation

@menu
* posix sem api::               Semaphores interface.
* posix sem examples::          Usage examples of semaphores.
@end menu

@c page
@node posix sem api
@subsection Semaphores interface


@defun sem-open @var{name} @var{oflag} @var{mode}
@defunx sem-open @var{name} @var{oflag} @var{mode} @var{value}
Interface to the C function @cfunc{sem_open}, see the manual page
@code{sem_open(3)}.  Initialise and open a named semaphore using the
pathname @var{name}.  If successful return a pointer object referencing
the semaphore, else raise an exception.

@var{oflag} must be a fixnum representing a bitwise inclusive OR
combination of some of the following values: @code{O_CREAT},
@code{O_EXCL}, @code{O_RDWR}.

@var{mode} must be a fixnum representing a bitwise inclusive OR
combination of some of the following values:

@example
S_IRUSR   S_IWUSR   S_IXUSR
S_IRGRP   S_IWGRP   S_IXGRP
S_IROTH   S_IWOTH   S_IXOTH
@end example

The optional @var{value} must be a exact integer in the range of the C
language type @code{unsigned int}; when not given it defaults to zero.

Named semaphores must be closed with @func{sem-close} and removed with
@func{sem-unlink}.
@end defun


@defun sem-close @var{sem}
Interface to the C function @cfunc{sem_close}, see the manual page
@code{sem_close(3)}.  Close the named semaphore referenced by @var{sem},
which must be a pointer object; note that the semaphore will continue to
exist until @func{sem-unlink} is called.  If successful return
unspecified values, else raise an exception.
@end defun


@defun sem-unlink @var{name}
Interface to the C function @cfunc{sem_unlink}, see the manual page
@code{sem_unlink(3)}.  Remove the named semaphore referenced by the
pathname @var{name}; note that the semaphore name is removed
immediately, but the semaphore itself will continue to exist until all
the processes referencing it will call @func{sem-close}.  If successful
return unspecified values, else raise an exception.
@end defun


@defun sizeof-sem_t
Return an exact integer representing the value of the C language
expression @code{sizeof(sem_t)}.  This value is needed to allocate
enough memory for @func{sem-init} to initialise a semaphore structure.
@end defun


@defun sem-init @var{sem} @var{pshared}
@defunx sem-init @var{sem} @var{pshared} @var{value}
Interface to the C function @cfunc{sem_init}, see the manual page
@code{sem_init(3)}.  Initialise an unnamed semaphore; if successful
return @var{sem} itself, else raise an exception.

@var{sem} must be a pointer object referencing a memory region big
enough to hold a C language @code{sem_t} data structure; such memory
region must be allocated in such a way that it can be shared among the
entities interested in accessing the semaphore.

@var{pshared} is interpreted as a boolean value: when false, the
semaphore is meant to be shared among multiple threads in this process;
when true, the semaphore is meant to be shared among multiple processes
resulting from forking the current process.

The optional @var{value} must be an exact integer in the range of the C
language type @code{unsigned int}: it represents the initial value of
the semaphore; when not given: it defaults to zero.

Unnamed semaphores must be finalised with @func{sem-destroy}.
@end defun


@defun sem-destroy @var{sem}
Interface to the C function @cfunc{sem_destroy}, see the manual page
@code{sem_destroy(3)}.  Finalise the unnamed semaphore referenced by
@var{sem}, which must be a pointer object; if successful return
unspecified values, else raise an exception.
@end defun


@defun sem-post @var{sem}
Interface to the C function @cfunc{sem_post}, see the manual page
@code{sem_post(3)}.  Increment (unlock) the unnamed semaphore referenced
by @var{sem}, which must be a pointer object; if successful return
unspecified values, else raise an exception.
@end defun


@defun sem-wait @var{sem}
Interface to the C function @cfunc{sem_wait}, see the manual page
@code{sem_wait(3)}.  Decrement (lock) the unnamed semaphore referenced
by @var{sem}, which must be a pointer object, until the semaphore is
unlocked; if successful return unspecified values, else raise an
exception.
@end defun


@defun sem-trywait @var{sem}
Interface to the C function @cfunc{sem_trywait}, see the manual page
@code{sem_trywait(3)}.  Decrement (lock) the unnamed semaphore
referenced by @var{sem}, which must be a pointer object; if successful
in locking return the boolean @true{}, if the semaphore is already
locked return the boolean @false{}, else raise an exception.
@end defun


@defun sem-timedwait @var{sem} @var{abs-timeout}
Interface to the C function @cfunc{sem_timedwait}, see the manual page
@code{sem_timedwait(3)}.  Attempt to decrement (lock) the unnamed
semaphore referenced by @var{sem}, which must be a pointer object, with
a timeout.  If successful in locking return the boolean @true{}; if the
semaphore is already locked and it is not unlocked before the timeout
expiration: return the boolean @false{}; else raise an exception.

@var{abs-timeout} must be an instance of @code{struct-timespec}
representing the absolute timeout since the Epoch.  @ref{posix time
timespec, struct-timespec}
@end defun


@defun sem-getvalue @var{sem}
Interface to the C function @cfunc{sem_getvalue}, see the manual page
@code{sem_getvalue(3)}.  Retrieve the current value of the semaphore
referenced by @var{sem}, which must be a pointer object; if successful
return an exact integer representing the value, else raise an exception.
@end defun

@c page
@node posix sem examples
@subsection Usage examples of semaphores


The following example shows how two processes can synchronise themselves
to exchange a signed integer using a @posix{} shared memory object and
an unnamed @posix{} semaphore allocated in such an object; the parent
process sets up the shared memory and initialises the semaphore, then it
waits for the semaphore and reads the integer; the child process writes
an integer in the shared memory, then it posts the semaphore.

Notice that the informations the two processes share are:

@enumerate
@item
The pathname of the shared memory object.

@item
The dimension of the allocated shared memory.

@item
The fact that the semaphore is allocated at the beginning of the shared
memory.

@item
The fact that the signed integer exchange area is right after the
semaphore structure in the shared memory.
@end enumerate

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants)
  (only (vicare syntactic-extensions)
        unwind-protect
        callet))

(define shm.pathname
  "/vicare.test")
(define shm.dim
  (px.sysconf _SC_PAGESIZE))

(define (parent child-pid)
  (let ((shm.fd (callet px.shm-open shm.pathname
                  (oflags   (fxior O_CREAT O_EXCL O_RDWR))
                  (mode     (fxior S_IRUSR S_IWUSR)))))
    (px.ftruncate shm.fd shm.dim)
    (unwind-protect
        (let ((shm.base (callet px.mmap
                          (address #f)
                          (size    shm.dim)
                          (prot    (fxior PROT_READ
                                          PROT_WRITE))
                          (flags   MAP_SHARED)
                          (fd      shm.fd)
                          (offset  0))))
          (unwind-protect
              (let* ((sem_t     shm.base)
                     (shm.start (pointer-add shm.base
                                  (px.sizeof-sem_t)))
                     (sem_t     (callet px.sem-init sem_t
                                  (pshared? #t)
                                  (value    0))))
                (define timeout
                  (let ((T (px.clock-gettime CLOCK_REALTIME
                             (px.make-struct-timespec 0 0))))
                    (px.set-struct-timespec-tv_sec! T
                      (+ 2 (px.struct-timespec-tv_sec T)))
                    T))
                (unwind-protect
                    (begin
                      (px.sem-timedwait sem_t timeout)
                      (pointer-ref-c-signed-int shm.start 0))
                  (px.sem-destroy sem_t)))
            (px.munmap shm.base shm.dim)))
      (px.close shm.fd)
      (px.shm-unlink shm.pathname))))

(define (child)
  ;; Give the parent some time to open the
  ;; shared memory object.
  (px.nanosleep 1 0)
  (let ((shm.fd (callet px.shm-open shm.pathname
                  (oflags   (fxior O_CREAT O_RDWR))
                  (mode     (fxior S_IRUSR S_IWUSR)))))
    (unwind-protect
        (let ((shm.base (callet px.mmap
                          (address #f)
                          (size    shm.dim)
                          (prot    (fxior PROT_READ
                                          PROT_WRITE))
                          (flags   MAP_SHARED)
                          (fd      shm.fd)
                          (offset  0))))
          (unwind-protect
              (let* ((sem_t     shm.base)
                     (shm.start (pointer-add shm.base
                                  (px.sizeof-sem_t))))
                (pointer-set-c-signed-int! shm.start 0 123)
                (px.sem-post sem_t))
            (px.munmap shm.base shm.dim)))
      (px.close shm.fd)))
  (exit 0))

(px.fork parent child)  @result{} 123
@end example

The following example shows how two processes can synchronise themselves
to exchange a signed integer using a @posix{} shared memory object and a
named @posix{} semaphore; the parent process sets up the shared memory
and the semaphore, then it waits for the semaphore and reads the
integer; the child process writes an integer in the shared memory, then
it posts the semaphore.

Notice that the informations the two processes share are:

@enumerate
@item
The pathname of the shared memory object.

@item
The pathname of the semaphore object.

@item
The dimension of the allocated shared memory.

@item
The fact that the signed integer exchange area is at the beginning of
the shared memory.
@end enumerate

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants)
  (only (vicare syntactic-extensions)
        unwind-protect
        callet))

(define sem.pathname
  "/vicare-posix-sem.test")
(define shm.pathname
  "/vicare-posix-shm.test")
(define shm.dim
  (px.sysconf _SC_PAGESIZE))

(define (parent child-pid)
  (let ((sem_t  (callet px.sem-open sem.pathname
                  (oflags (fxior O_CREAT O_EXCL O_RDWR))
                  (mode   (fxior S_IRUSR S_IWUSR))))
        (shm.fd (callet px.shm-open shm.pathname
                  (oflags   (fxior O_CREAT O_EXCL O_RDWR))
                  (mode     (fxior S_IRUSR S_IWUSR)))))
    (px.ftruncate shm.fd shm.dim)
    (unwind-protect
        (let ((shm.base (callet px.mmap
                          (address #f)
                          (size    shm.dim)
                          (prot    (fxior PROT_READ
                                          PROT_WRITE))
                          (flags   MAP_SHARED)
                          (fd      shm.fd)
                          (offset  0))))
          (unwind-protect
              (begin
                (px.sem-wait sem_t)
                (pointer-ref-c-signed-int shm.base 0))
            (px.munmap shm.base shm.dim)))
      (px.close shm.fd)
      (px.shm-unlink shm.pathname)
      (px.sem-close sem_t)
      (px.sem-unlink sem.pathname))))

(define (child)
  ;; Give the parent some time to open the
  ;; shared memory object.
  (px.nanosleep 1 0)
  (let ((sem_t  (callet px.sem-open sem.pathname
                  (oflags (fxior O_CREAT O_RDWR))
                  (mode   (fxior S_IRUSR S_IWUSR))))
        (shm.fd (callet px.shm-open shm.pathname
                  (oflags (fxior O_CREAT O_RDWR))
                  (mode   (fxior S_IRUSR S_IWUSR)))))
    (unwind-protect
        (let ((shm.base (callet px.mmap
                          (address #f)
                          (size    shm.dim)
                          (prot    (fxior PROT_READ
                                          PROT_WRITE))
                          (flags   MAP_SHARED)
                          (fd      shm.fd)
                          (offset  0))))
          (unwind-protect
              (begin
                (pointer-set-c-signed-int! shm.base 0 123)
                (px.sem-post sem_t))
            (px.munmap shm.base shm.dim)))
      (px.close shm.fd)
      (px.sem-close sem_t)))
  (exit 0))

(px.fork parent child) @result{} 123
@end example

@c page
@node posix misc
@section Miscellaneous functions


@defun strerror @var{errno}
Return a string describing the @code{errno} code @var{errno}.  Makes use
of the system function @cfunc{strerror}.  If @var{errno} is not a valid
@code{errno} value: return a string telling it.  As special cases
@var{errno} can be also @true{}, meaning ``unknown error'', and
@false{}, meaning ``no error''.

@glibcref{Error Messages, Error Messages}
@end defun


@defun file-descriptor? @var{obj}
Return true if @var{obj} is a non--negative fixnum less than the value
of @code{FD_SETSIZE}.
@end defun

@c page
@node posix not
@section @posix{} functions not interfaced


Not all the functions defined by @posix{} are exposed by @library{vicare
posix}; this section lists some of them along with reasons for not
interface them.  This is not the last word: if good reasons arise to
interface some of the functions, they will.

@table @cfunc
@item popen
@itemx pclose
@findex popen
@findex pclose
There seems to be no real advantage (in a Scheme @api{}) to use these
rather than explicitly call @func{pipe}, @func{fork} and @func{exec}.
@ref{posix fd, pipe} for details.
@end table

@c page
@node glibc
@chapter The @gnu{} C Library interface


The functions described in this chapter are exported by the library
@library{vicare glibc}.  The @api{} attempts to create a one--to--one
Scheme functions mapping towards @gnu{} C Library functions, keeping the
same semantics as much as possible; the platform's own documentation is
relevant at the Scheme level.

@quotation
@strong{NOTE} These bindings are included and installed by default and
they can be excluded at compile time by giving the option
@option{--disable-glibc} to the @command{configure} stript.
@end quotation

All the constants needed to use the interface are available as
identifier syntaxes exported by the @library{vicare platform-constants}
library; if a constant value is not exported file a feature request for
the project.  If a constant is not defined on a platform: its value is
set to @false{}.

On non--@gnu{} C Library platforms we must avoid calling these
functions, else the behaviour is undefined.

@menu
* glibc env::                   Operating system environment
                                variables.
* glibc dir::                   File system directories.
* glibc temp::                  Temporary files and directories.
* glibc sync::                  File system synchronisation.
* glibc socket::                Network sockets.
* glibc math::                  Mathematics.
* glibc random::                Pseudo--random numbers.
* glibc match::                 Pattern matching, globbing and
                                regular expressions.
* glibc word::                  Performing word expansion.
* glibc iconv::                 Generic character set conversion.
@end menu

@c page
@node glibc env
@section Operating system environment variables


The following bindings are exported by the @library{vicare glibc}
library.


@defun clearenv
Interface to the C function @cfunc{clearenv}, @glibcref{Environment
Access, clearenv}.  Remove all the entries from the environment.  Return
unspecified values.
@end defun

@c page
@node glibc dir
@section File system directories


The following bindings are exported by the @library{vicare glibc}
library.


@defun dirfd @var{stream}
Interface to the C function @cfunc{dirfd}, @glibcref{Opening a
Directory, dirfd}.  Acquire a file descriptor associated to
@var{stream}, which must be an instance of @code{directory-stream};
@ref{posix dir} for details.  If successful return a fixnum representing
the file descriptor, else raise an exception.
@end defun

@c page
@node glibc temp
@section Temporary files and directories


The following bindings are exported by the @library{vicare glibc}
library.


@defun mkstemp @var{template}
Interface to the C function @cfunc{mkstemp}, @glibcref{Temporary Files,
mkstemp}.  Create a temporary file, create it and open a file descriptor
for reading and writing.  @var{template} must be a mutable bytevector
holding a template pathname on entering and the actual pathname on
returning.  If successful return a file descriptor, else raise an
exception.
@end defun


@defun mkdtemp @var{template}
Interface to the C function @cfunc{mkdtemp}, @glibcref{Temporary Files,
mkdtemp}.  Create a temporary directory for reading and writing.
@var{template} must be a mutable bytevector holding a template pathname
on entering and the actual pathname on returning.  If successful return
@var{template} itself, else raise an exception.
@end defun

@c page
@node glibc sync
@section File system synchronisation


The following bindings are exported by the @library{vicare glibc}
library.


@defun sync
Interface to the C function @cfunc{sync}, @glibcref{Synchronizing I/O}.
Flush kernel buffer data and meta informations to the file system
devices.  If successful return unspecified values, else raise an
exception.
@end defun


@defun fsync @var{fd}
Interface to the C function @cfunc{fsync}, @glibcref{Synchronizing I/O}.
Flush kernel buffer data and meta informations to the file system device
for the file descriptor @var{fd}.  If successful return unspecified
values, else raise an exception.
@end defun


@defun fdatasync @var{fd}
Interface to the C function @cfunc{fdatasync}, @glibcref{Synchronizing
I/O}.  Flush kernel buffer data to the file system device for the file
descriptor @var{fd}.  If successful return unspecified values, else
raise an exception.
@end defun

@c page
@node glibc socket
@section Network sockets


The following bindings are exported by the @library{vicare glibc}
library.


@defun if-nametoindex @var{name}
Interface to the C function @cfunc{if_nametoindex}, @glibcref{Interface
Naming, if_nametoindex}.  Convert the string @var{name} representing a
network interface to the corresponding internal index.  Return a fixnum
representing the index or false if @var{name} is invalid.

@example
(import (vicare)
  (prefix (vicare glibc) glibc.))

(glibc.if-indextoname 0)      @result{} #f
(glibc.if-indextoname 1)      @result{} "lo"
(glibc.if-indextoname 2)      @result{} "eth0"
@end example
@end defun


@defun ikptr if-indextoname @var{index}
Interface to the C function @cfunc{if_indextoname}, @glibcref{Interface
Naming, if_indextoname}.  Convert the fixnum @var{index} associated to
an interface to the corresponding string name.  Return a string holding
the name or false if @var{index} is invalid.

@example
(import (vicare)
  (prefix (vicare glibc) glibc.))

(glibc.if-nametoindex "lo")   @result{} 1
(glibc.if-nametoindex "eth0") @result{} 2
@end example
@end defun


@defun if-nameindex
Interface to the C function @cfunc{if_nameindex}, @glibcref{Interface
Naming, if_nameindex}.  Build and return an association list having
fixnums as keys and strings as values; the fixnums are the interface
indexes, the strings are the corresponding interface names.

@example
(import (vicare)
  (prefix (vicare glibc) glibc.))

(glibc.if-nameindex)
@result{} ((4 . "wlan0")
    (2 . "eth0")
    (1 . "lo"))
@end example
@end defun

@c ------------------------------------------------------------

@defun gethostbyname2 @var{hostname} @var{addrtype}
Interface to the C function @cfunc{gethostbyname2}, @glibcref{Host Names,
gethostbyname2}.  Like @func{gethostbyname} but allows the selection of
the address type with the parameter @var{addrtype} which must be
@code{AF_INET} or @code{AF_INET6}.
@end defun

@c page
@node glibc math
@section Mathematics


A binding for each of the following constants is exported by
@library{vicare platform-constants}:

@example
M_E         M_LOG2E     M_LOG10E
M_LN2       M_LN10      M_PI
M_PI_2      M_PI_4      M_1_PI
M_2_PI      M_2_SQRTPI  M_SQRT2
M_SQRT1_2
@end example

The following bindings are exported by the @library{vicare glibc}
library.  The functions are implemented by the @gnu{} C library and are
probably faster than the ones implemented by the @rnrs{6} libraries.
All the arguments @var{fl} must be flonums, all the arguments @var{cfl}
must be complex flonums.

@c ------------------------------------------------------------

@subsubheading Trigonometric functions


@defun csin @var{cfl}
@defunx ccos @var{cfl}
@defunx ctan @var{cfl}
Trigonometric functions for complex flonums.
@end defun


@defun casin @var{cfl}
@defunx cacos @var{cfl}
@defunx catan @var{cfl}
Inverse trigonometric functions for complex flonums.
@end defun

@c ------------------------------------------------------------

@subsubheading Exponents and logarithms


@defun cexp @var{cfl}
Return the base of the natural logarithms raised to the power of the
operand.
@end defun


@defun clog @var{cfl}
Return the natural logarithm of the operand.
@end defun


@defun clog10 @var{cfl}
Return the base @math{10} logarithm of the operand.
@end defun


@defun csqrt @var{cfl}
Return the square root of the operand.
@end defun


@defun cpow @vari{cfl} @varii{cfl}
Return @vari{cfl} raised to the power of @varii{cfl}.
@end defun

@c ------------------------------------------------------------

@subsubheading Hyperbolic functions


@defun glibc-sinh @var{fl}
@defunx glibc-cosh @var{fl}
@defunx glibc-tanh @var{fl}
Hyperbolic functions for flonums.
@end defun


@defun glibc-asinh @var{fl}
@defunx glibc-acosh @var{fl}
@defunx glibc-atanh @var{fl}
Inverse hyperbolic functions for flonums.
@end defun


@defun csinh @var{cfl}
@defunx ccosh @var{cfl}
@defunx ctanh @var{cfl}
Hyperbolic functions for complex flonums.
@end defun


@defun casinh @var{cfl}
@defunx cacosh @var{cfl}
@defunx catanh @var{cfl}
Inverse hyperbolic functions for complex flonums.
@end defun

@c ------------------------------------------------------------

@subsubheading Special functions


@defun erf @var{fl}
@defunx erfc @var{fl}
Interfaces to the C functions @cfunc{erf} and @cfunc{erfc},
@glibcref{Special Functions, erf}.  Compute the error function.
@end defun


@defun lgamma @var{fl}
Interface to the C function @cfunc{lgamma}, @glibcref{Special Functions,
lgamma}.  Compute the natural logarithm of the absolute value of the
gamma function of the operand.  Return two values: a flonum being the
result of the function and a fixnum representing the sign of the
intermediate result.
@end defun


@defun tgamma @var{fl}
Interface to the C function @cfunc{tgamma}, @glibcref{Special Functions,
lgamma}.  Compute the gamma function of the operand.
@end defun


@defun j0 @var{fl}
@defunx j1 @var{fl}
@defunx jn @var{fx} @var{fl}
Interfaces to the C functions @cfunc{j0}, @cfunc{j1} and @cfunc{jn};
@glibcref{Special Functions, j0}.  Compute the Bessel functions of the
first kind.  @var{fx} must be a fixnum.
@end defun


@defun y0 @var{fl}
@defunx y1 @var{fl}
@defunx yn @var{fx} @var{fl}
Interfaces to the C functions @cfunc{y0}, @cfunc{y1} and @cfunc{yn};
@glibcref{Special Functions, y0}.  Compute the Bessel functions of the
second kind.  @var{fx} must be a fixnum.
@end defun

@c page
@node glibc random
@section Pseudo--random numbers


The following bindings are exported by the @library{vicare glibc}
library.


@defun rand
Interface to the C function @cfunc{rand}, @glibcref{ISO Random, rand}.
Return a non--negative exact integer representing the next
pseudo--random number in the series.  The maximum returned value is
@code{RAND_MAX}, which is a binding exported by @library{vicare
platform-constants}.
@end defun


@defun srand @var{seed}
Interface to the C function @cfunc{srand}, @glibcref{ISO Random, srand}.
Set to the exact integer @var{seed} the seed of the pseudo--random
numbers series.
@end defun

@c page
@node glibc match
@section Pattern matching, globbing and regular expressions


The following bindings are exported by the @library{vicare glibc}
library.


@defun fnmatch @var{pattern} @var{string} @var{flags}
Interface to the C function @cfunc{fnmatch}, @glibcref{Wildcard
Matching, fnmatch}.  Tests whether @var{string} matches @var{pattern}
according to @var{flags}; if it matches return @true{}, else return
@false{}.

@var{pattern} and @var{string} must be Scheme strings or bytevectors;
@var{flags} must be a fixnum resulting from the bitwise combination
(@func{fxior}) of the @code{FNM_} constants exported by @library{vicare
platform-constants}.

@example
#!r6rs
(import (vicare)
  (prefix (vicare glibc) glibc.)
  (vicare platform-constants))

(glibc.fnmatch "ciao" "ciao"  0)        @result{} #t
(glibc.fnmatch "ciao" "salut" 0)        @result{} #f

(glibc.fnmatch "ciao*" "ciao a tutti" 0)
@result{} #t

(glibc.fnmatch "*(Ciao)" "CiaoCiao" FNM_EXTMATCH)
@result{} #t

(glibc.fnmatch "?(Ciao|Hello)" "Hello" FNM_EXTMATCH)
@result{} #t
@end example
@end defun


@defun glob @var{pattern} @var{flags} @var{error-handler}
@defunx glob/string @var{pattern} @var{flags} @var{error-handler}
Interface to the C function @cfunc{glob}, @glibcref{Calling Glob, glob}.
Perform file globbing @strong{in the current directory} using
@var{pattern} to select entries according to @var{flags}.  If successful
@func{glob} returns a list of bytevectors representing the result,
@func{glob/string} returns a list of strings representing the result;
else both return a fixnum representing one of the error codes:
@code{GLOB_ABORTED}, @code{GLOB_NOMATCH}, @code{GLOB_NOSPACE}.

@var{pattern} must be a string or bytevector.  @var{flags} must be a
fixnum built as bitwise composition (@func{fxior}) of the flags:
@code{GLOB_ERR}, @code{GLOB_MARK}, @code{GLOB_NOCHECK},
@code{GLOB_NOSORT}, @code{GLOB_NOESCAPE}, @code{GLOB_PERIOD},
@code{GLOB_BRACE}, @code{GLOB_NOMAGIC}, @code{GLOB_TILDE},
@code{GLOB_TILDE_CHECK}, @code{GLOB_ONLYDIR}.

@var{error-handler} must be @false{} or a callback pointer with the
signature:

@example
int @var{error-handler} (const char * filename, int error-code)
@end example

@noindent
called by @func{glob} whenever it cannot open a directory; see the
documentation for @cfunc{glob} and the flag @code{GLOB_ERR} for details.

@example
#!r6rs
(import (vicare)
  (prefix (vicare glibc) glibc.)
  (vicare platform-constants))

(glibc.glob/string "*" 0 #f)
@result{} ("bin" "boot" "dev" "etc" "home" "lib"
    "libexec" "lost+found" "media" "mnt" "opt"
    "proc" "root" "sbin" "share" "srv" "sys"
    "tmp" "usr" "var")

(glibc.glob/string "~marco" GLOB_TILDE #f)
@result{} ("/home/marco")
@end example
@end defun

@c ------------------------------------------------------------

@subsubheading @posix{} regular expressions

The following are usage examples of @posix{} regular expressions
matching:

@example
#!r6rs
(import (vicare)
  (prefix (vicare glibc) glibc.)
  (vicare platform-constants))

(let ((rex (glibc.regcomp "abc" 0)))
  (glibc.regexec rex "abc" 0))
@result{} #((0 . 3)))   ;the regex matched the whole string

(let ((rex (glibc.regcomp "abc" 0)))
  (glibc.regexec rex "abcdef" 0))
@result{} #((0 . 3))    ;substring [0, 3) matched

(let ((rex (glibc.regcomp "ciao" 0)))
  (glibc.regexec rex "abc" 0))
@result{} #f            ;no match

(let ((rex (glibc.regcomp "\\(a\\)" 0)))
  (glibc.regexec rex "abc" 0))
@result{} #((0 . 1)     ;the regexp matched the whole string
     (0 . 1))    ;substring [0, 1) matched the 1st paren

(let ((rex (glibc.regcomp "\\(a\\)\\(b\\)\\(c\\)" 0)))
  (glibc.regexec rex "abc" 0))
@result{} #((0 . 3)     ;the regexp matched the whole string
     (0 . 1)     ;substring [0, 1) matched the 1st paren
     (1 . 2)     ;substring [1, 2) matched the 2nd paren
     (2 . 3))    ;substring [2, 3) matched the 3rd paren

(let ((rex (glibc.regcomp "\\(a\\(b\\(c\\)\\)\\)" 0)))
  (glibc.regexec rex "abc" 0))
@result{} #((0 . 3)     ;the regexp matched the whole string
     (0 . 3)     ;substring [0, 3) matched the 1st paren
     (1 . 3)     ;substring [1, 3) matched the 2nd paren
     (2 . 3))    ;substring [2, 3) matched the 3rd paren

(let* ((rex (glibc.regcomp/disown "[a-z]+" REG_EXTENDED))
       (rv  (glibc.regexec rex "abc" 0)))
  (glibc.regfree rex)
  rv)
@result{} #((0 . 3))
@end example

@noindent
we have to remember that this @api{} can be used only with bytevectors
representing @ascii{} coded strings and with Scheme strings containing
only characters whose Unicode code points are in the range @math{[0,
255]}.

@posix{} regular expression patterns are described in the ``Base
Definitions'' volume of @ieee{} Std 1003.1-2001, Chapter 9, Regular
Expressions:

@center @url{http://pubs.opengroup.org/onlinepubs/009695399/nframe.html}

@noindent
@aurl{} last verified Dec  9, 2011.


@defun regcomp @var{pattern} @var{flags}
Interface to the C function @cfunc{regcomp}, @glibcref{POSIX Regexp
Compilation, regcomp}.  Compile the regular expression in @var{pattern}
accoding to @var{flags}.  If successful return a pointer referencing the
compiled regexp, else raise an exception with condition components
@condition{error}, @condition{who}, @condition{message},
@condition{irritants}.

@var{pattern} must be a string or bytevector representing the regular
expression.  @var{flags} must be a fixnum resulting from the bitwise
combination (@func{fxior}) of @code{REG_} constants.

The pointer returned in case of success references a @code{regex_t} data
structure whose fields must be released explicitly by @func{regfree}, or
they are automatically released by the garbage collector whenever the
pointer itself is collected.
@end defun


@defun regcomp/disown @var{pattern} @var{flags}
Like @func{regcomp}, but when the returned pointer object is garbage
collected nothing happens; we have to explicitly apply @func{regfree} to
the returned pointer object to release the allocated resources.
@end defun


@defun regexec @var{regex} @var{string} @var{flags}
Interface to the C function @cfunc{regexec}, @glibcref{Matching POSIX
Regexps, regexec}.  Attempt to match @var{string} against the
precompiled regular expression @var{regex} according to @var{flags}.

@var{regex} must be a pointer returned by a previous call to
@func{regcomp}; @var{string} must be a string or bytevector in @ascii{}
encoding; @var{flags} must be a fixnum representing matching flags, we
can use zero for no flags.

If one or more matches occur return a vector holding pairs describing
the portions of @var{string} that did match; if no match occurs return
@false{}; if an error occurs raise an exception with condition
components: @condition{error}, @condition{who}, @condition{message},
@condition{irritants}.

The vector returned in case of success contains pairs: the car being a
fixnum representing the starting offset of a match substring, the cdr
being a fixnum representing the ending offset of a match substring.

The vector element at index @math{0} represents the portion of
@var{string} which matched the whole regular expression; the vector
element at index @math{1} represents the portion of @var{string} which
matched the first parenthetical subexpression, the vector element at
index @math{2} represents the portion of @var{string} which matched the
second parenthetical subexpression, and so on.  If @var{string} matches:
the returned vector has at least one element.
@end defun


@defun regfree @var{regex}
Interface to the C function @cfunc{regfree}, @glibcref{Regexp Cleanup,
regfree}.  Release the resources associated to the compiled regular
expression @var{regex}, which must be a pointer.

It is safe to apply this function multiple times to the same @var{regex}
pointer object: releasing occurs only if the first time, subsequent
applications do nothing.  After the resources have been released:
@var{regex} is reset to @cnull{}.
@end defun

@c page
@node glibc word
@section Performing word expansion


Word expansion is a set of operations acting on a given string and
involving the current system environment variable; it is usually
performed by Unix shell programs.  It works as follows:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (prefix (vicare glibc) glibc.)
  (vicare platform-constants))

(px.setenv "CIAO" "BLU")
(glibc.wordexp/string "$CIAO" 0)        @result{} #("BLU")

(px.setenv "CIAO" "BLUETTE")
(glibc.wordexp/string "$@{CIAO##BLU@}" 0) @result{} #("ETTE")

(glibc.wordexp/string "/bin/ch*" 0)
@result{} #("/bin/chcon""/bin/chgrp"
     "/bin/chmod" "/bin/chown" "/bin/chroot")

@end example

The following bindings are exported by the @library{vicare glibc}
library.


@defun wordexp @var{words} @var{flags}
@defunx wordexp/string @var{words} @var{flags}
Interface to the C function @cfunc{wordexp}, @glibcref{Calling Wordexp,
wordexp}.  Perform word expansion on @var{words} according to
@var{flags}.

@var{words} must be a string or bytevector.  @var{flags} must be a
fixnum resulting from the bitwise combination (@func{fxior}) of the
flags: @code{WRDE_NOCMD}, @code{WRDE_SHOWERR}, @code{WRDE_UNDEF}.

If successful @func{wordexp} returns a vector holding the resulting
bytevectors, @func{wordexp/string} returns a vector holding the
resulting strings; else the return value is a fixnum among:
@code{WRDE_BADCHAR}, @code{WRDE_BADVAL}, @code{WRDE_CMDSUB},
@code{WRDE_NOSPACE}, @code{WRDE_SYNTAX}.
@end defun

@c page
@node glibc iconv
@section Generic character set conversion


The Iconv functions allow conversion among character set encodings,
@glibcref{Generic Charset Conversion, Conversion}.  This @api{} is
available only if, at package configuration time, it was enabled with
the @option{--with-iconv} option to the @command{configure} script.

@menu
* glibc iconv set::             Encoding enumeration sets.
* glibc iconv conv::            Conversion functions.
@end menu

@c page
@node glibc iconv set
@subsection Encoding enumeration sets


The following bindings are exported by the @library{vicare glibc}
library.


@deftp {Enumeration Type} enum-iconv-encoding
Enumeration type for the symbols describing supported Iconv encodings.
All the encoding symbols are included with the exception of @samp{850},
@samp{862} and @samp{866} (because they are numbers) which are aliases
for @samp{CP850}, @samp{CP862} and @samp{CP866}.

Additionally @samp{TRANSLIT} and @samp{IGNORE} are included to allow the
specification of the corresponding modes for @func{iconv!}.
@end deftp


@deffn Syntax iconv-encoding @ameta{symbol} ...
Evaluate to an enumeration set holding symbols from the
@code{enum-iconv-encoding} enumeration.  It should be used to compose
sets with a single encoding symbol and optionally none, one or both the
symbols @samp{TRANSLIT} and @samp{IGNORE}.

Examples:

@example
(iconv-encoding ISO8859-4)
(iconv-encoding UTF-16BE IGNORE)
(iconv-encoding UCS-4 TRANSLIT IGNORE)
@end example
@end deffn


@defvr Constant iconv-encoding-universe
Enumeration set holding all the symbols in the
@code{enum-iconv-encoding} enumeration.
@end defvr


@defun iconv-encoding-aliases? @vari{set} @varii{set}
Return true if the encodings specified by the enumeration sets
@vari{set} and @varii{set} are aliases for the same encoding.  This
predicate does @strong{not} take into account the @samp{TRANSLIT} and
@samp{IGNORE} symbols.
@end defun


@defun iconv-encoding=? @vari{set} @varii{set}
Return true if the encodings specified by the enumeration sets
@vari{set} and @varii{set} are aliases for the same encoding, taking
into account the @samp{TRANSLIT} and @samp{IGNORE} symbols.
@end defun

@c page
@node glibc iconv conv
@subsection Conversion functions


The basics of the conversion are as follows:

@example
#!r6rs
(import (vicare)
  (prefix (vicare glibc) glibc.))

(let* ((handle    (glibc.iconv-open
                    (glibc.iconv-encoding UTF-16BE) ;from
                    (glibc.iconv-encoding UTF-8)))  ;to
       (in.bv     (string->utf16 "ciao hello salut"
                    (endianness big)))
       (out.bv    (make-bytevector 16)))
  (let-values (((in.start out.start)
               (glibc.iconv! handle in.bv 0 #f out.bv 0 #f)))
    (utf8->string out.bv)))
@result{} "ciao hello salut"
@end example

The following bindings are exported by the @library{vicare glibc}
library.


@defun iconv-open @var{from} @var{to}
Build and return a new conversion context object for the specified
encodings.  @var{from} and @var{to} must be enumeration sets of type
@code{enum-iconv-encoding}.  The returned handle must be finalised with
@func{iconv-close}; this operation is automatically performed when the
handle is garbage collected.

@quotation
@strong{NOTE} Beware of the order of the arguments!  An error may be
difficult to detect.
@end quotation
@end defun


@defun iconv? @var{obj}
Return true if @var{obj} is an Iconv context object.  Context objects
are disjoint from the other Scheme objects.
@end defun


@defun iconv-closed? @var{context}
Return @true{} if @var{context} is an Iconv context already closed;
return @false{} otherwise.
@end defun


@defun iconv-close @var{context}
Close the conversion @var{context} releasing all the associated
resources.  Applying this function multiple times to the same
@var{context} object is safe: the first time the context is finalised,
the subsequent times nothing happens.
@end defun


@defun iconv! @var{context} @var{in} @var{in.start} @var{in.past} @var{out} @var{out.start} @var{out.past}
Convert a range of bytes from the bytevector @var{in} and store the
result into a range of bytes in the bytevector @var{out}, according
to the context specified by @var{context}.

@var{in.start} is a fixnum representing the input inclusive start index;
@var{in.past} is a fixnum representing the input exclusive end index;
@var{out.start} is a fixnum representing the output inclusive start
index; @var{out.past} is a fixnum representing the output exclusive end
index.  They must be such that:

@example
0 <= @var{in.start}  <= @var{in.past}  <= length(@var{in})
0 <= @var{out.start} <= @var{out.past} <= length(@var{out})
@end example

As special cases: if @var{in.past} is false, the input past index is the
length of @var{in}; if @var{out.past} is false, the output past index is
the length of @var{out}.

If the operation is successful return two values:

@enumerate
@item
A fixnum representing the index of the first byte in @var{in} that was
not consumed.  If all the input range was processed: this value equals
@var{in.past}.

@item
A fixnum representing the index of the first byte in @var{out} that was
not filled with output data.  If all the output range was filled with
output: this value equals @var{out.past}.
@end enumerate

If an error occurs raise an exception.

@quotation
@strong{NOTE} Beware of the order of the arguments!  An error may be
difficult to detect.
@end quotation
@end defun

@c page
@node linux
@chapter The @gnu{}+Linux interface


The functions described in this chapter are exported by the library
@library{vicare linux}.  The @api{} attempts to create a one--to--one
Scheme functions mapping towards Linux functions, keeping the same
semantics as much as possible; the platform's own documentation is
relevant at the Scheme level.

@quotation
@strong{NOTE} These bindings are included and installed by default and
they can be excluded at compile time by giving the option
@option{--disable-linux} to the @command{configure} stript.
@end quotation

All the constants needed to use the interface are available as
identifier syntaxes exported by the @library{vicare platform-constants}
library; if a constant value is not exported, file a feature request for
the project.  If a constant is not defined on a platform: its value is
set to @false{}.

The library @library{vicare platform features} exports one identifier
syntax for each @code{HAVE_} symbol defined by @value{PRJNAME}
@command{configure} script, expanding to @true{} or @false{}.

For a list of Linux--specific system calls, see the @code{syscalls(2)}
manual page.

On non--Linux platforms we must avoid calling these functions, else the
behaviour is undefined.

@menu
* linux env::                   Operating system environment variables.
* linux status::                Process termination status.
* linux resources::             Resources usage and limits.
* linux epoll::                 Polling for events on file descriptors.
* linux signalfd::              Accepting signals through
                                file descriptors.
* linux timerfd::               Timer expiration handling through
                                file descriptors.
* linux inotify::               Monitoring file system events.
@end menu

@c page
@node linux env
@section Operating system environment variables


The following bindings are exported by the @library{vicare linux}
library.


@defun clearenv
Interface to the C function @cfunc{clearenv}, @glibcref{Environment
Access, clearenv}.  Remove all the entries from the environment.  Return
unspecified values.
@end defun

@c page
@node linux status
@section Process termination status


The following bindings are exported by the @library{vicare linux}
library.


@defun waitid @var{idtype} @var{id} @var{options}
Interface to the Linux specific C function @cfunc{waitid}, see the
@cfunc{waitid} manual page for details.  Wait for the termination of one
or more child processes with finer control of @func{waitpid}.  All the
arguments must be fixnums.  If successful: return an instance of
structure @code{struct-siginfo_t}, else raise an exception.
@end defun


@deftp Struct struct-siginfo_t
Data structure used by @func{waitid} to report its result; it has the
following fields:

@example
si_pid si_uid si_signo si_status si_code
@end example

See the @cfunc{waitid} manual page for details.
@end deftp


@defun make-struct-siginfo_t @var{pid} @var{uid} @var{signo} @var{status} @var{code}
@defunx struct-siginfo_t? @var{obj}
@defunx struct-siginfo_t-si_pid
@defunx struct-siginfo_t-si_uid
@defunx struct-siginfo_t-si_signo
@defunx struct-siginfo_t-si_status
@defunx struct-siginfo_t-si_code
Constructor, predicate and field accessors for structures of type
@code{struct-siginfo_t}.
@end defun


The following functions accept as argument a fixnum representing the
process termination status, for example the return value of
@cfunc{system} or the status acquired by @cfunc{waitpid}.


@defun WIFCONTINUED @var{status}
Interface to the Linux specific C macro @cfunc{WIFCONTINUED}.  Return
true if the process was resumed by delivery of @code{SIGCONT}.
@end defun

@c page
@node linux resources
@section Resources usage and limits


The following bindings are exported by @library{vicare posix} and
reexported by @library{vicare linux}.

@example
make-struct-rlimit      struct-rlimit?
struct-rlimit-rlim_cur  set-struct-rlimit-rlim_cur!
struct-rlimit-rlim_max  set-struct-rlimit-rlim_max!
RLIM_INFINITY
@end example


@defun prlimit @var{pid} @var{resource}
@defunx prlimit @var{pid} @var{resource} @var{new-rlim}
@defunx prlimit @var{pid} @var{resource} @var{new-rlim} @var{old-rlim}
Interface to the C function @cfunc{prlimit}, see the manual page
@code{prlimit(2)}.  Get and/or set the resource limits of an arbitrary
process; if successful return @var{old-rlim}, else raise an exception.

@var{pid} must be a fixnum representing the process identifier of the
target process.  @var{resource} must be an exact integer representing
the value of a @code{RLIMIT_} constant.

The optional @var{new-rlim} must be @false{} or an instance of
@code{struct-rlimit}; when @false{}: no new value is set and the
function only retrieves the current resources usage values; when a
structure instance: its fields are used to set new resource usage
limits.

The optional @var{old-rlim} must an instance of @code{struct-rlimit}: it
is filled with the previous values for the resource usage limits and
returned; when not given: a new instance is built, filled and returned.
@end defun

@c page
@node linux epoll
@section Polling for events on file descriptors


For details on the @api{} we should refer to the following manual pages:
@code{epoll(7)}, @code{epoll_create(2)}, @code{epoll_ctl(2)},
@code{epoll_wait(2)}.  The following bindings are exported by the
@library{vicare linux} library.


@defun epoll-create
@defunx epoll-create @var{size}
@defunx epoll-create1 @var{flags}
Interfaces to the C language functions @cfunc{epoll_create} and
@cfunc{epoll_create1}.  Open an epoll descriptor and return it as
fixnum.  When @var{size} is not used: it defaults to @math{16}.  If an
error occurs: raise an exception.
@end defun


@defun epoll-ctl @var{epfd} @var{op} @var{fd}
@defunx epoll-ctl @var{epfd} @var{op} @var{fd} @var{event}
Interface to the C language function @cfunc{epoll_ctl}.  Control
interface for an epoll descriptor.  Return unspecified values.  If an
error occurs: raise an exception.

@var{epfd} is the return value of a previous call to
@func{epoll-create}.  @var{op} is a fixnum representing an OR
combination of flags: @code{EPOLL_CTL_ADD}, @code{EPOLL_CTL_MOD},
@code{EPOLL_CTL_DEL}.  @var{fd} is a fixnum representing the file
descriptor subject of the action.  @var{event} is a pointer object
referencing a @code{struct epoll_event}; when @var{event} is @false{} or
not used: it defaults to the @cnull{} pointer.
@end defun


@defun epoll-wait @var{epfd} @var{event} @var{maxevents} @var{timeout-ms}
Interface to the C language function @cfunc{epoll_wait}.  Wait for an
I/O event on an epoll descriptor.  Return a fixnum representing the
number of file descriptors ready for the requested events; the return
value is zero if no file descriptors are ready.  If an error occurs:
raise an exception.

@var{epfd} is the return value of a previous call to
@func{epoll-create}.  @var{event} is a poiner object referencing an
array of @code{struct epoll_event} holding @var{maxevents} entries;
@var{maxevents} is a non--negative fixnum.  @var{timeout-ms} is an exact
integer in the range of a C language @code{int}, it represents a timeout
time in milliseconds; when set to @code{-1} causes the call to block
until at least one file descriptor is ready.
@end defun


To allow for faster operations, the @code{struct epoll_event} instances
handled by the epoll functions are meant to be allocated on raw memory.


@defun epoll-event-alloc @var{number-of-entries}
Allocate with @cfunc{malloc} an array of @code{struct epoll_event}
capable of holding @var{number-of-entries} structures.  If successful
return a pointer object, else raise an exception.
@end defun


@defun epoll-event-size
Return the number of bytes needed to hold an instance of @code{struct
epoll_event}.
@end defun


@defun epoll-event-set-events! @var{events-array} @var{index} @var{new-value}
@defunx epoll-event-ref-events @var{events-array} @var{index}
Mutator and accessor for the field @code{events} of the @code{struct
epoll_event} entry at @var{index}.
@end defun


@defun epoll-event-set-data-ptr! @var{events-array} @var{index} @var{new-value}
@defunx epoll-event-ref-data-ptr @var{events-array} @var{index}
Mutator and accessor for the field @code{data.ptr} of the @code{struct
epoll_event} entry at @var{index}.
@end defun


@defun epoll-event-set-data-fd! @var{events-array} @var{index} @var{new-value}
@defunx epoll-event-ref-data-fd @var{events-array} @var{index}
Mutator and accessor for the field @code{data.fd} of the @code{struct
epoll_event} entry at @var{index}.
@end defun


@defun epoll-event-set-data-u32! @var{events-array} @var{index} @var{new-value}
@defunx epoll-event-ref-data-u32 @var{events-array} @var{index}
Mutator and accessor for the field @code{data.u32} of the @code{struct
epoll_event} entry at @var{index}.
@end defun


@defun epoll-event-set-data-u64! @var{events-array} @var{index} @var{new-value}
@defunx epoll-event-ref-data-u64 @var{events-array} @var{index}
Mutator and accessor for the field @code{data.u4} of the @code{struct
epoll_event} entry at @var{index}.
@end defun


Here is a meaningless example showing the mechanics of the epoll @api{}:

@smallexample
(import (vicare)
  (prefix (vicare linux)
          linux.)
  (prefix (vicare posix)
          px.)
  (vicare platform-constants)
  (vicare syntactic-extensions))

(let-values (((in ou) (px.pipe)))
  (unwind-protect
      (let ((epfd (linux.epoll-create)))
        (unwind-protect
            (let ((sizeof-struct (vector (linux.epoll-event-size))))
              (with-local-storage sizeof-struct
                (lambda (event)
                  (linux.epoll-event-set-events!  event 0 EPOLLIN)
                  (linux.epoll-event-set-data-fd! event 0 in)
                  (linux.epoll-ctl epfd EPOLL_CTL_ADD in event)))
              (px.write ou '#vu8(1))
              (with-local-storage sizeof-struct
                (lambda (events)
                  (linux.epoll-wait epfd events 1 -1)
                  (linux.epoll-event-ref-data-fd events 0) @result{} in
                  (linux.epoll-event-ref-events events 0)  @result{} EPOLLIN
                  ))))
          (px.close epfd)))
    (px.close in)
    (px.close ou))
@end smallexample

@c page
@node linux signalfd
@section Accepting signals through file descriptors


The @code{signalfd} @api{} transforms interprocess signals into file
descriptor events, this way we can code event loops using @func{select}
or @func{epoll} and a uniform interface for signal and input/output
events.  For the full documentation see the @code{signalfd(2)} manual
page.  The following bindings are exported by the @library{vicare linux}
library.


@defun signalfd @var{fd} @var{mask} @var{flags}
Interface to the C function @cfunc{signalfd}.  Create a file descriptor
that can be used to accept interprocess signals.  If successful return a
fixnum representing the file descriptor, else raise an exception.

@var{fd} can be either a fixnum representing the file descriptor or
@code{-1} to request a new, unspecified, file descriptor; if @var{fd} is
the return value of a previous call to @func{signalfd}: this call
replaces the signal set previously specified.

@var{mask} must be a Scheme vector of fixnums representing the signal
numbers to be accepted.  Notice that these signals should have been
blocked.

@var{flags} can be the fixnum zero or an OR combination (@func{fxior})
of the constants: @code{SFD_CLOEXEC}, @code{SFD_NONBLOCK}.
@end defun


@defun read-signalfd-siginfo @var{fd}
Attempt to read from the file descriptor @var{fd} a single instance of
@code{struct signalfd_siginfo}: if successful return the result as an
instance of @code{struct-signalfd-siginfo}; if no signal is pending, and
@var{fd} is non--blocking, return @false{}; if an error occurs raise an
exception.
@end defun


@deftp {Struct Type} struct-signalfd-siginfo
Structure type mirroring the C language @code{struct signalfd_siginfo}.
It has the following fields:

@example
ssi_signo       ssi_errno       ssi_code
ssi_pid         ssi_uid         ssi_fd
ssi_tid         ssi_band        ssi_overrun
ssi_trapno      ssi_status      ssi_int
ssi_ptr         ssi_utime       ssi_stime
ssi_addr
@end example
@end deftp


@deftp make-struct-signalfd-siginfo @var{signo} @var{errno} @var{code} @var{pid} @var{uid} @var{fd} @var{tid} @var{band} @var{overrun} @var{trapno} @var{status} @var{int} @var{ptr} @var{utime} @var{stime} @var{addr}
Build and return a new instance of @code{struct-signalfd-siginfo}.
@end deftp


@defun struct-signalfd-siginfo? @var{obj}
Return @true{} if @var{obj} is an instance of
@code{struct-signalfd-siginfo}, else return @false{}.
@end defun


@defun struct-signalfd-siginfo-ssi_signo @var{info}
@defunx struct-signalfd-siginfo-ssi_errno @var{info}
@defunx struct-signalfd-siginfo-ssi_code @var{info}
@defunx struct-signalfd-siginfo-ssi_pid @var{info}
@defunx struct-signalfd-siginfo-ssi_uid @var{info}
@defunx struct-signalfd-siginfo-ssi_fd @var{info}
@defunx struct-signalfd-siginfo-ssi_tid @var{info}
@defunx struct-signalfd-siginfo-ssi_band @var{info}
@defunx struct-signalfd-siginfo-ssi_overrun @var{info}
@defunx struct-signalfd-siginfo-ssi_trapno @var{info}
@defunx struct-signalfd-siginfo-ssi_status @var{info}
@defunx struct-signalfd-siginfo-ssi_int @var{info}
@defunx struct-signalfd-siginfo-ssi_ptr @var{info}
@defunx struct-signalfd-siginfo-ssi_utime @var{info}
@defunx struct-signalfd-siginfo-ssi_stime @var{info}
@defunx struct-signalfd-siginfo-ssi_addr @var{info}
Accessors for the fields of a @code{struct-signalfd-siginfo}.
@end defun

In the following examples we use @func{signal-bub-init}, from
@library{vicare posix}, to block all the signals.  Let's say no signal
is pending:

@example
#!r6rs
(import (vicare)
  (prefix (vicare linux) lx.)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(px.signal-bub-init)
(let* ((mask  (vector SIGUSR1 SIGUSR2)
       (flags (fxior SFD_CLOEXEC SFD_NONBLOCK)))
       (fd    (lx.signalfd -1 mask flags)))
  (lx.read-signalfd-siginfo fd))
@result{} #f
@end example

@noindent
now we raise a single signal:

@example
#!r6rs
(import (vicare)
  (prefix (vicare linux) lx.)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(px.signal-bub-init)
(let* ((mask  (vector SIGUSR1 SIGUSR2)
       (flags (fxior SFD_CLOEXEC SFD_NONBLOCK)))
       (fd    (lx.signalfd -1 mask flags)))
  (px.raise SIGUSR1)
  (let ((info (lx.read-signalfd-siginfo fd))
        (done (lx.read-signalfd-siginfo fd)))

    (lx.struct-signalfd-siginfo-ssi_signo info)
    @result{} SIGUSR1

    done))
@result{} @false{}
@end example

@noindent
now we raise two signals:

@example
#!r6rs
(import (vicare)
  (prefix (vicare linux) lx.)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(px.signal-bub-init)
(let* ((mask  (vector SIGUSR1 SIGUSR2)
       (flags (fxior SFD_CLOEXEC SFD_NONBLOCK)))
       (fd    (lx.signalfd -1 mask flags)))
  (px.raise SIGUSR1)
  (px.raise SIGUSR2)
  (let ((info1 (lx.read-signalfd-siginfo fd))
        (info2 (lx.read-signalfd-siginfo fd))
        (done  (lx.read-signalfd-siginfo fd)))
    (lx.struct-signalfd-siginfo-ssi_signo info1)
    @result{} SIGUSR1

    (lx.struct-signalfd-siginfo-ssi_signo info2)
    @result{} SIGUSR2

    done))
@result{} #f
@end example

@c page
@node linux timerfd
@section Timer expiration handling through file descriptors


The @code{timerfd} @api{} transforms timer expiration events into file
descriptor events, this way we can code event loops using @func{select}
or @func{epoll} and a uniform interface for timer and input/output
events.  For the full documentation see the following manual pages:
@code{timerfd_create(2)}, @code{timerfd_settime(2)},
@code{timerfd_gettime(2)}.

@menu
* linux timerfd intro::         Introduction to the @code{timerfd} @api{}.
* linux timerfd api::           The @code{timerfd} @api{}.
* linux timerfd examples::      Usage examples of the @code{timerfd} @api{}.
@end menu

@c page
@node linux timerfd intro
@subsection Introduction to the @code{timerfd} @api{}


The @code{timerfd} @api{} allows the definition of time--periodic events
by specification of two time intervals:

@enumerate
@item
Initial expiration: how much time before the first event.

@item
Period: how much time between two time--adjacent events.
@end enumerate

@example
    time before the
    first event       period      period      period
   |               |           |           |           |
---+---------------+-----------+-----------+-----------+----
   ^               ^           ^           ^           ^
  now          1st event   2nd event   3rd event   4th event
@end example

Each timer can be started, stopped, reconfigured and queried for how
much time until the next event.

@c page
@node linux timerfd api
@subsection The @code{timerfd} @api{}


The following bindings are exported by @library{vicare posix} and
reexported by @library{vicare linux}:

@example
make-struct-timespec           struct-timespec?
struct-timespec-tv_sec         struct-timespec-tv_nsec
set-struct-timespec-tv_sec!    set-struct-timespec-tv_nsec!

make-struct-itimerspec         struct-itimerspec?
struct-itimerspec-it_interval  struct-itimerspec-it_value
set-struct-itimerspec-it_interval!
set-struct-itimerspec-it_value!
@end example

The following bindings are exported by the @library{vicare linux}
library.


@defun timerfd-create @var{clockid}
@defunx timerfd-create @var{clockid} @var{flags}
Interface to the C function @cfunc{timerfd_create}.  Create a new timer
object and a file descriptor that refers to that timer; if successful
return a fixnum representing the file descriptor, else raise an
exception.

@var{clockid} must be one among: @code{CLOCK_REALTIME},
@code{CLOCK_MONOTONIC}.  @var{flags} can be either the fixnum zero or a
bitwise OR combination of: @code{TFD_CLOEXEC}, @code{TFD_NONBLOCK}; when
not given: it defaults to the fixnum zero.
@end defun


@defun timerfd-settime @var{fd} @var{flags} @var{new}
@defunx timerfd-settime @var{fd} @var{flags} @var{new} @var{old}
Interface to the C function @cfunc{timerfd_settime}.  Start or stop the
timer referred to by the file descriptor @var{fd}.  If successful return
@var{old} or @false{} when @var{old} is not given; if an error occurs
raise an exception.

@var{flags} can be either the fixnum zero or @code{TFD_TIMER_ABSTIME}.
@var{new} must be a valid instance of @code{struct-itimerspec}, which is
used to set the timer.  The optional @var{old} can be @false{} or a
valid instance of @code{struct-itimerspec}; when given: it is filled
with the old timer specification.
@end defun


@defun timerfd-gettime @var{fd}
@defunx timerfd-gettime @var{fd} @var{curr}
Interface to the C function @cfunc{timerfd_gettime}.  Retrieve the
current timer specification associated to the file descriptor @var{fd}.
If successful return @var{curr} or a newly built instance of
@code{struct-itimerspec}; if an error occurs: raise an exception.

The optional @var{curr} must be a valid instance of
@code{struct-itimerspec}, when not given a new instance of this
structure type is internally built: it is filled with the current timer
specification.
@end defun


@defun timerfd-read @var{fd}
Perform a @cfunc{read} operation on @var{fd}, which must be a file
descriptor associated to a timer.  The function behaves as follows:

@itemize
@item
If the operation is successful: return the number of timer expirations
occurred since the timer was set or the last successful @cfunc{read}.

@item
if the operation fails with code @code{EWOULDBLOCK}: the return value is
zero.

@item
Else an exception is raised.
@end itemize
@end defun

@c page
@node linux timerfd examples
@subsection Usage examples of the @code{timerfd} @api{}


The following program watches a timer as time goes by:

@example
#!r6rs
(import (vicare)
  (vicare platform-constants)
  (only (vicare syntactic-extensions)
        unwind-protect)
  (prefix (vicare posix) px.)
  (prefix (vicare linux) lx.))

(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))

(define (%print-remaining-time fd)
  (pretty-print (lx.struct-itimerspec-it_value
                 (lx.timerfd-gettime fd))))

(define (%sleep-one-second)
  (px.nanosleep 1 0))

(let ((fd (lx.timerfd-create CLOCK_REALTIME)))
  (unwind-protect
      (let ( ;; one event every 3 seconds
            (period (lx.make-struct-timespec 3 0))
            ;; the first event after 1 nanosecond
            (offset (lx.make-struct-timespec 0 1)))
        (lx.timerfd-settime fd 0
           (lx.make-struct-itimerspec period offset))
        (do ((i 0 (fx+ 1 i)))
            ((fx= i 6))
          (%print-remaining-time fd)
          (%sleep-one-second))
        #f)
    (px.close fd)))
@end example

@noindent
the output is:

@example
#["struct-timespec" tv_sec=2 tv_nsec=999911022]
#["struct-timespec" tv_sec=1 tv_nsec=999307638]
#["struct-timespec" tv_sec=0 tv_nsec=998303788]
#["struct-timespec" tv_sec=2 tv_nsec=997338092]
#["struct-timespec" tv_sec=1 tv_nsec=996393490]
#["struct-timespec" tv_sec=0 tv_nsec=995418649]
@end example

The following example prints the number of timer expirations:

@example
#!r6rs
(import (vicare)
  (vicare platform-constants)
  (only (vicare syntactic-extensions)
        unwind-protect)
  (prefix (vicare posix) px.)
  (prefix (vicare linux) lx.))

(set-port-buffer-mode! (current-output-port)
                       (buffer-mode none))
(define fd
  (lx.timerfd-create CLOCK_REALTIME TFD_NONBLOCK))
(unwind-protect
    (begin
      ;; 0.3 seconds = 300 ms = 300,000 us = 300,000,000 ns
      (define nsecs  300000000)
;;;                 9876543210
      (lx.timerfd-settime fd 0
        (lx.make-struct-itimerspec
         ;; one event every 0.3 seconds
         (lx.make-struct-timespec 0 nsecs)
         ;; the first event after 1 nanosecond
         (lx.make-struct-timespec 0 1)))
      (printf "right after starting timer: ~a\n"
        (lx.timerfd-read fd))
      (px.nanosleep 1 0)
      (printf "after 1 second: ~a\n"
        (lx.timerfd-read fd))
      (px.nanosleep 0 nsecs)
      (printf "after 0.3 seconds: ~a\n"
        (lx.timerfd-read fd)))
  (px.close fd))
@end example

@noindent
the output is:

@example
right after starting timer: 1
after 1 second: 3
after 0.3 seconds: 1
@end example

@noindent
we notice that right after starting the timer: the number of expirations
is @math{1} because the timer starts @math{1} nanosecond after the call
to @func{timerfd-settime}, which is almost immediately.

@c page
@node linux inotify
@section Monitoring file system events


The @code{inotify} @api{} allows us to monitor file system events; for
an overview of the @api{} we must refer to the @code{inotify(7)} manual
page.


@deftp {Struct Type} struct-inotify-event
Scheme level representation of the C language type @code{struct
inotify-event}, see the @code{inotify(7)} manual page.  It has the
following fields:

@table @code
@item wd
An exact integer in the range of the C language type @code{int}.

@item mask
An exact integer in the range of the C language type @code{uint32_t}.

@item cookie
An exact integer in the range of the C language type @code{uint32_t}.

@item len
An exact integer in the range of the C language type @code{uint32_t}.
Zero or the number of bytes in the pathname represented by the
@code{name} field.

@item name
A bytevector representing a file system pathname or @false{}.
@end table
@end deftp


@defun make-struct-inotify-event
@defunx make-struct-inotify-event @var{wd} @var{mask} @var{cookie} @var{len} @var{name}
Build and return a new instance of @code{struct-inotify-event}.  When no
arguments are given: all the fields are set to the fixnum zero, but the
field @var{name} which is set to @false{}.
@end defun


@defun struct-inotify-event? @var{obj}
Return @true{} if @var{obj} is an instance of
@code{struct-inotify-event}.
@end defun


@defun struct-inotify-event-wd @var{iev}
@defunx struct-inotify-event-mask @var{iev}
@defunx struct-inotify-event-cookie @var{iev}
@defunx struct-inotify-event-len @var{iev}
@defunx struct-inotify-event-name @var{iev}
Accessors for the fields of @code{struct-inotify-event}.
@end defun


@defun set-struct-inotify-event-wd! @var{iev} @var{value}
@defunx set-struct-inotify-event-mask! @var{iev} @var{value}
@defunx set-struct-inotify-event-cookie! @var{iev} @var{value}
@defunx set-struct-inotify-event-len! @var{iev} @var{value}
@defunx set-struct-inotify-event-name! @var{iev} @var{value}
Mutators for the fields of @code{struct-inotify-event}.
@end defun


@defun inotify-init
Interface to the C function @cfunc{inotify_init}, see the manual page
@code{inotify_init(2)}.  Initialise a new @code{inotify} instance; if
successful return a file descriptor associated to a new event queue,
else raise an exception.
@end defun


@defun inotify-init1 @var{flags}
Interface to the C function @cfunc{inotify_init1}, see the manual page
@code{inotify_init1(2)}.  Initialise a new @code{inotify} instance; if
successful return a file descriptor associated to a new event queue,
else raise an exception.

@var{flags} must be a fixnum representing the bitwise inclusive OR
combination of @code{IN_NONBLOCK} and @code{IN_CLOEXEC}.
@end defun


@defun inotify-add-watch @var{fd} @var{pathname} @var{mask}
Interface to the C function @cfunc{inotify_add_watch}, see the manual
page @code{inotify_add_watch(2)}.  Add a watch to an initialised
@code{inotify} instance; if successful return an exact integer
representing watch descriptor, else raise an exception.

@var{fd} must be a finxum representing the file descriptor associated to
the @code{inotify} instance.  @var{pathname} must be a Scheme string or
bytevector representing the pathname to watch.  @var{mask} must be an
exact integer in the range of the C language type @code{uint32_t}
representing the watch mask.
@end defun


@defun inotify-rm-watch @var{fd} @var{wd}
Interface to the C function @cfunc{inotify_rm_watch}, see the manual
page @code{inotify_rm_watch(2)}.  Remove an existing watch from an
@code{inotify} instance; if successful return unspecified values, else
raise an exception.

@var{fd} must be a fixnum representing the file descriptor associated to
the @code{inotify} instance.  @var{wd} must be an exact integer in the
range of the C language type @code{int} representing the watch
descriptor.
@end defun


The following meaningless example shows how to watch for a modification
event on a file:

@example
#!r6rs
(import (vicare)
  (prefix (vicare linux) lx.)
  (prefix (vicare posix) px.)
  (vicare platform-constants)
  (vicare syntactic-extensions))

(let* ((infd     (lx.inotify-init))
       (pathname "inotify.test")
       (fd       (px.open pathname
                          (fxior O_CREAT O_EXCL O_RDWR)
                          (fxior S_IRUSR S_IWUSR))))
  (unwind-protect
       (let ((wd (lx.inotify-add-watch infd pathname
                                       IN_MODIFY)))
         (unwind-protect
              (begin
                (px.write fd #vu8(1 2 3))
                ;; let the event happen
                (px.select-fd infd 1 0)
                (let ((ev (lx.inotify-read infd)))
                  (lx.struct-inotify-event? ev)
                  @result{} #t
                  (= wd (lx.struct-inotify-event-wd ev))
                  @result{} #t
                  (lx.struct-inotify-event-len ev)
                  @result{} 0
                  (lx.struct-inotify-event-name ev)
                  @result{} #f
                  ))
              (lx.inotify-rm-watch infd wd)))
     (px.close fd)
     (delete-file pathname)))
@end example

@c page
@node syslib
@chapter Low level, fast, unsafe operations


The bindings documented in this chapter are low level operations inlined
by the compiler; mostly they are defined in the source file
@file{pass-specify-rep-primops.ss}.

They are unsafe because when acting upon wrong arguments will cause
undefined behaviour (probably a crash).  They are also faster than the
public interface exported by @library{ikarus} and @library{rnrs}.

@menu
* syslib symbols::              Low level symbol operations.
* syslib fixnums::              Low level fixnum operations.
* syslib bignums::              Low level bignum operations.
* syslib flonums::              Low level flonum operations.
* syslib ratnums::              Low level ratnum operations.
* syslib compnums::             Low level compnum operations.
* syslib cflonums::             Low level cflonum operations.
* syslib chars::                Low level character operations.
* syslib pairs::                Low level pair operations.
* syslib structs::              Low level structure operations.
* syslib vectors::              Low level vector operations.
* syslib bytevectors::          Low level bytevector operations.
* syslib strings::              Low level string operations.
* syslib ports::                Low level port structures.
* syslib transcoders::          Low level transcoder operations.
* syslib pointers::             Low level pointer operations.
@end menu

@c page
@node syslib symbols
@section Low level symbol operations


The arguments @var{sym} must be references to symbol blocks, the
arguments @var{str} must be references to strings.  The following
bindings are exported by the @library{ikarus system $symbols} library.


@deffn {Unsafe Operation} $make-symbol @var{str}
Allocate a new symbol block and initialise the @code{string} field with
@var{str}; return the reference to the symbol block.

The @code{ustring} is initialised to the fixnum zero.  The @code{value}
and @code{proc} fields are initialised to a special machine word value
meaning ``unbound''.  The @code{plist} field is initialised to nil.
@end deffn


@deffn {Unsafe Operation} $symbol-string @var{sym}
@deffnx {Unsafe Operation} $symbol-unique-string @var{sym}
@deffnx {Unsafe Operation} $symbol-plist @var{sym}
@deffnx {Unsafe Operation} $symbol-value @var{sym}
Accessors for the fields of @var{sym}.
@end deffn


@deffn {Unsafe Operation} $set-symbol-string! @var{sym} @var{str}
@deffnx {Unsafe Operation} $set-symbol-unique-string! @var{sym} @var{str}
@deffnx {Unsafe Operation} $set-symbol-plist! @var{sym} @var{ell}
@deffnx {Unsafe Operation} $set-symbol-value! @var{sym} @var{val}
@deffnx {Unsafe Operation} $set-symbol-proc! @var{sym} @var{proc}
Mutators for the fields of @var{sym}.
@end deffn


@deffn {Unsafe Operation} $set-symbol-value/proc! @var{sym} @var{val}
Set both the fields @code{value} and @code{proc} of @var{sym} to
@var{val}.
@end deffn


@deffn {Unsafe Operation} $unbound-object? @var{sym}
Return true if the @func{$symbol-value} field of @var{sym} is set to the
special ``unbound'' machine word value.
@end deffn


@deffn {Unsafe Operation} top-level-value @var{sym}
Still to be documented.
@end deffn


@deffn {Unsafe Operation} $init-symbol-function! @var{sym} @var{proc}
Still to be documented.
@end deffn


The following bindings are related to the symbol table collecting
interned symbols.


@defun $symbol-table-size
Return the number of interned symbols.
@end defun


@defun $log-symbol-table-status
Write to the current error port a description of the current symbol
table status.  Example:

@example
vicare> (import (ikarus system $symbols))
vicare> ($log-symbol-table-status)
Vicare internal symbol table status:
        number of interned symbols: 2962
        number of hash table buckets: 4096

vicare>
@end example
@end defun

@c page
@node syslib fixnums
@section Low level fixnum operations


The following bindings are exported by the @library{ikarus system $fx}
library.  The arguments to these operations must be fixnums.
@ref{objects fixnums} for details on the representation of fixnums.


@deffn {Unsafe Operation} $fxzero? @var{fx}
Evaluate to true if @var{fx} is zero.
@end deffn


@deffn {Unsafe Operation} $fx= @vari{fx} @varii{fx}
Evaluate to true if the arguments are equal.
@end deffn


@deffn {Unsafe Operation} $fx< @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is less than @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fx<= @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is less than or equal to @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fx> @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is greater than @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fx>= @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is greater than or equal to @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fxadd1 @var{fx}
Increment the operand by one and return the result.
@end deffn


@deffn {Unsafe Operation} $fxsub1 @var{fx}
Decrement the operand by one and return the result.
@end deffn


@deffn {Unsafe Operation} $fx+ @vari{fx} @varii{fx}
Sum the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fx- @vari{fx} @varii{fx}
Subtract the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fx* @vari{fx} @varii{fx}
Multiply the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlognot @var{fx}
Perform the bitwise NOT on the operand and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlogand @vari{fx} @varii{fx}
Perform the bitwise AND on the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlogor @vari{fx} @varii{fx}
Perform the bitwise inclusive OR on the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlogxor @vari{fx} @varii{fx}
Perform the bitwise exclusive OR on the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxsll @vari{fx} @varii{fx}
Perform bitwise shift left of @vari{fx} by @varii{fx} positions and
return the result.
@end deffn


@deffn {Unsafe Operation} $fxsra @vari{fx} @varii{fx}
Perform bitwise shift right of @vari{fx} by @varii{fx} positions and
return the result.
@end deffn


@deffn {Unsafe Operation} $fxquotient @vari{fx} @varii{fx}
Compute the quotient between the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxinthash @var{fx}
Evaluate to a fixnum which can be used as hash value.

@quotation
@strong{NOTE}  This appears to be unused in the source.
@end quotation
@end deffn

@c page
@node syslib bignums
@section Low level bignum operations


The arguments @var{bn} to these operations must be bignums.  The
following bindings are exported by the @library{ikarus system $bignums}
library.  @ref{iklib numerics} for more functions acting on bignums.


@deffn {Unsafe Operation} $bignum-positive? @var{bn}
Evaluate to true if the operand is positive.
@end deffn


@deffn {Unsafe Operation} $bignum-byte-ref @var{bn} @var{fx}
Return a fixnum representing the byte at index @var{fx} in the data of
@var{bn}.
@end deffn


@deffn {Unsafe Operation} $bignum-size @var{bn}
Return a fixnum representing the number of machine words in the data
portion of a bignum memory block.
@end deffn

@c page
@node syslib flonums
@section Low level flonum operations


The arguments @var{fl} to these operations must be flonums, the
arguments @var{fx} must be fixnums.  The following bindings are exported
by the @library{ikarus system $flonums} library.  @ref{iklib numerics}
for more functions acting on flonums.


@deffn {Unsafe Operation} $make-flonum
Allocate a new flonum memory block and return a reference to it.  Does
not initialise the data area.
@end deffn


@deffn {Unsafe Operation} $flonum-u8-ref @var{fl} @var{fx}
Return the octet at index @var{fx} in the data area of @var{fl}.
@end deffn


@deffn {Unsafe Operation} $flonum-set! @var{fl} @var{fx-index} @var{fx-value}
Store the byte or octet represented by @var{fx-value} at index
@var{fx-index} in the data area of @var{fl}.
@end deffn


@deffn {Unsafe Operation} $fixnum->flonum @var{fx}
Convert the fixnum operand into a flonum and return a reference to the
result.
@end deffn


@deffn {Unsafe Operation} $fl+ @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl- @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl* @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl/ @vari{fl} @varii{fl}
Perform arithmetic operations.
@end deffn


@deffn {Unsafe Operation} $fl= @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl< @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl<= @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl> @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl>= @vari{fl} @varii{fl}
Perform comparison operations
@end deffn


@deffn {Unsafe Operation} $flonum-sbe @var{fl}
Return a fixnum@dots{} Still undocumented, read the code look at the
format of @ieee{} double precision flonums.
@end deffn

@c page
@node syslib ratnums
@section Low level ratnum operations


The arguments @var{rat} to these operations must be ratnums, the
arguments @var{num} must be references to either fixnums or bignums.
The following bindings are exported by the @library{ikarus system
$ratnums} library.  @ref{iklib numerics} for more functions acting on
ratnums.


@deffn {Unsafe Operation} $make-ratnum @vari{num} @varii{num}
Allocate a new ratnum memory block, store @vari{num} as reference to the
numerator and @varii{num} as reference to the denominator.  Return a
reference to the ratnum.
@end deffn


@deffn {Unsafe Operation} $ratnum-n @var{rat}
Return the reference to the numerator.
@end deffn


@deffn {Unsafe Operation} $ratnum-d @var{rat}
Return the reference to the denominator.
@end deffn

@c page
@node syslib compnums
@section Low level compnum operations


The arguments @var{cmp} to these operations must be compnums, the
arguments @var{num} must be references to either fixnums, bignums or
flonums.  The following bindings are exported by the @library{ikarus
system $compnums} library.  @ref{iklib numerics} for more functions
acting on compnums.


@deffn {Unsafe Operation} $make-compnum @vari{num} @varii{num}
Allocate a new compnum memory block, store @vari{num} as reference to
the real part and @varii{num} as reference to the imaginary part.
Return a reference to the compnum.
@end deffn


@deffn {Unsafe Operation} $compnum-real @var{cmp}
Return the reference to the real part.
@end deffn


@deffn {Unsafe Operation} $compnum-imag @var{cmp}
Return the reference to the imaginary part.
@end deffn

@c page
@node syslib cflonums
@section Low level cflonum operations


The arguments @var{cmp} to these operations must be cflonums, the
arguments @var{fl} must be references to flonums.  The following
bindings are exported by the @library{ikarus system $compnums} library.
@ref{iklib numerics} for more functions acting on cflonums.


@deffn {Unsafe Operation} $make-cflonum @vari{fl} @varii{fl}
Allocate a new cflonum memory block, store @vari{fl} as reference to the
real part and @varii{fl} as reference to the imaginary part.  Return a
reference to the cflonum.
@end deffn


@deffn {Unsafe Operation} $cflonum-real @var{cmp}
Return the reference to the real part.
@end deffn


@deffn {Unsafe Operation} $cflonum-imag @var{cmp}
Return the reference to the imaginary part.
@end deffn

@c page
@node syslib chars
@section Low level character operations


The arguments @var{ch} to these operations must be characters, the
arguments @var{fx} must be fixnums in the range @code{[0, #x10FFFF]} but
not in the range @code{[#xD800, #xDFFF]}.  The following bindings are
exported by the @library{ikarus system $chars} library.


@deffn {Unsafe Operation} $char= @vari{ch} @varii{ch}
Evaluate to true if the operands are equal.
@end deffn


@deffn {Unsafe Operation} $char< @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is less than @varii{ch}.
@end deffn


@deffn {Unsafe Operation} $char<= @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is less than or equal to @varii{ch}.
@end deffn


@deffn {Unsafe Operation} $char> @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is greater than @varii{ch}.
@end deffn


@deffn {Unsafe Operation} $char>= @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is greater than or equal to
@varii{ch}.
@end deffn


@deffn {Unsafe Operation} $fixnum->char @var{fx}
Return a new character value whose code point equals @var{fx}.
@end deffn


@deffn {Unsafe Operation} $char->fixnum @var{ch}
Return a fixnum representing the code point of the operand.
@end deffn

@c page
@node syslib pairs
@section Low level pair operations


The arguments @var{P} to these operations must be pairs.  The following
bindings are exported by the @library{ikarus system $pairs} library.
@ref{objects pairs} for details of pair representation.


@deffn {Unsafe Operation} $car @var{P}
Return the car of the operand.
@end deffn


@deffn {Unsafe Operation} $cdr @var{P}
Return the cdr of the operand.
@end deffn


@deffn {Unsafe Operation} $set-car! @var{P} @var{value}
Store @var{value} in the car location of @var{P}.
@end deffn


@deffn {Unsafe Operation} $set-cdr! @var{P} @var{value}
Store @var{value} in the cdr location of @var{P}.
@end deffn

@c page
@node syslib structs
@section Low level structure operations


The arguments @var{stru} to these operations must be references to data
structures, the arguments @var{rtd} must be references to structure type
descriptors, the arguments @var{fx} must be fixnums of appropriate
value.  The following bindings are exported by the @library{ikarus
system $structs} library.


@deffn {Unsafe Operation} base-rtd
Return a reference to the type descriptor used as type for all the type
descriptors.
@end deffn


@deffn {Unsafe Operation} $struct? @var{obj}
Evaluate to true if @var{obj} is the reference to a structure.
@end deffn


@deffn {Unsafe Operation} $struct/rtd? @var{stru} @var{rtd}
Evaluate to true if @var{stru} is a structure of type @var{rtd}.
@end deffn


@deffn {Unsafe Operation} $make-struct @var{rtd} @var{fx}
Allocate a new data structure of type @var{rtd} capable of holding
@var{fx} words and return a reference to it.

@quotation
@strong{NOTE} This operation does @strong{not} initialise the field
words, leaving them holding whatever is on the heap.  We must be careful
not to trigger a garbage collection before those fields are initialised
with valid values, else the behaviour is undefined.
@end quotation
@end deffn


@deffn {Unsafe Operation} $struct-rtd @var{stru}
Return a reference to the type descriptor of @var{stru}.
@end deffn


@deffn {Unsafe Operation} $struct-ref @var{stru} @var{fx}
Return the value in the field at index @var{fx} of @var{stru}.
@end deffn


@deffn {Unsafe Operation} $struct-set! @var{stru} @var{fx} @var{value}
Store @var{value} in the field at index @var{fx} of @var{stru}.
@end deffn


@deffn {Unsafe Operation} $struct @var{rtd} @var{value} ...
Allocate a new data structure of type @var{rtd} capable of holding as
many words as given @var{value} arguments and initialise the fields with
such values.  Return a reference to the structure.
@end deffn

@c page
@node syslib vectors
@section Low level vector operations


The arguments @var{vec} to these operations must be fixnums, the
arguments @var{fx} must be fixnums.  The following bindings are exported
by the @library{ikarus system $vectors} library.


@deffn {Unsafe Operation} $make-vector @var{fx}
Allocate and return a new vector value of @var{fx} elements.

@quotation
@strong{NOTE} This operation does not initialise the data area, leaving
the items set to whatever is on the Scheme heap; this is bad for garbage
collection if the newly built vector is moved before the items are
initialised to correct Scheme values.  We should use the
@func{$make-clean-vector} operations from @library{vicare
unsafe-operations}.
@end quotation
@end deffn


@deffn {Unsafe Operation} $vector-length @var{vec}
Evaluate to a fixnum representing the numbe of values in @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-ref @var{vec} @var{fx}
Return the value at index @var{fx} in @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-set! @var{vec} @var{fx} @var{value}
Store @var{value} at index @var{fx} in @var{vec}.
@end deffn

@c page
@node syslib bytevectors
@section Low level bytevector operations


The arguments @var{bv} to these operations must be references to
bytevectors, the arguments @var{fx} must be fixnums in the appropriate
range, the arguments @var{fl} must be flonums.  The following bindings
are exported by the @library{ikarus system $bytevectors} library.


@deffn {Unsafe Operation} $make-bytevector @var{fx}
Allocate a new bytevector capable of holding @var{fx} bytes and return a
reference to it.
@end deffn


@deffn {Unsafe Operation} $bytevector-length @var{bv}
Return a fixnum representing the number of bytes in the operand.
@end deffn


@deffn {Unsafe Operation} $bytevector-u8-ref @var{bv} @var{fx}
Return a fixnum representing the octet at offset @var{fx} in @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-s8-ref @var{bv} @var{fx}
Return a fixnum representing the byte at offset @var{fx} in @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-set! @var{bv} @var{fx-index} @var{fx-value}
Store the octet or byte @var{fx-value} at index @var{fx-index} of
@var{bv}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Double--precision @ieee{} flonums


@deffn {Unsafe Operation} $bytevector-ieee-double-native-ref @var{bv} @var{fx}
Return a flonum representing the value at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-double-native-set! @var{bv} @var{fx} @var{fl}
Store @var{fl} at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-double-nonnative-ref @var{bv} @var{fx}
Return a flonum representing the value at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-double-nonnative-set! @var{bv} @var{fx} @var{fl}
Store @var{fl} at index @var{fx} of @var{bv}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Single--precision @ieee{} flonums


@deffn {Unsafe Operation} $bytevector-ieee-single-native-ref @var{bv} @var{fx}
Return a flonum representing the value at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-single-native-set! @var{bv} @var{fx} @var{fl}
Store @var{fl} at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-single-nonnative-ref @var{bv} @var{fx}
Return a flonum representing the value at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-single-nonnative-set! @var{bv} @var{fx} @var{fl}
Store @var{fl} at index @var{fx} of @var{bv}.
@end deffn

@c page
@node syslib strings
@section Low level string operations


The arguments @var{str} to these operations must be references to
strings, the arguments @var{fx} must be fixnums in the appropriate
range, the arguments @var{ch} must be characters.  The following
bindings are exported by the @library{ikarus system $strings} library.


@deffn {Unsafe Operation} $make-string @var{fx}
Allocate a new string capable of holding @var{fx} characters and return
a reference to it.
@end deffn


@deffn {Unsafe Operation} $string-length @var{str}
Return a fixnum representing the length of the operand.
@end deffn


@deffn {Unsafe Operation} $string-ref @var{str} @var{fx}
Return the character at offset @var{fx} in @var{str}.
@end deffn


@deffn {Unsafe Operation} $string-set! @var{str} @var{fx} @var{ch}
Store @var{ch} at index @var{fx} of @var{str}.
@end deffn

@c page
@node syslib ports
@section Low level port structures


The following bindings are exported by the @library{ikarus system $io}
library.


@defun port? @var{obj}
Return true if @var{obj} is the reference to a port structure; return
false otherwise.
@end defun


@deffn {Unsafe Operation} $make-port @var{attrs} @var{idx} @var{sz} @var{buf} @var{tr} @var{id} @var{read} @var{write} @var{getp} @var{setp} @var{cl} @var{cookie}
Allocate a new port structure, initialise its fields with the arguments,
return a reference to it.
@end deffn


@deffn {Unsafe Operation} $port-index @var{port}
@deffnx {Unsafe Operation} $port-size @var{port}
@deffnx {Unsafe Operation} $port-buffer @var{port}
@deffnx {Unsafe Operation} $port-transcoder @var{port}
@deffnx {Unsafe Operation} $port-id @var{port}
@deffnx {Unsafe Operation} $port-read! @var{port}
@deffnx {Unsafe Operation} $port-write! @var{port}
@deffnx {Unsafe Operation} $port-get-position @var{port}
@deffnx {Unsafe Operation} $port-set-position! @var{port}
@deffnx {Unsafe Operation} $port-close @var{port}
@deffnx {Unsafe Operation} $port-cookie @var{port}
Accessors for the fields of a port structure.
@end deffn


@deffn {Unsafe Operation} $port-attrs @var{port}
Given a port value: return a fixnum representing the port attributes.
@end deffn


@deffn {Safe Operation} $port-tag @var{port}
Extract from a port reference a fixnum representing the port attributes;
if the argument is not a port reference the return value is zero.
@end deffn


@deffn {Unsafe Operation} $set-port-index! @var{port} @var{new-index}
Mutator for the buffer index field.
@end deffn


@deffn {Unsafe Operation} $set-port-size! @var{port} @var{new-used-size}
Mutator for the buffer used size field.
@end deffn


@deffn {Unsafe Operation} $set-port-attrs! @var{port} @var{new-attrs}
Mutator for the port attributes.
@end deffn

@c page
@node syslib transcoders
@section Low level transcoder operations


The arguments @var{tran} to these operations must be transcoders, the
arguments @var{fx} must be fixnums in the appropriate range.  The
following bindings are exported by the @library{ikarus system
$transcoders} library.


@deffn {Unsafe Operation} $data->transcoder @var{fx}
Encode @var{fx} as payload bits of a transcoder word and return the
resulting transcoder.
@end deffn


@deffn {Unsafe Operation} $transcoder->data @var{tran}
Extract the payload bits from a transcoder and return them as fixnum.
@end deffn

@c page
@node syslib pointers
@section Low level pointer operations


In the following definitions the @var{ptr} arguments must be pointer
objects.


@deffn {Primitive Operation} $pointer? @var{obj}
Return @true{} if @var{obj} is a reference to a pointer memory block,
else return @false{}.
@end deffn


@deffn {Unsafe Operation} $pointer= @vari{ptr} @varii{ptr}
Return @true{} if @vari{ptr} and @varii{ptr} are equal, else return
@false{}.
@end deffn

@c page
@node capi
@chapter C language programming interface


The executable @value{EXECUTABLE} defines a number of C language
functions that can be invoked by compiled code to access various
services, both to handle startup and to access the operating system.

When on a @gnu{}+Linux system: the Linux specific functions are
available; when on other systems: calling such functions will terminate
the process.

@menu
* capi ffi::                    C language level @ffi{}.
* capi posix::                  C language level @posix{} interface.
* capi linux::                  C language level @gnu{}+Linux interface.
* capi glibc::                  C language level @gnu{} C Library
                                interface.
@end menu

@c page
@node capi ffi
@section C language level @ffi{}


@menu
* capi ffi accessors::          Raw memory accessors.
* capi ffi mutators::           Raw memory mutators.
@end menu

@c page
@node capi ffi accessors
@subsection Raw memory accessors


@subsubheading Bit--sized values

In all the following definitions: @var{pointer} must be a pointer
object, @var{offset} must be an exact integer.


@deftypefun ikptr ikrt_ref_uint8 (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the 8-bit unsigned integer at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_sint8 (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the 8-bit signed integer at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_uint16 (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the 16-bit unsigned integer at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_sint16 (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the 16-bit signed integer at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_uint32 (ikptr @var{pointer}, ikptr @var{offset}, ikpcb * @var{pcb})
Extract and return the 32-bit unsigned integer at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_sint32 (ikptr @var{pointer}, ikptr @var{offset}, ikpcb * @var{pcb})
Extract and return the 32-bit signed integer at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_uint64 (ikptr @var{pointer}, ikptr @var{offset}, ikpcb * @var{pcb})
Extract and return the 64-bit unsigned integer at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_sint64 (ikptr @var{pointer}, ikptr @var{offset}, ikpcb * @var{pcb})
Extract and return the 64-bit signed integer at @var{offset} from
@var{pointer}.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading C language integer type--sized values

In all the following definitions: @var{pointer} must be a pointer
object, @var{offset} must be an exact integer.


@deftypefun ikptr ikrt_ref_char (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the exact integer representation of the C language
@code{signed char} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_uchar (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the exact integer representation of the C language
@code{unsigned char} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_short (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the exact integer representation of the C language
@code{signed short int} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_ushort (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the exact integer representation of the C language
@code{unsigned short int} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_long (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the exact integer representation of the C language
@code{signed long} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_ulong (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the exact integer representation of the C language
@code{unsigned long} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_longlong (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the exact integer representation of the C language
@code{signed long long} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_ulonglong (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the exact integer representation of the C language
@code{unsigned long long} value at @var{offset} from @var{pointer}.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Other C language type--sized values

In all the following definitions: @var{pointer} must be a pointer
object, @var{offset} must be an exact integer.


@deftypefun ikptr ikrt_ref_float (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the flonum representation of the C language
@code{float} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_double (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the flonum representation of the C language
@code{double} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_ref_pointer (ikptr @var{pointer}, ikptr @var{offset})
Extract and return the pointer representation of the C language
@code{void *} value at @var{offset} from @var{pointer}.
@end deftypefun

@c page
@node capi ffi mutators
@subsection Raw memory mutators


@subsubheading Bit--sized values

In all the following definitions: @var{pointer} must be a pointer
object, @var{offset} and @var{value} must be an exact integers.


@deftypefun ikptr ikrt_set_uint8 (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the 8-bit unsigned integer @var{value} at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_sint8 (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the 8-bit signed integer @var{value} at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_uint16 (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the 16-bit unsigned integer @var{value} at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_sint16 (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the 16-bit signed integer @var{value} at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_uint32 (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the 32-bit unsigned integer @var{value} at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_sint32 (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the 32-bit signed integer @var{value} at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_uint64 (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the 64-bit unsigned integer @var{value} at @var{offset} from
@var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_sint64 (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the 64-bit signed integer @var{value} at @var{offset} from
@var{pointer}.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading C language integer type--sized values

In all the following definitions: @var{pointer} must be a pointer
object, @var{offset} and @var{value} must be an exact integers.


@deftypefun ikptr ikrt_set_char (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the exact integer @var{value} representing a C language
@code{signed char} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_uchar (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the exact integer @var{value} representing a C language
@code{unsigned char} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_short (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the exact integer @var{value} representing a C language
@code{signed short int} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_ushort (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the exact integer @var{value} representing a C language
@code{unsigned short int} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_int (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the exact integer @var{value} representing a C language
@code{signed int} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_uint (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the exact integer @var{value} representing a C language
@code{unsigned int} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_long (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the exact integer @var{value} representing a C language
@code{signed long} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_ulong (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the exact integer @var{value} representing a C language
@code{unsigned long} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_longlong (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the exact integer @var{value} representing a C language
@code{signed long long} value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_ulonglong (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the exact integer @var{value} representing a C language
@code{unsigned long long} value at @var{offset} from @var{pointer}.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Other C language type--sized values

In all the following definitions: @var{pointer} must be a pointer
object, @var{offset} must be an exact integer.


@deftypefun ikptr ikrt_set_float (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the flonum @var{value} representing a C language @code{float}
value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_double (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the flonum @var{value} representing a C language @code{double}
value at @var{offset} from @var{pointer}.
@end deftypefun


@deftypefun ikptr ikrt_set_pointer (ikptr @var{pointer}, ikptr @var{offset}, ikptr @var{value})
Store the pointer @var{value} representing a C language @code{void *}
value at @var{offset} from @var{pointer}.
@end deftypefun

@c page
@node capi posix
@section C language level @posix{} interface


Several files are involved in the full implementation of the @posix{}
interface:

@example
src/ikarus-posix.c
lib/vicare/unsafe-capi.sls
scheme/ikarus.posix.sls
scheme/makefile.sps
tests/test-vicare-posix.sps
@end example

File pathnames are bytevectors at the C language level and strings at
the Scheme language level; the conversion is performed with the function
in the parameter @func{string->filename-func}.

The authoritative documentation for all the interface functions is the
one of the C library on the platform's operating system; this file gives
only a brief overview of the features and explains the Scheme
adaptation.

@menu
* capi posix adding::           How to add a @posix{} primitive.
* capi posix errno::            Handling @code{errno} codes.
* capi posix env::              Operating system environment variables.
* capi posix port::             File descriptors and Scheme ports.
* capi posix pid::              Process identifier functions.
* capi posix process::          Forking and executing processes.
* capi posix status::           Process termination status.
* capi posix signals::          Delivering interprocess signals.
* capi posix stat::             File system inspection.
* capi posix file::             File system interface.
* capi posix link::             Hard and symbolic links.
* capi posix dir::              File system directories.
* capi posix fd::               File descriptors at low level.
* capi posix socket::           Network sockets.
* capi posix users::            Users and groups.
* capi posix job::              Job control.
* capi posix time::             Time and date.
@end menu

@c page
@node capi posix adding
@subsection How to add a @posix{} primitive


We must remember that the @posix{} primitives end up exported by both
the @library{vicare} and @library{ikarus} libraries; following the
example of the @cfunc{getpid} function, to add a @posix{} primitive we
should follow these steps:

@enumerate
@item
In the file @file{src/ikarus-posix.c} add the primitive C language
function:

@example
ikptr
ikrt_posix_getpid(void)
@{
  int   retval = getpid();
  return fix(retval);
@}
@end example

@item
In the file @file{lib/vicare/unsafe-capi.sls} add the following macro
definition to the library:

@example
(define-inline (posix-getpid)
  (foreign-call "ikrt_posix_getpid"))
@end example

@noindent
and add the binding to the export list.

@item
In the file @file{scheme/ikarus.posix.sls}: add the binding to both the
export list of the library and to the @code{except} import list from
@library{ikarus}; add the function implementation calling a syntax
associated to the foreign function:

@example
(define (getpid)
  (posix-getpid))
@end example

@item
In the file @file{scheme/makefile.sps}: add an entry for the function to
the list bound to @code{identifier->library-map} to have the function
exported by @library{ikarus} and @library{vicare}:

@example
(getpid         i v)
@end example

@item
In the file @file{tests/test-vicare-posix.sps} add test cases for the
function.
@end enumerate

@c page
@node capi posix errno
@subsection Handling @code{errno} codes


@value{PRJNAME} makes use of the platform's own @code{errno} codes; they
are negated to make them different from file descriptors, and so
distinguishable when used as single return values from C functions, and
converted to fixnums.  Example: if the C language code for @code{EPERM}
is the integer @code{1}, the corresponding Scheme language value is the
fixnum @code{-1}.


@deftypefun ikptr ik_errno_to_code (void)
Negate the current @code{errno} value and convert the result into a
fixnum, return the fixnum.  When an error occurs: many functions call
this function and return its return value.
@end deftypefun


@deftypefun ikptr ikrt_strerror (ikptr @var{ec}, ikpcb * @var{pcb})
Interface to the C function @cfunc{strerror}, @glibcref{Error Messages,
strerror}.  Convert a fixnum representing an encoded @code{errno} code
into a bytevector holding the string message which describes it; return
a reference to the bytevector; if @var{ec} is invalid: return false.
@end deftypefun


@deftypefun ikptr ikrt_last_errno (ikpcb * pcb)
Return a fixnum representing the negated value of @code{errno} right
after the last call to a foreign function through the @ffi{}.
@end deftypefun

@c page
@node capi posix env
@subsection Accessing environment variables


@deftypefun ikptr ikrt_posix_getenv (ikptr @var{variable}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getenv}, @glibcref{Environment
Access, getenv}.  Retrieve the value of environment variables.
@var{variable} must reference a bytevector object representing the name
of the environment variable.  If the environment variable is set: return
a bytevector representing its value; else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_setenv (ikptr @var{variable}, ikptr @var{value}, ikptr @var{overwrite})
Interface to the C function @cfunc{setenv}, @glibcref{Environment
Access, setenv}.  Set a new value for an environment variable.

@var{variable} must reference a bytevector object representing the name
of the environment variable; @var{value} must reference a bytevector
object representing the new value.  If @var{overwrite} is
@code{IK_FALSE_OBJECT} and the environment variable already exists: the
environment variable is left untouched; else the new value is set,
either creating a new environment variable or replacing the old value.

If successful return @code{IK_TRUE_OBJECT}; if an error occurs in
@cfunc{setenv} return @code{IK_FALSE_OBJECT}.
@end deftypefun


@deftypefun ikptr ikrt_posix_unsetenv (ikptr @var{variable})
Interface to the C function @cfunc{unsetenv}, @glibcref{Environment
Access, unsetenv}.  Unset an environment variable.  @var{variable} must
reference a bytevector object representing the name of the environment
variable.  Return true if @var{variable} has the correct format, else
return false; there is no way to know if a variable was actually unset.
@end deftypefun


@deftypefun ikptr ikrt_posix_environ (ikpcb * @var{pcb})
Interface to the global C variable @code{environ}, @glibcref{Environment
Access, unsetenv}.  Retrieve the full environment.  Return a list of
bytevectors representing the contents of the @code{environ} array; if
the environment is empty (no environment variables set) return nil.
@end deftypefun

@c page
@node capi posix port
@subsection File descriptors and Scheme ports


@menu
* capi posix port open::        Opening and closing file descriptors.
* capi posix port seek::        Handling file descriptor cursor.
* capi posix port rw::          Reading and writing.
* capi posix port event::       Handling file descriptor events.
* capi posix port net::         Handling sockets.
@end menu

@c page
@node capi posix port open
@subsubsection Opening and closing file descriptors


@deftypefun ikptr ikrt_close_fd (ikptr @var{fd})
Interface to the @cfunc{close} C function.  @glibcref{Opening and
Closing Files, close}.  Close a file descriptor.

@var{fd} must be a fixnum representing a file descriptor.

If successful return @code{IK_FALSE_OBJECT}; if an error occurs in
@cfunc{close} return the return value of @cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_open_input_fd (ikptr @var{pathname})
Interface to the @cfunc{open} C function.  @glibcref{Opening and Closing
Files, open}.  Open a file for reading, using open mode @code{O_RDONLY}.

@var{pathname} must reference a bytevector object holding the file
pathname.

If successful return a fixnum representing the file descriptor; if an
error occurs in @cfunc{open} return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_open_output_fd (ikptr @var{pathname}, ikptr @var{opts})
Interface to the @cfunc{open} C function.  @glibcref{Opening and Closing
Files, open}.  Open a file for writing with configurable mode based on
@code{O_WRONLY}; the access permissions when a new file is created are
@code{S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH}.

@var{pathname} must reference a bytevector object holding the file
pathname; @var{opts} must be a fixnum with the following encoding:

@table @code
@item 0
The open mode is @code{O_WRONLY | O_CREAT | O_EXCL}.

@item 1
The open mode is @code{O_WRONLY | O_TRUNC}.

@item 2
The open mode is @code{O_WRONLY | O_TRUNC | O_CREAT}.

@item 3
The open mode is @code{O_WRONLY | O_TRUNC}.

@item 4
The open mode is @code{O_WRONLY | O_CREAT | O_EXCL}.

@item 5
The open mode is @code{O_WRONLY | O_CREAT}.

@item 6
The open mode is @code{O_WRONLY | O_CREAT}.

@item 7
The open mode is @code{O_WRONLY}.
@end table

If successful return a fixnum representing the file descriptor; if an
error occurs in @cfunc{open} return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_open_input_output_fd (ikptr @var{pathname}, ikptr @var{opts})
Interface to the @cfunc{open} C function.  @glibcref{Opening and Closing
Files, open}.  Open a file for reading and writing with configurable
mode based on @code{O_RDWR}; the access permissions when a new file is
created are @code{S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH}.

@var{pathname} must reference a bytevector object holding the file
pathname; @var{opts} must be a fixnum representing the opening flags, it
has the same format of the @var{opts} argument to
@func{ikrt_open_output_fd}.

If successful return a fixnum representing the file descriptor; if an
error occurs in @cfunc{open} return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun

@c page
@node capi posix port seek
@subsubsection Handling file descriptor cursor


@deftypefun ikptr ikrt_set_position (ikptr @var{fd}, ikptr @var{pos})
Interface to the @cfunc{lseek} C function.  @glibcref{File Position
Primitive, lseek}.  Set the cursor position.

@var{fd} must be a fixnum representing a file descriptor; @var{pos} must
be an exact integer in the range of the @code{off_t} platform type.

If successful return @code{IK_FALSE_OBJECT}; if an error occurs in
@cfunc{lseek} return the return value of @cfunc{ik_errno_to_code}.
@end deftypefun

@c page
@node capi posix port rw
@subsubsection Reading and writing


@deftypefun ikptr ikrt_read_fd (ikptr @var{fd}, ikptr @var{buffer}, ikptr @var{buffer-start}, ikptr @var{size})
Interface to the @cfunc{read} C function.  @glibcref{Input and Output
Primitives, read}.  Read data from a file descriptor.

@var{fd} must be a fixnum representing a file descriptor; @var{buffer}
must reference a bytevector object in which the data will be stored;
@var{buffer-start} must be a fixnum representing the offset in the
buffer at which data will be written; @var{size} must be a fixnum
representing the number of bytes to read.

If successful return a fixnum representing the number of bytes actually
read and stored in the buffer; if an error occurs in @cfunc{read} return
the return value of @cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_write_fd (ikptr @var{fd}, ikptr @var{buffer}, ikptr @var{buffer-start}, ikptr @var{size})
Interface to the @cfunc{write} C function.  @glibcref{Input and Output
Primitives, write}.  Write data to a file descriptor.

@var{fd} must be a fixnum representing a file descriptor; @var{buffer}
must reference a bytevector object from which the data will be read;
@var{buffer-start} must be a fixnum representing the offset in the
buffer from which data will be read; @var{size} must be a fixnum
representing the number of bytes to write.

If successful return a fixnum representing the number of bytes actually
written; if an error occurs in @cfunc{write} return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun

@c page
@node capi posix port event
@subsubsection Handling file descriptor events


@deftypefun ikptr ikrt_select (ikptr @var{max-fd}, ikptr @var{rfds}, ikptr @var{wfds}, ikptr @var{xfds})
Interface to the @cfunc{select} C function.  @glibcref{Waiting for I/O,
select}.  Poll for events on sets of file descriptors, without timeout.

@var{max-fd} must be a fixnum representing the maximum file descriptor
for which to wait for events; @var{rfds}, @var{wfds} and @var{xfds} must
reference bytevectors holding @code{fd_set} data structures.

If successful return a fixnum representing the return value from
@cfunc{select}; if an error occurs in @cfunc{select} return the return
value of @cfunc{ik_errno_to_code}.  Notice that if the call is
interrupted by a signal, so it returns with @code{EINTR}, the function
returns with error without reattempting the call.
@end deftypefun


@deftypefun ikptr ikrt_make_fd_nonblocking (ikptr @var{fd})
Interface to the @cfunc{fcntl} C function.  @glibcref{Control
Operations, fcntl}.  Set non--blocking mode for a file descriptor.

@var{fd} must be a fixnum representing the file descriptor.

If successful return the raw C language @cnull{} pointer; if an error
occurs in @cfunc{fcntl} return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun

@c page
@node capi posix port net
@subsubsection Handling sockets


@deftypefun ikptr ikrt_tcp_connect (ikptr @var{host}, ikptr @var{srvc})
@deftypefunx ikptr ikrt_ucp_connect (ikptr @var{host}, ikptr @var{srvc})
Interface to the @cfunc{getaddrinfo}, @cfunc{socket} and @cfunc{connect}
C functions.  @glibcref{Sockets, Sockets}.  Establish a client
connection to a remote server using the @code{SOCK_STREAM} or
@code{SOCK_DGRAM} style.

@var{host} must reference a bytevector holding the remote server
hostname; @var{srvc} must reference a bytevector holding the service
specification.

If successful return a fixnum representing the socket; if an error
occurs resolving the host name and address, return @code{IK_FALSE_OBJECT};
if an error occurs in one of the C function calls, return the return
value of @cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_listen (ikptr @var{port-number})
Interface to the @cfunc{socket}, @cfunc{bind}, @cfunc{listen} and
@cfunc{setsockopt} C functions.  @glibcref{Sockets, Sockets}.  Create a
server socket bound to the given port number for the local host, using
the @code{AF_INET} namespace and the @code{SOCK_STREAM} style; the
option @code{SO_REUSEADDR} is set for the server socket; at most
@math{1024} concurrent connections to the socket will be enqueued.

@var{port-number} must be a fixnum representing the port number to use.

If successful return a fixnum representing the server socket; if an
error occurs in one of the C function calls, return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_accept (ikptr @var{sock}, ikptr @var{sockaddr})
Interface to the @cfunc{accept} C function.  @glibcref{Accepting
Connections, accept}.  Accept a connection to a server socket.

@var{sock} must be a fixnum representing the server socket;
@var{sockaddr} must reference a bytevector object which will hold the
@code{struct sockaddr} describing the client's address.

If successful return a fixnum representing the client socket and fill
@var{sockaddr} with the client address; if an error occurs in
@cfunc{accept}, return the return value of @cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_shutdown (ikptr @var{sock})
Interface to the @cfunc{shutdown} C function.  @glibcref{Closing a
Socket, shutdown}.  Close a socket for both reading and writing.

@var{sock} must be a fixnum representing the socket.

If successful return the raw C language @cnull{} pointer; if an error
occurs in @cfunc{shutdown}, return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun

@c page
@node capi posix pid
@subsection Process identifier functions


@deftypefun ikptr ikrt_posix_getpid (void)
Return the process identifier as fixnum.  @glibcref{Process
Identification, getpid}.
@end deftypefun


@deftypefun ikptr ikrt_posix_getppid (void)
Return the parent process identifier as fixnum.  @glibcref{Process
Identification, getpid}.
@end deftypefun

@c page
@node capi posix process
@subsection Forking and executing processes


@deftypefun ikptr ikrt_posix_system (ikptr @var{command})
Interface to the C function @cfunc{system}, @glibcref{Running a Command,
system}.  Execute a command through the system shell; @var{command} must
reference a bytevector object holding the command to execute.  If
successful return the termination status of the executed process,
@ref{capi posix status} for details; if an error occurs: return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_fork (void)
Interface to the C function @cfunc{fork}, @glibcref{Creating a Process,
fork}.  Create a new process by forking the current; if successful
return a non--negative fixnum representing the the return value of
@cfunc{fork}; if an error occurs: return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_execv (ikptr @var{filename}, ikptr @var{argv})
Interface to the C function @cfunc{execv}, @glibcref{Executing a File,
execv}.  @var{filename} must be a bytevector representing the pathname
of an executable file; @var{argv} must be a list of bytevectors
representing command line arguments.  Execute the command; if the
function returns: an error has occurred, return an encoded @code{errno}
value.
@end deftypefun


@deftypefun ikptr ikrt_posix_execve (ikptr @var{filename}, ikptr @var{argv}, ikptr @var{env})
Interface to the C function @cfunc{execve}, @glibcref{Executing a File,
execve}.  @var{filename} must be a bytevector representing the pathname
of an executable file; @var{argv} must be a list of bytevectors
representing command line arguments; @var{env} must be a list of
bytevectors representing environment variables assignments.  Execute the
command; if the function returns: an error has occurred, return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_execvp (ikptr @var{filename}, ikptr @var{argv})
Interface to the C function @cfunc{execvp}, @glibcref{Executing a File,
execvp}.  @var{filename} must be a bytevector representing the file name
of an executable file reachable in the current @env{PATH}; @var{argv}
must be a list of bytevectors representing command line arguments.
Execute the command; if the function returns: an error has occurred,
return an encoded @code{errno} value.
@end deftypefun

@c page
@node capi posix status
@subsection Process termination status


The following functions accept as argument a fixnum representing the
process termination status, for example the return value of
@cfunc{system} or the status acquired by @cfunc{waitpid}.


@deftypefun ikptr ikrt_posix_waitpid (ikptr @var{pid}, ikptr @var{options})
Interface to the C function @cfunc{waitpid}, @glibcref{Process
Completion, waitpid}.  Request status informations on a process or group
of processes knowing the identifier.  If successful return a fixnum
representing the status; if an error occurs: return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_wait (void)
Interface to the C function @cfunc{wait}, @glibcref{Process Completion,
wait}.  Request status informations on any process or group of
processes.  If successful return a fixnum representing the status; if an
error occurs: return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_WIFEXITED (ikptr @var{status})
Interface to the C macro @cfunc{WIFEXITED}, @glibcref{Process Completion
Status, WIFEXITED}.  Return true if the process terminated normally with
@cfunc{exit}.
@end deftypefun


@deftypefun ikptr ikrt_posix_WEXITSTATUS (ikptr @var{status})
Interface to the C macro @cfunc{WEXITSTATUS}, @glibcref{Process
Completion Status, WEXITSTATUS}.  If @cfunc{WIFEXITED} applied to
@var{status} would return true: return the low--order @math{8} bits from
the exit status, which is the process exit status selected with
@cfunc{exit}.
@end deftypefun


@deftypefun ikptr ikrt_posix_WIFSIGNALED (ikptr @var{status})
Interface to the C macro @cfunc{WIFSIGNALED}, @glibcref{Process
Completion Status, WIFSIGNALED}.  Return true if the process terminated
because it received an interprocess signal which was not handled.
@end deftypefun


@deftypefun ikptr ikrt_posix_WTERMSIG (ikptr @var{status})
Interface to the C macro @cfunc{WTERMSIG}, @glibcref{Process Completion
Status, WTERMSIG}.  If @cfunc{WIFSIGNALED} applied to @var{status} would
return true: return the number of the interprocess signal that
terminated the process.
@end deftypefun


@deftypefun ikptr ikrt_posix_WCOREDUMP (ikptr @var{status})
Interface to the C macro @cfunc{WCOREDUMP}, @glibcref{Process Completion
Status, WCOREDUMP}.  Return true if the process terminated and produced
a core dump.
@end deftypefun


@deftypefun ikptr ikrt_posix_WIFSTOPPED (ikptr @var{status})
Interface to the C macro @cfunc{WIFSTOPPED}, @glibcref{Process
Completion Status, WIFSTOPPED}.  Return true if the process is stopped.
@end deftypefun


@deftypefun ikptr ikrt_posix_WSTOPSIG (ikptr @var{status})
Interface to the C macro @cfunc{WSTOPSIG}, @glibcref{Process Completion
Status, WSTOPSIG}.  If @cfunc{WIFSTOPPED} applied to @var{status} would
return true: return the number of the interprocess signal that caused
the process to stop.
@end deftypefun

@c page
@node capi posix signals
@subsection Delivering interprocess signals


@deftypefun ikptr ikrt_posix_raise (ikptr @var{signum})
Interface to the C function @cfunc{raise}, @glibcref{Signaling Yourself,
raise}.  Send the selected signal to the calling process.  If successful
return zero, else return an encoded @code{errno} code.
@end deftypefun


@deftypefun ikptr ikrt_posix_kill (ikptr @var{pid}, ikptr @var{signum})
Interface to the C function @cfunc{kill}, @glibcref{Signaling Another
Process, kill}.  Send the selected signal to selected process.  If
successful return zero, else return an encoded @code{errno} code.
@end deftypefun


@deftypefun ikptr ikrt_posix_pause (void)
Interface to the C function @cfunc{pause}, @glibcref{Using Pause,
pause}.  Suspend the process until a signal is received.  Return the
void object.
@end deftypefun

@c page
@node capi posix stat
@subsection File system inspection


@deftypefun ikptr ikrt_posix_stat (ikptr @var{pathname}, ikptr @var{stat}, ikpcb * @var{pcb})
@deftypefunx ikptr ikrt_posix_lstat (ikptr @var{pathname}, ikptr @var{stat}, ikpcb * @var{pcb})
Interfaces to the C functions @cfunc{stat} and @cfunc{lstat},
@glibcref{Reading Attributes, stat}.  Inspect the file system entry
selected by @var{pathname}, which must be a bytevector, and fill the
@code{struct-stat} instance referenced by @var{stat} with the results.
If successful return zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_fstat (ikptr @var{fd}, ikptr @var{stat}, ikpcb * @var{pcb})
Interface to the C function @cfunc{fstat}, @glibcref{Reading Attributes,
fstat}.  Inspect the file system entry associated to the file descriptor
@var{fd}, which must be a fixnum, and fill the @code{struct-stat}
instance referenced by @var{stat} with the results.  If successful
return zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_file_is_directory (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_char_device (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_block_device (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_regular_file (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_symbolic_link (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_socket (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_fifo (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_message_queue (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_semaphore (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_shared_memory (ikptr @var{pathname}, ikptr @var{follow})
Return @true{} or @false{} whether the file system entry selected by
@var{pathname}, which must be a bytevector, is of the specified type; if
an error occurs return an encoded @code{errno} value.  When @var{follow}
is true: @cfunc{stat} is used to inspect the entry, else @cfunc{lstat}
is used.
@end deftypefun


@deftypefun ikptr ikrt_posix_access (ikptr @var{pathname}, ikptr @var{how})
Interface to the C function @cfunc{access}, @glibcref{Testing File
Access, access}.  Test the access mode selected by @var{how}, which must
be a fixnum, for the file system entry selected by @var{pathname}, which
must be a bytevector.  Return @true{} or @false{} or an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_file_size (ikptr @var{filename}, ikpcb * @var{pcb})
Determine the size of the file selected by @var{filename}, which must be
a bytevector, relying on a call to @cfunc{stat}.  If successful: return
an exact integer representing the size, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_file_atime (ikptr @var{pathname}, ikptr @var{vector}, ikpcb * @var{pcb})
@deftypefunx ikptr ikrt_posix_file_mtime (ikptr @var{pathname}, ikptr @var{vector}, ikpcb * @var{pcb})
@deftypefunx ikptr ikrt_posix_file_ctime (ikptr @var{pathname}, ikptr @var{vector}, ikpcb * @var{pcb})
Compute an exact integer representing the access, modification and
creation times for @var{pathname}, which must be a bytevector.  If
successful return zero, else return an encoded @code{errno} value.

The @var{vector} argument must be a vector which is mutated as follows:
the first item holds an exact integer representing the number of
seconds, the second item holds an exact integer representing the number
of microseconds.
@end deftypefun

@c page
@node capi posix file
@subsection File system interface


@deftypefun ikptr ikrt_posix_chown (ikptr @var{pathname}, ikptr @var{owner}, ikptr @var{group})
Interface to the C function @cfunc{chown}, @glibcref{File Owner, chown}.
Changes the owner and group of the file system entry selected by
@var{pathname}, which must be a bytevector.  @var{owner} and @var{group}
must be fixnums.  If successful return zero, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_fchown (ikptr @var{fd}, ikptr @var{owner}, ikptr @var{group})
Interface to the C function @cfunc{fchown}, @glibcref{File Owner,
fchown}.  Changes the owner and group of the file system entry selected
by @var{fd}, which must be a fixnum representing a platform file
descriptor.  @var{owner} and @var{group} must be fixnums.  If successful
return zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_chmod (ikptr @var{pathname}, ikptr @var{mode})
Interface to the C function @cfunc{chmod}, @glibcref{Setting
Permissions, chmod}.  Change to @var{mode}, which must be a fixnum, the
access permissions for the file system entry selected by @var{pathname},
which must be a bytevector.  If successful return zero, else return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_fchmod (ikptr @var{fd}, ikptr @var{mode})
Interface to the C function @cfunc{fchmod}, @glibcref{Setting
Permissions, fchmod}.  Change to @var{mode}, which must be a fixnum, the
access permissions for the file system entry associated to @var{fd},
which must be a fixnum representing a platform file descriptor.  If
successful return zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_umask (ikptr @var{mask})
Interface to the C function @cfunc{umask}, @glibcref{Setting
Permissions, umask}.  Set the current file creation mask to @var{mask}
which must be a fixnum and return the previous mask as a fixnum.
@end deftypefun


@deftypefun ikptr ikrt_posix_getumask (void)
Interface to the C function @cfunc{getumask}, @glibcref{Setting
Permissions, getumask}.  Return the current file creation mask as a
fixnum.
@end deftypefun


@deftypefun ikptr ikrt_posix_utime (ikptr @var{pathname}, ikptr @var{atime_sec}, ikptr @var{mtime_sec})
Interface to the C function @cfunc{utime}, @glibcref{File Times, utime}.
Set the access and modification times of the file system entry selected
by @var{pathname}, which must be a bytevector, to the specified counts
of seconds; both @var{atime_sec} and @var{mtime_sec} must be fixnums.
If successful return zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_utimes (ikptr @var{pathname}, ikptr @var{atime_sec}, ikptr @var{atime_usec}, ikptr @var{mtime_sec}, ikptr @var{mtime_usec})
@deftypefunx ikptr ikrt_posix_lutimes (ikptr @var{pathname}, ikptr @var{atime_sec}, ikptr @var{atime_usec}, ikptr @var{mtime_sec}, ikptr @var{mtime_usec})
Interface to the C functions @cfunc{utimes} and @cfunc{lutimes},
@glibcref{File Times, utimes}.  Set the access and modification times of
the file system entry selected by @var{pathname}, which must be a
bytevector, to the specified counts of seconds and microseconds; all the
numeric arguments must be fixnums.  If successful return zero, else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_futimes (ikptr @var{fd}, ikptr @var{atime_sec}, ikptr @var{atime_usec}, ikptr @var{mtime_sec}, ikptr @var{mtime_usec})
Interface to the C function @cfunc{futimes}, @glibcref{File Times,
futimes}.  Set the access and modification times of the file system
entry associated to @var{fd}, which must be a fixnum representing a file
descriptor, to the specified counts of seconds and microseconds; all the
numeric arguments must be fixnums.  If successful return zero, else
return an encoded @code{errno} value.
@end deftypefun

@c page
@node capi posix link
@subsection Hard and symbolic links


@deftypefun ikptr ikrt_posix_link (ikptr @var{old_pathname}, ikptr @var{new_pathname})
Interface to the C function @cfunc{link}, @glibcref{Hard Links, link}.
Create a hard link @var{new_pathname} to the source file system entry
@var{old_pathname}.  If successful return zero, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_symlink (ikptr @var{file_pathname}, ikptr @var{link_pathname})
Interface to the C function @cfunc{symlink}, @glibcref{Symbolic Links,
symlink}.  Create a symbolic link @var{link_pathname} to the source file
system entry @var{file_pathname}.  If successful return zero, else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_readlink (ikptr @var{link_pathname}, ikpcb * @var{pcb})
Interface to the C function @cfunc{readlink}, @glibcref{Symbolic Links,
readlink}.  If @var{pathname} references a symbolic link: follow it once
and return the referenced pathname as bytevector; if an error occurs:
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_realpath (ikptr @var{pathname})
Interface to the C function @cfunc{realpath}, @glibcref{Symbolic Links,
realpath}.  If @var{pathname} references a symbolic link: follow it and
return the real pathname as bytevector; if an error occurs: return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_unlink (ikptr @var{pathname})
Interface to the C function @cfunc{unlink}, @glibcref{Deleting Files,
unlink}.  Delete the file system entry referenced by @var{pathname},
which must be a bytevector and referencing a file.  If successful return
zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_remove (ikptr @var{pathname})
Interface to the C function @cfunc{remove}, @glibcref{Deleting Files,
remove}.  Delete the file system entry referenced by @var{pathname},
which must be a bytevector and referencing a file or directory.  If
successful return zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_rename (ikptr @var{old_pathname}, ikptr @var{new_pathname})
Interface to the C function @cfunc{rename}, @glibcref{Renaming Files,
rename}.  Rename the file system entry @var{old_pathname} to
@var{new_pathname}, both of which must be bytevectors.  If successful
return zero, else return an encoded @code{errno} value.
@end deftypefun

@c page
@node capi posix dir
@subsection File system directories


@deftypefun ikptr ikrt_posix_mkdir (ikptr @var{pathname}, ikptr @var{mode})
Interface to the C function @cfunc{mkdir}, @glibcref{Creating
Directories, mkdir}.  Create a new directory file system entry with name
@var{pathname}, which must be a bytevector; @var{mode} must be a fixnum
specifying access permissions.  If successful return the fixnum zero,
else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_rmdir (ikptr @var{pathname})
Interface to the C function @cfunc{rmdir}, @glibcref{Creating
Directories, rmdir}.  Remove the directory file system entry selected by
@var{pathname}, which must be a bytevector.  If successful return the
fixnum zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_getcwd (ikpcb * @var{pcb})
Interface to the C function @cfunc{getcwd}, @glibcref{Working Directory,
getcwd}.  Acquire the pathname of the current working directory.  If
successful return a bytevector holding the pathname, else return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_chdir (ikptr @var{pathname})
Interface to the C function @cfunc{chdir}, @glibcref{Working Directory,
chdir}.  Change the current working directory to the file system entry
selected by @var{pathname}, which must be a bytevector.  If successful
return the fixnum zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_fchdir (ikptr @var{fd})
Interface to the C function @cfunc{fchdir}, @glibcref{Working Directory,
fchdir}.  Change the current working directory to the file system entry
associated to @var{fd}, which must be a fixnum representing a file
descriptor.  If successful return the fixnum zero, else return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_opendir (ikptr @var{pathname}, ikpcb * @var{pcb})
Interface to the C function @cfunc{opendir}, @glibcref{Opening a
Directory, opendir}.  Open a directory stream for the inspection of the
file system entry @var{pathname}, which must be a bytevector.  If
successful return a pointer object, else return an encoded @code{errno}
value.
@end deftypefun


@deftypefun ikptr ikrt_posix_fdopendir (ikptr @var{fd}, ikpcb * @var{pcb})
Interface to the C function @cfunc{fdopendir}, @glibcref{Opening a
Directory, fdopendir}.  Open a directory stream for the inspection of
the file system entry associated to @var{fd}, which must be a fixnum
representing a file descriptor.  If successful return a pointer object,
else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_readdir (ikptr @var{pointer}, ikpcb * @var{pcb})
Interface to the C function @cfunc{readdir}, @glibcref{Reading/Closing
Directory, readdir}.  Acquire the next entry from a directory stream
referenced by @var{pointer}, which must be a pointer object.  If
successful and an entry is available: return a pointer object; if
successful and no more entries are available: return the false object;
else return an encoded @code{errno} value.

When no more entries are available or an error occurs: the directory
stream is closed.
@end deftypefun


@deftypefun ikptr ikrt_posix_closedir (ikptr @var{pointer}, ikpcb * @var{pcb})
Interface to the C function @cfunc{closedir}, @glibcref{Reading/Closing
Directory, closedir}.  Close the directory stream referenced by
@var{pointer}, which must be a pointer object.  If successful return the
fixnum zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_rewinddir (ikptr @var{pointer})
Interface to the C function @cfunc{rewinddir}, @glibcref{Random Access
Directory, rewinddir}.  Rewind to the beginning the directory stream
referenced by @var{pointer}, which must be a pointer object.  Return the
void object.
@end deftypefun


@deftypefun ikptr ikrt_posix_telldir (ikptr @var{pointer})
Interface to the C function @cfunc{telldir}, @glibcref{Random Access
Directory, telldir}.  Return an exact integer representing the current
position in the directory stream referenced by @var{pointer}, which must
be a pointer object.
@end deftypefun


@deftypefun ikptr ikrt_posix_seekdir (ikptr @var{pointer}, ikptr @var{pos})
Interface to the C function @cfunc{seekdir}, @glibcref{Random Access
Directory, seekdir}.  Set to @var{pos} the position of the directory
stream referenced by @var{pointer}, which must be a pointer object;
@var{pos} must be the return value of a previous call to
@cfunc{telldir}.  Return the void object.
@end deftypefun

@c page
@node capi posix fd
@subsection File descriptors at low level


@deftypefun ikptr ikrt_posix_open (ikptr @var{pathname}, ikptr @var{flags}, ikptr @var{mode})
Interface to the C function @cfunc{open}, @glibcref{Opening and Closing
Files, open}.  Open a file descriptor for the file system entry
@var{pathname}, which must be a bytevector; @var{flags} and @var{mode}
must be fixnums.  If successful return a fixnum representing the file
descriptor, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_close (ikptr @var{fd})
Interface to the C function @cfunc{close}, @glibcref{Opening and Closing
Files, close}.  Close a file descriptor represented by @var{fd}, which
must be a fixnum.  If successful return the fixnum zero, else return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_read (ikptr @var{fd}, ikptr @var{buffer}, ikptr @var{size})
Interface to the C function @cfunc{read}, @glibcref{I/O Primitives,
read}.  Read bytes from the file descriptor @var{fd} and store them in
the bytevector @var{buffer}; if @var{size} is a fixnum, read @var{size}
bytes; if @var{size} is false, read a number of bytes equal to the
length of @var{buffer}.  If successful return a non--negative fixnum
representing the number of bytes read, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_pread (ikptr @var{fd}, ikptr @var{buffer}, ikptr @var{size}, ikptr @var{off})
Interface to the C function @cfunc{pread}, @glibcref{I/O Primitives,
pread}.  Like @cfunc{ikrt_posix_read}, but start reading at offset
@var{off} from the start of the file; @var{off} must be a non--negative
exact integer.
@end deftypefun


@deftypefun ikptr ikrt_posix_write (ikptr @var{fd}, ikptr @var{buffer}, ikptr @var{size})
Interface to the C function @cfunc{write}, @glibcref{I/O Primitives,
write}.  Write bytes to the file descriptor @var{fd} from the bytevector
@var{buffer}; if @var{size} is a fixnum, write @var{size} bytes; if
@var{size} is false, write a number of bytes equal to the length of
@var{buffer}.  If successful return a non--negative fixnum representing
the number of written bytes, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_pwrite (ikptr @var{fd}, ikptr @var{buffer}, ikptr @var{size}, ikptr @var{off})
Interface to the C function @cfunc{pwrite}, @glibcref{I/O Primitives,
pwrite}.  Like @cfunc{ikrt_posix_write}, but start writing at offset
@var{off} from the start of the file; @var{off} must be a non--negative
exact integer.
@end deftypefun


@deftypefun ikptr ikrt_posix_lseek (ikptr @var{fd}, ikptr @var{off}, ikptr @var{whence}, ikpcb * @var{pcb})
Interface to the C function @cfunc{lseek}, @glibcref{File Position
Primitive, lseek}.  Change the file position of the file descriptor
@var{fd} to @var{off} from @var{whence}; @var{fd} and @var{whence} must
be fixnums, @var{off} must be an exact integer.  If successful return a
non--negative exact integer representing the number of bytes from the
beginning of the file, else return an encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_readv (ikptr @var{fd}, ikptr @var{buffers}, ikpcb * @var{pcb})
Interface to the C function @cfunc{readv}, @glibcref{Scatter-Gather,
readv}.  Read bytes from the file descriptor @var{fd} and store them
into the list of bytevectors referenced by @var{buffers}.  If successful
return a non--negative exact integer representing the number of bytes
actually read, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_writev (ikptr @var{fd}, ikptr @var{buffers}, ikpcb * @var{pcb})
Interface to the C function @cfunc{writev}, @glibcref{Scatter-Gather,
writev}.  Write bytes to the file descriptor @var{fd} from the list of
bytevectors referenced by @var{buffers}.  If successful return a
non--negative exact integer representing the number of bytes actually
written, else return an encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_select (ikptr @var{nfds}, ikptr @var{read_fds}, ikptr @var{write_fds}, ikptr @var{except_fds}, ikptr @var{sec}, ikptr @var{usec}, ikpcb * @var{pcb})
Interface to the C function @cfunc{select}, @glibcref{Waiting for I/O,
select}.  Wait for read, write or exceptional events on selected lists
of file descriptors.

@var{nfds} must be false or a non--negative fixnum, when false it
defaults to the maximum file descriptor value in the given lists; it is
the maximum file descriptor number in the sets to be checked for events,
plus one.  @var{read_fds}, @var{write_fds} and @var{except_fds} must be
nil or lists of file descriptors to be checked for events.  @var{sec}
and @var{usec} must be fixnums representing timeout seconds and
microseconds.

Return the fixnum zero if the timeout expired before any event arrived;
else return a vector of 3 elements being lists of file descriptors,
respectively, ready for reading, writing or an exceptional condition.
If an error occurs: return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_select_fd (ikptr @var{fd}, ikptr @var{sec}, ikptr @var{usec}, ikpcb * @var{pcb})
Interface to the C function @cfunc{select}, @glibcref{Waiting for I/O,
select}.  Wait for read, write or exceptional events on the single file
descriptor @var{fd}.  @var{sec} and @var{usec} must be fixnums
representing timeout seconds and microseconds.

Return the fixnum zero if the timeout expired before any event arrived;
else return a fixnum being the OR combination of the flags: @code{1} if
@var{fd} is readable, @code{2} if @var{fd} is writable, @code{4} if
@var{fd} received an exception.  If an error occurs: return an encoded
@code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_fcntl (ikptr @var{fd}, ikptr @var{command}, ikptr @var{arg})
Interface to the C function @cfunc{fcntl}, @glibcref{Control Operations,
fcntl}.  Perform the operation specified by @var{command} on the file
descriptor @var{fd} using @var{arg}; @var{fd} and @var{command} must be
fixnums; @var{arg} must be the false object, a fixnum, a bytevector or a
pointer, if it is @false{} no argument is handed to @cfunc{fcntl}.  If
successful return a fixnum representing the return value of
@cfunc{fcntl}, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_ioctl (ikptr @var{fd}, ikptr @var{command}, ikptr @var{arg})
Interface to the C function @cfunc{ioctl}, @glibcref{IOCTLs, ioctl}.
Perform the operation specified by @var{command} on the file descriptor
@var{fd} using @var{arg}; @var{fd} and @var{command} must be fixnums;
@var{arg} must be the false object, a fixnum, a bytevector or a pointer,
if it is @false{} no argument is handed to @cfunc{ioctl}.  If successful
return a fixnum representing the return value of @cfunc{ioctl}, else
return an encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_dup (ikptr @var{fd})
Interface to the C function @cfunc{dup}, @glibcref{Duplicating
Descriptors, dup}.  Duplicate the file descriptor @var{fd}.  If
successful return a non--negative fixnum representing the new
descriptor, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_dup2 (ikptr @var{old}, ikptr @var{new})
Interface to the C function @cfunc{dup2}, @glibcref{Duplicating
Descriptors, dup}.  Duplicate the file descriptor @var{old} to
@var{new}.  If successful return the fixnum zero, else return an encoded
@code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_pipe (ikpcb * @var{pcb})
Interface to the C function @cfunc{pipe}, @glibcref{Creating a Pipe,
pipe}.  Create a pair of file descriptors connected through a pipe.  If
successful return a pair whose car and cdr are fixnums representing the
file descriptors, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_mkfifo (ikptr @var{pathname}, ikptr @var{mode})
Interface to the C function @cfunc{mkfifo}, @glibcref{FIFO Special
Files, mkfifo}.  Create a FIFO special file with name @var{pathname},
which must be a bytevector, and mode @var{mode}, which must be a fixnum.
If successful return the fixnum zero, else return an encoded
@code{errno} value.
@end deftypefun

@c page
@node capi posix socket
@subsection Network sockets


@subsubheading Address structures

@deftypefun ikptr ikrt_posix_make_sockaddr_un (ikptr @var{pathname}, ikpcb * @var{pcb})
Given a bytevector @var{pathname} representing the pathname of a local
socket, build and return a bytevector holding the @code{struct
sockaddr_un} representing it.
@end deftypefun


@deftypefun ikptr ikrt_posix_sockaddr_un_pathname (ikptr @var{socket_address}, ikpcb * @var{pcb})
Given a bytevector @var{socket_address}, which must be the return value
of a previous call to @cfunc{ikrt_posix_make_sockaddr_un}, holding a
@code{struct sockaddr_un} build and return a bytevector holding the
corresponding socket pathname.  If the data in @var{socket_address} is
invalid: return false.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_make_sockaddr_in (ikptr @var{host_address}, ikptr @var{port}, ikpcb * @var{pcb})
Given a bytevector @var{host_address} holding a @code{struct in_addr}
and a fixnum @var{port} representing a network port number, build and
return a bytevector holding a @code{struct sockaddr_in} initialised with
this data.
@end deftypefun


@deftypefun ikptr ikrt_posix_sockaddr_in_in_addr (ikptr @var{socket_address}, ikpcb * @var{pcb})
@deftypefunx ikptr ikrt_posix_sockaddr_in_in_port (ikptr @var{socket_address})
Given a bytevector @var{socket_address} holding a @code{struct
sockaddr_in}, extract the @code{in_addr} and @code{in_port} fields and
return them as bytevector holding the corresponding @code{struct
in_addr} and as fixnum.  If the data in @var{socket_address} is invalid:
return false.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_make_sockaddr_in6 (ikptr @var{host_address}, ikptr @var{port}, ikpcb * @var{pcb})
Given a bytevector @var{host_address} holding a @code{struct in6_addr}
and a fixnum @var{port} representing a network port number, build and
return a bytevector holding a @code{struct sockaddr_in6} initialised
with this data.
@end deftypefun


@deftypefun ikptr ikrt_posix_sockaddr_in6_in6_addr (ikptr @var{socket_address}, ikpcb * @var{pcb})
@deftypefunx ikptr ikrt_posix_sockaddr_in6_in6_port (ikptr @var{socket_address})
Given a bytevector @var{socket_address} holding a @code{struct
sockaddr_in6}, extract the @code{in6_addr} and @code{in6_port} fields
and return them as bytevector holding the corresponding @code{struct
in6_addr} and as fixnum.  If the data in @var{socket_address} is
invalid: return false.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_in6addr_loopback (ikpcb * @var{pcb})
@deftypefunx ikptr ikrt_posix_in6addr_any (ikpcb * @var{pcb})
Build and return a bytevector holding the constant structures of type
@code{struct in6_addr} defined by @code{in6addr_loopback} and
@code{in6addr_any}.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_inet_aton (ikptr @var{dotted_quad}, ikpcb * @var{pcb})
Given the bytevector @var{dotted_quad} holding the @ascii{} dotted quad
representation of a host address, build and return a bytevector holding
the corresponding @code{struct in_addr}.  If @var{dotted_quad} is
invalid: return false.
@end deftypefun


@deftypefun ikptr ikrt_inet_ntoa (ikptr @var{host_address}, ikpcb * @var{pcb})
Given the bytevector @var{host_address} holding a @code{struct in_addr},
build and return a bytevector holding the corresponding @ascii{} dotted
quad representation.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_inet_pton (ikptr @var{af}, ikptr @var{presentation}, ikpcb * @var{pcb})
Given the fixnum @var{af}, being @code{AF_INET} or @code{AF_INET6}, and
the bytevector @var{presentation} holding the @ascii{} presentation of
an Internet address, build and return a bytevector holding the
corresponding @code{struct in_addr} or @code{struct in6_addr}.  If
either @var{af} or @var{presentation} is invalid: return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_inet_ntop (ikptr @var{af}, ikptr @var{host_address}, ikpcb * @var{pcb})
Given the fixnum @var{af}, being @code{AF_INET} or @code{AF_INET6}, and
the bytevector @var{host_address} holding a @code{struct in_addr} or
@code{struct in6_addr}, build and return a bytevector holding the
corresponding @ascii{} presentation of the Internet address .  If the
arguments are invalid: return false.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Host address resolution


@deftypefun ikptr ikrt_posix_gethostbyname (ikptr @var{rtd}, ikptr @var{hostname}, ikpcb * @var{pcb})
Interface to the C function @cfunc{gethostbyname}, @glibcref{Host Names,
gethostbyname}.  Given the bytevector @var{hostname} holding the
@ascii{} representation of a host name, build and return an instance of
@code{struct-hostent} using @var{rtd} as its type descriptor.  If an
error occurs, return an encoded @code{h_errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_gethostbyaddr (ikptr @var{rtd}, ikptr @var{addr}, ikpcb * @var{pcb})
Interface to the C function @cfunc{gethostbyaddr}, @glibcref{Host Names,
gethostbyaddr}.  Given the bytevector @var{addr} holding a @code{struct
in_addr} or a @code{struct in6_addr}, build and return an instance of
@code{struct-hostent} using @var{rtd} as its type descriptor; the type
of address is automatically inferred from the length of the bytevector.
If an error occurs, return an encoded @code{h_errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_host_entries (ikptr @var{rtd}, ikpcb * pcb)
Interface to the C functions @cfunc{sethostent}, @cfunc{gethostent} and
@cfunc{endhostent}, @glibcref{Host Names, gethostbyaddr}.  Build and
return a list of @code{struct-hostent} representing the entries in the
hosts database, using @var{rtd} as type descriptor.
@end deftypefun


@deftypefun ikptr ikrt_posix_getaddrinfo (ikptr @var{rtd}, ikptr @var{node}, ikptr @var{service}, ikptr @var{hints}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getaddrinfo}, see the manual page
@code{getaddrinfo(3)}.  Given the bytevectors @var{node} and
@var{service} identifying an Internet host and a service, build a list
of @code{struct-addrinfo} instances representing addresses to which
sockets can be bound or connected.

Both @var{node} and @var{service} can be false, in which case the
corresponding arguments handed to the C function are @code{NULL}.

@var{hints} must be an instance of @code{struct-addrinfo} used to select
matching hosts.  @var{rtd} must be the type descriptor of
@code{struct-addrinfo}.

If successful: return the list of data structures, else return a fixnum
representing an @code{EAI_} error code.
@end deftypefun


@deftypefun ikptr ikrt_posix_gai_strerror (ikptr @var{error_code}, ikpcb * @var{pcb})
Interface to the C function @cfunc{gai_strerror}, see the manual page
@code{gai_strerror(3)}.  Convert a @code{EAI_} error code into the
corresponding error message, return a bytevector holding such message in
@ascii{} coding.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Network protocols


@deftypefun ikptr ikrt_posix_getprotobyname (ikptr @var{rtd}, ikptr @var{name}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getprotobyname}, @glibcref{Protocols
Database, getprotobyname}.  Given a bytevector @var{name} holding the
@ascii{} coding of a network protocol name, query the network protocols
database and build an instance of @code{struct-protoent} mirroring the
resulting @code{struct protoent} entry; @var{rtd} must be the type
descriptor of @code{struct-protoent}.  If successful return the data
structure, else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_getprotobynumber (ikptr @var{rtd}, ikptr @var{proto_num}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getprotobynumber},
@glibcref{Protocols Database, getprotobynumber}.  Given a fixnum
@var{proto_num} being the number of a network protocol, query the
network protocols database and build an instance of
@code{struct-protoent} mirroring the resulting @code{struct protoent}
entry; @var{rtd} must be the type descriptor of @code{struct-protoent}.
If successful return the data structure, else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_protocol_entries (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C functions @cfunc{setprotoent}, @cfunc{getprotoent}
and @cfunc{endprotoent}, @glibcref{Protocols Database, setprotoent}.
Scan the network protocol database and build a list of
@code{struct-protoent} mirroring the resulting @code{struct protoent}
entries; @var{rtd} must be the type descriptor of
@code{struct-protoent}.  Return the list of structures.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Network services


@deftypefun ikptr ikrt_posix_getservbyname (ikptr @var{rtd}, ikptr @var{name}, ikptr @var{protocol}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getservbyname}, @glibcref{Services
Database, getservbyname}.  Given the bytevectors @var{name} and
@var{protocol} holding the @ascii{} coding of a network service name and
protocol, query the network services database and build an instance of
@code{struct-servent} mirroring the resulting @code{struct servent}
entry.  @var{rtd} must be the type descriptor of @code{struct-servent}.
If successful return the data structure, else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_getservbynumber (ikptr @var{rtd}, ikptr @var{port}, ikptr @var{protocol}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getservbynumber}, @glibcref{Services
Database, getservbynumber}.  Given a fixnum @var{port} and a string or
bytevector @var{protocol} being the port number and protocol name of a
network service, query the network services database and build an
instance of @code{struct-servent} mirroring the resulting @code{struct
servent} entry.  @var{rtd} must be the type descriptor of
@code{struct-servent}.  If successful return the data structure, else
return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_service_entries (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C functions @cfunc{setservent}, @cfunc{getservent} and
@cfunc{endservent}, @glibcref{Services Database, setservent}.  Scan the
network service database and build a list of @code{struct-servent}
mirroring the resulting @code{struct servent} entries.  @var{rtd} must
be the type descriptor of @code{struct-servent}.  Return the list of
structures.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Networks database


@deftypefun ikptr ikrt_posix_getnetbyname (ikptr @var{rtd}, ikptr @var{name}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getnetbyname}, @glibcref{Networks
Database, getnetbyname}.  Given the bytevector @var{name} holding the
@ascii{} coding of a network name, query the networks database and build
an instance of @code{struct-netent} mirroring the resulting @code{struct
netent} entry.  @var{rtd} must be the type descriptor of
@code{struct-netent}.  If successful return the data structure, else
return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_getnetbyaddr (ikptr @var{rtd}, ikptr @var{net}, ikptr @var{type}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getnetbyaddr}, @glibcref{Networks
Database, getnetbyaddr}.  Given an exact integer @var{net} representing
a network number and the fixnum @var{type} representing a network type,
query the networks database and build an instance of
@code{struct-netent} mirroring the resulting @code{struct netent} entry.
@var{rtd} must be the type descriptor of @code{struct-netent}.  If
successful return the data structure, else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_network_entries (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C functions @cfunc{setnetent}, @cfunc{getnetent} and
@cfunc{endnetent}, @glibcref{Networks Database, setnetent}.  Scan the
networks database and build a list of @code{struct-netent} mirroring the
resulting @code{struct netent} entries.  @var{rtd} must be the type
descriptor of @code{struct-netent}.  Return the list of structures.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Sockets creation and shutdown


@deftypefun ikptr ikrt_posix_socket (ikptr @var{namespace}, ikptr @var{style}, ikptr @var{protocol})
Interface to the C function @cfunc{socket}, @glibcref{Creating a Socket,
socket}.  Create a new socket descriptor and return it as non--negative
fixnum; if an error occurs return an encoded @code{errno} value.  All
the arguments must be fixnums.
@end deftypefun


@deftypefun ikptr ikrt_posix_shutdown (ikptr @var{sock}, ikptr @var{how})
Interface to the C function @cfunc{shutdown}, @glibcref{Closing a
Socket, shutdown}.  Close the socket @var{sock} according to @var{how}.
If successful return the fixnum zero, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_socketpair (ikptr @var{namespace}, ikptr @var{style}, ikptr @var{protocol}, ikpcb * @var{pcb})
Interface to the C function @cfunc{socketpair}, @glibcref{Socket Pairs,
socketpair}.  Create a pairs of connected sockets and return a pair
holding the descriptors as non--negative fixnums; if an error occurs
return an encoded @code{errno} value.  All the arguments must be
fixnums, but @var{pcb}.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Socket operations


@deftypefun ikptr ikrt_posix_connect (ikptr @var{sock}, ikptr @var{addr})
Interface to the C function @cfunc{connect}, @glibcref{Connecting,
connect}.  Connect the socket @var{sock} to the address specified by the
bytevector @var{addr} which must hold a concrete instance of
@code{struct sockaddr}.  If successful return the fixnum zero, else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_listen (ikptr @var{sock}, ikptr @var{pending_conns})
Interface to the C function @cfunc{listen}, @glibcref{Listening,
listen}.  Enable the socket @var{sock} to accept connections; the fixnum
@var{pending_conns} specifies the maximum length of the pending
connection requests queue.  If successful return the fixnum zero, else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_accept (ikptr @var{sock}, ikpcb * @var{pcb})
Interface to the C function @cfunc{accept}, @glibcref{Accepting
Connections, accept}.  Accept an incoming connection to the server
socket @var{sock}.  If successful return a pair whose car is a
non--negative fixnum representing the socket and whose cdr is a
bytevector representing the client address as @code{struct sockaddr};
else return an encoded @code{errno} value, including @code{EWOULDBLOCK}
which means that @var{sock} is in non--blocking mode and no pending
connections exist.
@end deftypefun


@deftypefun ikptr ikrt_posix_bind (ikptr @var{sock}, ikptr @var{sockaddr})
Interface to the C function @cfunc{bind}, @glibcref{Setting Address,
bind}.  Bind the socket descriptor @var{sock} to the address specified
by the @code{struct sockaddr} in the bytevector @var{sockaddr}.  If
successful return the fixnum zero, else return an encoded @code{errno}
value.
@end deftypefun


@deftypefun ikptr ikrt_posix_getpeername (ikptr @var{sock}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getpeername}, @glibcref{Who is
Connected, getpeername}.  Retrieve informations about the address of the
socket to which the @var{sock} socket is connected to.  If successful
return a bytevector holding a @code{struct sockaddr}, else return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_getsockname (ikptr @var{sock}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getsockanme}, @glibcref{Setting
Address, getsockname}.  Retrieve informations about the address bound to
the socket descriptor @var{sock}.  If successful return a bytevector
holding the @code{struct sockaddr}, else return an encoded @code{errno}
value.
@end deftypefun


@deftypefun ikptr ikrt_posix_send (ikptr @var{sock}, ikptr @var{buffer}, ikptr @var{size}, ikptr @var{flags})
Interface to the C function @cfunc{send}, @glibcref{Sending Data, send}.
Like @cfunc{write} but with the additional argument @var{flags} which
must be a fixnum: write data from the bytevector @var{buffer} to the
socket @var{sock}; if @var{size} is a fixnum, write @var{size} bytes; if
@var{size} is false, write a number of bytes equal to the length of
@var{buffer}.  If successful return a non--negative fixnum representing
the number of bytes actually sent, else return an encoded @code{errno}
value.
@end deftypefun


@deftypefun ikptr ikrt_posix_recv (ikptr @var{sock}, ikptr @var{buffer}, ikptr @var{size}, ikptr @var{flags})
Interface to the C function @cfunc{recv}, @glibcref{Receiving Data,
recv}.  Like @cfunc{read} but with the additional argument @var{flags}
which must be a fixnum: read data from @var{sock} and store it in the
bytevector @var{buffer}; if @var{size} is a fixnum, read @var{size}
bytes; if @var{size} is false, read a number of bytes equal to the
length of @var{buffer}.  If successful return a non--negative fixnum
representing the number of bytes actually received, else return an
encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_sendto (ikptr @var{sock}, ikptr @var{buffer}, ikptr @var{size}, ikptr @var{flags}, ikptr @var{addr})
Interface to the C function @cfunc{sendto}, @glibcref{Sending Datagrams,
sendto}.  Like @cfunc{send} but with the additional argument @var{addr}
which must be a bytevector holding a @code{struct sockaddr}: write data
from the bytevector @var{buffer} to the socket @var{sock} to the
destination specified by @var{addr}.

If @var{size} is a fixnum, write @var{size} bytes; if @var{size} is
false, write a number of bytes equal to the length of @var{buffer}.

If successful return a non--negative fixnum representing the number of
bytes actually sent, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_recvfrom (ikptr @var{sock}, ikptr @var{buffer}, ikptr @var{size}, ikptr @var{flags}, ikpcb * @var{pcb})
Interface to the C function @cfunc{recvfrom}, @glibcref{Receiving
Datagrams, recvfrom}.  Like @cfunc{recv} but additionally retrieve
informations about the address of the sender: read data from @var{sock}
and store it in the bytevector @var{buffer}.

If @var{size} is a fixnum, read @var{size} bytes; if @var{size} is
false, read a number of bytes equal to the length of @var{buffer}.

If successful return a pair whose car is a non--negative fixnum
representing the number of bytes actually received and whose cdr is a
bytevector holding a @code{struct sockaddr} representing the address of
the sender; else return an encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_getsockopt (ikptr @var{sock}, ikptr @var{level}, ikptr @var{option}, ikptr @var{optval}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getsockopt}, @glibcref{Socket Option
Function, getsockopt}.  Retrieve the value of @var{option} of socket
@var{sock} at @var{level} and store it in the bytevector @var{optval}.
@var{option} and @var{level} must be fixnums.  If successful return the
fixnum zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_setsockopt (ikptr @var{sock}, ikptr @var{level}, ikptr @var{option}, ikptr @var{optval}, ikpcb * @var{pcb})
Interface to the C function @cfunc{setsockopt}, @glibcref{Socket Option
Function, setsockopt}.  Set a new value for @var{option} of socket
@var{sock} at @var{level} reading it from the bytevector @var{optval}.
@var{option} and @var{level} must be fixnums.  If successful return the
fixnum zero, else return an encoded @code{errno} value.
@end deftypefun

@c page
@node capi posix users
@subsection Users and groups


@deftypefun ikptr ikrt_posix_getuid (void)
Interface to the C function @cfunc{getuid}, @glibcref{Reading Persona,
getuid}.  Return a fixnum representing the real user ID of the process.
@end deftypefun


@deftypefun ikptr ikrt_posix_getgid (void)
Interface to the C function @cfunc{getgid}, @glibcref{Reading Persona,
getgid}.  Return a fixnum representing the real group ID of the process.
@end deftypefun


@deftypefun ikptr ikrt_posix_geteuid (void)
Interface to the C function @cfunc{geteuid}, @glibcref{Reading Persona,
geteuid}.  Return a fixnum representing the effective user ID of the
process.
@end deftypefun


@deftypefun ikptr ikrt_posix_getegid (void)
Interface to the C function @cfunc{getegid}, @glibcref{Reading Persona,
getegid}.  Return a fixnum representing the effective group ID of the
process.
@end deftypefun


@deftypefun ikptr ikrt_posix_getgroups (ikpcb * @var{pcb})
Interface to the C function @cfunc{getgroups}, @glibcref{Reading
Persona, getgroups}.  Return a list of fixnums representing the
supplementary group IDs of the process; if an error occurs return an
encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_seteuid (ikptr @var{new_uid})
Interface to the C function @cfunc{seteuid}, @glibcref{Setting User ID,
seteuid}.  Set the effective user ID to @var{new_uid}, which must be a
fixnum.  If successful return the fixnum zero, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_setuid (ikptr @var{new_uid})
Interface to the C function @cfunc{setuid}, @glibcref{Setting User ID,
setuid}.  Set both the real and effective user IDs to @var{new_uid},
which must be a fixnum.  If successful return the fixnum zero, else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_setreuid (ikptr @var{real_uid}, ikptr @var{effective_uid})
Interface to the C function @cfunc{setreuid}, @glibcref{Setting User ID,
setreuid}.  Set the real user ID to @var{real_uid} and the effective
user ID to @var{effective_uid}, both the arguments must be fixnums.  If
successful return the fixnum zero, else return an encoded @code{errno}
value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_setegid (ikptr @var{new_gid})
Interface to the C function @cfunc{setegid}, @glibcref{Setting Groups,
setegid}.  Set the effective group ID to @var{new_gid}, which must be a
fixnum.  If successful return the fixnum zero, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_setgid (ikptr @var{new_gid})
Interface to the C function @cfunc{setgid}, @glibcref{Setting Groups,
setgid}.  Set both the real and effective group IDs to @var{new_gid},
which must be a fixnum.  If successful return the fixnum zero, else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_setregid (ikptr @var{real_gid}, ikptr @var{effective_gid})
Interface to the C function @cfunc{setregid}, @glibcref{Setting Groups,
setregid}.  Set the real group ID to @var{real_gid} and the effective
group ID to @var{effective_gid}, both the arguments must be fixnums.  If
successful return the fixnum zero, else return an encoded @code{errno}
value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_getlogin (ikpcb * @var{pcb})
Interface to the C function @cfunc{getlogin}, @glibcref{Who Logged In,
getlogin}.  Return a bytevector holding the @ascii{} coding of the name
of the user logged in on the controlling terminal of the process; if the
name cannot be determined: return false.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_getpwuid (ikptr @var{rtd}, ikptr @var{uid}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getpwuid}, @glibcref{Lookup User,
getpwuid}.  Retrieve informations on the user with identifier @var{uid},
which must be a fixnum.  If successful return an instance of
@code{struct-passwd} initialised with @var{rtd}, which must be its type
descriptor; if a user with such an ID does not exists: return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_getpwnam (ikptr @var{rtd}, ikptr @var{name}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getpwnam}, @glibcref{Lookup User,
getpwnam}.  Retrieve informations on the user with name represented in
@ascii{} coding by the bytevector @var{name}.  If successful return an
instance of @code{struct-passwd} initialised with @var{rtd}, which must
be its type descriptor; if a user with such an ID does not exists:
return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_user_entries (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C functions @cfunc{setpwent}, @cfunc{getpwent} and
@cfunc{endpwent}, @glibcref{Scanning All Users, setpwent}.  Iterate the
database of users and return a list of @code{struct-passwd} representing
the entries; the structures are initialised with @var{rtd} which must be
the type descriptor of @code{struct-passwd}.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_getgrgid (ikptr @var{rtd}, ikptr @var{gid}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getgrgid}, @glibcref{Lookup Group,
getgrgid}.  Retrieve informations on the group with identifier
@var{gid}, which must be a fixnum.  If successful return an instance of
@code{struct-group} initialised with @var{rtd}, which must be its type
descriptor; if a group with such an ID does not exists: return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_getgrnam (ikptr @var{rtd}, ikptr @var{name}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getgrnam}, @glibcref{Lookup Group,
getgrnam}.  Retrieve informations on the group with name represented in
@ascii{} coding by the bytevector @var{name}.  If successful return an
instance of @code{struct-group} initialised with @var{rtd}, which must
be its type descriptor; if a group with such an ID does not exists:
return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_group_entries (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C functions @cfunc{setgrent}, @cfunc{getgrent} and
@cfunc{endgrent}, @glibcref{Scanning All Groups, setgrent}.  Iterate the
database of groups and return a list of @code{struct-group} representing
the entries; the structures are initialised with @var{rtd} which must be
the type descriptor of @code{struct-group}.
@end deftypefun

@c page
@node capi posix job
@subsection Job control


@deftypefun ikptr ikrt_posix_ctermid (ikpcb * @var{pcb})
Interface to the C function @cfunc{ctermid}, @glibcref{Identifying the
Terminal, ctermid}.  Return a bytevector holding the @ascii{} coded
pathname of the controlling terminal of the current process; the
returned value may be the empty bytevector.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_setsid (void)
Interface to the C function @cfunc{setsid}, @glibcref{Process Group
Functions, setsid}.  Create a new session, making the current process
the group leader with no controlling terminal.  If successful return a
fixnum representing the new process groups ID, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_getsid (ikptr @var{pid})
Interface to the C function @cfunc{getsid}, @glibcref{Process Group
Functions, getsid}.  If successful return a fixnum representing the
session ID of the process with process ID @var{pid}, which must be a
fixnum; else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_getpgrp (void)
Interface to the C function @cfunc{getpgrp}, @glibcref{Process Group
Functions, getpgrp}.  Return a fixnum representing the process group ID
of the calling process.
@end deftypefun


@deftypefun ikptr ikrt_posix_setpgid (ikptr @var{pid}, ikptr @var{pgid})
Interface to the C function @cfunc{setpgid}, @glibcref{Process Group
Functions, setpgid}.  Put the process @var{pid} in the process group
@var{pgid}.  If successful return the fixnum zero, else return an
encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_tcgetpgrp (ikptr @var{fd})
Interface to the C function @cfunc{tcgetpgrp}, @glibcref{Terminal Access
Functions, tcgetpgrp}.  If successful return a fixnum representing the
process group ID of the foreground process group associated with the
terminal open on descriptor @var{fd}, which must be a fixnum; else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_tcsetpgrp (ikptr @var{fd}, ikptr @var{pgid})
Interface to the C function @cfunc{tcsetpgrp}, @glibcref{Terminal Access
Functions, tcsetpgrp}.  Set to process group ID @var{pgid} the
foreground process group for the terminal open on descriptor @var{fd};
both the arguments must be fixnums.  If successful return the fixnum
zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_tcgetsid (ikptr @var{fd})
Interface to the C function @cfunc{tcgetsid}, @glibcref{Terminal Access
Functions, tcgetsid}.  If successful return a fixnum representing the
process group ID of the session for which the terminal open on
descriptor @var{fd} is the controlling terminal; else return an encoded
@code{errno} value.
@end deftypefun

@c page
@node capi posix time
@subsection Date and time


@deftypefun ikptr ikrt_posix_clock (ikpcb * @var{pcb})
Interface to the C function @cfunc{clock}, @glibcref{CPU Time, clock}.
If successful return an @strong{inexact} integer representing the CPU
time for the calling process expressed in clock ticks; if the clock time
is not available return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_times (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C function @cfunc{times}, @glibcref{Processor Time,
times}.  If successful return an instance of @code{struct-tms}
representing the current processor time with all the fields set to
inexact integers, else return false; @var{rtd} must be the type
descriptor of @code{struct-tms}.
@end deftypefun


@deftypefun ikptr ikrt_posix_time (ikpcb * @var{pcb})
Interface to the C function @cfunc{time}, @glibcref{Simple Calendar
Time, time}.  If successful return the calendar time as an
@strong{inexact} integer, else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_gettimeofday (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C function @cfunc{gettimeofday},
@glibcref{High-Resolution Calendar, gettimeofday}.  Acquire the current
time.  If successful return an instance of @code{struct-timeval}, else
return an encoded @code{errno} value.  @var{rtd} must be the type
descriptor of @code{struct-timeval}.
@end deftypefun


@deftypefun ikptr ikrt_posix_localtime (ikptr @var{rtd}, ikptr @var{time}, ikpcb * @var{pcb})
Interface to the C function @cfunc{localtime}, @glibcref{Broken-down
Time, localtime}.  Given an exact integer @var{time} representing the
local time as returned by the @func{time} function: build and return an
instance of @code{struct-tm} representing the same time in human
readable form; if an error occurs return false.  @var{rtd} must be the
type descriptor of @code{struct-tm}.
@end deftypefun


@deftypefun ikptr ikrt_posix_gmtime (ikptr @var{rtd}, ikptr @var{time}, ikpcb * @var{pcb})
Interface to the C function @cfunc{gmtime}, @glibcref{Broken-down Time,
gmtime}.  Given an exact integer @var{time} representing the @utc{} time
as returned by the @func{time} function: build and return an instance of
@code{struct-tm} representing the same time in human readable form; if
an error occurs return false.  @var{rtd} must be the type descriptor of
@code{struct-tm}.
@end deftypefun


@deftypefun ikptr ikrt_posix_timelocal (ikptr @var{tm}, ikpcb * @var{pcb})
Interface to the C function @cfunc{timelocal}, @glibcref{Broken-down
Time, timelocal}.  Given a reference to a @code{struct-rm}, @var{tm},
representing a local broken time, convert it into a time value as
returned by @cfunc{time}.  If successful return an @strong{inexact}
integer representing the time value, else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_timegm (ikptr @var{tm}, ikpcb * @var{pcb})
Interface to the C function @cfunc{timegm}, @glibcref{Broken-down Time,
timegm}.  Given a reference to a @code{struct-rm}, @var{tm},
representing a @utc{} broken time, convert it into a time value as
returned by @cfunc{time}.  If successful return an @strong{inexact}
integer representing the time value, else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_strftime (ikptr @var{template}, ikptr @var{tm}, ikpcb * @var{pcb})
Interface to the C function @cfunc{strftime}, @glibcref{Formatting
Calendar Time, strftime}.  Given a bytevector @var{template} holding an
@ascii{} coded format string and a @code{struct-tm} instance @var{tm}:
build a formatted time string; the resulting time string can be at most
@math{4096} bytes wide.  If successful return a bytevector holding the
time string in @ascii{} coding, else return false.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_nanosleep (ikptr @var{secs}, ikptr @var{nsecs})
Interface to the C function @cfunc{nanosleep}, @glibcref{Sleeping,
nanosleep}.  Halt the current process for the specified amount of time.

The count of seconds @var{secs} must be an exact integer in the range
@math{[0, 2^32)}; the count of nanoseconds @var{nsecs} must be an exact
integer in the range @math{[0, 999999999]}.

If successful and the requested time is elapsed: return a pair whose car
is false and whose cdr is false.  If successful and the sleeping was
interrupted by an interprocess signal: return a pair whose car is an
exact integer representing the count of remaining seconds and whose cdr
is an exact integer representing the count of remaining nanoseconds.  If
an error occurs return an encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_current_time (ikptr @var{time})
Interface to the @cfunc{gettimeofday} C function.
@glibcref{High-Resolution Calendar, gettimeofday}.  Retrieve the current
time.  @var{time} must reference a @code{time} internal structure, which
is filled with three values: megaseconds, seconds and microseconds.
Always return @var{time} itself.
@end deftypefun


@deftypefun ikptr ikrt_gmt_offset (ikptr @var{time})
Compute the offset in seconds between the local time and the
@acronym{UTC} time.  @var{time} must reference a @code{time} internal
structure, already filled with megaseconds, seconds and microseconds.
Return a fixnum representing the offset.
@end deftypefun


@c page
@node capi linux
@section C language level @gnu{}+Linux interface


@menu
* capi linux status::           Process termination status.
@end menu

@c page
@node capi linux status
@subsection Process termination status


@deftypefun ikptr ikrt_linux_waitid (ikptr @var{idtype}, ikptr @var{id}, ikptr @var{info}, ikptr @var{options})
Interface to the Linux specific C function @cfunc{waitid}, see the
@cfunc{waitid} manual page for details.  Wait for the termination of one
or more child processes with finer control of @cfunc{waitpid}.  The
arguments @var{idtype}, @var{id} and @var{options} must be fixnums.
@var{info} must be a reference to a structure of type
@code{struct-siginfo_t}, @ref{linux status} for details.  If successful:
return @var{info} itself, else raise an exception.
@end deftypefun


The following functions accept as argument a fixnum representing the
process termination status, for example the return value of
@cfunc{system} or the status acquired by @cfunc{waitpid}.


@deftypefun ikptr ikrt_linux_WIFCONTINUED (ikptr @var{status})
Interface to the Linux specific C macro @cfunc{WIFCONTINUED}.  Return
true if the process was resumed by delivery of @code{SIGCONT}.
@end deftypefun

@c page
@node capi glibc
@section C language level @gnu{} C Library interface


@menu
* capi glibc env::              Operating system environment variables.
* capi glibc dir::              File system directories.
* capi glibc temp::             Temporary files and directories.
* capi glibc sync::             File system synchronisation.
* capi glibc socket::           Network sockets.
@end menu

@c page
@node capi glibc env
@subsection Operating system environment variables


@deftypefun ikrt ikrt_glibc_clearenv (void)
Interface to the C function @cfunc{clearenv}, @glibcref{Environment
Access, clearenv}.  Remove all the entries from the environment.  Return
the void object.
@end deftypefun

@c page
@node capi glibc dir
@subsection File system directories


@deftypefun ikptr ikrt_glibc_dirfd (ikptr @var{pointer})
Interface to the C function @cfunc{dirfd}, @glibcref{Opening a
Directory, dirfd}.  Acquire a file descriptor associated to the
directory entry referenced by @var{pointer}, which must be a pointer
object to a directory entry.  If successful return a fixnum representing
the file descriptor, else return an encoded @code{errno} value.
@end deftypefun

@c page
@node capi glibc temp
@subsection Temporary files and directories


@deftypefun ikptr ikrt_glibc_mkstemp (ikptr @var{template}, ikpcb * @var{pcb})
Interface to the C function @cfunc{mkstemp}, @glibcref{Temporary Files,
mkstemp}.  Create a temporary file, open it and open a file descriptor
for reading and writing.  @var{template} must be a mutable bytevector
holding a template pathname on entering and the actual pathname on
returning.  If successful return a file descriptor, else return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_glibc_mkdtemp (ikptr @var{template}, ikpcb * @var{pcb})
Interface to the C function @cfunc{mkdtemp}, @glibcref{Temporary Files,
mkdtemp}.  Create a temporary directory for reading and writing.
@var{template} must be a mutable bytevector holding a template pathname
on entering and the actual pathname on returning.  If successful return
@var{template} itself, else return an encoded @code{errno} value.
@end deftypefun

@c page
@node capi glibc sync
@subsection File system synchronisation


@deftypefun ikptr ikrt_glibc_sync (void)
Interface to the C function @cfunc{sync}, @glibcref{Synchronizing I/O}.
Flush kernel buffer data and meta informations to the file system
devices.  If successful return the fixnum zero, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_glibc_fsync (ikptr @var{fd})
Interface to the C function @cfunc{fsync}, @glibcref{Synchronizing I/O}.
Flush kernel buffer data and meta informations to the file system device
for the file descriptor @var{fd}.  If successful return the fixnum zero,
else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_glibc_fdatasync (ikptr @var{fd})
Interface to the C function @cfunc{fdatasync}, @glibcref{Synchronizing
I/O}.  Flush kernel buffer data to the file system device for the file
descriptor @var{fd}.  If successful return the fixnum zero, else return
an encoded @code{errno} value.
@end deftypefun

@c page
@node capi glibc socket
@subsection Network sockets


@deftypefun ikptr ikrt_glibc_if_nametoindex (ikptr @var{name})
Interface to the C function @cfunc{if_nametoindex}, @glibcref{Interface
Naming, if_nametoindex}.  Convert a string representing a network
interface to the corresponding internal index.  @var{name} must be a
bytevector holding the @utf{}-8 representation of the string.  Return a
fixnum representing the index or false if @var{name} is invalid.
@end deftypefun


@deftypefun ikptr ikrt_glibc_if_indextoname (ikptr @var{index}, ikpcb * @var{pcb})
Interface to the C function @cfunc{if_indextoname}, @glibcref{Interface
Naming, if_indextoname}.  Convert the index associated to an interface
to the corresponding string name.  @var{index} must be a fixnum
representing the index.  Return a bytevector holding the name or false
if @var{index} is invalid.
@end deftypefun


@deftypefun ikptr ikrt_glibc_if_nameindex (ikpcb * @var{pcb})
Interface to the C function @cfunc{if_nameindex}, @glibcref{Interface
Naming, if_nameindex}.  Build and return an association list having
fixnums as keys and bytevectors as values; the fixnums are the interface
indexes, the bytevectors are the corresponding interface names.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_glibc_gethostbyname2 (ikptr @var{rtd}, ikptr @var{hostname}, ikptr @var{addrtype}, ikpcb * @var{pcb})
Interface to the C function @cfunc{gethostbyname2}, @glibcref{Host
Names, gethostbyname2}.  Like @cfunc{ikrt_posix_gethostbyname} but
allows the selection of the address type with @var{addrtype} which must
be @code{AF_INET} or @code{AF_INET6}.
@end deftypefun

@c page
@node libs
@chapter Other libraries


@value{PRJNAME} comes with a set of additional libraries.

@menu
* include::                     Including source files at expand time.
* errno::                       More features for @code{errno}.
* words::                       Exact integer predicates and constants.
* keywords::                    More facilities for keyword objects.
* readline::                    Extended interface to @gnu{} Readline.
* parser logic::                Defining parsers logic.
* gcc::                         A toy library interface to @gcc{}.
* wtables::                     Weak hashtables.
* flonum format::               Formatting flonums.
* flonum parse::                Parsing flonums.
* sel::                         Simple event loop.
* syntaxes::                    Language syntactic extensions.
* infix::                       Infix to prefix transformer.
@end menu

@c page
@node include
@section Including source files at expand time


@cindex Library @library{vicare include}
@cindex @library{vicare include}, library


The following bindings are exported by the library @library{vicare
include}.


@deffn Syntax include @var{filename}
Include in the current source file the contents of the file selected by
the pathname @var{filename}, which must be a string.  Everything happens
as if the code was present in place of the @func{include} form.
@end deffn


@deffn Syntax include/lexical-context @var{filename} @var{identifier}
Include in the current source file the contents of the file selected by
the pathname @var{filename}, which must be a string.  @var{identifier}
must be a Scheme identifier and it is used to assign a lexical context
to the sourced code.
@end deffn

@c page
@node errno
@section More features for @code{errno}


@cindex Library @library{vicare errno}
@cindex @library{vicare errno}, library


One syntax identifier binding for each known @code{errno} value is
exported by the library @library{vicare errno}; @ref{iklib errno} for
details on @value{PRJNAME} internal encoding of @code{errno} codes.  The
following bindings are exported by the library @library{vicare errno}.


@deffn Syntax errno-code @meta{symbol}
Verify that @meta{symbol} is one of the symbolic names of @code{errno};
if successful expand to an expression evaluating to the coded
@code{errno} value, else raise a syntax violation.
@end deffn


@deffn Syntax case-errno @meta{errno} ((@metao{code} @meta{code} ...) . @meta{cbody}) ...
@deffnx Syntax case-errno @meta{errno} ((@metao{code} @meta{code} ...) . @meta{cbody}) ... (else . @meta{ebody})
@deffnx {Auxiliary Syntax} else
Specialised @func{case} macro for @code{errno} values.  @func{else} is
the auxiliary keyword exported by @library{rnrs}.  Example:

@example
#!r6rs
(import (rnrs)
  (vicare ffi))

(define identifier "some-port")

(case-errno (errno)
  ((EACCES EFAULT)
   (make-i/o-file-protection-error identifier))
  ((EROFS)
   (make-i/o-file-is-read-only-error identifier))
  ((EEXIST)
   (make-i/o-file-already-exists-error identifier))
  ((EIO)
   (make-i/o-error))
  ((ENOENT)
   (make-i/o-file-does-not-exist-error identifier))
  (else
   (make-irritants-condition (list identifier))))
@end example

The @meta{code} must be symbols representing @code{errno} codes, they
are @strong{not} meant to be binding identifiers.
@end deffn

@c page
@node words
@section Exact integer predicates and constants


@cindex Library @library{vicare words}
@cindex @library{vicare words}, library


It is often needed to validate exact integers agains fixed range bounds,
for example for 32-bit and 64-bit representations or some platform
specific C language type.  The library @library{vicare words} implements
such predicates and minimum/maximum range constants.

@menu
* words sizeof::                Knowing the size of C language types.
* words predicates::            Verifying the range of integers.
* words limits::                Exact integer range limits.
@end menu

@c page
@node words sizeof
@subsection Knowing the size of C language types


The following bindings are exported by the @library{vicare words}
library.


@deffn {Identifier Syntax} SIZEOF_CHAR
Number of bytes in the C language type @code{char}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_SHORT
Number of bytes in the C language type @code{short int}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_INT
Number of bytes in the C language type @code{int}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_LONG
Number of bytes in the C language type @code{long}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_LONG_LONG
Number of bytes in the C language type @code{long long}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_SIZE_T
Number of bytes in the C language type @code{size_t}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_SSIZE_T
Number of bytes in the C language type @code{ssize_t}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_OFF_T
Number of bytes in the C language type @code{off_t}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_PTRDIFF_T
Number of bytes in the C language type @code{ptrdiff_t}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_FLOAT
Number of bytes in the C language type @code{float}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_DOUBLE
Number of bytes in the C language type @code{double}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_POINTER
Number of bytes in the C language type @code{void *}.
@end deffn

@c page
@node words predicates
@subsection Verifying the range of integers


The following bindings are exported by the @library{vicare words}
library.


@deffn Syntax word? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum, that is an exact
integer; else return @false{}.
@end deffn


@deffn Syntax machine-word? @var{obj}
On 32-bit platforms: return @true{} if @var{obj} is a fixnum or bignum
in the 32-bit range; on 64-bit platforms: return @true{} if @var{obj} is
a fixnum or bignum in the 64-bit range; else return @false{}.
@end deffn


@deffn Syntax word-u8? @var{obj}
@deffnx Syntax word-s8? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum in the 8-bit
range; else return @false{}.
@end deffn


@deffn Syntax word-u16? @var{obj}
@deffnx Syntax word-s16? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum in the 16-bit
range; else return @false{}.
@end deffn


@deffn Syntax word-u32? @var{obj}
@deffnx Syntax word-s32? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum or bignum in
the 32-bit range; else return @false{}.
@end deffn


@deffn Syntax word-u64? @var{obj}
@deffnx Syntax word-s64? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum or bignum in
the 64-bit range; else return @false{}.
@end deffn


@deffn Syntax word-u128? @var{obj}
@deffnx Syntax word-s128? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum or bignum in
the 128-bit range; else return @false{}.
@end deffn


@deffn Syntax word-u256? @var{obj}
@deffnx Syntax word-s256? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum or bignum in
the 256-bit range; else return @false{}.
@end deffn


@deffn Syntax unsigned-char? @var{obj}
@deffnx Syntax signed-char? @var{obj}
Return @true{} if @var{obj} is a fixnum in the range representable with
a platform C language type @code{signed char} or @code{unsigned char}.
@end deffn


@deffn Syntax unsigned-short? @var{obj}
@deffnx Syntax signed-short? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{signed short int} or
@code{unsigned short int}.
@end deffn


@deffn Syntax unsigned-int? @var{obj}
@deffnx Syntax signed-int? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{signed int} or
@code{unsigned int}.
@end deffn


@deffn Syntax unsigned-long? @var{obj}
@deffnx Syntax signed-long? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{signed long int} or
@code{unsigned long int}.
@end deffn


@deffn Syntax unsigned-long-long? @var{obj}
@deffnx Syntax signed-long-long? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{signed long long
int} or @code{unsigned long long int}.
@end deffn


@deffn Syntax pointer-integer? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{void *}.
@end deffn


@deffn Syntax size_t? @var{obj}
@deffnx Syntax ssize_t? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{size_t} or
@code{ssize_t} as defined by @file{stddef.h}.
@end deffn


@deffn Syntax off_t? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{off_t} as defined by
@file{stdio.h}.
@end deffn


@deffn Syntax ptrdiff_t? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{ptrdiff_t} as
defined by @file{stddef.h}.
@end deffn


The following predicates are meant to be used to validate indices in
bytevectors.


@deffn Syntax fixnum-aligned-to-2? @var{N}
@strong{Unsafe syntax: @var{N} must be a fixnum.}  Evaluate to @true{}
if @var{N} is a fixnum multiple of @math{2}; else evaluate to @false{}.
@end deffn


@deffn Syntax fixnum-aligned-to-4? @var{N}
@strong{Unsafe syntax: @var{N} must be a fixnum.}  Evaluate to @true{}
if @var{N} is a fixnum multiple of @math{4}; else evaluate to @false{}.
@end deffn


@deffn Syntax fixnum-aligned-to-8? @var{N}
@strong{Unsafe syntax: @var{N} must be a fixnum.}  Evaluate to @true{}
if @var{N} is a fixnum multiple of @math{8}; else evaluate to @false{}.
@end deffn


@deffn Syntax fixnum-aligned-to? @var{N} @var{alignment}
@strong{Unsafe syntax: @var{N} and @var{alignment} must be fixnums.}
Evaluate to @true{} if @var{N} is a fixnum multiple of @math{alignment};
else evaluate to @false{}.
@end deffn

@c page
@node words limits
@subsection Exact integer range limits


The following bindings are exported by the @library{vicare words}
library.

@c ------------------------------------------------------------

@subsubheading Inclusive limits


@deffn Syntax greatest-u8
@deffnx Syntax greatest-s8
@deffnx Syntax least-u8
@deffnx Syntax least-s8
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 8-bit range.
@end deffn


@deffn Syntax greatest-u16
@deffnx Syntax greatest-s16
@deffnx Syntax least-u16
@deffnx Syntax least-s16
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 16-bit range.
@end deffn


@deffn Syntax greatest-u32
@deffnx Syntax greatest-s32
@deffnx Syntax least-u32
@deffnx Syntax least-s32
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 32-bit range.
@end deffn


@deffn Syntax greatest-u64
@deffnx Syntax greatest-s64
@deffnx Syntax least-u64
@deffnx Syntax least-s64
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 64-bit range.
@end deffn


@deffn Syntax greatest-s128
@deffnx Syntax greatest-u128
@deffnx Syntax least-u128
@deffnx Syntax least-s128
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 128-bit range.
@end deffn


@deffn Syntax greatest-s256
@deffnx Syntax greatest-u256
@deffnx Syntax least-u256
@deffnx Syntax least-s256
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 256-bit range.
@end deffn


@deffn Syntax greatest-machine-word
@deffnx Syntax least-machine-word
On 32-bit platforms: evaluate to the greatest or least unsigned exact
integer in the 32-bit range.

On 64-bit platforms: evaluate to the greatest or least unsigned exact
integer in the 64-bit range.
@end deffn


@deffn Syntax greatest-c-unsigned-char
@deffnx Syntax greatest-c-signed-char
@deffnx Syntax least-c-unsigned-char
@deffnx Syntax least-c-signed-char
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{char} range.
@end deffn


@deffn Syntax greatest-c-unsigned-short
@deffnx Syntax greatest-c-signed-short
@deffnx Syntax least-c-unsigned-short
@deffnx Syntax least-c-signed-short
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{short int} range.
@end deffn


@deffn Syntax greatest-c-unsigned-int
@deffnx Syntax greatest-c-signed-int
@deffnx Syntax least-c-unsigned-int
@deffnx Syntax least-c-signed-int
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{int} range.
@end deffn


@deffn Syntax greatest-c-unsigned-long
@deffnx Syntax greatest-c-signed-long
@deffnx Syntax least-c-unsigned-long
@deffnx Syntax least-c-signed-long
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{long} range.
@end deffn


@deffn Syntax greatest-c-unsigned-long-long
@deffnx Syntax greatest-c-signed-long-long
@deffnx Syntax least-c-unsigned-long-long
@deffnx Syntax least-c-signed-long-long
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{long long} range.
@end deffn


@deffn Syntax greatest-c-pointer
@deffnx Syntax least-c-pointer
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{void *} range.
@end deffn


@deffn Syntax greatest-c-size_t
@deffnx Syntax least-c-size_t
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{size_t} range.
@end deffn


@deffn Syntax greatest-c-ssize_t
@deffnx Syntax least-c-ssize_t
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{ssize_t} range.
@end deffn


@deffn Syntax greatest-c-off_t
@deffnx Syntax least-c-off_t
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{off_t} range.
@end deffn


@deffn Syntax greatest-c-ptrdiff_t
@deffnx Syntax least-c-ptrdiff_t
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{ptrdiff_t} range.
@end deffn

@c ------------------------------------------------------------

@subsubheading Exclusive limits


@deffn Syntax greatest-u8*
@deffnx Syntax greatest-s8*
@deffnx Syntax least-u8*
@deffnx Syntax least-s8*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 8-bit range.
@end deffn


@deffn Syntax greatest-u16*
@deffnx Syntax greatest-s16*
@deffnx Syntax least-u16*
@deffnx Syntax least-s16*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 16-bit range.
@end deffn


@deffn Syntax greatest-u32*
@deffnx Syntax greatest-s32*
@deffnx Syntax least-u32*
@deffnx Syntax least-s32*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 32-bit range.
@end deffn


@deffn Syntax greatest-u64*
@deffnx Syntax greatest-s64*
@deffnx Syntax least-u64*
@deffnx Syntax least-s64*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 64-bit range.
@end deffn


@deffn Syntax greatest-s128*
@deffnx Syntax greatest-u128*
@deffnx Syntax least-u128*
@deffnx Syntax least-s128*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 128-bit range.
@end deffn


@deffn Syntax greatest-s256*
@deffnx Syntax greatest-u256*
@deffnx Syntax least-u256*
@deffnx Syntax least-s256*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 256-bit range.
@end deffn


@deffn Syntax greatest-machine-word*
@deffnx Syntax least-machine-word*
On 32-bit platforms: evaluate to the greatest--plus--1 or
least--minus--1 unsigned exact integer in the 32-bit range.

On 64-bit platforms: evaluate to the greatest--plus--1 or
least--minus--1 unsigned exact integer in the 64-bit range.
@end deffn


@deffn Syntax greatest-c-unsigned-char*
@deffnx Syntax greatest-c-signed-char*
@deffnx Syntax least-c-unsigned-char*
@deffnx Syntax least-c-signed-char*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{char} range.
@end deffn


@deffn Syntax greatest-c-unsigned-short*
@deffnx Syntax greatest-c-signed-short*
@deffnx Syntax least-c-unsigned-short*
@deffnx Syntax least-c-signed-short*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{short int} range.
@end deffn


@deffn Syntax greatest-c-unsigned-int*
@deffnx Syntax greatest-c-signed-int*
@deffnx Syntax least-c-unsigned-int*
@deffnx Syntax least-c-signed-int*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{int} range.
@end deffn


@deffn Syntax greatest-c-unsigned-long*
@deffnx Syntax greatest-c-signed-long*
@deffnx Syntax least-c-unsigned-long*
@deffnx Syntax least-c-signed-long*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{long} range.
@end deffn


@deffn Syntax greatest-c-unsigned-long-long*
@deffnx Syntax greatest-c-signed-long-long*
@deffnx Syntax least-c-unsigned-long-long*
@deffnx Syntax least-c-signed-long-long*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{long long} range.
@end deffn


@deffn Syntax greatest-c-pointer*
@deffnx Syntax least-c-pointer*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{void *} range.
@end deffn


@deffn Syntax greatest-c-size_t*
@deffnx Syntax least-c-size_t*
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{size_t*} range.
@end deffn


@deffn Syntax greatest-c-ssize_t*
@deffnx Syntax least-c-ssize_t*
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{ssize_t*} range.
@end deffn


@deffn Syntax greatest-c-off_t*
@deffnx Syntax least-c-off_t*
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{off_t} range.
@end deffn


@deffn Syntax greatest-c-ptrdiff_t*
@deffnx Syntax least-c-ptrdiff_t*
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{ptrdiff_t} range.
@end deffn

@c page
@node keywords
@section More facilities for keyword objects


@cindex Library @library{vicare keywords}
@cindex @library{vicare keywords}, library


Keywords are disjoint objects which can be read by @value{PRJNAME}'s
reader in @code{#!vicare} mode, @ref{iklib reader stx}.  The core
bindings and keyword objects handling is embedded in @value{PRJNAME}'s
boot image, but additional facilities are required to make use of
keywords.

The following bindings are exported by the library @library{vicare
keywords}.  Additionally the following bindings are reexported from
@library{vicare}:

@example
symbol->keyword         keyword->symbol
keyword?                keyword=?
keyword-hash
@end example


@defun keyword->string @var{keyword}
@defunx string->keyword @var{string}
Convert a keyword object to and from a string object.  The string is the
name of the symbol embedded in the keyword.
@end defun


@deffn Syntax let-keywords @meta{input} @meta{args} @meta{allow} @meta{options-spec} @metao{form} @meta{form} ...
@deffnx Syntax let*-keywords @meta{input} @meta{args} @meta{allow} @meta{options-spec} @metao{form} @meta{form} ...
@deffnx Syntax letrec-keywords @meta{input} @meta{args} @meta{allow} @meta{options-spec} @metao{form} @meta{form} ...
@deffnx Syntax letrec*-keywords @meta{input} @meta{args} @meta{allow} @meta{options-spec} @metao{form} @meta{form} ...
@deffnx {Auxiliary Syntax} with-argument @meta{name} @meta{default} @meta{keyword}
@deffnx {Auxiliary Syntax} without-argument @meta{name} @meta{default} @meta{keyword} @meta{when-given}
Expand into a @func{let} like form whose bindings are configured from a
list of arguments and options.

@func{let-keywords} expands into a @func{let} syntax,
@func{let*-keywords} expands into a @func{let*} syntax,
@func{letrec-keywords} expands into a @func{letrec} syntax,
@func{let-keywords} expands into a @func{let} syntax.

@meta{input} must be an expression evaluating to a list of values and
keywords; keywords must be compliant to the specification in
@meta{options-spec}.  The same keyword can be present multiple times in
@meta{input}.

@meta{args} must be an identifier which will be bound to a list of
values from @meta{input} not matching any of the options specified in
@meta{options-spec}.

@meta{allow} must be an expression meant to evaluate to @false{} or
true; when @false{}: keyword values in @meta{input} not matched by
specifications in @meta{options-spec} will cause an assertion violation;
when true: keyword values in @meta{input} not matched by specifications
in @meta{options-spec} will be collected in @meta{args}.

@meta{options-spec} must be null or a list of lists, each with the
following formats:

@example
(with-argument @meta{name} @meta{default} @meta{keyword})
(without-argument @meta{name} @meta{default} @meta{keyword} @meta{when-given})
@end example

@noindent
such specifications are interpreted as follows:

@itemize
@item
The @func{with-argument} specification describes an optional keyword
argument with mandatory value, which must @strong{not} be a keyword
itself.

@item
The @func{without-argument} specification describes an optional keyword
argument with mandatory value, which must @strong{not} be a keyword
itself.

@item
@meta{name} must be an identifier which will become the name of a
binding in the output @func{let} like syntax.

@item
@meta{default} must be an expression which will become a the value of
binding in the output @func{let} like syntax.

@item
@meta{keyword} must be a keyword object which can be present in
@meta{input} to mutate the associated @meta{name} binding.

@item
For keywords with argument: when the @meta{keyword} is present in
@meta{input}, it must be followed by a value which will become the new
value of the corresponding @meta{name} binding.


@item
For keywords without argument: when the @meta{keyword} is present in
@meta{input}, the value resulting from the evaluation of
@meta{when-given} will become the new value of the corresponding
@meta{name} binding.
@end itemize

We can imagine the following macro use:

@example
(let-keywords @meta{input} args #f
    ((with-argument a 1 #:a)
     (with-argument b 2 #:b))
  (alpha)
  (beta))
@end example

@noindent
to expand to something like:

@example
(let ((a 1)
      (b 2))
  (let ((args @meta{options-parser}))
    (alpha)
    (beta)))
@end example

@noindent
where @meta{options-parser} is a form which takes care of parsing the
@meta{input}.
@end deffn


Examples:

@example
#!vicare
(import (vicare)
  (vicare keywords))

;; options with arguments
(let-keywords '(#:a 1 #:b 2 #:d 4) args #f
    ((with-argument a #\a #:a)
     (with-argument b #\b #:b)
     (with-argument c #\c #:c)
     (with-argument d #\d #:d))
  (list a b c d args))
@result{} (1 2 #\c 4 ())

;; options without arguments
(let-keywords '(#:a #:b #:d 4) args #f
    ((without-argument a #\a #:a #\A)
     (without-argument b #\b #:b #\B)
     (without-argument c #\c #:c #\C)
     (with-argument d #\d #:d))
  (list a b c d args))
@result{} (#\A #\B #\c 4 ())

;; options with arguments, leftover arguments
(let-keywords '(#:a 1 ciao #:b 2 hello #:d 4) args #f
    ((with-argument a #\a #:a)
     (with-argument b #\b #:b)
     (with-argument c #\c #:c)
     (with-argument d #\d #:d))
  (list a b c d args))
@result{} (1 2 #\c 4 (ciao hello))

;; no options, allow unknown
(let-keywords '(#:a 1 #:b 2 #:d 4) args #t
    ()
  args)
@result{} (#:a 1 #:b 2 #:d 4)

(let-keywords '(#:a) args #f
    ()
  args)
@error{} unknown option #:a

(let-keywords '(#:a #:b 123) args #t
    ((with-argument a 1 #:a)
     (with-argument b 2 #:b))
  args)
@error{} option value for #:a cannot be a keyword

(let-keywords '(#:a) args #t
    ((with-argument a 1 #:a)
     (with-argument b 2 #:b))
  args)
@error{} option #:a requires argument

;; keywords used multiple times
(let-keywords '(#:verbose #:verbose #:verbose) args #f
  ((without-argument verbosity 0 #:verbose (+ 1 verbosity)))
  verbosity)
@result{} 3
@end example

@c page
@node readline
@section Extended interface to @gnu{} Readline


@cindex Library @library{vicare readline}
@cindex @library{vicare readline}, library


The library @library{vicare readline} extends the basic readline @api{}
exported by @library{vicare} (@pxref{iklib readline}) with features
specific to the @gnu{} Readline library.  The following bindings:

@example
readline-enabled?
readline
make-readline-input-port
@end example

@noindent
exported by @library{vicare} are reexported by @library{vicare
readline}.


@defun rl-version
If support for readline is enabled and the linked library is @gnu{}
Readline: return an exact integer representing the @gnu{} Readline
version number as encoded in the C symbol @code{RL_READLINE_VERSION};
else return @false{}.  When this function returns @false{}: no other
@gnu{} Readline functions must be called, lest the process be aborted.
@end defun

@c page
@node parser logic
@section Defining parsers logic


@cindex Library @library{vicare parser-logic}
@cindex @library{vicare parser-logic}, library


The library @library{vicare parser-logic} defines an infrastructure to
declare the logic of a parser for sequences of characters; such logic
can be specialised for different underlying devices.  The library
heavily relies on macros.

@menu
* parser logic intro::          Introductory examples.
* parser logic operators::      The logic of parser operators.
* parser logic api::            Programming interface to
                                parser definition.
@end menu

@c page
@node parser logic intro
@subsection Introductory examples


@subsubheading Parsing a string of selected characters

As first usage example, let's see a simple parser using a full Scheme
string as argument and accepting lexemes being the empty string or
strings of characters @samp{#\a} and @samp{\#b}; the result of a call to
the parser is the list of characters or @false{} if the input is
invalid:

@example
#!r6rs
(import (vicare)
  (vicare parser-logic))

(module (parse-abba)

  (define (parse-abba input-string)
    (assert (string? input-string))
    (%parse-string input-string
                   (string-length input-string)
                   0    ;start index
                   '()  ;start value for ACCUMULATOR
                   ))

  (define-parser-logic define-string->abba-parser ch next fail
    (%parse-string (accumulator)
       ((:end-of-input)
        (reverse accumulator))
       ((#\a #\b)
        (next %parse-string (cons ch accumulator)))))

  (define-string->abba-parser string->token-or-false
    (%parse-string))

  #| end of module |# )

(parse-abba "")         @result{} ()
(parse-abba "a")        @result{} (#\a)
(parse-abba "b")        @result{} (#\b)
(parse-abba "1")        @result{} #f)
(parse-abba "ciao")     @result{} #f)
(parse-abba "abb")      @result{} (#\a #\b #\b)
@end example

@noindent
notice the use of @func{next} to recursively tail--call
@func{parse-string}.

The macro @func{string->token-or-false} is exported by @library{vicare
parser-logic}; it implements the device logic for a full input Scheme
string representing a lexeme; it is to be used in a parser returning
@false{} when the input is invalid.

The macros in the module combine their output and expand to the
definition of a function @func{%parse-string} equivalent to the
following:

@example
(define (%parse-string input.string input.length input.index
                       accumulator)
  (if (fx=? input.index input.length)
      (reverse accumulator)
    (let ((ch (string-ref input.string input.index)))
      (cond ((or (char=? #\a ch)
                 (char=? #\b ch))
             (%parse-string input.string input.length
                            (fx+ 1 input.index)
                            (cons ch accumulator)))
            (else #f)))))
@end example

@c ------------------------------------------------------------

@subsubheading Parsing a string of intermixed selected characters

Let's see a parser using a full Scheme string as argument and accepting
lexemes being the empty string or strings of characters @samp{#\a} and
@samp{\#b}:

@itemize
@item
@samp{#\a} can be followed only by @samp{#\b} or end--of--input.

@item
@samp{#\b} can be followed only by @samp{#\a} or end--of--input.
@end itemize

@noindent
the result of a call to the parser is the list of characters or @false{}
if the input is invalid:

@example
#!r6rs
(import (vicare)
  (vicare parser-logic))

(module (parse-abab)

  (define (parse-abab input-string)
    (assert (string? input-string))
    (%parse-string input-string
                   (string-length input-string)
                   0    ;start index
                   '()  ;start value for ACCUMULATOR
                   ))

  ;;Parser logic to convert a string of intermixed
  ;;#\a and #\b into a list of characters.
  (define-parser-logic define-string->abab-parser ch next fail
    (%parse-string (accumulator)
       ((:end-of-input)
        (reverse accumulator))
       ((#\a #\b)
        (if (or (null? accumulator)
                (case ch
                  ((#\a) (char=? #\b (car accumulator)))
                  ((#\b) (char=? #\a (car accumulator)))))
            (next %parse-string (cons ch accumulator))
          (fail)))))

  ;;Actual parser drawing characters from an input string.
  (define-string->abab-parser string->token-or-false
    (%parse-string))

  #| end of module |# )

(parse-abab "")         @result{} ()
(parse-abab "a")        @result{} (#\a)
(parse-abab "b")        @result{} (#\b)
(parse-abab "1")        @result{} #f
(parse-abab "ciao")     @result{} #f
(parse-abab "abb")      @result{} #f
(parse-abab "baa")      @result{} #f
(parse-abab "abab")     @result{} (#\a #\b #\a #\b)
(parse-abab "baba")     @result{} (#\b #\a #\b #\a)
@end example

@noindent
notice the use of @func{fail} to signal an input error from inside an
operator clause.

The macros in the module combine their output and expand to the
definition of a function @func{%parse-string} equivalent to the
following:

@example
(define (%parse-string input.string input.length input.index
                       accumulator)
  (if (fx=? input.index input.length)
      (reverse accumulator)
    (let ((ch (string-ref input.string input.index)))
      (cond ((or (char=? #\a ch)
                 (char=? #\b ch))
             (if (or (null? accumulator)
                     (case ch
                       ((#\a) (char=? #\b (car accumulator)))
                       ((#\b) (char=? #\a (car accumulator)))))
                 (%parse-string input.string input.length
                                (fx+ 1 input.index)
                                (cons ch accumulator))
               #f))
            (else #f)))))
@end example

@c ------------------------------------------------------------

@subsubheading Parsing exact integers in base @math{10}

Let's see a parser using a full Scheme string as argument and accepting
lexemes representing exact integers in base @math{10}; the result of a
call to the parser is the exact integer object or @false{} if the input
is invalid:

@example
#!r6rs
(import (vicare)
  (vicare parser-logic))

(define (parse-integer input-string)

  (define (%digit ch)
    ;;Given a character argument: return the corresponding
    ;;fixnum if the character is between #\0 and #\9, else
    ;;return false.
    ;;
    (let ((N (fx- (char->integer ch) (char->integer #\0))))
      (and (fx>= N 0)
           (fx<  N 10)
           N)))

  ;;Parser logic to convert a string into an exact integer
  ;;in base 10.
  (define-parser-logic define-string->integer-parser ch next fail
    (%parse-integer ()
       ((%digit) => D
        (next %parse-digit+ D)))
    (%parse-digit+ (accumulator)
       ((:end-of-input)
        accumulator)
       ((%digit) => D
        (next %parse-digit+ (+ D (* 10 accumulator))))))

  ;;Actual parser drawing characters from an input string.
  (define-string->integer-parser string->token-or-false
    (%parse-integer))

  (assert (string? input-string))
  (%parse-integer input-string (string-length input-string) 0))

(parse-integer "")              @result{} #f
(parse-integer "1")             @result{} 1
(parse-integer "123")           @result{} 123
(parse-integer "ciao")          @result{} #f
(parse-integer "123ciao")       @result{} #f
@end example

The macros in the body of @func{parse-integer} combine their output and
expand to the definition of two functions @func{%parse-integer} and
@func{%parse-digit+} equivalent to the following:

@example
(define (%parse-integer input.string input.length input.index)
  (if (fx=? input.index input.length)
      #f
    (let ((ch (string-ref input.string input.index)))
      (cond ((%digit ch)
             => (lambda (D)
                  (%parse-digit+ input.string input.length
                                 (fx+ 1 input.index) D)))
            (else #f)))))

(define (%parse-digit+ input.string input.length input.index
                       accumulator)
  (if (fx=? input.index input.length)
      accumulator
    (let ((ch (string-ref input.string input.index)))
      (cond ((%digit ch)
             => (lambda (D)
                  (%parse-digit+ input.string input.length
                                 (fx+ 1 input.index)
                                 (+ D (* 10 accumulator)))))
            (else #f)))))
@end example



@c page
@node parser logic operators
@subsection The logic of parser operators


After all the macros have been expanded, the parser is a set of
@dfn{operator functions} extracting characters from an input device with
the purpose of producing a token.  Some operators are ``entry points''
to the parser: public functions we can call to start parsing; other
operators are for internal use only.  Each operator is meant to either:
tail--call another operator, terminate parsing by raising an exception,
terminate parsing by returning an error value, terminate parsing
successfully by returning a token value.

@quotation
@strong{NOTE} Operator functions are just ordinary Scheme functions
playing a special role in a parser; they are given a name with the only
purpose of letting us talk about them, and it happens that such name is
``operator''.
@end quotation

Operators are generated by macros from a symbolic expression specifying
an abstract parser:

@example
(define-parser-logic define-parser ch next fail . @meta{operators})
@end example

@noindent
and containing a subexpression for each operator.  Access to the input
device is specified by another macro which must implement a set of
@func{syntax-rules}:

@example
(define-syntax device-logic
  (syntax-rules (:introduce-device-arguments
                 :generate-end-of-input-or-char-tests
                 :unexpected-end-of-input
                 :generate-delimiter-test
                 :invalid-input-char)
    ((_ :introduce-device-arguments          ---) ---)
    ((_ :generate-end-of-input-or-char-tests ---) ---)
    ((_ :unexpected-end-of-input             ---) ---)
    ((_ :generate-delimiter-test             ---) ---)
    ((_ :invalid-input-char                  ---) ---)))
@end example

Concrete parsers are defined by combining the parser logic with the
device logic:

@example
(define-parser device-logic (@meta{operator-name} ...))
@end example

@noindent
we can define any number of concrete parsers using the same parser logic
and different device logics; at the end of the expansion, the input
device forms are hard coded into the operator.  The list of
@meta{operator-name} is a list of identifiers bound to the operators
being entry points to the parser.

To understand the semantics of operators, let's consider one accepting
only the characters @samp{#\X} or @samp{#\Y} and rejecting the
end--of-input:

@example
(define (operator-1 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (error-form))
          ((char=? X ch)
           (a-clause-form))
          ((char=? Y ch)
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
such operator would be specified by the following @meta{operator}
symbolic subexpression:

@example
(operator-1 (parser-state)
  ((#\X)
   (a-clause-form))
  ((#\Y)
   (another-clause-form)))
@end example

@noindent
notice how the end--of--input test is automatically generated.  The
operator has some arguments representing the input device state and
other arguments representing the parser state; the list of input device
arguments comes first and is specified by the device logic, discussed
later; the list of parser state arguments comes last and is specified in
the @meta{operator} symbolic expression.

An operator function accepting characters @samp{#\X}, @samp{#\Y} or
@samp{#\Z}, with @samp{#\Y} and @samp{#\Z} to be processed in the same
way, and rejecting the end--of-input looks like this:

@example
(define (operator-2 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (error-form))
          ((char=? #\X ch)
           (a-clause-form))
          ((or (char=? #\Y ch)
               (char=? #\Z ch))
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
such operator would be specified by the following @meta{operator}
symbolic subexpression:

@example
(operator-2 (parser-state)
  ((#\X)
   (a-clause-form))
  ((#\Y #\Z)
   (another-clause-form)))
@end example

An operator function accepting characters @samp{#\X} or @samp{#\Y}, but
also the end--of--input from the device, looks like this:

@example
(define (operator-3 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (end-of-input-form))
          ((char=? #\X ch)
           (a-clause-form))
          ((char=? #\Y ch)
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
and is specified in the parser logic as the following @meta{operator}
symbolic subexpression:

@example
(operator-3 (parser-state)
  ((:end-of-input)
   (end-of-input-form))
  ((#\X)
   (a-clause-form))
  ((#\Y)
   (another-clause-form)))
@end example

An operator function accepting characters @samp{#\X} or @samp{#\Y}, the
end--of--input from the device, and also a set of end--of--lexeme
delimiter characters, looks like this:

@example
(define (operator-4 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (end-of-input-form))
          ((char=? #\X ch)
           (a-clause-form))
          ((char=? #\Y ch)
           (another-clause-form))
          ((end-of-lexeme-delimiter? ch)
           (end-of-input-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
notice how the @code{end-of-input-form} is used for both the proper
end--of--input state and the end--of--lexeme state; such operator is
specified in the parser logic as the following @meta{operator} symbolic
subexpression:

@example
(operator-4 (parser-state)
  ((:end-of-input)
   (end-of-input-form))
  ((X)
   (a-clause-form))
  ((Y)
   (another-clause-form)))
@end example

@noindent
notice that processing of the end--of--lexeme state is not specified in
the parser logic: its generation is completely delegated to the device
logic.

Sometimes it is useful to apply a test function or macro to an input
character and collect the result for further processing; this can be
done as follows:

@example
(define (the-test ch arg1 arg2 arg3)
  ---)

(define (operator-5 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (error-form))
          ((the-test ch 1 2 3)
           => (lambda (result)
                (a-clause-form)))
          ((char=? #\Y ch)
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
and is specified in the parser logic as the symbolic subexpression:

@example
(operator-5 (parser-state)
  ((the-test 1 2 3) => result
   (a-clause-form))
  ((#\Y)
   (another-clause-form)))
@end example

@noindent
where @func{=>} is the auxiliary syntax exported by @rsixlibrary{base}.

@c page
@node parser logic api
@subsection Programming interface to parser definition


The following bindings are exported by the library @library{vicare
parser-logic}.


@deffn Syntax define-parser-logic @meta{definer} @meta{ch} @meta{next} @meta{fail} . @meta{operators}
@deffnx {Auxiliary Syntax} :end-of-input
Define an abstract parser specifying the rules for parsing the input
characters through calls to a set of operator functions; the result of
the expansion is a syntax definition which can be used to instantiate a
concrete parser by combining the parser logic with the input device
logic.

The input arguments are:

@table @meta
@item definer
It must be an identifier.  It is bound to the generated syntax
definition; such syntax is used as follows:

@example
(@meta{definer} @meta{device-logic} (@meta{operator-name} @dots{}))
@end example

@noindent
where: @meta{device-logic} is the identifier bound to the device logic
syntax; the @meta{operator-name} are identifiers among the public
operator function names.

@item ch
It must be an identifier.  When a character is successfully extracted
from the input device, it is bound to this identifier and made available
to the operator clauses.

@item next
It must be an identifier.  The device logic rule
@code{:generate-end-of-input-or-char-tests} must bind it to a syntax;
such syntax must expand to a tail--call to an operator processing the
next input character.  @meta{next} is used as follows in the operator
clauses:

@example
(next @meta{operator-name} @meta{operator-arg} @dots{})
@end example

@noindent
and it should expand to something like:

@example
(@meta{operator-name} @meta{device-arg} @dots{} @meta{operator-arg} @dots{})
@end example

@noindent
where: @meta{device-arg} are the arguments representing the input device
state; @meta{operator-arg} are the arguments representing the parser
state as specified in the @meta{operator-spec}.

@item fail
It must be an identifier.  The device logic rule
@code{:generate-end-of-input-or-char-tests} must bind it to a syntax;
such syntax is used to handle parsing errors detected by the operator
clauses.  @meta{fail} is simply used as @code{(@meta{fail})}.
@end table

Each @meta{operator-spec} must have the form:

@example
(@meta{operator-name} (@meta{operator-arg} @dots{}) @meta{operator-clause} @dots{})
@end example

@noindent
where:

@table @meta
@item operator-name
Must be an identifier.  It is bound to a generated operator function.

There is no difference in the way public operators and private ones are
specified; the public operators names are listed in the concrete parser
definition.  An operator can be public in a concrete parser and private
in another concrete parser.

@item operator-arg
Must be identifiers bound to the formal arguments associated to the
parser state.

@item operator-clause
Are symbolic expressions specifying the input accepted by the operator.
@end table

Each @meta{operator-clause} must have one of the formats:

@table @code
@item ((@metao{char} @meta{char} @dots{}) @metao{body} @meta{body} @dots{})
Each @meta{char} must be an expression evaluating to a Scheme character
object.  The @meta{body} forms are evaluated if the input character
bound to @meta{ch} is equal, according to @func{char=?}, to one among
the @meta{char} characters.

@item ((@meta{func} @meta{expr} @dots{}) => @meta{ret} @metao{body} @meta{body} @dots{})
@meta{func} must be an expression evaluating to a function; the
@meta{expr} must be expressions; @meta{ret} must be an identifier.  The
@meta{body} forms are evaluated if the form:

@example
(@meta{func} @meta{ch} @meta{expr} @dots{})
@end example

@noindent
evaluates to a true value; such true value is bound to @meta{ret} prior
to evaluating the @meta{body}.

@item ((:end-of-input) @metao{body} @meta{body} @dots{})
The @meta{body} forms are evaluated if no more characters are available
from the input device.  This clause is to be used by operators accepting
the end--of--input state as valid; if such rule is not present: the
end--of--input will cause an error and the device logic is used to
handle it.
@end table
@end deffn

@c ------------------------------------------------------------

@deffn {Auxiliary Syntax} :introduce-device-arguments
@deffnx {Auxiliary Syntax} :generate-end-of-input-or-char-tests
@deffnx {Auxiliary Syntax} :unexpected-end-of-input
@deffnx {Auxiliary Syntax} :generate-delimiter-test
@deffnx {Auxiliary Syntax} :invalid-input-char
Identifiers used to specify device logic syntax rules; they must be used
in a syntax definition like:

@example
(define-syntax device-logic
  (syntax-rules (:introduce-device-arguments
                 :generate-end-of-input-or-char-tests
                 :unexpected-end-of-input
                 :generate-delimiter-test
                 :invalid-input-char)
    ((_ :introduce-device-arguments          ---) ---)
    ((_ :generate-end-of-input-or-char-tests ---) ---)
    ((_ :unexpected-end-of-input             ---) ---)
    ((_ :generate-delimiter-test             ---) ---)
    ((_ :invalid-input-char                  ---) ---)))
@end example

@noindent
the rules have the following syntax:

@table @code
@item :introduce-device-arguments
The input form is:

@example
(_ :introduce-device-arguments @meta{kont} . @meta{rest})
@end example

@noindent
this rule introduces a list of identifiers used as device--specific
arguments; they will be the first arguments for each parser operator
function.  The output form must be:

@example
(@meta{kont} (@meta{device-arg} @dots{}) . @meta{rest})
@end example

@noindent
where the @meta{device-arg} are identifiers.

@item :generate-end-of-input-or-char-tests
The input form is:

@example
(_ :generate-end-of-input-or-char-tests
   @meta{ch} @meta{next} @meta{fail}
   (@meta{device-arg} @dots{})
   @meta{end-of-input-kont} @meta{parse-input-char-kont})
@end example

@noindent
this rule is used to generate the input device tests for an operator
function.  The expanded code must first test for the end--of--input
state and then proceed to evaluate code for the input character; in
pseudocode the output form should be:

@example
(if (end-of-input? @meta{device-arg} ...)
    @meta{end-of-input-kont}
  (let ((@meta{ch} (get-next-char @meta{device-arg} ...)))
    @meta{parse-input-char-kont}))
@end example

@meta{ch} is an identifier.  The input character must be bound to it
before evaluating @meta{parse-input-char-kont}.

@meta{next} is an identifier.  This rule must bind it to a syntax used
to tail--call another operator using @meta{device-arg} as first
arguments; for example:

@example
(define-syntax @meta{next}
  (syntax-rules ()
    ((_ ?operator-name ?operator-arg ...)
     (?operator-name @meta{device-arg} ... ?operator-arg))))
@end example

@meta{fail} is an identifier.  This rule must bind it to a syntax used
to signal an error detected by an operator clause; for example:

@example
(define-syntax @meta{fail}
  (syntax-rules ()
    ((_)
     (error #f "invalid input character"
       @meta{device-arg} ...))))
@end example

The @meta{device-arg} are the identifiers introduced by
@code{:introduce-device-arguments}.

@meta{end-of-input-kont} is a form to be evaluated whenever the
end--of--input is detected.

@meta{parse-input-char-kont} is a form to be evaluated whenever a
character is extracted from the input device.

@item :unexpected-end-of-input
The input form is:

@example
(_ :unexpected-end-of-input (@meta{device-arg} @dots{}))
@end example

@noindent
whenever the end--of--input is found by an operator that does not accept
it as valid, this rule is used to decide what to do.

The @meta{device-arg} are the identifiers introduced by
@code{:introduce-device-arguments}.

The output form can return a value or raise an exception; the returned
value becomes the return value of the call to the parser.

@item :generate-delimiter-test
The input form is:

@example
(_ :generate-delimiter-test
   @meta{ch}
   @meta{ch-is-delimiter-kont}
   @meta{ch-is-not-delimiter-kont})
@end example

@noindent
this rule is used for input devices for which the lexeme string is
embedded into a sequence of other characters, so there exists a set of
characters that delimit the end--of--lexeme.  The parser delegates to
the device the responsibility of knowing which characters are
delimiters, if any.

@meta{ch} is an identifier bound to the input character.
@meta{ch-is-delimiter-kont} is a form to be evaluated whenever @meta{ch}
is a delimiter character.  @meta{ch-is-not-delimiter-kont} is a form to
be evaluated whenever @meta{ch} is not a delimiter character.

For parsers accepting a full Scheme string as lexeme: there are no
delimiters,3 the end--of--lexeme is the end--of--input; such parsers
should just use @meta{ch-is-not-delimiter-kont} as output form.

For parsers having delimiter characters, for example, recognised by a
function like:

@example
(define (delimiter? ch)
  (or (char=? ch #\space)
      (char=? ch #\linefeed)))
@end example

@noindent
the output form should be something like:

@example
(if (delimiter? @meta{ch})
    @meta{ch-is-delimiter-kont}
  @meta{ch-is-not-delimiter-kont})
@end example

@item :invalid-input-char
The input form is:

@example
(_ :invalid-input-char (@meta{device-arg} @dots{}) @meta{ch})
@end example

@noindent
whenever an input character is not accepted by an operator function this
rule is used to decide what to do.

The @meta{device-arg} are the identifiers introduced by
@code{:introduce-device-arguments}; @meta{ch} is an identifier bound to
the invalid input character.

The output form can return a value or raise an exception; the returned
value becomes the return value of the call to the parser.
@end table
@end deffn

@c ------------------------------------------------------------

@deffn Syntax string->token-or-false @meta{keyword} @meta{arg} ...
Define the device logic to parse a lexeme from a full Scheme string
object as in @func{string->number}.  It is implemented as follows:

@example
(define-syntax string->token-or-false
  (syntax-rules (:introduce-device-arguments
                 :generate-end-of-input-or-char-tests
                 :unexpected-end-of-input
                 :generate-delimiter-test
                 :invalid-input-char)
    ((_ :introduce-device-arguments
        ?kont . ?rest)
     (?kont (input.string input.length input.index) . ?rest))

    ((_ :invalid-input-char
        (?input.string ?input.length ?input.index)
        ?ch)
     #f)

    ((_ :unexpected-end-of-input
        (?input.string ?input.length ?input.index))
     #f)

    ((_ :generate-delimiter-test
        ?ch ?ch-is-delimiter-kont ?ch-is-not-delimiter-kont)
     ?ch-is-not-delimiter-kont)

    ((_ :generate-end-of-input-or-char-tests
        ?ch ?next ?fail
        (?input.string ?input.length ?input.index)
        ?end-of-input-kont ?parse-input-char-kont)
     (let-syntax
         ((?fail (syntax-rules ()
                   ((_) #f)))
          (?next (syntax-rules ()
                   ((_ ?operator-name ?operator-arg (... ...))
                    (?operator-name ?input.string ?input.length
                                    (fx+ 1 ?input.index)
                                    ?operator-arg (... ...))))))
       (if (fx=? ?input.index ?input.length)
           ?end-of-input-kont
         (let ((?ch (string-ref ?input.string ?input.index)))
           ?parse-input-char-kont))))
    ))
@end example
@end deffn

@c page
@node gcc
@section A toy library interface to @gcc{}


@cindex Library @library{vicare gcc}
@cindex @library{vicare gcc}, library


The library @library{vicare gcc} is installed along with
@value{PRJNAME}; it implements a toy interface to @command{gcc}, the
@gnu{} C Compiler.  Its purpose is to build, at runtime, a C language
shared library from possibly dynamically constructed C code; then load
the library and access a C function as @ffi{} callout.

@library{vicare gcc} must be considered as a toy to demonstrate the
features of @value{PRJNAME}; it is installed only if the @posix{},
@gnu{} C library and Libffi @api{}s are enabled at package configuration
time.

The following is an example of function to increment an integer:

@example
#!r6rs
(import (vicare)
  (prefix (vicare gcc) gcc.))

(gcc.initialise "/usr/local/bin/gcc" "/home/marco/var/tmp/")

(gcc.define-c-function
  signed-int incr (signed-int)
  "#include <stdio.h>
   int incr (int a) @{
     return 1+a;
   @}")

(incr 1)        @result{} 2
@end example

@noindent
the code creates a shared library @code{libincr.so} in a subdirectory of
the given initialisation directory, then load it and access the symbol
@code{incr}.

@library{vicare gcc} depends upon the following libraries:

@example
(vicare ffi)
(vicare posix)
(vicare glibc)
(vicare platform-constants)
(vicare syntactic-extensions)
@end example


@defun initialise @var{gcc} @var{tmpdir}
Initialise the library.  @var{gcc} must be the string full filename of
the @gcc{} executable.  @var{tmpdir} must be the string pathname of an
existing directory on a partition with executable permissions; it is
used to create temporary files, including the shared libraries.

Temporary files go in a subdirectory of @var{tmpdir}; it is the
responsibility of the system administrator to clean up regularly such
subdirectories.
@end defun


@deffn Syntax define-c-function @meta{retval} @meta{name} @meta{args} @meta{code}
Define a new Scheme function wrapping a C function from a shared
library.  @meta{name} must be an identifier representing the name of the
function.

@meta{retval} must be a symbol selecting the type of the return value;
@meta{args} must be a list of symbols selecting the types of the
arguments; @ref{ffi call types} for details.

@meta{code} must be a Scheme string representing the C code to be
compiled.
@end deffn


@deffn Parameter COMPILE-FLAGS
References a list of string.  Base options for the compiler, it is
initialised to @code{("-c")}.
@end deffn


@deffn Parameter LINK-FLAGS
References a list of string.  Base options for the linker, it is
initialised to @code{("-pipe" "-shared" "-fPIC")}.
@end deffn


@deffn Parameter CFLAGS
References a list of string.  Additional options for the compiler, it is
initialised to @code{("-O2")}.
@end deffn


@deffn Parameter LDFLAGS
References a list of string.  Additional options for the linker, it is
initialised to nil.
@end deffn

@c page
@node wtables
@section Weak hashtables


@cindex Library @library{vicare weak-hashtables}
@cindex @library{vicare weak-hashtables}, library


Weak hashtables are associative containers whose keys are held by weak
references; registering a key into a weak hashtable does not prevent its
garbage collection.  A weak hashtable is a vector holding nulls or
alists; each vector location is called @dfn{bucket}.  Alists have the
spine composed of strong pairs, while the entries are weak pairs:

@example
|-----|-----|-----|-----|-----| vector of buckets
         |
         v
      |-----|-----|strong pair
         |      |
         |       ------------> |-----|-----|strong pair
         |                        |     |
      |-----|-----|weak pair      |      -------> null
        key  value                v
                               |-----|-----| weak pair
                                 key  value
@end example

Whenever a key in a weak hashtable is garbage collected: the
corresponding location in the weak pair is set to the @acronym{BWP}
object; whenever a bucket is accessed, it is first cleared of weak pairs
holding @acronym{BWP} in key position.  Notice that fixnums, characters
and the other values that fit in a single machine word are never
collected from the point of view of a weak hashtable.

@quotation
@strong{NOTE} Immediate values (@true{}, @false{}, nil, fixnums, etc.)
used as weak hashtable keys are @strong{never} garbage collected; so the
associated entries will never be removed from the table unless we
explicitly do it with @func{weak-hashtable-delete!} or
@func{weak-hashtable-clear!}.
@end quotation

When the number of collected objects equals the number of buckets
(whatever the distribution of elements), the table is enlarged doubling
the number of buckets; the table is @strong{never} restricted by
reducing the number of buckets.

Weak hashtables are subjected to the following constraints:

@itemize
@item
The number of buckets is always an exact power of @math{2}.

@item
The maximum number of buckets is the value of @code{(greatest-fixnum)}.

@item
The maximum number of entries is the value of @code{(greatest-fixnum)}.
@end itemize

The @api{} of weak hashtables is similar to the @api{} of @rnrs{6}
hashtables.  The following bindings are exported by the @library{vicare
weak-hashtables} library.


@defun make-weak-hashtable @var{hash-function} @var{equiv-function}
@defunx make-weak-hashtable @var{hash-function} @var{equiv-function} @var{dimension}
Build and return a new weak hashtable using @var{hash-function} as hash
function for keys and @var{equiv-function} as comparison function
between keys.  When @var{dimension} is used: it is approximately the
initial number of buckets; when not used it defaults to @math{16}.
@end defun


@defun weak-hashtable? @var{obj}
Return true if @var{obj} is a weak hashtable.  Weak hashtables are
disjoint values.
@end defun


@defun weak-hashtable-set! @var{table} @var{key} @var{value}
Add an entry to @var{table} holding @var{key} and @var{value}.  Return
unspecified values.
@end defun


@defun weak-hashtable-ref @var{table} @var{key} @var{default}
Search for @var{key} in @var{table}; if found: return the corresponding
value, else return @var{default}.
@end defun


@defun weak-hashtable-contains? @var{table} @var{key}
Return @true{} if @var{table} contains an entry for @var{key}, else
return @false{}.
@end defun


@defun weak-hashtable-delete! @var{table} @var{key}
If @var{key} is in @var{table}: remove it, else do nothing.  Return
unspecified values.
@end defun


@defun weak-hashtable-size @var{table}
Return the approximate number of entries in @var{table}.  The returned
value can be incorrect if some keys have been garbage collected but the
corresponding entries in the table are not yet removed.
@end defun


@defun weak-hashtable-clear! @var{table}
Remove all the entries from @var{table}.  The number of buckets is reset
to the its initial value.  Return unspecified values.
@end defun


@defun weak-hashtable-keys @var{table}
Return a vector holding the keys in @var{table}.
@end defun


@defun weak-hashtable-entries @var{table}
Return two values: a vector holding the keys in @var{table}, a vector
holding the values in @var{table}.
@end defun


@defun weak-hashtable-update! @var{table} @var{key} @var{proc} @var{default}
If no entry exists for @var{key} in @var{table}: create a new entry
associating @var{key} to the result of applying @var{proc} to
@var{default}.

If an entry exists for @var{key} in @var{table}: replace the its value
with the result of applying @var{proc} to the old value.
@end defun

@c page
@node flonum format
@section Formatting flonums


@cindex Library @library{vicare flonum-formatter}
@cindex @library{vicare flonum-formatter}, library


The following bindings are exported by the library @library{vicare
flonum-formatter}.


@defun format-flonum @var{positive?} @var{digits} @var{exponent}
Given a list of characters @var{digits} and a fixnum @var{exponent}
compose a string representing the corresponding flonum.  @var{positive?}
determines the sign.

@example
#!r6rs
(import (vicare)
  (vicare flonum-formatter))

(define digits
  '(#\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))

(format-flonum #t digits 0)     @result{} "0.123456789"
(format-flonum #t digits 1)     @result{} "1.23456789"
(format-flonum #t digits 2)     @result{} "12.3456789"
(format-flonum #t digits 3)     @result{} "123.456789"
(format-flonum #t digits 8)     @result{} "12345678.9"
(format-flonum #t digits 9)     @result{} "123456789.0"
(format-flonum #t digits 10)    @result{} "1.23456789e9"

(format-flonum #t digits -1)    @result{} "0.0123456789"
(format-flonum #t digits -2)    @result{} "0.00123456789"
(format-flonum #t digits -3)    @result{} "0.000123456789"
(format-flonum #t digits -4)    @result{} "1.23456789e-5"

(format-flonum #f digits 1)     @result{} "-1.23456789"
(format-flonum #f digits 2)     @result{} "-12.3456789"
(format-flonum #f digits 3)     @result{} "-123.456789"
(format-flonum #f digits 8)     @result{} "-12345678.9"
(format-flonum #f digits 9)     @result{} "-123456789.0"
(format-flonum #f digits 10)    @result{} "-1.23456789e9"

(format-flonum #f digits -1)    @result{} "-0.0123456789"
(format-flonum #f digits -2)    @result{} "-0.00123456789"
(format-flonum #f digits -3)    @result{} "-0.000123456789"
(format-flonum #f digits -4)    @result{} "-1.23456789e-5"
@end example
@end defun

@c page
@node flonum parse
@section Parsing flonums


@cindex Library @library{vicare flonum-parser}
@cindex @library{vicare flonum-parser}, library


The following bindings are exported by the library @library{vicare
flonum-parser}.


@defun parse-flonum @var{flonum} @var{real-func} @var{unreal-func}
Parse the @var{flonum} its components for string formatting.

If @var{flonum} is representable as real number, apply the function
@var{real-func} to @math{3} arguments: a boolean, true if @var{flonum}
is positive; a list of characters representing the digits of
@var{flonum}; a fixnum representing the exponent of @var{flonum}.
Return the result of the application.

If @var{flonum} is not representable as real number, apply the function
@var{unreal-func} to a single argument being the string representation
of @var{flonum}.  Return the result of the application.

Notice how the arguments handed to @var{real-func} match the argument of
@func{format-flonum} from @library{vicare flonum-formatter}.

@example
#!r6rs
(import (vicare)
  (vicare flonum-parser))

(parse-flonum 1.23456789
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (real #t
    (#\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
     #\0 #\0 #\0 #\0 #\0 #\0 #\0 #\1)
    1)

(parse-flonum 12.34e5
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (real #t (#\1 #\2 #\3 #\4) 7)

(parse-flonum -12.34e5
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (real #f (#\1 #\2 #\3 #\4) 7)

(parse-flonum +inf.0
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (unreal "+inf.0")

(parse-flonum +nan.0
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (unreal "+nan.0")
@end example
@end defun

@c page
@node sel
@section Simple event loop (@sel{})


@cindex Library @library{vicare simple-event-loop}
@cindex @library{vicare simple-event-loop}, library


The library @library{vicare simple-event-loop} implements an event loop
capable of serving: file descriptors, interprocess signals, batch task
execution.  The library is available if @value{PRJNAME} is configured
with the @posix{} @api{} enabled.  The @sel{} makes use of the @bub{}
@api{} for interprocess signals.

When importing this library it is suggested to prefix the bindings as
follows:

@example
(import (vicare)
  (prefix (vicare posix) px.)
  (prefix (vicare simple-event-loop) sel.))
@end example

@noindent
in practice the @sel{} can be used only along with @library{vicare
posix}.

Exceptions raised by registered event handlers are catched with
@func{guard} and silently discarded; it is our responsibility to handle
errors appropriately in the handlers.


@defun initialise
@defunx finalise
Initialise or finalise the infrastructure of @sel{}.  Prior to entering
the loop we must call @func{initialise}.

@func{initialise} calls @func{signal-bub-init} and @func{finalise} calls
@func{signal-bub-final} from @library{vicare posix}.
@end defun


@defun do-one-event
Serve all the events associated to pending received interprocess
signals, then serve a single event from file descriptors or fragmented
tasks.  Return @true{} if one event from file descriptors or fragmented
tasks was served, return @false{} otherwise.
@end defun


@defun enter
@defunx leave-asap
Enter or leave the event loop.  @func{enter} starts servicing events
from the registered event sources, indefinitely until @func{leave-asap}
is called.
@end defun


@defun busy?
Return a boolean, @true{} if at least one event source is registered.
In this context: interprocess signals do @strong{not} count as event
source.
@end defun

@c ------------------------------------------------------------

@subsubheading Interprocess signals


@defun receive-signal @var{signum} @var{handler}
Register the thunk @var{handler} to be called whenever the signal
@var{signum} is received.  Any number of handlers can be associated to a
single signal.  Every handler is called @strong{once} and removed from
the loop.
@end defun


@defun serve-interprocess-signals
Serve all the pending events for received interprocess signals.  Return
unspecified values.
@end defun

@c ------------------------------------------------------------

@subsubheading File descriptor events


@sel{} can interface with both raw file descriptors and Scheme ports
wrapping a file descriptor; other Scheme port types are not supported.


@defun readable @var{port/fd} @var{handler}
@defunx writable @var{port/fd} @var{handler}
@defunx exception @var{port/fd} @var{handler}
Register the thunk @var{handler} to be called whenever the port or file
descriptor @var{port/fd} becomes readable, writable or receives an
exceptional notification.  Every handler is called @strong{once} and
removed from the loop.
@end defun


@defun forget-fd @var{port/fd}
Remove all the registered handlers associated to the port or file
descriptor @var{port/fd}.
@end defun


@defun do-one-fd-event
Serve one file descriptor event, if any.  Return a boolean, @true{} if
an event was served.
@end defun

@c ------------------------------------------------------------

@subsubheading Fragmented tasks


A @dfn{fragmented task} is a thunk performing a portion of a job.  If
the thunk returns @false{}: the job is finished.  If the thunk returns a
procedure: a portion of job was finished and the returned procedure is a
thunk to call to execute the next portion.


@defun task-fragment @var{thunk}
Register the @var{thunk} as fragment of a task.  When @var{thunk} is
evaluated: if its return value is a procedure, that procedure is
automatically registered as task fragment.
@end defun


@defun do-one-task-event
Evaluate one task event, if any.  Return a boolean, @true{} if a task
was run.
@end defun

@c page
@node syntaxes
@section Language syntactic extensions


@cindex Library @library{vicare syntactic-extensions}
@cindex @library{vicare syntactic-extensions}, library


The library @library{vicare syntactic-extensions} provides bindings to
macros that extend the Scheme language implemented by @library{vicare}
and @library{rnrs}.

@menu
* syntaxes defines::            Special definitions.
* syntaxes bindings::           Special local bindings.
* syntaxes sequencing::         Sequencing execution.
* syntaxes conversion::         Converting common arguments.
* syntaxes cases::              Special cases.
* syntaxes args::               Arguments validation.
* syntaxes misc::               Miscellaneous syntaxes.
@end menu

@c page
@node syntaxes defines
@subsection Special definitions


The following bindings are exported by the library @library{vicare
syntactic-extensions}.


@defmac Syntax define-inline (@meta{name} @meta{arg} ... . @meta{rest}) @metao{form} @meta{form} ...
Wrapper for @func{syntax-rules}, expand to:

@example
(define-syntax @meta{name}
  (syntax-rules ()
    ((_ @meta{arg} ... . @meta{rest})
     (begin @metao{form} @meta{form} ...))))
@end example
@end defmac


@defmac define-constant @meta{name} @meta{expr}
Wrapper for @func{identifier-syntax}, expand to:

@example
(begin
  (define ghost @meta{expr})
  (define-syntax @meta{name}
    (identifier-syntax ghost)))
@end example

@noindent
@meta{expr} is evaluated once and the identifier syntax @meta{name} can
be used to access the result; it is impossible to modify the value by
acting upon @meta{name}.
@end defmac


@defmac define-inline-constant @meta{name} @meta{value}
Wrapper for @func{identifier-syntax}, expand to:

@example
(define-syntax @meta{name}
  (identifier-syntax @meta{value}))
@end example

@noindent
@meta{value} is evaluated every time @meta{name} is referenced; it is
impossible to modify the @meta{value} by acting upon @meta{name}.  This
syntax is useful to defined constants resulting from @gnu{} Autoconf
expansion:

@example
(define-inline-constant SEEK_SET @@VALUEOF_SEEK_SET@@)
@end example
@end defmac


@defmac define-syntax* (@meta{who} @meta{stx}) . @meta{body}
Wrapper for @func{define-syntax}, expand to:

@example
(define-syntax @meta{who}
  (lambda (@meta{stx}) . @meta{body}))
@end example
@end defmac


@defmac define-auxiliary-syntaxes @metao{name} @meta{name} ...
Define auxiliary syntaxes to be used as literal identifiers by
@func{syntax-rules}, @func{syntax-case} and similar macros; expand to:

@example
(define-syntax @metao{name} (syntax-rules ()))
(define-syntax @meta{name}  (syntax-rules ()))
...
@end example
@end defmac


@defmac define-exact-integer->symbol-function @meta{who} (@meta{code} ...)
Define a function used to convert exact intgers to the corresponding
symbolic name.  Expand to:

@example
(define (@meta{who} code)
  (define who '@meta{who})
  (with-arguments-validation (who)
      ((exact-integer      code))
    (case-integers code
      ((@meta{code})     '@meta{code})
      ...
      (else #f))))
@end example
@end defmac

@c page
@node syntaxes bindings
@subsection Special local bindings


The following bindings are exported by the library @library{vicare
syntactic-extensions}.


@defmac let-inline ((@meta{var} @meta{expr}) ...) @metao{body} . @meta{body}
Wrapper for @func{let-syntax}, expand to:

@example
(let-syntax ((@meta{var} (identifier-syntax @meta{expr}))
             ...)
  @metao{body} . @meta{body})
@end example
@end defmac


@defmac {let*-inline} () @metao{body} . @meta{body}
@defmacx {let*-inline} ((@metao{var} @metao{expr}) (@meta{var} @meta{expr}) ...) @metao{body} . @meta{body}
Wrapper for @func{let-syntax}, expand to:

@example
(let-syntax ((@metao{var} (identifier-syntax @meta{expr})))
  (let*-inline ((@meta{var} @meta{expr})
                ...)
    @metao{body} . @meta{body}))
@end example
@end defmac

@c page
@node syntaxes sequencing
@subsection Sequencing execution


The following bindings are exported by the library @library{vicare
syntactic-extensions}.


@defmac begin0 @metao{expr} @meta{expr} ...
Expand to:

@example
(call-with-values
     (lambda () @metao{expr})
  (lambda args
    @meta{expr} ...
    (apply values args)))
@end example

This syntax comes from the @rnrs{6} original document, Appendix A
``Formal semantics''.
@end defmac


@defmac begin0-let ((@metao{var} @metao{init}) (@meta{var} @meta{init}) ...) @metao{form} @meta{form} ...
Expand to:

@example
(let ((@metao{var} @metao{init})
      (@meta{var}  @meta{init})
      ...)
  @metao{form} @meta{form} ...
  @metao{var})
@end example
@end defmac

@c page
@node syntaxes conversion
@subsection Converting common arguments


The following bindings are exported by the library @library{vicare
syntactic-extensions}.


@defmac with-pathnames ((@meta{pathname.bv} @meta{pathname}) ...) . @meta{body}
Used to preprocess function arguments which must be bytevectors or
strings representing pathnames; the strings are converted to
bytevectors.  This macro assumes that the arguments have already been
validated.  Expand to:

@example
(let ((@meta{pathname.bv} (let ((pathname @meta{pathname}))
                      (if (bytevector? pathname)
                          pathname
                        ((string->filename-func) pathname))))
      ...)
  . @meta{body})
@end example
@end defmac


@defmac with-bytevectors ((@meta{value.bv} @meta{value}) ...) . @meta{body}
Used to preprocess function arguments which must be bytevectors or
strings; the strings are converted to bytevectors.  This macro assumes
that the arguments have already been validated.  Expand to:

@example
(let ((@meta{value.bv} (let ((V @meta{value}))
                   (if (bytevector? V)
                       V
                     (string->latin1 V))))
      ...)
  . @meta{body})
@end example
@end defmac


@defmac with-bytevectors/or-false ((@meta{value.bv} @meta{value}) ...) . @meta{body}
Used to preprocess function arguments which must be bytevectors, strings
or false; the strings are converted to bytevectors.  This macro assumes
that the arguments have already been validated.  Expand to:

@example
(let ((?value.bv (let ((V ?value))
                   (cond ((bytevector? V)
                          V)
                         ((string? V)
                          (string->latin1 V))
                         (else V))))
      ...)
  . ?body)
@end example
@end defmac

@c page
@node syntaxes cases
@subsection Special cases


The following bindings are exported by the library @library{vicare
syntactic-extensions}.


@defmac case-word-size ((32) . @meta{body-32}) ((64) . @meta{body-64})
If the platform word size is 32-bit expand to @meta{body-32}, else
expand to @meta{body-64}.
@end defmac


@deffn Macro case-endianness (@meta{who} @meta{endianness}) ((little) . @meta{lit-body}) ((big) . @meta{big-body})
@deffnx Macro case-endianness (@meta{who} @meta{endianness}) ((big) . @meta{big-body}) ((little) . @meta{lit-body})
@deffnx {Auxiliary Syntax} big
@deffnx {Auxiliary Syntax} little
If the platform endianness is little expand to @meta{lit-body}, else
expand to @meta{big-body}.
@end deffn


@deffn Macro case-fixnums @meta{expr} ((@metao{fixnum} @meta{fixnum} ...) @metao{fx-body} @meta{fx-body} ...) ...
@deffnx Macro case-fixnums @meta{expr} ((@metao{fixnum} @meta{fixnum} ...) @metao{fx-body} @meta{fx-body} ...) ... (else @metao{else-body} @meta{else-body} ...)
@deffnx {Auxiliary Syntax} else
Special implementation of @func{case} expeting only fixnums as datums;
for maximum speed, it makes use of unsafe operations on fixnums.
@func{else} must be the binding exported by @library{rnrs} and
@library{vicare}.

@meta{expr} must be an expression evaluating to a fixnum, else the
behaviour is undefined (and you do not want it).
@end deffn


@deffn Macro case-integers @meta{expr} ((@metao{int} @meta{int} ...) @metao{int-body} @meta{int-body} ...) ...
@deffnx Macro case-integers @meta{expr} ((@metao{int} @meta{int} ...) @metao{int-body} @meta{int-body} ...) ... (else @metao{else-body} @meta{else-body} ...)
@deffnx {Auxiliary Syntax} else
Special implementation of @func{case} expecting only exact integers as
datums.  @func{else} must be the binding exported by @library{rnrs} and
@library{vicare}.

@meta{expr} must be an expression evaluating to an exact integer, else
the behaviour is undefined (and you do not want it).
@end deffn

@c page
@node syntaxes args
@subsection Arguments validation


Global arguments validation is enabled or disabled by setting to @true{}
or @false{} the @code{arguments-validation} identifier syntax exported
by @library{vicare installation-configuration}, the default is @true{};
such value can be configured at installation time with the
@option{--enable-arguments-validation} option of the @command{configure}
script.

The following bindings are exported by the library @library{vicare
syntactic-extensions}.


@defmac define-argument-validation (@meta{name} @meta{who} @meta{arg} ...) @meta{predicate} @meta{error-handler}
Define a set of macros to validate arguments, to be used along with
@func{WITH-ARGUMENTS-VALIDATION}.  Transform:

@example
(define-argument-validation (bytevector who bv)
  (bytevector? bv)
  (assertion-violation who "expected a bytevector as argument" bv))
@end example

@noindent
into:

@smallexample
(define-inline (vicare.argument-validation-for-bytevector who bv . body)
  (if (vicare.argument-validation-predicate-for-bytevector bv)
      (begin . body)
    (vicare.argument-validation-error-for-bytevector who bv)))

(define-inline (vicare.argument-validation-predicate-for-bytevector bv)
  (bytevector? bv))

(define-inline (vicare.argument-validation-error-for-bytevector who bv))
  (assertion-violation who "expected a bytevector as argument" bv))
@end smallexample

If we need to export a validator from a library: we can export just the
identifier @code{vicare.argument-validation-for-@meta{name}}, without
prefixing it.
@end defmac


@defmac arguments-validation-forms . @meta{body}
If arguments validation is enabled, expand to:

@example
(begin . @meta{body})
@end example

@noindent
else expand to @code{(values)}.
@end defmac


@defmac with-arguments-validation (@meta{who}) ((@meta{validator} @meta{arg} ...) ...) . @meta{body}
If arguments validation is enabled: expand to code that validates the
@meta{arg} expressions according to the @meta{validator}, then evaluate
@meta{body}; else just evaluate @meta{body}.

@meta{who} must be an identifier and it is used as first argument to the
validator macro.

For example:

@example
(with-arguments-validation (who)
     ((fixnum  X)
      (integer Y))
  (do-this)
  (do-that))
@end example

@noindent
expands into:

@example
(vicare.argument-validation-for-fixnum who X
 (vicare.argument-validation-for-integer who Y
  (do-this)
  (do-that)))
@end example
@end defmac


@defmac with-dangerous-arguments-validation (@meta{who}) ((@meta{validator} @meta{arg} ...) ...) . @meta{body}
Like @func{with-arguments-validation}, but the validation is always
performed even when global arguments validation is disabled.
@end defmac

@c page
@node syntaxes misc
@subsection Miscellaneous syntaxes


The following bindings are exported by the library @library{vicare
syntactic-extensions}.


@defmac callet @meta{func} @meta{arg} ...
Expand to a call to @meta{func}, which must evaluate to a function,
applied to the arguments resulting from processing the @var{arg}
syntaxes; @var{arg} can be one among:

@example
@meta{expr}
(@meta{name} @meta{expr})
@end example

@noindent
where @meta{expr} is an expression that will become the actual argument
and @meta{name} must be an identifier used to comment the meaning of the
arguments.  Examples:

@example
(callet printf
        (string "ciao ~a")
        (arg    123))
@expansion{} (printf "ciao ~a" 123)
@end example
@end defmac


@defmac callet* @meta{func} @meta{arg} ...
Like @func{callet}, but define local @func{let*} bindings for the
@var{arg} with name.  Example:

@example
(callet printf
        (string "ciao ~a")
        (arg    123))
@expansion{} (let* ((string "ciao ~a")
           (arg    123))
      (printf string arg))
@end example
@end defmac


@defmac unwind-protect @meta{body} @metao{cleanup} @meta{cleanup} ...
Not a general @func{unwind-protect} for Scheme, but fine where we do not
use continuations to escape from the body.  Expand to:

@example
(let ((cleanup (lambda ()
                 @metao{cleanup}
                 @meta{cleanup}
                 ...)))
  (with-exception-handler
      (lambda (E)
        (cleanup)
        (raise E))
    (lambda ()
      (begin0
          @meta{body}
        (cleanup)))))
@end example
@end defmac

@c page
@node infix
@section Infix to prefix transformer


@cindex Library @library{vicare infix}
@cindex @library{vicare infix}, library


The library @library{vicare infix} provides the @func{infix} macro which
converts the traditional infix notation for expressions to the
equivalent Scheme's prefix notation.

To use the library just import @library{vicare infix} and use the
@func{infix} macro: it expands to a prefix expression to be evaluated at
runtime, in the lexical context of the macro use; as a special case
@code{(infix)} is equivalent to @code{(values)}.

The macro allows us to evaluate forms like:

@example
(let ((a 1) (b 2) (c 3))

  (infix cos (a) * tan (b) / c)
  @expansion{} (/ (* (cos a) (tan b)) c)

  (infix (cos (a) * tan (b) / c))
  @expansion{} (/ (* (cos a) (tan b)) c)

  (infix a ? b : c)
  @expansion{} (if a b c)

 #f)
@end example

Some interpretation rules:

@itemize
@item
Any Scheme value can be element of the input form.

@item
The following infix operators are supported; in order of descending
precedence from top to bottom, operators on the same line have equal
precedence:

@example
bitwise-arithmetic-shift-left bitwise-arithmetic-shift-right
bitwise-not
bitwise-and bitwise-ior bitwise-xor
incr! decr!
(unary +) (unary -)
expt
mod mod0
* / div div0
+ -
< > <= >= = eq? eqv? equal?
not
and or xor
@end example

@noindent
remember that the Scheme comparison operators are meant to return a
boolean value, rather than a number object.

@item
All the operators are left--associative with the exception of
@func{expt} which is right--associative and of the unary @func{+},
@func{-}, @func{incr!}, @func{decr!}, @func{not} and @func{bitwise-not}
which are non--associative:

@example
;; left-associative
(infix 10 - 5 - 3) @expansion{} (- (- 10 5) 3)
(infix 10 - 5 - 3) @expansion{} (- 10 5 3)
(infix 10 / 5 / 3) @expansion{} (/ (/ 10 5) 3)
(infix 10 / 5 / 3) @expansion{} (/ 10 5 3)

;; right-associative
(infix 10 expt 5 expt 3) @expansion{} (expt 10 (expt 5 3))
@end example

@item
The following operators for fixnums are supported with the same
precedence of the corresponding generic operators:

@example
fx+               fx-
fx*
fxdiv             fxdiv0
fxmod             fxmod0
fx<?              fx>?
fx<=?             fx>=?
fx=?

fxand             fxior
fxxor             fxnot
fxarithmetic-shift-left
fxarithmetic-shift-right
@end example

All the operators are left-associative with the exception of FXNOT which
is non-associative:

@example
(infix 10 fx- 5 fx- 3)     @expansion{} (fx- (fx- 10 5) 3)
(infix 10 fxdiv 5 fxdiv 3) @expansion{} (fxdiv (fxdiv 10 5) 3)
@end example

@item
The following operators for flonums are supported with the same
precedence of the corresponding generic operators:

@example
fl+               fl-
fl*               fl/
flexpt
fl<?              fl>?
fl<=?             fl>=?
fl=?
@end example

All the operators are left--associative with the exception of
@func{flexpt} which is right--associative:

@example
;; left-associative
(infix 10. fl- 5. fl- 3.)         @expansion{} (fl- (fl- 10. 5.) 3.))
(infix 10. fl- 5. fl- 3.)         @expansion{} (fl- 10. 5. 3.))
(infix 10. fl/ 5. fl/ 3.)         @expansion{} (fl/ (fl/ 10. 5.) 3.))
(infix 10. fl/ 5. fl/ 3.)         @expansion{} (fl/ 10. 5. 3.))

;; right-associative
(infix 10 expt 5 expt 3)          @expansion{} (expt 10 (expt 5 3))
(infix 10. flexpt 5. flexpt 3.)   @expansion{} (flexpt 10. (flexpt 5. 3.))
@end example

@item
@func{incr!} and @func{decr!} are unary operators that can be applied to
expressions both in prefix and suffix positions.  @library{vicare infix}
exports the identifiers @func{++} and @func{--} as aliases for
@func{incr!} and @func{decr!}; such aliases are invalid in @code{#!r6rs}
mode, but are allowed by the reader when in @code{#!vicare} mode.

When applied in prefix position to an identifier, @func{incr!} expands
to:

@example
(infix incr! ?id) @expansion{} (begin (set! ?id (+ ?id 1)) ?id)
@end example

@noindent
and @func{decr!} expands to:

@example
(infix decr! ?id) @expansion{} (begin (set! ?id (- ?id 1)) ?id)
@end example

When applied in suffix position to an identifier, @func{incr!} expands
to:

@example
(infix ?id incr!) @expansion{} (let ((v ?id)) (set! ?id (+ ?id 1)) v)
@end example

@noindent
and @func{decr!} expands to:

@example
(infix ?id decr!) @expansion{} (let ((v ?id)) (set! ?id (- ?id 1)) v)
@end example

When applied to a non--identifier expression, both in prefix and suffix
position, @func{incr!} expands to:

@example
(infix incr! ?expr) @expansion{} (+ ?expr 1)
(infix ?expr incr!) @expansion{} (+ ?expr 1)
@end example

@noindent
and @func{decr!} expands to:

@example
(infix decr! ?expr) @expansion{} (- ?expr 1)
(infix ?expr decr!) @expansion{} (- ?expr 1)
@end example

@item
The if-then-else statement involves the identifiers @func{?}  and
@func{:}.  This statement has the least precedence of all.

@item
Identifiers which are not operators are interpreted as variable
references; if an identifier is followed by a list, it is a function
call.

@item
Function calls with one or more arguments require the arguments to be
grouped in a list; there is no special separator in the list of
arguments.

@example
(define (fun a b c)
  (+ a b c))

(infix fun (1 2 3)) @expansion{} (fun 1 2 3)
@end example

Notice that grouping the function arguments in a list is a requirement
of the infix expression grammar.

@item
Numbers and all the other values are just put there as operands.

@item
As a special exception: the binding @func{begin} from @library{vicare}
is recognised in the input form and allows us to nest prefix--notation
expressions.

@example
(infix (begin (+ 1 2))) @result{} 3

(infix (begin
         (let ((a 3))
           (/ a 4))))
@result{} 3/4

(let ((a 3))
  (infix (begin (/ a 4))))
@result{} 3/4

(let ((a 1) (b 2) (c 3))
  (infix (1 + a ? (begin
                    (+ 2 b))
                : 3 + c - 4))
  @expansion{} (if (+ 1 a)
          (begin (+ 2 b))
        (- (+ 3 c) 4))
  #f)
@end example

@item
The following binding aliases are exported by the library:

@example
and                               -> &&
or                                -> !!
xor                               -> ^^
not                               -> ~~
mod                               -> %
bitwise-and                       -> &
bitwise-ior                       -> !
bitwise-xor                       -> ^
bitwise-not                       -> ~
bitwise-arithmetic-shift-left     -> <<
bitwise-arithmetic-shift-right    -> >>
fxand                             -> fx&
fxior                             -> fx!
fxxor                             -> fx^
fxnot                             -> fx~
fxarithmetic-shift-left           -> fx<<
fxarithmetic-shift-right          -> fx>>
@end example
@end itemize

@c page
@node objects
@chapter Built in Scheme objects


Built in Scheme objects are mostly implemented in the C language portion
of the source code, but many core operations are also reimplemented at
the Scheme level.  The overall definitions are in the C language file
@file{vicare.h} (for the public @api{}) the C language file
@file{internal.h} (for the private @api{}) and the definition of many
values is duplicated in the Scheme language compiler
@file{ikarus.compiler.sls}.

@menu
* objects types::               Some basic type definitions.
* objects refs::                Builtin objects and tags.
* objects memory::              Memory allocation and collection.
* objects booleans::            Boolean objects.
* objects fixnums::             Fixnum objects.
* objects pairs::               Pair objects and lists.
* objects bytevectors::         Bytevector objects.
* objects vectors::             Vector objects.
* objects structs::             Struct objects.
* objects chars::               Character objects.
* objects strings::             String objects.
* objects symbols::             Symbol objects.
* objects bignums::             Bignum objects.
* objects integers::            Exact integer objects.
* objects ratnums::             Ratnum objects.
* objects flonums::             Flonum objects.
* objects compnums::            Compnum objects.
* objects cflonums::            Cflonum objects.
* objects ports::               Port objects.
* objects transcoders::         Transcoder objects.
* objects pointers::            Pointer objects.
* objects misc::                Miscellaneous functions and
                                preprocessor macros.
* objects callbacks::           Notes on calling Scheme code from C.
@end menu

@c page
@node objects types
@section Some basic type definitions


@deftp Typedef ik_int
An alias for @code{signed int}.
@end deftp


@deftp Typedef ik_long
An alias for @code{signed long}.
@end deftp


@deftp Typedef ik_llong
An alias for @code{signed long long}.
@end deftp


@deftp Typedef ik_uint
An alias for @code{unsigned int}.
@end deftp


@deftp Typedef ik_ulong
An alias for @code{unsigned long}.
@end deftp


@deftp Typedef ik_ullong
An alias for @code{unsigned long long}.
@end deftp

@c page
@node objects refs
@section Built in object references


Values of type @ikptr{} at the C language level are the ones we move
around as arguments and return values at the Scheme level; they
represent machine words.  @ikptr{} values have two major
interpretations:

@table @strong
@item Immediate values
Objects that fit in a single machine word: special constants, fixnums,
characters and input/output port transcoders.

@item Reference values
Objects allocated on the heap and subject to garbage collection; they
are represented by tagged pointers: symbols, pairs, vectors,
bytevectors, structures, ports, bignums, ratnums, flonums, compnums,
cflonums, strings, closures, continuations, codes, pointers.
@end table

@noindent
immediate @ikptr{} values have two minor interpretations:

@table @strong
@item Immediate special constants
These are @true{}, @false{}, nil, void, unbound, @acronym{BWP}.

@item Immediate variable values
These are fixnums, characters and transcoders.
@end table

@noindent
reference @ikptr{} values have two minor interpretations:

@table @strong
@item Vector tagged references
Memory pointer values whose @math{3} least significant bits are set to
the vector tag.  They reference multiword objects allocated on the heap:
vectors, bignums, structures, flonums, ratnums, compnums, cflonums,
continuations, code, ports, symbols, pointers.

@item Specially tagged references
Pointer values whose @math{3} least significant bits are set to a
type--specific tag.  They reference multiword objects allocated on the
heap: pairs, bytevectors, closures, strings.
@end table


@deftp {Object Reference} ikptr
An immediate built in object or a reference to a built in object;
implemented as an @code{unsigned long int} it is meant to be the size of
a machine word.  The definition assumes that:

@itemize
@item
On 32-bit platforms, @code{unsigned long int} is a 32-bit value.

@item
On 64-bit platforms, @code{unsigned long int} is a 64-bit value.

@item
The type @code{unsigned long int} is big enough to hold a pointer for
the underlying platform.
@end itemize
@end deftp


@deftypefn {Preprocessor Macro} int IK_TAGOF (ikptr @var{ref})
Return an integer representing the @math{3} least significant bits of an
@ikptr{} value.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_REF (ikptr @var{value_ref}, long @var{byte_offset})
@deftypefnx {Preprocessor Macro} ikptr ref (ikptr @var{value_ref}, long @var{byte_offset})
Getter and setter for machine words allocated on the heap.  Interpret
@var{value_ref} as a pointer to an array of @ikptr{} and locate the
value at the zero--based @var{byte_offset}.  A use of this macro can
appear both as operand and as left--side of an assignment.

@example
ikptr   P, Q;

Q = IK_REF(P, 2);     /* retrieve the 3rd word */
IK_REF(P, 0) = 123L;  /* store a value in the 1st word */
@end example

Both @var{value_ref} and @var{byte_offset} are first cast to @code{long}
values, then added and the sum is cast to @code{ikptr *}.

Values for @var{byte_offset} are usually precomputed and take into
account a component used to remove the tag from the pointer in
@var{value_ref}.

@quotation
@strong{NOTE} @cfunc{ref} is defined only in the internal header file
and its use is deprecated.
@end quotation
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Immediate values

All the immediate values but fixnums have the @math{3} least significant
bits set to @math{1}; to distinguish between immediate values and
references we can do:

@example
ikptr   X;

if (IK_IS_FIXNUM(X) || (immediate_tag == IK_TAGOF(X)))
  it_is_immediate();
else
  it_is_not();
@end example

@noindent
where:

@example
immediate_tag = 7 = #b111
@end example


@defmac IK_FALSE_OBJECT 0x2F
@defmacx IK_FALSE
@defmacx IK_TRUE_OBJECT 0x3F
@defmacx IK_TRUE
@defmacx IK_NULL_OBJECT 0x4F
@defmacx IK_NULL
@defmacx IK_EOF_OBJECT 0x5F
@defmacx IK_EOF
@defmacx IK_VOID_OBJECT 0x7F
@defmacx IK_VOID
Special machine words of type @ikptr{} representing, respectively:
@false{}; @true{}; nil, the empty list; @eof{}, the end of file;
@void{}, the return value of functions returning no value.
@end defmac


@defmac IK_UNBOUND_OBJECT 0x6F
@defmacx IK_UNBOUND
Special machine word value stored in the @code{value} and @code{proc}
fields of Scheme symbol memory blocks to signal that these fields are
unset.
@end defmac


@defmac IK_BWP_OBJECT 0x8F
@defmacx IK_BWP
Special machine word value stored in locations that used to hold weak
references to values which have been already garbage collected.
@end defmac

The variable values that fit in a single machine word are fixnums,
characters and port transcoders.  The last byte of these machine words
is tagged as follows:

@example
   object      |  tag bits  | tag hex | mask bits
---------------+------------+---------+------------
fixnums 32-bit | #b??????00 |   --    | #b00000011
fixnums 64-bit | #b?????000 |   --    | #b00000111
characters     | #b00001111 |  #x0F   | #b11111111
transcoders    | #b01111111 |  #x7F   | #b11111111
@end example

@noindent
to identify a fixnum we can do:

@example
ikptr   X;

if (fx_tag == (X & fx_mask))
  it_is_a_fixnum();
else
  it_is_not();
@end example

@noindent
or just use the macro @cfunc{IK_IS_FIXNUM}; similarly for for the other
immediate variable values.

Notice that a @cnull{} pointer stored in a @ikptr{} with zero bits as
tag represents the fixnum zero; also, the zero tag bits for fixnums are
in such a number that: a tagged @ikptr{} fixnum can be interpreted as
the number of bytes needed to hold a number of machine words equal to
the number represented by the fixnum itself, that is the following holds
true:

@example
long    number_of_words = ...;

number_of_words * wordsize == number_of_words << fx_shift;
@end example

@noindent
where @code{fx_shift} is the number of bits in the fixnum's tag.

@c ------------------------------------------------------------

@subsubheading Values allocated on the heap

The values that do not fit into a single machine word are composed of a
reference machine word and an array of machine words on the heap; they
are: symbols, pairs, vectors, bytevectors, structures, ports, bignums,
ratnums, flonums, compnums, cflonums, strings, closures, continuations,
codes, pointers.

The machine words used as reference have the @math{3} least significant
bits used as tag and the remaining most significant bits used to store a
pointer in memory; on 32-bit platforms the layout of such machine words
is:

@example
 PPPPPPPP PPPPPPPP PPPPPPPP PPPPPTTT   P = bit of pointer
|--------|--------|--------|--------|  T = bit of tag
  byte 3   byte 2   byte 1   byte 0
@end example

@noindent
the following tags are used:

@example
  object    | tag bits | tag hex | mask bits
------------+----------+---------+------------
pairs       |   #b001  |   #x1   | #b00000111
bytevectors |   #b010  |   #x2   | #b00000111
closure     |   #b011  |   #x3   | #b00000111
vectors     |   #b101  |   #x5   | #b00000111
strings     |   #b110  |   #x6   | #b00000111
@end example

@noindent
notice how @strong{none} of the tags for reference words is
@code{#b111}, which is reserved for immediate values; also notice how
@code{#b100} must @strong{not} be used as tag, because on 32-bit
platforms it would match the fixnums with the least significant bit set
to zero.

The vector tag is used to tag machine word references to multiple object
types: vectors, bignums, structures, flonums, ratnums, compnums,
cflonums, continuations, code, ports, symbols, pointers, system
continuations.  The first word in the memory block of these types has
the least significant bits set to a secondary tag.

All the possible values for @math{3}-bit tags in reference values are
already allocated; new object types can be added only defining a new
secondary tag with references tagged as vector.

While the @api{} defines predicates to recognise values, to identify a
type--specific reference we can do:

@example
ikptr   X;

if (pair_tag == (X & pair_mask))
  it_is_a_pair();
else
  it_is_not();
@end example

@noindent
similarly for the other types.  The vector tag acts as @dfn{primary
tag}; a @dfn{secondary tag} is stored in the least significant bits of
the referenced vector of words on the heap; to recognise such values we
can do:

@example
ikptr  X;

if ((vector_tag    == (X & vector_tag)) &&
    (secondary_tag == (secondary_mask
                       & IK_REF(X, -vector_tag))))
  it_is();
else
  it_is_not();
@end example

@noindent
where @code{secondary_tag} and @code{secondary_mask} are type--specific.
The secondary tags and the associated masks are:

@example
   object           |  tag bits   | tag hex | tag mask
                    |    76543210 |         |    76543210
--------------------+-------------+---------+-------------
vector              |  #b??????00 | fixnum  | #b00000111
bignum              |  #b????s011 |   #x03  | #b00000111
structure           |  #b?????101 |   #x05  | #b00000111
flonum              |  #b00010111 |   #x17  |    --
ratnum              |  #b00100111 |   #x27  |    --
compnum             |  #b00110111 |   #x37  |    --
cflonum             |  #b01000111 |   #x47  |    --
continuation        |  #b00011111 |   #x1F  |    --
code                |  #b00101111 |   #x2F  |    --
port                |  #b??111111 |   #x3F  | #b00111111
symbol              |  #b01011111 |   #x5F  |    --
pointer             | #b100000111 |  #x107  |    --
system continuation | #b100011111 |  #x11F  |    --
@end example

@noindent
notice how the port secondary tag has all the @math{6} least significant
bits set to @math{1}: no other tag must have all such bits set to
@math{1}.  Secondary tags for new types can be allocated by selecting
the least significant byte to @code{#x0F} and reserving a specific bit
pattern in the most significant bytes.

The only tags having an associated mask are the ones of objects storing
additional informations in the first word of the heap vector:

@table @strong
@item Vectors
The first word of a vector is a fixnum representing the number of
elements.

@item Bignums
The first word uses the @math{3} least significant bits as tag, the
@math{4}th bit representing the sign (@math{0} for positive, @math{1}
for negative) and the remaining bits representing the number of words in
the bignum data area.

@item Structures
The first word is tagged as vector, because the first word of a
structure is itself a reference to a structure: the type descriptor.

@item Ports
The most significant bits of the first word are used for port
attributes.
@end table

@c page
@node objects memory
@section Memory allocation and collection


In short, memory allocation which may trigger a garbage collection is
performed as follows:

@example
ikpcb *   pcb = ik_the_pcb();
long int  number_of_bytes = the_number_of_bytes;
ikptr     p = ik_safe_alloc(pcb, IK_ALIGN(number_of_bytes));
@end example

@noindent
while memory allocation without garbage collection is performed as
follows:

@example
ikpcb *   pcb = ik_the_pcb();
long int  number_of_bytes = the_number_of_bytes;
ikptr     p = ik_unsafe_alloc(pcb, IK_ALIGN(number_of_bytes));
@end example

@noindent
where @code{p} is an untagged memory pointer and @code{pcb} is a pointer
to the ``Process Control Block'' data structure.

To add a tag, for example the @code{vector_tag}, to an untagged memory
pointer we can do:

@example
ikpcb * pcb = ik_the_pcb();
long    len = IK_ALIGN(the_number_of_bytes);
ikptr   ref = ik_safe_alloc(pcb, len) | vector_tag;
@end example

Objects subject to garbage collection are allocated on the Scheme heap,
which is an array of contiguous memory segments; the next object is
allocated in the ``current segment'' of the heap:

@example
    allocated  allocated      allocated
    block      block          block
...|----------|--------------|--------|------...
    ^          ^              ^        ^
    |          |              |        |
  pointer    pointer        pointer   pointer to
                                      next block
@end example

@noindent
every pointer must satisfy alignment constraints with the following
purposes:

@enumerate
@item
To make pointer indirection efficient for the underlying platform.

@item
To have pointer values with the @math{3} least significant bits set to
zero, so that such bits can be used to hold an object's type tag.
@end enumerate

@noindent
for these reasons we must always filter the requested size (in bytes)
through the @cfunc{IK_ALIGN} macro.  The @pcb{} always references a
``pointer to the next free block'' with alignment constraints satisfied;
if we filter the requested number of bytes through @cfunc{IK_ALIGN}, we
obtain a number of bytes which, added to the pointer, gives a correctly
aligned pointer:

@example
uint8_t * allocated_block = (uint8_t *)pcb->allocation_pointer;
long      requested_size  = ...;
long      align_size      = IK_ALIGN(requested_size);
uint8_t * next_free_block = allocated_block + align_size;
pcb->allocation_pointer   = (ikptr)next_free_block;

/* use "allocated_block" */


            requested size
       |.......................|
            aligned size
       |..........................|
...----|--------------------------|-----------....
        ^                          ^
        |                          |
      pointer to an              pointer to the
      allocated block            next block
@end example


@deftypefun {ikpcb *} ik_the_pcb (void)
Return a pointer to the current process control block.  It is rarely
needed because when calling a C function from Scheme a pointer to the
@pcb{} is always pushed on the C stack as last argument.
@end deftypefun


@deftypefn {Preprocessor Macro} {unsigned long} IK_ALIGN (unsigned long @var{number_of_bytes})
Convert @var{number_of_bytes} to the number of bytes requested to
satisfy pointer alignment constraints.  The aligned size is always an
exact multiple of the underlying platform's word size (32-bit or
64-bit); precisely: it is the smallest multiple of the wordsize which is
greater than @var{number_of_bytes}.
@ignore
We can simulate the computation with:

@example
(import (ikarus))

(define sizeof-ikptr
  (make-parameter #f))

(define (align n)
  (let* ((wordsize      (sizeof-ikptr))
         (wordshift     (if (= wordsize 4) 2 3))
         (align_shift   (+ 1 wordshift))
         (align_size    (* 2 wordsize))
         (<<            bitwise-arithmetic-shift-left)
         (>>            bitwise-arithmetic-shift-right))
    (<< (>> (- (+ n align_size) 1)
            align_shift)
        align_shift)))

(define (print-align n)
  (let ((m (align n))
        (base-pointer (expt 2 (- (* 8 (sizeof-ikptr)) 1))))
    (display n)
    (display " -> ")
    (display m)
    (display "\t")
    (display (number->string base-pointer 2))
    (display " -> ")
    (display (number->string (+ base-pointer m) 2))
    (newline)))

(parameterize ((sizeof-ikptr 4)) ; 32 bits platform
  (print-align 12)
  (print-align 17)
  (print-align 1234))
@end example
@end ignore
@end deftypefn


@deftypefun ikptr ik_safe_alloc (ikpcb * @var{pcb}, unsigned long @var{align_size})
Allocate a memory block on the heap and return a reference to it as an
@strong{untagged} pointer.  @var{pcb} must reference the process control
block, @var{align_size} must be the requested number of bytes filtered
through @cfunc{IK_ALIGN}.

If not enough memory is available on the current heap segment: a garbage
collection is triggered; then allocation is tried again: if it still
fails the process is terminated with exit status @code{EXIT_FAILURE}.
@end deftypefun


@deftypefun ikptr ik_unsafe_alloc (ikpcb * @var{pcb}, unsigned long @var{align_size})
Allocate a memory block on the Scheme heap and return a reference to it
as an @strong{untagged} pointer.  @var{pcb} must reference the process
control block, @var{align_size} must be the requested number of bytes
filtered through @cfunc{IK_ALIGN}.

If not enough memory is available on the current heap segment: a new
heap segment is allocated; if such allocation fails: the process is
terminated with exit status @code{EXIT_FAILURE}.

We notice explicitly that this function @strong{does not} trigger a
garbage collection run, so, when using it, it is not needed to register
C pointers as garbage collection roots.
@end deftypefun


@deffn {Preprocessor Macro} IK_ASS (ikptr @var{left}, ikptr @var{right})
Perform a C language assignment enforcing the order of evaluation of the
left--side and right--side expressions.  First evaluate @var{right},
then evaluate @var{left}, finally store the result of @var{right} in the
lvalue resulting from evaluating @var{left}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Writing correct C language code

The garbage collector considers an object ``in use'' if at least one
reference to it is reachable from the roots of the garbage collection;
if an @ikptr{} reference exists only in a @acronym{CPU} register or on
the C language stack, or on the C language heap out of segments
allocated for Scheme: the garbage collector will not see it.  This
allows to avoid scanning the full process' stack for references to
values, but imposes care when writing C language code.

Whenever we call @cfunc{ik_safe_alloc} or a function relying on it for
memory allocation: a garbage collection may run and Scheme objects may
be moved from their location in memory to another memory segment; this
renders invalid all the pointers in the @acronym{CPU} registers, on the
C stack and the C heap.  Notice that this includes the arguments to C
functions called from Scheme through the macro @func{foreign-call}.

We must write C code with the following constraints:

@itemize
@item
Before a call to @cfunc{ik_safe_alloc}: we must make sure that all the
Scheme objects we are using in C code are reachable by the garbage
collector.  This is done by registering an object as garbage collector
root through the @code{root} fields of the @pcb{}.

@item
After a call to @cfunc{ik_safe_alloc}: we must reobtain all the pointers
to the internals of the objects we are using.
@end itemize

To help identification of C functions and macros allocating memory: the
ones calling @cfunc{ik_safe_alloc} are prefixed with @code{ika_} and
@code{IKA_}; the ones calling @cfunc{ik_unsafe_alloc} are prefixed with
@code{iku_} and @code{IKU_}.

Example of @strong{correct} code: @code{s_one} is protected while
allocating @code{s_two}:

@example
ikpcb * pcb = ik_the_pcb();
ikptr   s_one, s_two;

s_one = ika_bytevector_alloc(pcb, 10);
pcb->root0 = &s_one;
@{
  s_two = ika_bytevector_alloc(pcb, 10); /* GOOD */
@}
pcb->root0 = NULL;
@end example

@noindent
example of @strong{wrong} code: after the second call to the allocation
function the value in @code{s_one} may be invalid:

@example
ikpcb * pcb = ik_the_pcb();
ikptr   s_one, s_two;

s_one = ika_bytevector_alloc(pcb, 10);
s_two = ika_bytevector_alloc(pcb, 10);
/* do something with "s_one" and "s_two" */ /* WRONG */
@end example

Example of @strong{correct} code: @code{s_one} is protected while
allocating @code{s_two} and after the second allocation the pointer to
the data area of @code{s_one} is retrieved again:

@example
ikpcb * pcb = ik_the_pcb();
ikptr   s_one;
ikptr   s_two;
char *  one;
char *  two;

s_one = ika_bytevector_alloc(pcb, 10);
one   = IK_BYTEVECTOR_DATA_CHARP(s_one);
/* do something with "one" */
pcb->root0 = &s_one;
@{
  s_two = ika_bytevector_alloc(pcb, 10);
@}
pcb->root0 = NULL;
one   = IK_BYTEVECTOR_DATA_CHARP(s_one); /* GOOD */
two   = IK_BYTEVECTOR_DATA_CHARP(s_two);
/* do something with "one" and "two" */
@end example

@noindent
example of @strong{wrong} code: after the second call to the allocation
function the pointer to the data area of @code{s_one} may be invalid:

@example
ikpcb * pcb = ik_the_pcb();
ikptr   s_one;
ikptr   s_two;
char *  one;
char *  two;

s_one = ika_bytevector_alloc(pcb, 10);
one   = IK_BYTEVECTOR_DATA_CHARP(s_one);
/* do something with "one" */
pcb->root0 = &s_one;
@{
  s_two = ika_bytevector_alloc(pcb, 10);
@}
pcb->root0 = NULL;
two   = IK_BYTEVECTOR_DATA_CHARP(s_two);
/* do something with "one" and "two" */ /* WRONG */
@end example

Notice that, according to the C standard Section 6.5.16 ``Assignment
operators'': the order of evaluation of the operands is
unspecified@footnote{For an introduction to such problems see
@urldate{Jan 12, 2012}:

@center @url{http://en.wikipedia.org/wiki/Sequence_point}
}.  In the following code:

@example
IK_CAR(s_pair) = ika_bytevector_alloc(pcb, 8); /* WRONG */
@end example

@noindent
the left--side expression may be evaluated before the right--side one,
resulting in the value referenced by @code{s_pair} to be invalid when
the memory assigment actually takes place; so we have to code:

@example
ikptr   s_tmp;
s_tmp          = ika_bytevector_alloc(pcb, 8); /* GOOD */
IK_CAR(s_pair) = s_tmp;
@end example

@noindent
or:

@example
IK_ASS(IK_CAR(s_pair), ika_bytevector_alloc(pcb, 8)); /* GOOD */
@end example

@noindent
yes, it is a hard life.

Let's consider the following snippet, which is @strong{wrong}:

@example
ikpcb * pcb = ik_the_pcb();
ikptr   s_one, s_two;

s_one = IKA_PAIR_ALLOC(pcb); /* WRONG */
pcb->root0 = &s_one;
@{
  s_two = IKA_PAIR_ALLOC(pcb);
@}
pcb->root0 = NULL;
@end example

@noindent
when the second pair is allocated, the first pair has car and cdr still
uninitialised: the content of these words is undefined; this may cause
undefined behaviour while the second allocation takes place and the
garbage collection tries to scan the first pair.  The @strong{correct}
code is:

@example
ikpcb * pcb = ik_the_pcb();
ikptr   s_one, s_two;

s_one = ika_pair_alloc(pcb); /* GOOD */
pcb->root0 = &s_one;
@{
  s_two = IKA_PAIR_ALLOC(pcb);
@}
pcb->root0 = NULL;
@end example

@noindent
because @cfunc{ika_pair_alloc} initialises the car and the cdr.

@c page
@node objects booleans
@section Boolean objects


@deftypefn {Preprocessor Macro} int IK_IS_BOOLEAN (ikptr @var{obj})
If @var{obj} is @code{IK_FALSE} or @code{IK_TRUE} return true, else
return zero.
@end deftypefn


@deftypefn {Preprocessor Macro} int IK_BOOLEAN_TO_INT (ikptr @var{obj})
If @var{obj} is @code{IK_FALSE} return @code{0}, else return @code{1}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_BOOLEAN_FROM_INT (int @var{val})
If @var{val} is @code{0} return @code{IK_FALSE}, else return
@code{IK_TRUE}.
@end deftypefn

@c page
@node objects fixnums
@section Fixnum objects


Fixnums are ``small'' exact integers which fit in a single machine word:
if the word size is @math{4}, @math{30} bits are used for fixnum
representation; else the word size is @math{8} and @math{61} bits are
used for fixnum representation.  On a 32-bit platform, @math{30} bits
are available to store the number:

@example
(greatest-fixnum)       @result{} +536870911
(expt 2 29)             @result{} +536870912
(- (expt 2 29) 1)       @result{} +536870911

(least-fixnum)          @result{} -536870912
(- (expt 2 29))         @result{} -536870912
@end example

With machine words 32-bit wide, which means the word size is @math{4}
bytes, the representation of a fixnum is:

@example
 30 bits fixnum representation
      |........................|00

      |-----|-----|-----|------+--|
       byte3 byte2 byte1   byte0
@end example

@noindent
the two least significant bits are set to zero: this ``tags'' the
machine words which embed fixnums.  With machine words 64-bit wide,
which means the word size is @math{8} bytes, the representation of a
fixnum is:

@example
         61 bits fixnum representation
|...............................................|000

|-----|-----|-----|-----|-----|-----|-----|-----+---|
 byte7 byte6 byte5 byte4 byte3 byte2 byte1  byte0
@end example

@noindent
the three least significant bits are set to zero: this ``tags'' the
machine words which embed fixnums.

The fixnums tag is @code{00} on 32-bit platforms and @code{000} on
64-bit platforms; given the symbol @code{fx_shift}, which is set to the
number of bits in the tag, the value is selected in such a way that:

@example
length_in_bytes = number_of_words *  fx_shift
                = number_of_words *  wordsize
                = number_of_words << fx_shift
@end example

@noindent
this allows us, for example, to take the fixnum representing the number
of items in a vector and consider it directly as size of the vector's
data area in bytes.

@c ------------------------------------------------------------

@subsubheading Basic operations


Given an exact integer stored in a @code{long} value with the right
amount of bits, we encode a fixnum as follows:

@example
long    the_value  = ...;
ikptr   the_fixnum = (ikptr)(the_value << fx_shift);
@end example

@noindent
and we decode it as follows:

@example
ikptr   the_fixnum = ...;
long    the_value  = (long)(the_fixnum >> fx_shift);
@end example

@noindent
to verify if a @code{ikptr} is a fixnum we do:

@example
ikptr   the_fixnum = ...;

if (fx_tag == ((long)the_fixnum & fx_mask))
  it_is_a_fixnum();
else
  it_is_not();
@end example

@noindent
it is better to use the convenience macros described below.


@defmac fx_tag 0
The fixnums tag.
@end defmac


@defmac fx_shift
The number of bits in the fixnums tag.  It is the amount of bits we have
to left--shift a machine word to encode its value as fixnum.
@end defmac


@defmac fx_mask
Bit mask used to isolate the tag bits of a fixnum.
@end defmac

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


Examples:

@example
long int  N = 123L;
ikptr     P = IK_FIX(N);
long int  M = IK_UNFIX(P);
@end example


@deftypefn {Preprocessor Macro} ikptr IK_FIX (@var{num})
@deftypefnx {Preprocessor Macro} ikptr fix (@var{num})
Convert a small exact integer in the correct range for a fixnum, into a
@ikptr{} value.  @var{num} is cast to @code{long int}.

@quotation
@strong{NOTE} The macro @func{fix} is defined only in the internal
header file and its usage is deprecated.
@end quotation
@end deftypefn


@deftypefn {Preprocessor Macro} long IK_UNFIX (ikptr @var{ref})
@deftypefnx {Preprocessor Macro} long unfix (ikptr @var{ref})
Convert an @ikptr{} value holding a fixnum into a fixnum of type
@code{long int}.

@quotation
@strong{NOTE} The macro @func{unfix} is defined only in the internal
header file and its usage is deprecated.
@end quotation
@end deftypefn


@deftypefn {Preprocessor Macro} int IK_IS_FIXNUM (ikptr @var{ref})
Expand to true if @var{ref} is an @ikptr{} embedding a fixnum.  It
just tests if the least significant bits in the tag are set to zero.
@end deftypefn

@c page
@node objects pairs
@section Pair objects and lists


A pair is a fixed--length block of memory composed of two machine words;
the @math{3} least significant bits of an @ikptr{} reference to a pair
are the pair tag.

@example
|-------------------------|-------------| reference to pair
      heap pointer           pair tag

|-------------------|-------------------| pair memory block
    word 0 = car        word 1 = cdr
@end example

The empty list is not a pair: it is a special constant fitting in a
single @ikptr{} machine word, and it is defined by the preprocessor
symbol @code{IK_NULL_OBJECT}.

@c ------------------------------------------------------------

@subsubheading Basic operations

Pairs are allocated as follows, leaving the car and cdr uninitialised:

@example
ikpcb *  pcb = ik_the_pcb();
ikptr    s_pair;

s_pair = ik_safe_alloc(pcb, pair_size) | pair_tag;
@end example

@noindent
the car and cdr of a pair are extracted as follows:

@example
ikptr   s_pair = ...;
ikptr   s_car, s_cdr;

s_car = IK_REF(s_pair, off_car);
s_cdr = IK_REF(s_pair, off_cdr);
@end example

@noindent
or as follows:

@example
ikptr   s_pair = ...;
ikptr   s_car, s_cdr;

s_car = IK_CAR(s_pair);
s_cdr = IK_CDR(s_pair);
@end example

@noindent
the car and cdr of a pair are set as follows:

@example
ikptr   s_pair = ...;
ikptr   s_car  = ...;
ikptr   s_cdr  = ...;

IK_REF(s_pair, off_car) = s_car;
IK_REF(s_pair, off_cdr) = s_car;
@end example

@noindent
or as follows:

@example
ikptr   s_pair = ...;
ikptr   s_car  = ...;
ikptr   s_cdr  = ...;

IK_CAR(s_pair) = s_car;
IK_CDR(s_pair) = s_car;
@end example


@defvr {Preprocessor Symbol} pair_mask
@defvrx {Preprocessor Symbol} pair_tag
@defvrx {Preprocessor Symbol} pair_size
@code{pair_mask} is the bit pattern used to isolate a pair tag from a
reference @ikptr{}; @code{pair_tag} is the tag of @ikptr{} values
referencing a pair; @code{pair_size} is the number of bytes in a pair
memory block on the heap.
@end defvr


@defvr {Preprocessor Symbol} disp_car
@defvrx {Preprocessor Symbol} disp_cdr
@defvrx {Preprocessor Symbol} off_car
@defvrx {Preprocessor Symbol} off_cdr
@code{disp_car} and @code{disp_cdr} are the offsets in bytes of the car
and cdr from the beginning of a pair memory block; @code{off_car} and
@code{off_cdr} are integers to be added to a reference @ikptr{} tagged
as pair to retrieve the car and the cdr from a pair memory block.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_PAIR (ikptr @var{X})
Evaluate to true if the machine word @var{X} is tagged as pair.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IKA_PAIR_ALLOC (ikpcb * @var{pcb})
Allocate a new pair object using @cfunc{ik_safe_alloc} and return a
tagged reference to it.  The pair words are left @strong{uninitialised}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IKU_PAIR_ALLOC (ikpcb * @var{pcb})
Allocate a new pair object using @cfunc{ik_unsafe_alloc} and return a
tagged reference to it.  The pair words are left @strong{uninitialised}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_CAR (ikptr @var{pair})
@deftypefnx {Preprocessor Macro} ikptr IK_CDR (ikptr @var{pair})
Evaluate to the locations of the car and cdr of a pair; uses of these
macros can appear both as operands and as left--side of assignments.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_CAAR (ikptr @var{pair})
@deftypefnx {Preprocessor Macro} ikptr IK_CDAR (ikptr @var{pair})
@deftypefnx {Preprocessor Macro} ikptr IK_CADR (ikptr @var{pair})
@deftypefnx {Preprocessor Macro} ikptr IK_CDDR (ikptr @var{pair})
Return, respectively: the car of the car, the cdr of the car, the car of
the cdr, the cdr of the cdr.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on pairs and lists


@deftypefun ikptr ika_pair_alloc (ikpcb * @var{pcb})
@deftypefunx ikptr iku_pair_alloc (ikpcb * @var{pcb})
Allocate and return a new pair object using, respectively,
@cfunc{ik_safe_alloc} and @cfunc{ik_unsafe_alloc} and return a tagged
reference to it.  Both the car and cdr are initialised to
@code{IK_VOID_OBJECT}.
@end deftypefun


@deftypefun long ik_list_length (ikptr @var{list})
Return the length of the proper list referenced by @var{list}.  Do not
handle circular lists.  If the length exceeds @code{LONG_MAX}: terminate
the process with @cfunc{ik_abort}.
@end deftypefun


@deftypefun void ik_list_to_argv (ikptr @var{list}, char ** @var{argv})
Given a reference @var{list} to a proper list of bytevectors, fill
@var{argv} with pointers to the data areas, setting the last element of
@var{argv} to @cnull{}.  The array referenced by @var{argv} must be wide
enough to hold all the pointers from @var{list} plus the terminating
@cnull{}.
@end deftypefun


@deftypefun void ik_list_to_argv_and_argc (ikptr @var{list}, char ** @var{argv}, long * @var{argc})
Given a reference @var{list} to a proper list of bytevectors: fill
@var{argv} with pointers to the data areas, setting the last element of
@var{argv} to @cnull{}; fill @var{argc} with the lengths of the
bytevectors.  The array referenced by @var{argv} must be wide enough to
hold all the pointers from @var{list} plus the terminating @cnull{}; the
array referenced by @var{argc} must be wide enough to hold all the
lengths.
@end deftypefun


@deftypefun ikptr ika_list_from_argv (ikpcb * @var{pcb}, char ** @var{argv})
Given a pointer @var{argv} to a @cnull{}--terminated array of @asciiz{}
strings build and return a list of bytevectors holding a copy of the
@asciiz{} strings.  Make use of @code{pcb->root8} and @code{pcb->root9}.
@end deftypefun


@deftypefun ikptr ika_list_from_argv_and_argc (ikpcb * @var{pcb}, char ** @var{argv}, int @var{argc})
Given a pointer @var{argv} to an array of @asciiz{} strings holding
@var{argc} pointers: build and return a list of bytevectors holding a
copy of the @asciiz{} strings.  Make use of @code{pcb->root8} and
@code{pcb->root9}.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Pairs and lists code examples

The suggested general way to allocate and initialise a pair is as
follows:

@example
ikpcb * pcb    = ik_the_pcb();
ikptr   s_pair = ika_pair_alloc(pcb);

pcb->root0 = &s_pair;
@{
  IK_ASS(IK_CAR(s_pair), allocate_and_build_the_car(pcb));
  IK_ASS(IK_CDR(s_pair), allocate_and_build_the_cdr(pcb));
@}
pcb->root0 = NULL;
@end example

@noindent
notice how we take care of allocating the new pair with a function that
initialises the component words and of registering the pair as garbage
collection root before calling the constructors for the car and cdr.

If the component words do not need memory allocation, for example
because they are fixnums or already existing objects, we can use the
faster code:

@example
ikpcb * pcb    = ik_the_pcb();
ikptr   s_pair = IKA_PAIR_ALLOC(pcb);

IK_CAR(s_pair) = IK_FIX(123);
IK_CDR(s_pair) = IK_FIX(456);
@end example

Let's say we need to build a list of bytevectors from @asciiz{} strings
in the array @code{argv} and there are @code{argc} of them:

@example
ikpcb *  pcb  = ik_the_pcb();
char **  argv = ...;
long     argc = ...;
ikptr    s_list;

if (argc) @{
  ikptr  s_spine;
  long   i;

  s_list = s_spine = ika_pair_alloc(pcb);
  pcb->root0 = &s_list;
  pcb->root1 = &s_spine;
  @{
    for (i=0; i<argc;) @{
      IK_ASS(IK_CAR(s_spine),
             ika_bytevector_from_cstring(pcb, argv[i]));
      if (++i < argc) @{
        IK_ASS(IK_CDR(s_spine), ika_pair_alloc(pcb));
        s_spine = IK_CDR(s_spine);
      @} else @{
        IK_CDR(s_spine) = IK_NULL_OBJECT;
        break;
      @}
    @}
  @}
  pcb->root1 = NULL;
  pcb->root0 = NULL;
@} else
  s_list = IK_NULL_OBJECT;

/* make use of S_LIST */
@end example

@c page
@node objects bytevectors
@section Bytevector objects


Bytevectors are blocks of memory referenced by machine words tagged as
bytevectors.  The first word in the memory block is a fixnum
representing the number of bytes in the data area; a bytevector is
capable of holding at most a number of bytes equal to the return value
of @func{greatest-fixnum}.

When allocating a bytevector capable of holding @math{N} bytes, the
actual size of the allocated data area is @math{N+1}; the additional
last byte is not part of the data area and is perpetually set to zero.
All @value{PRJNAME}'s functions operating on bytevectors set to zero the
byte right after the last used one in the data area.  This last byte
allows every bytevector to be used as @asciiz{} string at the C language
level.

To allow for the same binary layout on both 32-bit and 64-bit platforms,
the data area starts @math{8} bytes after the beginning; on a 32-bit
platform the layout is:

@example
  1st word   2nd word                       last byte
|----------|----------|-------------------|-----------|
   length     unused        data area      set to zero
@end example

@noindent
on a 64-bit platform the layout is:

@example
       1st word                             last byte
|---------------------|-------------------|-----------|
       length               data area      set to zero
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations

Bytevector objects are fully allocated on the heap and subject to
garbage collection; to perform the allocation we compute the whole size
of the bytevector data area, add to it room for meta data and finally
compute the aligned block size:

@example
ikpcb * pcb        = ik_the_pcb();
long    bv_len     = the_number_of_bytes;
long    block_size = disp_bytevector_data + bv_len + 1;
lont    align_size = IK_ALIGN(block_size);
ikptr   bv = ik_safe_alloc(pcb, align_size) | bytevector_tag;
@end example

@cfunc{ik_safe_alloc} returns an @ikptr{} value representing the
aligned pointer, having the @math{3} least significant bits set to zero;
we add to it the bytevector tag (an integer value fitting in @math{3}
bits) which allows to recognise bytevectors among all the other built in
objects.

We have to explicitly store the bytevector length in the memory block as
a fixnum and set the last byte to zero, so usually a full allocation
looks like this:

@example
ikptr
ika_bytevector_alloc (ikpcb * pcb, long bv_len)
@{
  long   align_size;
  ikptr  s_bv;
  char * data;
  align_size = IK_ALIGN(disp_bytevector_data + bv_len + 1);
  s_bv       = ik_safe_alloc(pcb, align_size)
               | bytevector_tag;
  IK_REF(s_bv, off_bytevector_length) = IK_FIX(bv_len);
  data = (char *)(long)(s_bv + off_bytevector_data);
  data[bv_len] = '\0';
  return s_bv;
@}
@end example

@noindent
to acquire the number of bytes we do:

@example
ikptr  s_bv = the_bytevector;
long   bv_len;

bv_len = IK_UNFIX(IK_REF(s_bv, off_bytevector_length));
@end example

@noindent
and to access the data area we do:

@example
ikptr      s_bv = the_bytevector;
uint8_t *  data_area;

data_area = (uint8_t *)(long)(s_bv + off_bytevector_data);
@end example


@defvr {Preprocessor Symbol} bytevector_tag
An integer used to tag @ikptr{} references to bytevector memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_bytevector_length
Displacement of length.  The number of bytes to add to an untagged
pointer to bytevector to get the pointer to the first byte in the
machine word holding the bytevector length as fixnum.
@end defvr


@defvr {Preprocessor Symbol} disp_bytevector_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to bytevector to get the pointer to the first byte in the data
area.
@end defvr


@defvr {Preprocessor Symbol} off_bytevector_length
An integer to add to a tagged @ikptr{} bytevector reference to retrieve
the pointer to the first byte of the fixnum representing the bytevector
length.
@end defvr


@defvr {Preprocessor Symbol} off_bytevector_data
An integer to add to a tagged @ikptr{} bytevector reference to retrieve
the pointer to the first byte of the data area.

Notice that on both 32-bit and 64-bit platforms: the first byte of the
data area is at the same byte offset from the first byte of the
bytevector memory block.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefun {Preprocessor Macro} IK_IS_BYTEVECTOR (ikptr @var{obj})
Evaluate to true if @var{obj} is a bytevector.
@end deftypefun


@deftypefn {Preprocessor Macro} long IK_BYTEVECTOR_LENGTH (ikptr @var{bv})
Return the number of bytes in the data area of @var{bv}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_BYTEVECTOR_LENGTH_FX (ikptr @var{bv})
Return a fixnum representing the number of bytes in the data area of
@var{bv}.
@end deftypefn


@deftypefn {Preprocessor Macro} long IK_BYTEVECTOR_DATA (ikptr @var{bv})
Return a integer representing the memory address of the first byte in
the data area of @var{bv}.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_BYTEVECTOR_DATA_VOIDP (ikptr @var{bv})
@deftypefnx {Preprocessor Macro} {char *} IK_BYTEVECTOR_DATA_CHARP (ikptr @var{bv})
@deftypefnx {Preprocessor Macro} {uint8_t *} IK_BYTEVECTOR_DATA_UINT8P (ikptr @var{bv})
Return a pointer referencing the first byte in the data area of
@var{bv}.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on bytevectors


@deftypefun ikptr ika_bytevector_alloc (ikpcb * @var{pcb}, long @var{requested_number_of_bytes})
Allocate, initialise and return a new bytevector capable of holding the
specified number of bytes.  The contents of the data area are
unspecified.  The requested bytevector length @strong{must} be in the
range of fixnums.
@end deftypefun


@deftypefun ikptr ika_bytevector_from_cstring (ikpcb * @var{pcb}, const char * @var{cstr})
Allocate, initialise and return a new bytevector and copy the contents
of the @asciiz{} string referenced by @var{cstr} in the data area.

@strong{NOTE} If the string length is greater than the maximum positive
fixnum: the string is @strong{silently truncated} to a length equal to
the maximum positive fixnum.
@end deftypefun


@deftypefun ikptr ika_bytevector_from_cstring_len (ikpcb * @var{pcb}, const char * @var{cstr}, size_t @var{len})
Allocate, initialise and return a new bytevector and copy the @var{len}
bytes of the @ascii{} string referenced by @var{cstr} in the data area.

@strong{NOTE} If the string length is greater than the maximum positive
fixnum: the string is @strong{silently truncated} to a length equal to
the maximum positive fixnum.
@end deftypefun


@deftypefun ikptr ika_bytevector_from_memory_block (ikpcb * @var{pcb}, const void * @var{memory}, size_t @var{length})
Allocate, initialise and return a new bytevector and copy in the data
area @var{length} bytes from of the memory block referenced by
@var{memory}.

@strong{NOTE} If the memory block length is greater than the maximum
positive fixnum: the block is @strong{silently truncated} to a length
equal to the maximum positive fixnum.
@end deftypefun


@deftypefun ikptr ik_bytevector_from_utf16z (ikpcb * @var{pcb}, const void * @var{data});
Build and return a new bytevector from a memory block referencing a
@utf{}-16 string terminated with two consecutive zeros starting at even
offset:

@example
   char      char      char      char     0    0
|----+----|----+----|----+----|----+----|----+----|
 byte byte byte byte byte byte byte byte byte byte
@end example

If the the end of the string is not found before the byte index reaches
the maximum fixnum: return the false object.
@end deftypefun


@deftypefun ikptr ikrt_bytevector_copy (ikptr @var{dst}, ikptr @var{dst_start}, ikptr @var{src}, ikptr @var{src_start}, ikptr @var{count})
Copy @var{count} bytes from bytevector @var{src} starting at offset
@var{src_start}, to bytevector @var{dst} starting at offset
@var{dst_start}; @var{src_start}, @var{dst_start} and @var{count} must
be non--negative fixnums.  Return unspecified values.
@end deftypefun

@c page
@node objects vectors
@section Vector objects


Vectors are variable length blocks of memory referenced by machine words
tagged as vectors.  The first machine word of a vector block contains a
fixnum representing the vector length; a vector is capable of holding at
most a number of values equal to the return value of
@func{greatest-fixnum}.  This means that the first word of a vector is
tagged as a fixnum.

@example
|------------------------|-------------| reference to vector
      heap pointer         vector tag

|------------------------|-------------| vector first word
     number of words       fixnum tag
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations

Vector objects are allocated on the heap; to perform the allocation we
compute the whole size of the data area, add to it room for meta data
and finally compute the aligned block size:

@example
ikpcb * pcb            = ik_the_pcb();
long    length         = the_number_of_items;
long    requested_size = wordsize * length;
long    block_size     = disp_vector_data + requested_size;
long    align_size     = IK_ALIGN(block_size);
ikptr   vec = ik_safe_alloc(pcb, align_size) | vector_tag;
@end example

@noindent
@cfunc{ik_safe_alloc} returns an @ikptr{} value representing the
aligned pointer, having the @math{3} least significant bits set to zero;
we add to it the vector tag (an integer value fitting in @math{3} bits)
which allows to recognise vectors among all the other built in objects.

We have to explicitly store the vector length in the memory block as a
fixnum, so usually a full allocation looks like this:

@example
ikptr
ika_vector_alloc (ikpcb * pcb, long number_of_items)
@{
  long  align_size;
  ikptr s_len;
  ikptr s_vec;
  s_len      = IK_FIX(number_of_items);
  align_size = IK_ALIGN(disp_vector_data + s_len);
  s_vec      = ik_safe_alloc(pcb, align_size) | vector_tag;
  IK_REF(s_vec, off_vector_length) = s_len;
  return s_vec;
@}
@end example

@noindent
notice how we exploit the fact that the fixnum representing the number
of elements equals the number of bytes in the data area needed to hold
such elements.

The allocation operations described above leaves the data area
uninitialised: its content is undefined.  This is bad if the garbage
collector moves the newly built vector before the elements are
initialised to a correct Scheme value.  The following function resets
the data area to a vector of zero fixnums:

@example
ikptr
ikrt_vector_clean (ikptr s_vec)
@{
  ikptr	s_len = IK_VECTOR_LENGTH_FX(s_vec);
  memset((char*)(long)(s_vec + off_vector_data), 0, s_len);
  return s_vec;
@}
@end example

To fill a vector of @math{3} items with fixnums we should do:

@example
ikptr  s_vec = the_vector;
IK_REF(s_vec, off_vector_data + 0 * wordsize) = IK_FIX(10);
IK_REF(s_vec, off_vector_data + 1 * wordsize) = IK_FIX(20);
IK_REF(s_vec, off_vector_data + 2 * wordsize) = IK_FIX(30);
@end example

@noindent
to retrieve the item at index @math{2} we do:

@example
ikptr  s_vec  = the_vector;
ikptr  s_item = IK_REF(s_vec, off_vector_data + 2 * wordsize);
@end example

@noindent
and to retrieve the vector length:

@example
ikptr  s_vec  = the_vector;
ikptr  s_len  = IK_REF(s_vec, off_vector_length);
long   length = IK_UNFIX(s_len);
@end example


@defvr {Preprocessor Symbol} vector_tag
An integer used to tag @ikptr{} references  to vector memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_vector_length
Displacement of length.  The number of bytes to add to an untagged
pointer to vector to get the pointer to the first byte in the word
holding the vector length as fixnum.
@end defvr


@defvr {Preprocessor Symbol} disp_vector_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to vector to get the pointer to the first byte in the data area.
@end defvr


@defvr {Preprocessor Symbol} off_vector_length
An integer to add to a tagged @ikptr{} reference to retrieve the pointer
to the first byte of the vector length as fixnum.
@end defvr


@defvr {Preprocessor Symbol} off_vector_data
An integer to add to a tagged @ikptr{} vector reference to retrieve the
pointer to the first byte of the data area.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} ikptr IK_VECTOR_LENGTH_FX (ikptr @var{vec})
Return a fixnum representing the number of items in the vector
@var{vec}.
@end deftypefn


@deftypefn {Preprocessor Macro} long IK_VECTOR_LENGTH (ikptr @var{vec})
Return an integer representing the number of items in the vector
@var{vec}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_ITEM (ikptr @var{vec}, long @var{idx})
Evaluate to the item at index @var{idx} in the vector @var{vec}.  A use
of this macro can appear both as operand and as left--side of an
assignment; example:

@example
long    idx   = the_index;
ikptr   s_vec = the_vector;
ikptr   fx;

IK_ITEM(s_vec, idx) = IK_FIX(10);
fx = IK_ITEM(s_vec, idx);
@end example
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on vectors


@deftypefun ikptr ika_vector_alloc_no_init (ikpcb * @var{pcb}, long @var{number_of_items})
Allocate, initialise and return a new vector object capable of holding
the specified number of items.  Leave the data area uninitialised.
@end deftypefun


@deftypefun ikptr ika_vector_alloc_and_init (ikpcb * @var{pcb}, long @var{number_of_items})
Allocate, initialise and return a new vector object capable of holding
the specified number of items.  Initialise the data area so that all the
items are set to the fixnum zero.
@end deftypefun


@deftypefun int ik_is_vector (ikptr @var{vec})
Return true if @var{vec} is a reference to a vector object.  This
predicate tests that @var{vec} is tagged as vector reference and that
the first machine word in the referenced memory block is a fixnum.
@end deftypefun


@deftypefun ikptr ikrt_vector_clean (ikptr @var{vec})
Clean the data area so that all the items are set to the fixnum
zero.
@end deftypefun


@deftypefun ikptr ikrt_vector_copy (ikptr @var{dst}, ikptr @var{dst_start}, ikptr @var{src}, ikptr @var{src_start}, ikptr @var{count})
Copy @var{count} items from vector @var{src} starting at offset
@var{src_start}, to vector @var{dst} starting at offset @var{dst_start};
@var{src_start}, @var{dst_start} and @var{count} must be non--negative
fixnums.  Return unspecified values.
@end deftypefun

@c page
@node objects structs
@section Struct objects


A data structure is a variable--length block of memory referenced by
machine words tagged as vectors; the first machine word of the structure
is a reference to the type descriptor (@rtd{}), which is itself a data
structure; the subsequent words, if any, are the fields of the
structure.  A block of memory is a data structure if and only if: a
reference to it is tagged as vector and its first word is tagged as
vector.

@example
|----------------|----------| reference to structure
  heap pointer    vector tag

|----------------|----------| first word of structure
  heap pointer    vector tag    = reference to rtd
                                = reference to structure
@end example

The type descriptor of the type descriptors is the return value of
@func{base-rtd} at the Scheme level and the structure referenced by the
field @code{base_rtd} in the process control block.  Such base type
descriptor is built at @value{PRJNAME}'s startup.  The graph of
references for a structure and its type descriptor is as follows:

@example
      rtd ref
     |-------|---------------| structure instance
         |
  ---<---
 |
 |     rtd ref
  -->|-------|---------------| type descriptor
         |
  ---<---
 |
 |     rtd ref
 +-->|-------|---------------| base type descriptor
 |       |
  ---<---
@end example

@noindent
the type descriptor of the base type descriptor is the base type
descriptor itself.

An @rnrs{6} record--type descriptor is a struct instance of type @rtd{}.
An @rnrs{6} record instance is a struct instance whose first word
references its type descriptor, that is a struct instance of type
@rtd{}.

@example
     RTD ref
    |-------|---------------| R6RS record instance
        |
 ---<---
|
|     std ref
 -->|-------|---------------| R6RS record type descriptor
        |                      = struct instance of type RTD
 ---<---
|
|     std ref
+-->|-------|---------------| RTD type descriptor
        |
 ---<---
|
|     std ref
+-->|-------|---------------| base struct type descriptor
|       |
 ---<---
@end example

A struct type descriptor is a fixed--length block of memory composed of
@math{6} machine words interpreted as follows:

@enumerate
@item
A reference to the base @rtd{}.

@item
A fixnum representing the number of machine words in the structure minus
@math{1}; this is the number of fields in the structure excluding the
reference to the @rtd{}.  This value is @math{5} in the base @rtd{}.

@item
Scheme symbol representing the name of this structure type.

@item
Scheme list of symbols representing the names of fields in structures of
this type.

@item
False or a reference to closure used to print to a Scheme port the
structures of this type.  This is the printer function.

@item
Scheme symbol used as unique identifier for this type.
@end enumerate

Type descriptors are best defined at the Scheme level using the
functions from the @library{vicare} library, @ref{iklib structs} for
details.  To instantiate a structure at the C language level we should
write a C function accepting the type descriptor as argument, and have
the Scheme code hand the descriptor to it.  For example, at the Scheme
level we do:

@example
(define-struct timeval
  (tv_sec tv_usec))

(define (gettimeofday)
  (foreign-call "ikrt_posix_gettimeofday"
                (type-descriptor timeval)))
@end example

@noindent
and at the C level we do:

@example
ikptr
ikrt_posix_gettimeofday (ikptr s_rtd, ikpcb * pcb)
@{
  /* build and return an instance of "timeval" */
@}
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations

Data structure objects are allocated on the heap; to perform the
allocation we compute the whole size of the structure:

@example
ikpcb * pcb        = ik_the_pcb();
long    num_of_fields = ...;
long    block_size = disp_record_data +
                     wordsize * num_of_fields;
long    align_size = IK_ALIGN(block_size);
ikptr   s_stru     = ik_safe_alloc(pcb, align_size) | record_tag;
@end example

@noindent
@cfunc{ik_safe_alloc} returns an @ikptr{} value representing the aligned
pointer, having the @math{3} least significant bits set to zero; we add
to it the record tag (an integer value fitting in @math{3} bits) which
allows to recognise records among all the other built in objects.

We have to explicitly store a reference to the @rtd{} in the first
machine word of the structure, so a full allocation looks like this:

@example
ikptr
ika_struct_alloc (ikpcb * pcb, ikptr s_rtd)
@{
  long	num_of_fields;
  long  align_size;
  ikptr s_stru;
  num_of_fields = IK_UNFIX(IK_REF(s_rtd, off_rtd_length));
  align_size = IK_ALIGN(disp_record_data +
                        num_of_fields * wordsize);
  pcb->root9 = &s_rtd;
  @{
    s_ stru = ik_safe_alloc(pcb, align_size) | record_tag;
  @}
  pcb->root9 = NULL;
  IK_REF(s_stru, off_record_rtd) = s_rtd;
  return s_stru;
@}
@end example

The allocation operation described above leaves the data area
uninitialised: its content is undefined.  This is bad if the garbage
collector moves the newly built record before the elements are
initialised to a correct Scheme value.

To recognise an @ikptr{} value as reference to a structure we do:

@example
ikptr   R = the_value;

if ((record_tag == (record_mask & R)) &&
    (record_tag == (record_mask & IK_REF(R, off_record_rtd))))
  it_is_a_structure();
else
  it_is_not();
@end example

@noindent
structure fields are identified at the C level by a zero--based index;
to store a value in field @math{2} of a structure we do:

@example
ikptr  s_stru  = the_structure;
ikptr  s_field = the_field;

IK_REF(s_stru, off_record_data + 2 * wordsize) = the_field;
@end example

@noindent
and to retrieve a the value of field @math{2} we do:

@example
ikptr  s_stru  = the_structure;
ikptr  s_field;

s_field = IK_REF(s_stru, off_record_data + 2 * wordsize);
@end example


@defvr {Preprocessor Symbol} record_mask
@defvrx {Preprocessor Symbol} record_tag
Integer values used to tag and recognise @ikptr{} references to
structures.  @code{record_mask} isolates the tag bits from an @ikptr{}
and @code{record_tag} represents the tag bits.  These values are the
same used for vectors.
@end defvr


@defvr {Preprocessor Symbol} disp_record_rtd
Displacement of the @rtd{} from the beginning of a structure block.  The
number of bytes to add to an untagged pointer to structure to get the
pointer to the first byte in the word holding the @rtd{}.
@end defvr


@defvr {Preprocessor Symbol} disp_record_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to structure to get the pointer to the first byte of the first
field in the data area.
@end defvr


@defvr {Preprocessor Symbol} off_record_rtd
An integer to add to a tagged @ikptr{} structure reference to retrieve
the pointer to the first byte of the @rtd{}.
@end defvr


@defvr {Preprocessor Symbol} off_record_data
An integer to add to a tagged @ikptr{} structure reference to retrieve
the pointer to the first byte of the first field of the structure.
@end defvr


@defvr {Preprocessor Symbol} disp_rtd_rtd
Displacement of the base @rtd{} from the beginning of an @rtd{} block.
The number of bytes to add to an untagged pointer to @rtd{} to get the
pointer to the first byte of the reference to @rtd{}.
@end defvr


@defvr {Preprocessor Symbol} disp_rtd_name
@defvrx {Preprocessor Symbol} disp_rtd_length
@defvrx {Preprocessor Symbol} disp_rtd_fields
@defvrx {Preprocessor Symbol} disp_rtd_printer
@defvrx {Preprocessor Symbol} disp_rtd_symbol
Displacements of the fields of an @rtd{}.
@end defvr


@defvr {Preprocessor Symbol} rtd_size
The total number of bytes in a memory block holding an @rtd{}.
@end defvr


@defvr {Preprocessor Symbol} off_rtd_rtd
@defvrx {Preprocessor Symbol} off_rtd_name
@defvrx {Preprocessor Symbol} off_rtd_length
@defvrx {Preprocessor Symbol} off_rtd_fields
@defvrx {Preprocessor Symbol} off_rtd_printer
@defvrx {Preprocessor Symbol} off_rtd_symbol
Integer to add to a tagged @ikptr{} @rtd{} reference to retrieve the
pointer to the first byte of the fields.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} ikptr IK_FIELD (ikptr @var{stru}, @var{idx})
Evaluate to the location of the field at zero--based index @var{idx} for
the structure @var{stru}.  A use of this macro can appear both as
operand and as left--side of an assignment.

@example
ikptr   s_stru = the_structure;
ikptr   s_field;

s_field = IK_FIELD(s_stru, 2);
IK_FIELD(s_stru, 2) = s_field;
@end example
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on vectors


@deftypefun ikptr ika_struct_alloc_no_init (ikpcb * @var{pcb}, ikptr @var{rtd})
Allocate, initialise and return a new structure instance of type
@var{rtd}.  The first word of the allocated block is initialised with
@var{rtd}, the other words are left uninitialised.
@end deftypefun


@deftypefun ikptr ika_struct_alloc_and_init (ikpcb * @var{pcb}, ikptr @var{rtd})
Allocate, initialise and return a new structure instance of type
@var{rtd}.  The first word of the allocated block is initialised with
@var{rtd}, the other words are initialised to the fixnum zero.
@end deftypefun


@deftypefun int ik_is_struct (ikptr @var{R})
Return true if @var{R} is a reference to a structure.
@end deftypefun

@c page
@node objects chars
@section Character objects


A Scheme character has two representations:

@itemize
@item
As a standalone Scheme object, it is a machine word whose least
significant bits are set to the character tag and whose most significant
bits are set to the character's Unicode code point.

@item
When embedded in a Scheme string, it is a 32-bit value whose least
significant bits are set to the character tag and whose most significant
bits are set to the character's Unicode code point.
@end itemize

@noindent
the least significant 32 bits of the two representations are equal.
@ref{unicode} for details on Unicode.

Let's say that machine words are 32-bit values, which means the word
size is @math{4} bytes; then the representation of a character is:

@example
|    Unicode code point    | char tag

|--------|--------|--------|--------|
  byte3    byte2    byte1    byte0
@end example

@noindent
the least significant byte is set to @code{#x0F}: this ``tags'' the
machine words which embed characters.  On 64-bit machines, the layout
is:

@example
        Unused              |Unicode code point  |char tag
|...........................|....................|......|

|------|------|------|------|------|------|------|------|
 byte7  byte6  byte5  byte4  byte3  byte2  byte1  byte0
@end example

At the Scheme level: standalone characters are moved around as @ikptr{}
values, but when characters are stored in a string the @ikptr{} value is
converted to a 32-bit integer of type @code{ikchar}.

@c ------------------------------------------------------------

@subsubheading Basic operations

Standalone characters are encoded into @ikptr{} values as follows:

@example
unsigned long   unicode_code_point = the_code_point;
ikptr           s_char;

s_char = (unicode_code_point << char_shift) | char_tag;
@end example

@noindent
decoded to @code{unsigned long} values as follows:

@example
ikptr           s_char = the_character;
unsigned long   unicode_code_point;

unicode_code_point = s_char >> char_shift;
@end example

@noindent
and identified as follows:

@example
ikptr   X = the_value;

if (char_tag == (char_mask & X))
  it_is_a_character();
else
  it_is_not();
@end example

Characters from a Scheme string are decoded from @code{ikchar} to
@code{unsigned long} as follows:

@example
ikchar          ch = the_32bit_character;
unsigned long   unicode_code_point;

unicode_code_point = s_char >> char_shift;
@end example

@noindent
and encoded from @code{unsigned long} to @code{ikchar} as follows:

@example
unsigned long   unicode_code_point = the_code_point;
ikchar          ch;

ch = (ikchar)((unicode_code_point << char_shift) | char_tag);
@end example


@deftp {Type Definition} ikchar
An alias for @code{uint32_t} used to store a Unicode code point tagged
as character.
@end deftp


@defvr {Preprocessor Symbol} char_mask
@defvrx {Preprocessor Symbol} char_tag
Integer values used to tag and recognise @ikptr{} values representing
characters.  @code{char_mask} isolates the tag bits from an @ikptr{} and
@code{char_tag} represents the tag bits.
@end defvr


@defvr {Preprocessor Symbol} char_shift
Integer value representing the number of bits we must shift left to turn
a C language @code{long} into a machine word ready to be tagged as
Scheme character.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_CHAR (ikptr @var{X})
Evaluate to true if @var{X} is a Scheme character.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_CHAR_FROM_INTEGER (unsigned long @var{X})
@deftypefnx {Preprocessor Macro} {unsigned long} IK_CHAR_TO_INTEGER (ikptr @var{X})
Convert a Scheme character to and from an @code{unsigned long} value
representing the Unicode code point.
@end deftypefn


@deftypefn {Preprocessor Macro} ikchar IK_CHAR32_FROM_INTEGER (unsigned long @var{X})
Convert a @code{unsigned long} value representing the Unicode code
point into a 32-bit integer representing a Scheme character to be stored
into a string.
@end deftypefn

@c page
@node objects strings
@section String objects


Strings are variable--length blocks of memory referenced by machine
words tagged as strings; strings are @strong{not} stored in memory in
@utf{}-32 format.  The first word in the memory block is a fixnum
representing the number of characters in the data area; a string is
capable of holding at most a number of characters equal to the return
value of @func{greatest-fixnum}.

@example
|------------------------|-------------| reference to string
      heap pointer         string tag

|------------------------|-------------| string first word
     number of words       fixnum tag
@end example

All the remaining space in the memory block is filled with 32-bit
unsigned integers whose least significant bits are set to the character
tag and whose most significant bits are set to the character's Unicode
code point.

@c ------------------------------------------------------------

@subsubheading Basic operations

String objects are allocated on the heap; to perform the allocation we
compute the whole size of the data area, add to it room for meta data
and finally compute the aligned block size:

@example
ikpcb * pcb            = ik_the_pcb();
long    length         = the_number_of_chars;
long    requested_size = sizeof(ikchar) * length;
long    block_size     = disp_string_data + requested_size;
long    align_size     = IK_ALIGN(block_size);
ikptr   str = ik_safe_alloc(pcb, align_size) | string_tag;
@end example

@noindent
@cfunc{ik_safe_alloc} returns an @ikptr{} value representing the aligned
pointer, having the @math{3} least significant bits set to zero; we add
to it the string tag (an integer value fitting in @math{3} bits) which
allows to recognise strings among all the other built in objects.

We have to explicitly store the string length in the memory block as a
fixnum, so usually a full allocation looks like this:

@example
ikptr
ik_string_alloc (ikpcb * pcb, long number_of_chars)
@{
  long  align_size;
  ikptr str;
  align_size = IK_ALIGN(disp_string_data
                        + number_of_chars * sizeof(ikchar));
  str        = ik_safe_alloc(pcb, align_size) | string_tag;
  IK_REF(str, off_string_length) = IK_FIX(number_of_chars);
  return str;
@}
@end example

To fill a string of @math{3} chars with characters we should do:

@example
ikptr     s_str = the_string;
ikchar *  ch    = (ikchar*)(s_str + off_string_data);

ch[0] = IK_CHAR32_FROM_INTEGER(10);
ch[1] = IK_CHAR32_FROM_INTEGER(20);
ch[2] = IK_CHAR32_FROM_INTEGER(30);
@end example

@noindent
to retrieve the character at index @math{2} we do:

@example
long      index  = 2;
ikptr     s_str  = the_string;
ikchar *  ch     = (ikchar*)(s_str + off_string_data);
ikptr     s_char = (ikptr)ch[index];
@end example

@noindent
and to retrieve the string length:

@example
ikptr  s_str    = the_string;
ikptr  s_length = IK_REF(s_str, off_string_length);
long   length   = IK_UNFIX(s_length);
@end example


@defvr {Preprocessor Symbol} string_char_size
Integer value representing the number of bytes in a Scheme character
stored in a Scheme string.
@end defvr


@defvr {Preprocessor Symbol} string_mask
@defvrx {Preprocessor Symbol} string_tag
Integer values used to tag and recognise @ikptr{} values representing
string references.  @code{string_mask} isolates the tag bits from an
@ikptr{} and @code{string_tag} represents the tag bits.
@end defvr


@defvr {Preprocessor Symbol} disp_string_length
Displacement of length.  The number of bytes to add to an untagged
pointer to string to get the pointer to the first byte in the word
holding the string length as fixnum.
@end defvr


@defvr {Preprocessor Symbol} disp_string_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to string to get the pointer to the first byte in the data area.
@end defvr


@defvr {Preprocessor Symbol} off_string_length
An integer to add to a tagged @ikptr{} reference to retrieve the pointer
to the first byte of the string length as fixnum.
@end defvr


@defvr {Preprocessor Symbol} off_string_data
An integer to add to a tagged @ikptr{} string reference to retrieve the
pointer to the first byte of the data area.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_STRING (ikptr @var{obj})
Return true if @var{obj} is a reference to a string object.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_STRING_LENGTH_FX (ikptr @var{str})
Return a fixnum representing the number of characters in the string
@var{str}.
@end deftypefn


@deftypefn {Preprocessor Macro} long IK_STRING_LENGTH (ikptr @var{str})
Return an integer representing the number of characters in the string
@var{str}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikchar IK_CHAR32 (ikptr @var{str}, long @var{idx})
Evaluate to the 32-bit character representation at index @var{idx} in
the string @var{str}.  A use of this macro can appear both as operand
and as left--side of an assignment; example:

@example
long    idx   = the_index;
ikptr   s_str = the_string;
ikchar  ch;

IK_CHAR32(s_str, idx) = IK_CHAR32_FROM_INTEGER(10);
ch = IK_CHAR32(s_str, idx);
@end example
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on strings


@deftypefun ikptr ika_string_alloc (ikpcb * @var{pcb}, long @var{number_of_chars})
Allocate, initialise and return a new string object capable of holding
the specified number of chars.
@end deftypefun

@c page
@node objects symbols
@section Symbol objects


A symbol is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a symbol block is tagged
has symbol in its least significant bits and it has the most significant
bits set to zero.

@example
|------------------------|-------------| reference to symbol
      heap pointer         vector tag

|------------------------|-------------| symbol first word
   all set to zero         symbol tag
@end example

A symbol memory block is @math{6} words wide and contains references to
the following fields: @code{string}, @code{ustring}, @code{value},
@code{proc}, @code{plist}.

@c ------------------------------------------------------------

@subsubheading Basic operations

Symbol objects are allocated on the heap and must be interned, that is
registered in a global symbol table.


@defvr {Preprocessor Symbol} symbol_mask
@defvrx {Preprocessor Symbol} symbol_tag
Integer values used to tag and recognise the first word in symbol memory
blocks.  @code{symbol_mask} isolates the tag bits from an @ikptr{} and
@code{symbol_tag} represents the tag bits.
@end defvr


@defvr {Preprocessor Symbol} symbol_record_size
Number of bytes needed to hold a symbol memory block.
@end defvr


@defvr {Preprocessor Symbol} disp_symbol_record_tag
@defvrx {Preprocessor Symbol} disp_symbol_record_string
@defvrx {Preprocessor Symbol} disp_symbol_record_ustring
@defvrx {Preprocessor Symbol} disp_symbol_record_value
@defvrx {Preprocessor Symbol} disp_symbol_record_proc
@defvrx {Preprocessor Symbol} disp_symbol_record_plist
Symbol field displacements.  The number of bytes to add to an untagged
pointer to symbol to get the pointer to the first byte in the word
holding the specified field.
@end defvr


@defvr {Preprocessor Symbol} off_symbol_record_tag
@defvrx {Preprocessor Symbol} off_symbol_record_string
@defvrx {Preprocessor Symbol} off_symbol_record_ustring
@defvrx {Preprocessor Symbol} off_symbol_record_value
@defvrx {Preprocessor Symbol} off_symbol_record_proc
@defvrx {Preprocessor Symbol} off_symbol_record_plist
Symbol field offsets.  The number of bytes to add to an tagged pointer
to symbol to get the pointer to the first byte in the word holding the
specified field.
@end defvr

@c ------------------------------------------------------------

@subsubheading Operations on symbols


@deftypefun int ik_is_symbol (ikptr @var{obj})
Return true if @var{obj} is a symbol.
@end deftypefun

@c page
@node objects bignums
@section Bignum objects


Bignums are multi--precision exact integers bigger than fixnums; they
are implemented using the @code{mpn} @api{} of @gnu{} @gmp{},
@xref{Low-level Functions, mpn, Low-level Functions, gmp}.

@value{PRJNAME} only uses a bignum to represent an exact integer when
the value does not fit in a fixnum; it follows that the following ranges
are enforced:

@example
negative bignums < (least-fixnum) <= all fixnums

all fixnums <= (greatest-fixnum) < positive bignums
@end example

A bignum is a variable length memory block referenced by machine words
tagged as vectors.  The first machine word of a bignum block is tagged
has bignum in its least significant bits; then comes a sign bit, zero if
positive; the remaining most significant bits represent the number of
words in the memory block after the first one.

@example
|------------------------|-------------| reference to bignum
      heap pointer         vector tag

                     sign bit
|----------------------|-|-------------| bignum first word
   number of words         bignum tag
@end example

A pointer to the second machine word in a bignum memory block is the
pointer of type @code{mp_limb_t} accepted by the @code{mpn_} functions
of @gmp{}; @dfn{limb}, in @gmp{} jargon, is a machine word holding a
portion of multi--precision number.  The layout of a bignum memory block
is as follows:

@example
|----|-----|-----|-----|-----| ...
 fst  limb0 limb1 limb2 limb3
@end example

@noindent
where the first word @code{fst} is header of meta informations encoded
as explained above and each limb is a machine word stored in native
endianness; the big number is the concatenation of limbs with
@code{limb0} being the least significant one.  There is always at least
one limb; when a bignum is composed of a single limb, its value is
always non--zero and outside the range of fixnums.

@c ------------------------------------------------------------

@subsubheading Basic operations


To allocate a bignum we must know the number of required limbs:

@example
ikpcb * pcb        = ik_the_pcb();
long    nlimbs     = the_number_of_limbs;
long    block_size = disp_bignum_data + nlimbs * wordsize;
long    align_size = IK_ALIGN(block_size);
ikptr s_bn = ik_safe_alloc(pcb, align_size) | vector_tag;
@end example

@noindent
we must explicitly build and encode the first word; the number of limbs
is encoded as follows:

@example
long   nlimbs      = the_number_of_limbs;
ikptr  meta_nlimbs = nlimbs << bignum_nlimbs_shift;
@end example

@noindent
the sign bit is encoded as follows:

@example
long   sign      = zero_if_positive_one_if_negative;
ikptr  meta_sign = sign << bignum_sign_shift;
@end example

@noindent
and the full first word is composed and stored as follows:

@example
ikptr  s_bn        = the_bignum;
ikptr  meta_nlimbs = ...;
ikptr  meta_sign   = ...;
ikptr  s_fst       = meta_nlimbs | meta_sign | bignum_tag;

IK_REF(s_bn, off_bignum_tag) = s_fst;
@end example

To identify an object as bignum we do:

@example
ikptr  X = the_object;

if ((vector_tag == IK_TAGOF(X)) &&
    (bignum_tag == (bignum_mask & IK_REF(X, -vector_tag))))
  it_is_a_bignum();
else
  it_is_not();
@end example

@noindent
to extract meta informations we must first extract the first word:

@example
ikptr   s_bn  = the_bignum;
ikptr   s_fst = IK_REF(s_bn, off_bignum_tag);
long    nlimbs;
long    meta_sign;

nlimbs    = ((ik_ulong)s_fst) >> bignum_nlimbs_shift;
meta_sign = ((ik_ulong)s_fst) &  bignum_sign_mask;
@end example

@noindent
if @code{meta_sign} is zero the bignum is positive, else it is negative.

To acquire a pointer to the data area we do:

@example
ikptr        s_bn = the_bignum;
mp_limb_t *  data;

data = (mp_limb_t*)(long)(s_bn + off_bignum_data);
@end example

@noindent
to extract the @math{N}-th limb we do:

@example
ikptr      s_bn = the_bignum;
long       N    = the_index;
mp_limb_t  limb;

limb = (mp_limb_t)IK_REF(s_bn, off_bignum_data + N * wordsize);
@end example


@defvr {Preprocessor Symbol} bignum_mask
@defvrx {Preprocessor Symbol} bignum_tag
@code{bignum_mask} is the bit pattern used to isolate a bignum tag from
an @ikptr{} value; @code{bignum_tag} is the tag of @ikptr{} values used
as first words in bignum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} bignum_sign_mask
A bit pattern used to isolate the sign bit from the @code{ikptr} value
used as first word in bignum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} bignum_sign_shift
The number representing the bit left--shift offset of the sign bit in
the @code{ikptr} value used as first word in bignum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} bignum_nlimbs_shift
The number representing the bit left--shift offset of the number of
limbs in the @code{ikptr} value used as first word in bignum memory
blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_bignum_tag
Offset in bytes of the first word in a bignum memory block from the
beginning of the block.  It is zero.
@end defvr


@defvr {Preprocessor Symbol} disp_bignum_data
Offset in bytes of the first byte in the data area of a bignum memory
block from the beginning of the block.
@end defvr


@defvr {Preprocessor Symbol} off_bignum_tag
Number to add to a tagged @ikptr{} reference to bignum to obtain a
pointer to the first word in a bignum memory block.
@end defvr


@defvr {Preprocessor Symbol} off_bignum_data
Number to add to a tagged @ikptr{} reference to bignum to obtain a
pointer to the first byte in the data area of bignum memory block.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} long IK_BIGNUM_ALLOC_SIZE (long @var{nlimbs})
Given a number of limbs: evaluate to the aligned size of the memory
block needed to hold the bignum.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IKA_BIGNUM_ALLOC (ikpcb * @var{pcb}, long @var{nlimb})
Given a number of limbs: allocate, using @cfunc{ik_safe_alloc}, the
memory block needed to hold the bignum and return an untagged pointer to
it.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_COMPOSE_BIGNUM_FIRST_WORD (long @var{nlimb}, ikptr @var{meta_sign})
Given a number of limbs and the encoded sign bit: evaluate to the first
word of a bignum object.  It is equivalent to the following:

@example
ikptr  meta_nlimbs;
ikptr  s_fst;

meta_nlimbs = (@var{nlimbs} << bignum_nlimbs_shift)
s_fst       = meta_nlimbs | @var{meta_sign} | bignum_tag;
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POSITIVE_BIGNUM_FIRST_WORD (long @var{nlimb})
@deftypefnx {Preprocessor Macro} ikptr IK_NEGATIVE_BIGNUM_FIRST_WORD (long @var{nlimb})
Given a number of limbs evaluate to the corresponding first word of
bignum representing a positive or negative number.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_BIGNUM_FIRST (ikptr @var{bn})
Given a reference to bignum: evaluate to the location of the first word
holding meta informations.  Can be used both as operand or left--side of
assignment:

@example
ikptr  s_bn = the_bignum;
ikptr  s_fst;

s_fst = IK_BIGNUM_FIRST(s_bn);
IK_BIGNUM_FIRST(s_bn) = s_fst;
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_LIMB (ikptr @var{bn}, long @var{N})
Given a reference to bignum: evaluate to the location of the @var{N}-th
limb in the data area.  Can be used both as operand or left--side of
assignment:

@example
ikptr      s_bn = the_bignum;
mp_limb_t  limb;

limb = (mp_limb_t)IK_LIMB(s_bn);
IK_LIMB(s_bn) = (ikptr)limb;
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {mp_limb_t *} IK_BIGNUM_DATA_LIMBP (ikptr @var{bn})
Given a reference to bignum: evaluate to a pointer to the first byte in
the data area, which is a pointer to the least significant limb.
@end deftypefn


@deftypefn {Preprocessor Macro} mp_limb_t IK_BIGNUM_FIRST_LIMB (ikptr @var{bn})
Given a reference to bignum: evaluate to the least significant limb in
the data area.
@end deftypefn


@deftypefn {Preprocessor Macro} mp_limb_t IK_BIGNUM_LAST_LIMB (ikptr @var{bn}, long @var{nlimbs})
Given a reference to bignum and its number of limbs: evaluate to the
most significant limb in the data area.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on exact integers


@deftypefun int ik_is_bignum (ikptr @var{obj})
Return true if @var{obj} is a bignum.
@end deftypefun


@deftypefun ikptr ika_integer_from_int (ikpcb * @var{pcb}, int @var{N})
@deftypefunx ikptr ika_integer_from_long (ikpcb * @var{pcb}, long @var{N})
@deftypefunx ikptr ika_integer_from_llong (ikpcb * @var{pcb}, ik_llong @var{N})
@deftypefunx ikptr ika_integer_from_uint (ikpcb * @var{pcb}, ik_uint @var{N})
@deftypefunx ikptr ika_integer_from_ulong (ikpcb * @var{pcb}, ik_ulong @var{N})
@deftypefunx ikptr ika_integer_from_ullong (ikpcb * @var{pcb}, ik_ullong @var{N})
Build and return a new exact integer object from the given C language
value.
@end deftypefun


@deftypefun ikptr ika_integer_from_sint32 (ikpcb * @var{pcb}, int32_t @var{N})
@deftypefunx ikptr ika_integer_from_sint64 (ikpcb * @var{pcb}, int64_t @var{N})
@deftypefunx ikptr ika_integer_from_uint32 (ikpcb * @var{pcb}, uint32_t @var{N})
@deftypefunx ikptr ika_integer_from_uint64 (ikpcb * @var{pcb}, uint64_t @var{N})
Build and return a new exact integer object from the given C language
value.
@end deftypefun


@deftypefun ikptr ika_integer_from_off_t (ikpcb * @var{pcb}, off_t @var{N})
@deftypefunx ikptr ika_integer_from_ssize_t (ikpcb * @var{pcb}, ssize_t @var{N})
@deftypefunx ikptr ika_integer_from_size_t (ikpcb * @var{pcb}, size_t @var{N})
@deftypefunx ikptr ika_integer_from_ptrdiff_t (ikpcb * @var{pcb}, ptrdiff_t @var{N})
Build and return a new exact integer object from the given C language
value.
@end deftypefun


@deftypefun int ik_integer_to_int (ikptr @var{X})
@deftypefunx long ik_integer_to_long (ikptr @var{X})
@deftypefunx ik_llong ik_integer_to_llong (ikptr @var{X})
@deftypefunx ik_uint ik_integer_to_uint (ikptr @var{X})
@deftypefunx ik_ulong ik_integer_to_ulong (ikptr @var{X})
@deftypefunx ik_ullong ik_integer_to_ullong (ikptr @var{X})
Return a C language number from a Scheme exact integer object.  The
object @var{X} must be in the correct range for the requested
conversion.
@end deftypefun


@deftypefun int32_t ik_integer_to_sint32 (ikptr @var{X})
@deftypefunx int64_t ik_integer_to_sint64 (ikptr @var{X})
@deftypefunx uint32_t ik_integer_to_uint32 (ikptr @var{X})
@deftypefunx uint64_t ik_integer_to_uint64 (ikptr @var{X})
Return a C language number from a Scheme exact integer object.  The
object @var{X} must be in the correct range for the requested
conversion.
@end deftypefun


@deftypefun off_t ik_integer_to_off_t (ikptr @var{x})
@deftypefunx size_t ik_integer_to_size_t (ikptr @var{x})
@deftypefunx ssize_t ik_integer_to_ssize_t (ikptr @var{x})
@deftypefunx ptrdiff_t ik_integer_to_ptrdiff_t (ikptr @var{x})
Return a C language number from a Scheme exact integer object.  The
object @var{X} must be in the correct range for the requested
conversion.
@end deftypefun

@c page
@node objects integers
@section Exact integer objects


An exact integer is either a fixnum or a bignum.


@deftypefn {Preprocessor Macro} int IK_IS_INTEGER (ikptr @var{obj})
Evaluate to true if @var{obj} is either a fixnum or a bignum.
@end deftypefn

@c page
@node objects ratnums
@section Ratnum objects


Ratnums are exact rational numbers, having a fixnum or bignum as
numerator and a fixnum or bignum as denominator.  A ratnum is a fixed
length memory block referenced by machine words tagged as vectors.  The
first machine word of a ratnum block is tagged has ratnum in its least
significant bits and it has the most significant bits set to zero.

@example
|------------------------|-------------| reference to ratnum
      heap pointer         vector tag

|------------------------|-------------| ratnum first word
   all set to zero         ratnum tag
@end example

A ratnum memory block is @math{4} words wide; a reference to the
numerator is stored in the second word and a reference to the
denominator is stored in the third word

@example
   1st word     2nd word     3rd word     4th word
|------------|------------|------------|------------|
 tagged word   numerator   denominator     unused
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations


Ratnums are allocated on the Scheme heap as follows:

@example
ikpcb * pcb   = ik_the_pcb();
ikptr   s_rn;

s_rn = ik_safe_alloc(pcb, ratnum_size) | vector_tag;
IK_REF(s_rn, off_ratnum_tag) = ratnum_tag;
@end example

@noindent
after allocation we must always initialise the numerator and denominator
fields to some correct value before running the next garbage collection;
a full allocation and initialisation is as follows:

@example
ikpcb * pcb   = ik_the_pcb();
ikptr   s_num = the_numerator;
ikptr   s_den = the_denominator;
ikptr   s_rn;

pcb->root9 = &s_num;
pcb->root8 = &s_den;
@{
  s_rn = ik_safe_alloc(pcb, ratnum_size) | vector_tag;
@}
pcb->root8 = NULL;
pcb->root9 = NULL;

IK_REF(s_rn, off_ratnum_tag) = ratnum_tag;
IK_REF(s_rn, off_ratnum_num) = s_num;
IK_REF(s_rn, off_ratnum_den) = s_den;
@end example

To identify an object as ratnum we do:

@example
ikptr  X = the_object;

if ((vector_tag == IK_TAGOF(X)) &&
    (ratnum_tag == IK_REF(X, -vector_tag)))
  it_is_a_ratnum();
else
  it_is_not();
@end example

@noindent
to set or retrieve the numerator and denominator we do:

@example
ikptr  s_rn = the_ratnum;
ikptr  s_num;
ikptr  s_den;

s_num = IK_REF(s_rn, off_ratnum_num);
s_den = IK_REF(s_rn, off_ratnum_den);
IK_REF(s_rn, off_ratnum_num) = s_num;
IK_REF(s_rn, off_ratnum_den) = s_den;
@end example


@defvr {Preprocessor Symbol} ratnum_size
The number of bytes to allocate to hold a ratnum memory block.
@end defvr


@defvr {Preprocessor Symbol} ratnum_tag
The tag of @ikptr{} values used as first words in ratnum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_ratnum_tag
Displacement of secondary tag word.  The number of bytes to add to an
untagged pointer to ratnum to get the pointer to the first byte in the
word holding the ratnum tag.
@end defvr


@defvr {Preprocessor Symbol} disp_ratnum_num
@defvrx {Preprocessor Symbol} disp_ratnum_den
Displacements of numerator and denominator.  The number of bytes to add
to an untagged pointer to ratnum to get the pointer to the first byte of
the reference to the numerator or denominator.
@end defvr


@defvr {Preprocessor Symbol} off_ratnum_tag
An integer to add to add to a tagged @ikptr{} pointer to ratnum to get
the pointer to the first byte in the word holding the ratnum tag.
@end defvr


@defvr {Preprocessor Symbol} off_ratnum_num
@defvrx {Preprocessor Symbol} off_ratnum_den
An integer to add to a tagged @ikptr{} pointer to ratnum to get the
pointer to the first byte of the words referencing the numerator or
denominator.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} ikptr IK_NUMERATOR (ikptr @var{X})
@deftypefnx {Preprocessor Macro} ikptr IK_DENOMINATOR (ikptr @var{X})
Evaluate to the location of the numerator or denominator in the ratnum
memory block.  A use of these macros can appear both as operand and as
left--side of an assignment:

@example
ikptr  s_rn  = the_ratnum;
ikptr  s_num;

s_num = IK_NUMERATOR(s_rn);
IK_NUMERATOR(s_rn) = s_num;
@end example
@end deftypefn


@c ------------------------------------------------------------

@subsubheading Operations on ratnums


@deftypefun int ik_is_ratnum (ikptr @var{obj})
Return true if @var{obj} is a ratnum object.
@end deftypefun


@deftypefun ikptr ika_ratnum_alloc_no_init (ikpcb * @var{pcb})
Allocate a new ratnum object using @cfunc{ik_safe_alloc} and return a
tagged reference to it.  The fields are left uninitialised.
@end deftypefun


@deftypefun ikptr ika_ratnum_alloc_and_init (ikpcb * @var{pcb})
Allocate a new ratnum object using @cfunc{ik_safe_alloc} and return a
tagged reference to it.  Both the fields are set to the fixnum zero.
@end deftypefun

@c page
@node objects flonums
@section Flonum objects


Flonums are double--precision floating point numbers (@math{8} bytes
wide) implemented as specified by @ieee{} 754 on the hosting platform.
A flonum is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a flonum block is tagged
has flonum in its least significant bits and it has the most significant
bits set to zero.

@example
|------------------------|-------------| reference to flonum
      heap pointer         vector tag

|------------------------|-------------| flonum first word
   all set to zero         flonum tag
@end example

A flonum memory block is @math{16} bytes wide on both 32-bit and 64-bit
platforms; to allow for the same binary layout on both platforms, on a
32-bit platform the actual number is stored in the last two words:

@example
   1st word     2nd word     3rd word     4th word
|------------|------------|------------|------------|
 tagged word     unused           data words
@end example

@noindent
on a 64-bit platform the actual number is stored in the second word:

@example
          1st word                 2nd word
|-------------------------|-------------------------|
         tagged word               data word
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations

Flonums are allcated on the heap as follows:

@example
ikpcb * pcb  = ik_the_pcb();
ikptr   s_fl;

s_fl = ik_safe_alloc(pcb, flonum_size) | vector_tag;
IK_REF(s_fl, off_flonum_tag) = (ikptr)flonum_tag
@end example

@noindent
to identify an object as flonum we do:

@example
ikptr  X = the_object;

if ((vector_tag == IK_TAGOF(X)) &&
    (flonum_tag == IK_REF(X, -vector_tag)))
  it_is_a_flonum();
else
  it_is_not();
@end example

@noindent
to obtain a pointer to the data area we do:

@example
ikptr     s_fl = the_flonum;
double *  data;

data = (double*)((long)(X) + off_flonum_data);
@end example


@defvr {Preprocessor Symbol} flonum_size
The number of bytes to allocate to hold a flonum memory block.
@end defvr


@defvr {Preprocessor Symbol} flonum_tag
The tag of @ikptr{} values used as first words in bignum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_flonum_tag
Displacement of secondary tag word.  The number of bytes to add to an
untagged pointer to flonum to get the pointer to the first byte in the
word holding the flonum tag.
@end defvr


@defvr {Preprocessor Symbol} disp_flonum_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to flonum to get the pointer to the first byte in the data area
holding the actual @code{double} value.
@end defvr


@defvr {Preprocessor Symbol} off_flonum_tag
An integer to add to add to a tagged @ikptr{} pointer to flonum to get
the pointer to the first byte in the word holding the flonum tag.
@end defvr


@defvr {Preprocessor Symbol} off_flonum_data
An integer to add to a tagged @ikptr{} pointer to flonum to get the
pointer to the first byte in the data area holding the actual
@code{double} value.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} double IK_FLONUM_DATA (ikptr @var{fl})
Set or retrieve the floating point number.  A use of this macro can
appear both as operand or left--side of assignment:

@example
ikptr  s_fl = the_flonum;
double num;

IK_FLONUM_DATA(s_fl) = 1.2;
num = IK_FLONUM_DATA(s_fl);
@end example
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on flonums


@deftypefun int ik_is_flonum (ikptr @var{obj})
Return true if @var{obj} is a flonum object.
@end deftypefun


@deftypefun ikptr iku_flonum_alloc (ikpcb * @var{pcb}, double @var{N})
Allocate and return a new flonum object, using @cfunc{ik_unsafe_alloc},
intialised with @var{N}.
@end deftypefun


@deftypefun ikptr ika_flonum_from_double (ikpcb * @var{pcb}, double @var{N})
Allocate and return a new flonum object, using @cfunc{ik_safe_alloc},
intialised with @var{N}.
@end deftypefun

@c page
@node objects compnums
@section Compnum objects


Compnums are complex numbers having a fixnum, bignum, ratnum or flonum
as real part and a fixnum, bignum, ratnum or flonum as imaginary part,
but @strong{not} both flonums.

A compnum is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a compnum block is tagged
has compnum in its least significant bits and it has the most
significant bits set to zero.

@example
|------------------------|-------------| reference to compnum
      heap pointer         vector tag

|------------------------|-------------| compnum first word
   all set to zero         compnum tag
@end example

A compnum memory block is @math{4} words wide; a reference to the real
part is stored in the second word and a reference to the imaginary part
is stored in the third word

@example
   1st word     2nd word     3rd word     4th word
|------------|------------|------------|------------|
 tagged word   real part    imag part     unused
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations


Compnums are allocated on the Scheme heap as follows:

@example
ikpcb * pcb   = ik_the_pcb();
ikptr   s_cn;

s_cn = ik_safe_alloc(pcb, compnum_size) | vector_tag;
IK_REF(s_cn, off_compnum_tag) = compnum_tag;
@end example

@noindent
after allocation we must always initialise the real and imaginary parts
to some correct value before running the next garbage collection; a full
allocation and initialisation is as follows:

@example
ikpcb * pcb  = ik_the_pcb();
ikptr   s_re = the_real;
ikptr   s_im = the_imag;
ikptr   s_cn;

pcb->root9 = &s_re;
pcb->root8 = &s_im;
@{
  s_rn = ik_safe_alloc(pcb, compnum_size) | vector_tag;
@}
pcb->root8 = NULL;
pcb->root9 = NULL;

IK_REF(s_cn, off_compnum_tag)  = compnum_tag;
IK_REF(s_cn, off_compnum_real) = s_re;
IK_REF(s_cn, off_compnum_imag) = s_im;
@end example

To identify an object as compnum we do:

@example
ikptr  X = the_object;

if ((vector_tag  == IK_TAGOF(X)) &&
    (compnum_tag == IK_REF(X, -vector_tag)))
  it_is_a_compnum();
else
  it_is_not();
@end example

@noindent
to set or retrieve the real and imaginary parts we do:

@example
ikptr  s_cn = the_compnum;
ikptr  s_re;
ikptr  s_im;

s_re = IK_REF(s_cn, off_compnum_real);
s_im = IK_REF(s_cn, off_compnum_imag);
IK_REF(s_cn, off_compnum_real) = s_re;
IK_REF(s_cn, off_compnum_imag) = s_im;
@end example


@defvr {Preprocessor Symbol} compnum_size
The number of bytes to allocate to hold a compnum memory block.
@end defvr


@defvr {Preprocessor Symbol} compnum_tag
The tag of @ikptr{} values used as first words in compnum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_compnum_tag
Displacement of secondary tag word.  The number of bytes to add to an
untagged pointer to compnum to get the pointer to the first byte in the
word holding the compnum tag.
@end defvr


@defvr {Preprocessor Symbol} disp_compnum_real
@defvrx {Preprocessor Symbol} disp_compnum_imag
Displacements of real and imaginary parts.  The number of bytes to add
to an untagged pointer to compnum to get the pointer to the first byte
of the reference to the real or imaginary part.
@end defvr


@defvr {Preprocessor Symbol} off_compnum_tag
An integer to add to add to a tagged @ikptr{} pointer to compnum to get
the pointer to the first byte in the word holding the compnum tag.
@end defvr


@defvr {Preprocessor Symbol} off_compnum_real
@defvrx {Preprocessor Symbol} off_compnum_imag
An integer to add to a tagged @ikptr{} pointer to compnum to get the
pointer to the first byte of the words referencing the real or
imaginary part.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} ikptr IK_COMPNUM_REAL (ikptr @var{X})
@deftypefnx {Preprocessor Macro} ikptr IK_COMPNUM_IMAG (ikptr @var{X})
Evaluate to the location of the real and imaginary parts in the compnum
memory block.  A use of these macros can appear both as operand and as
left--side of an assignment:

@example
ikptr  s_cn = the_compnum;
ikptr  s_re;

s_re = IK_COMPNUM_REAL(s_cn);
IK_COMPNUM_REAL(s_cn) = s_re;
@end example
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on compnums


@deftypefun int ik_is_compnum (ikptr @var{obj})
Return true if @var{obj} is a compnum object.
@end deftypefun


@deftypefun ikptr ika_compnum_alloc_no_init (ikpcb * @var{pcb})
Allocate a new compnum object using @cfunc{ik_safe_alloc} and return a
tagged reference to it.  The fields are left uninitialised.
@end deftypefun


@deftypefun ikptr ika_compnum_alloc_and_init (ikpcb * @var{pcb})
Allocate a new compnum object using @cfunc{ik_safe_alloc} and return a
tagged reference to it.  Both the fields are set to the fixnum zero.
@end deftypefun

@c page
@node objects cflonums
@section Cflonum objects


Cflonums are complex numbers having a flonum as real part and flonum as
imaginary part.  A cflonum is a fixed length memory block referenced by
machine words tagged as vectors.  The first machine word of a cflonum
block is tagged has cflonum in its least significant bits and it has the
most significant bits set to zero.

@example
|------------------------|-------------| reference to cflonum
      heap pointer         vector tag

|------------------------|-------------| cflonum first word
   all set to zero         cflonum tag
@end example

A cflonum memory block is @math{4} words wide; a reference to the real
part is stored in the second word and a reference to the imaginary part
is stored in the third word

@example
   1st word     2nd word     3rd word     4th word
|------------|------------|------------|------------|
 tagged word   real part    imag part     unused
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations


Cflonums are allocated on the Scheme heap as follows:

@example
ikpcb * pcb   = ik_the_pcb();
ikptr   s_cn;

s_cn = ik_safe_alloc(pcb, cflonum_size) | vector_tag;
IK_REF(s_cn, off_cflonum_tag) = cflonum_tag;
@end example

@noindent
after allocation we must always initialise the real and imaginary parts
to some correct value before running the next garbage collection; a full
allocation and initialisation is as follows:

@example
ikpcb * pcb  = ik_the_pcb();
ikptr   s_re = the_real;
ikptr   s_im = the_imag;
ikptr   s_cn;

pcb->root9 = &s_re;
pcb->root8 = &s_im;
@{
  s_rn = ik_safe_alloc(pcb, cflonum_size) | vector_tag;
@}
pcb->root8 = NULL;
pcb->root9 = NULL;

IK_REF(s_cn, off_cflonum_tag)  = cflonum_tag;
IK_REF(s_cn, off_cflonum_real) = s_re;
IK_REF(s_cn, off_cflonum_imag) = s_im;
@end example

To identify an object as cflonum we do:

@example
ikptr  X = the_object;

if ((vector_tag  == IK_TAGOF(X)) &&
    (cflonum_tag == IK_REF(X, -vector_tag)))
  it_is_a_cflonum();
else
  it_is_not();
@end example

@noindent
to set or retrieve the real and imaginary parts we do:

@example
ikptr  s_cn = the_cflonum;
ikptr  s_re;
ikptr  s_im;

s_re = IK_REF(s_cn, off_cflonum_real);
s_im = IK_REF(s_cn, off_cflonum_imag);
IK_REF(s_cn, off_cflonum_real) = s_re;
IK_REF(s_cn, off_cflonum_imag) = s_im;
@end example


@defvr {Preprocessor Symbol} cflonum_size
The number of bytes to allocate to hold a cflonum memory block.
@end defvr


@defvr {Preprocessor Symbol} cflonum_tag
The tag of @ikptr{} values used as first words in cflonum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_cflonum_tag
Displacement of secondary tag word.  The number of bytes to add to an
untagged pointer to cflonum to get the pointer to the first byte in the
word holding the cflonum tag.
@end defvr


@defvr {Preprocessor Symbol} disp_cflonum_real
@defvrx {Preprocessor Symbol} disp_cflonum_imag
Displacements of real and imaginary parts.  The number of bytes to add
to an untagged pointer to cflonum to get the pointer to the first byte
of the reference to the real or imaginary part.
@end defvr


@defvr {Preprocessor Symbol} off_cflonum_tag
An integer to add to add to a tagged @ikptr{} pointer to cflonum to get
the pointer to the first byte in the word holding the cflonum tag.
@end defvr


@defvr {Preprocessor Symbol} off_cflonum_real
@defvrx {Preprocessor Symbol} off_cflonum_imag
An integer to add to a tagged @ikptr{} pointer to cflonum to get the
pointer to the first byte of the words referencing the real or
imaginary part.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} ikptr IK_CFLONUM_REAL (ikptr @var{X})
@deftypefnx {Preprocessor Macro} ikptr IK_CFLONUM_IMAG (ikptr @var{X})
Evaluate to the location of the real and imaginary parts in the cflonum
memory block.  A use of these macros can appear both as operand and as
left--side of an assignment:

@example
ikptr  s_cn = the_cflonum;
ikptr  s_re;

s_re = IK_CFLONUM_REAL(s_cn);
IK_CFLONUM_REAL(s_cn) = s_re;
@end example
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on cflonums


@deftypefun int ik_is_cflonum (ikptr @var{obj})
Return true if @var{obj} is a cflonum object.
@end deftypefun


@deftypefun ikptr iku_cflonum_alloc_and_init (ikpcb * @var{pcb}, double @var{re}, double @var{im})
Allocate a cflonum and its flonum components using
@cfunc{ik_unsafe_alloc} and return a tagged reference to it.  No garbage
collection is run while this function is evaluating.
@end deftypefun

@c page
@node objects ports
@section Port objects


A port value is a block of memory allocated as a vector; a reference to
a port value is a reference to a vector.  The first word of the vector
is the bitwise OR between a port tag and a bitvector of port attributes.

@example
|----------------|----------| port value
  heap pointer    vector tag

|----------------|----------| 1st word of port's memory block
 port attributes   port tag
@end example

At present the port tag is @math{6} bits wide, so we have: on 32-bit
platforms: @math{32 - 6 = 24} bits available for attributes; on 64-bit
platforms: @math{64 - 6 = 58} bits available for attributes.

See the source code in @file{ikarus.io.sls} for a more comprehensive
documentation.

@c page
@node objects pointers
@section Pointer objects


A pointer is a fixed length memory block, two words wide, referenced by
machine words tagged as vectors.  The first machine word of a pointer
block is tagged has pointer in its least significant bits and it has the
most significant bits set to zero.  The second machine word of a pointer
block holds the actual pointer value.

@example
|------------------------|-------------| reference to pointer
      heap pointer         vector tag

|------------------------|-------------| pointer first word
   all set to zero         pointer tag

|--------------------------------------| pointer second word
            pointer value
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations


Pointers are allocated on the Scheme heap as follows:

@example
ikpcb * pcb   = ik_the_pcb();
ikptr   s_ptr;

s_ptr = ik_safe_alloc(pcb, pointer_size) | vector_tag;
IK_REF(s_ptr, off_pointer_tag) = pointer_tag;
@end example

@noindent
to identify an object as pointer we do:

@example
ikptr  X = the_object;

if ((vector_tag  == IK_TAGOF(X)) &&
    (pointer_tag == IK_REF(X, -vector_tag)))
  it_is_a_pointer();
else
  it_is_not();
@end example

@noindent
to set or retrieve the pointer value we do:

@example
ikptr  s_ptr = the_pointer;
void * ptr;

ptr = (void *)IK_REF((X), off_pointer_data);
IK_REF((X), off_pointer_data) = (ikptr)ptr;
@end example


@defvr {Preprocessor Symbol} pointer_size
The number of bytes to allocate to hold a pointer memory block.
@end defvr


@defvr {Preprocessor Symbol} pointer_tag
The tag of @ikptr{} values used as first words in pointer memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_pointer_tag
Displacement of secondary tag word.  The number of bytes to add to an
untagged pointer to pointer object to get the pointer to the first byte
in the word holding the pointer tag.
@end defvr


@defvr {Preprocessor Symbol} disp_pointer_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to pointer object to get the pointer to the first byte of the
data area.
@end defvr


@defvr {Preprocessor Symbol} off_pointer_tag
An integer to add to add to a tagged @ikptr{} pointer to pointer object
to get the pointer to the first byte in the word holding the pointer
tag.
@end defvr


@defvr {Preprocessor Symbol} off_pointer_data
An integer to add to a tagged @ikptr{} pointer to pointer object to get
the pointer to the first byte of the word holding the pointer value.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_POINTER (ikptr @var{X})
Evaluate to true if @var{X} is a pointer object.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_DATA (ikptr @var{X})
Return the value of the pointer as @code{ikptr}.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_POINTER_DATA_VOIDP (ikptr @var{X})
@deftypefnx {Preprocessor Macro} {char *} IK_POINTER_DATA_CHARP (ikptr @var{X})
@deftypefnx {Preprocessor Macro} {uint8_t *} IK_POINTER_DATA_UINT8P (ikptr @var{X})
@deftypefnx {Preprocessor Macro} {long *} IK_POINTER_DATA_LONG (ikptr @var{X})
@deftypefnx {Preprocessor Macro} {ik_llong *} IK_POINTER_DATA_LLONG (ikptr @var{X})
@deftypefnx {Preprocessor Macro} {ik_ulong *} IK_POINTER_DATA_ULONG (ikptr @var{X})
@deftypefnx {Preprocessor Macro} {ik_ullong *} IK_POINTER_DATA_ULLONG (ikptr @var{X})
Return the value of the pointer cast to a specific type.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_SET (ikptr @var{X}, void * @var{ptr})
Reset to @var{ptr} the value of the pointer @var{X}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_SET_NULL (ikptr @var{X})
Reset to @cnull{} the value of the pointer.
@end deftypefn


@deftypefn {Preprocessor Macro} int IK_POINTER_IS_NULL (ikptr @var{X})
Evaluate to true if the pointer value is @cnull{}.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on pointers


@deftypefun ikptr ika_pointer_alloc (ikpcb * @var{pcb}, ik_ulong @var{memory})
Allocate a pointer object using @cfunc{ik_safe_alloc} and return a
tagged reference to it.  The pointer is initialised to @var{memory}.
@end deftypefun


@deftypefun ikptr iku_pointer_alloc (ikpcb* pcb, ik_ulong @var{memory})
Allocate a pointer object using @cfunc{ik_unsafe_alloc} and return a
tagged reference to it.  The pointer is initialised to @var{memory}.
@end deftypefun


@deftypefun int ik_is_pointer (ikptr @var{X})
Return true if @var{X} is a pointer object.
@end deftypefun


@deftypefun ikptr ikrt_is_pointer (ikptr @var{X})
Return @code{IK_TRUE_OBJECT} if @var{X} is a pointer object, else return
@code{IK_FALSE_OBJECT}.
@end deftypefun

@c page
@node objects transcoders
@section Transcoder objects


A transcoder is a machine word tagged to make it of a disjoint type.
The transcoder data (codec, @eol{} style, error handling) is encoded in
the most significant bits of this word:

@example
|---------------------------|------------| transcoder
       payload bits          transcoder-tag
@end example

@noindent
the payload of this word is an 8-bit vector whose format is as follows:

@example
765 432 10
 |   |   |
 |   |    -- error handling mode
 |    ------ end of line style
  ---------- codec
@end example

See the source code in the file @file{ikarus.codecs.sls} for more
details.

@c page
@node objects misc
@section Miscellaneous functions and preprocessor macros


@menu
* objects misc func::           Miscellaneous functions.
* objects misc mblock::         Macros handling @code{memory-block}.
* objects misc voidp::          Macros extracting @code{void *}.
* objects misc charp::          Macros extracting @code{char *}.
@end menu

@c page
@node objects misc func
@subsection Miscellaneous functions


@deftypefun ikptr ikrt_general_copy (ikptr @var{dst}, ikptr @var{dst_start}, ikptr @var{src}, ikptr @var{src_start}, ikptr @var{count})
Copy @var{count} items from @var{src} starting at offset
@var{src_start}, to @var{dst} starting at offset @var{dst_start};
@var{src_start}, @var{dst_start} and @var{count} must be non--negative
fixnums.  Return unspecified values.

Both @var{dst} and @var{src} can be one among: a bytevector, a pointer,
a string.  For bytevectors and pointers: bytes are moved and
@var{src_start}, @var{dst_start} and @var{count} are in byte units.  For
strings: 32-bit values representing Unicode code points are moved and
@var{src_start}, @var{dst_start} and @var{count} are in character units.
@end deftypefun

@c page
@node objects misc mblock
@subsection Macros handling @code{memory-block}


@deftypefn {Preprocessor Macro} ikptr IK_MBLOCK_POINTER (ikptr @var{obj})
Given an instance of @code{memory-block}, return a pointer object being
the value of its @code{pointer} field.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_MBLOCK_SIZE (ikptr @var{obj})
Given an instance of @code{memory-block}, return an exact integer being
the value of its @code{size} field.  Notice that the returned value can
be either a fixnum or a bignum.
@end deftypefn


@deftypefn {Preprocessor Macro} size_t IK_MBLOCK_SIZE_T (ikptr @var{obj})
Given an instance of @code{memory-block}, return the value of the
@code{size} field as @code{size_t}.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_MBLOCK_DATA_VOIDP (ikptr @var{obj})
Given an instance of @code{memory-block}, return a @code{void *} pointer
referencing the first byte of data.
@end deftypefn


@deftypefn {Preprocessor Macro} {char *} IK_MBLOCK_DATA_CHARP (ikptr @var{obj})
Given an instance of @code{memory-block}, return a @code{charp *} pointer
referencing the first byte of data.
@end deftypefn

@c page
@node objects misc voidp
@subsection Macros extracting @code{void *}


@deftypefn {Preprocessor Macro} {void *} IK_POINTER_FROM_POINTER_OR_FALSE (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} {void *} IK_VOIDP_FROM_POINTER_OR_FALSE (ikptr @var{obj})
Given @false{} or a pointer object return a @code{void *} pointer
referencing the data; when @var{obj} is @false{}: the returned value is
@cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_BYTEVECTOR_OR_FALSE (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_VOIDP_FROM_BYTEVECTOR_OR_FALSE (ikptr @var{obj})
Given @false{} or a bytevector object return a @code{void *} pointer
referencing the data; when @var{obj} is @false{}: the returned value is
@cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_MBLOCK_OR_FALSE (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_VOIDP_FROM_MBLOCK_OR_FALSE (ikptr @var{obj})
Given @false{} or a @code{memory-block} object return a @code{void *}
pointer referencing the data; when @var{obj} is @false{}: the returned
value is @cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_BYTEVECTOR_OR_POINTER (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_VOIDP_FROM_BYTEVECTOR_OR_POINTER (ikptr @var{obj})
Given a bytevector object or a pointer object return a @code{void *}
pointer referencing the data.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_FALSE (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_VOIDP_FROM_BYTEVECTOR_OR_POINTER_OR_FALSE (ikptr @var{obj})
Given @false{} or a bytevector object or a pointer object return a
@code{void *} pointer referencing the data; when @var{obj} is @false{}:
the returned value is @cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_POINTER_OR_MBLOCK (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_VOIDP_FROM_POINTER_OR_MBLOCK (ikptr @var{obj})
Given a pointer object or @code{memory-block} object return a @code{void
*} pointer referencing the data.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_POINTER_OR_MBLOCK_OR_FALSE (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_VOIDP_FROM_POINTER_OR_MBLOCK_OR_FALSE (ikptr @var{obj})
Given @false{} or a pointer object or a @code{memory-block} object
return a @code{void *} pointer referencing the data; when @var{obj} is
@false{}: the returned value is @cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_VOIDP_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK (ikptr @var{obj})
Given a bytevector object or a pointer object or a @code{memory-block}
object return a @code{void *} pointer referencing the data.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK_OR_FALSE (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_VOIDP_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK_OR_FALSE (ikptr @var{obj})
Given @false{} or a bytevector object or a pointer object or a
@code{memory-block} object return a @code{void *} pointer referencing
the data; when @var{obj} is @false{}: the returned value is @cnull{}.
@end deftypefn

@c page
@node objects misc charp
@subsection Macros extracting @code{char *}


@deftypefn {Preprocessor Macro} {char *} IK_POINTER_FROM_POINTER_OR_FALSE (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} {char *} IK_CHARP_FROM_POINTER_OR_FALSE (ikptr @var{obj})
Given @false{} or a pointer object return a @code{char *} pointer
referencing the data; when @var{obj} is @false{}: the returned value is
@cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_BYTEVECTOR_OR_FALSE (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_CHARP_FROM_BYTEVECTOR_OR_FALSE (ikptr @var{obj})
Given @false{} or a bytevector object return a @code{char *} pointer
referencing the data; when @var{obj} is @false{}: the returned value is
@cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_MBLOCK_OR_FALSE (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_CHARP_FROM_MBLOCK_OR_FALSE (ikptr @var{obj})
Given @false{} or a @code{memory-block} object return a @code{char *}
pointer referencing the data; when @var{obj} is @false{}: the returned
value is @cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_BYTEVECTOR_OR_POINTER (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_CHARP_FROM_BYTEVECTOR_OR_POINTER (ikptr @var{obj})
Given a bytevector object or a pointer object return a @code{char *}
pointer referencing the data.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_FALSE (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_CHARP_FROM_BYTEVECTOR_OR_POINTER_OR_FALSE (ikptr @var{obj})
Given @false{} or a bytevector object or a pointer object return a
@code{char *} pointer referencing the data; when @var{obj} is @false{}:
the returned value is @cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_POINTER_OR_MBLOCK (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_CHARP_FROM_POINTER_OR_MBLOCK (ikptr @var{obj})
Given a pointer object or @code{memory-block} object return a @code{void
*} pointer referencing the data.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_POINTER_OR_MBLOCK_OR_FALSE (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_CHARP_FROM_POINTER_OR_MBLOCK_OR_FALSE (ikptr @var{obj})
Given @false{} or a pointer object or a @code{memory-block} object
return a @code{char *} pointer referencing the data; when @var{obj} is
@false{}: the returned value is @cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_CHARP_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK (ikptr @var{obj})
Given a bytevector object or a pointer object or a @code{memory-block}
object return a @code{char *} pointer referencing the data.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK_OR_FALSE (ikptr @var{obj})
@deftypefnx {Preprocessor Macro} ikptr IK_CHARP_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK_OR_FALSE (ikptr @var{obj})
Given @false{} or a bytevector object or a pointer object or a
@code{memory-block} object return a @code{char *} pointer referencing
the data; when @var{obj} is @false{}: the returned value is @cnull{}.
@end deftypefn

@c page
@node objects callbacks
@section Notes on calling Scheme code from C


While writing C language code interfacing with Scheme, if we call a C
language function which calls back a Scheme function we have to save and
restore the continuation:

@example
ikpcb * pcb = the_pcb;
ikptr   sk;

sk = ik_enter_c_function(pcb);
@{
  /* place here C code that calls Scheme code */
@}
ik_leave_c_function(pcb, sk);
@end example

@noindent
else, upon returning from the Scheme code, the execution flow will go to
the wrong continuation and undefined behaviour ensues.


@deftypefun ikptr ik_enter_c_function (ikpcb * @var{pcb})
Save the current Scheme continuation and return a reference to it.
@end deftypefun


@deftypefun ikptr ik_leave_c_function (ikpcb * @var{pcb}, ikptr @var{sk})
Restore the previously saved Scheme continuation @var{sk}.
@end deftypefun

@c page
@node debug int
@chapter Internals: debug mode


@menu
* debug int intro::             Introduction to debug mode.
@end menu

@c page
@node debug int intro
@section Introduction to debug mode


Debug mode is driven with the following options:

@table @option
@item -d
@itemx --debug
Turn on debugging mode.  The parameter @func{generate-debug-calls} is
set to true.

@item -nd
@itemx --no-debug
Turn off debugging mode.  The parameter @func{generate-debug-calls} is
set to false.
@end table

The implementation is mostly in @file{ikarus.debugger.sls} and
@file{ikarus.compiler.sls}.


@deffn Parameter generate-debug-calls
Set to true when debug mode is turned on.  Defined in
@file{ikarus.compiler.sls}, configured in @file{ikarus.main.sls}.
@end deffn


@defun guarded-start @var{proc}
Evaluate the procedure @var{proc} under the debugging infrastructure.
It is used in the @library{ikarus main} library (@file{ikarus.main.sls})
to start the execution of a program and all the other execution modes.

@var{proc} is evaluated under the installation of an exception handler
displaying the stack trace and offering the continuation alternatives.
@end defun

@c page
@node compiler
@chapter Wild notes on the compiler internals


@quotation
This chapter is a collection of notes on the internals of the compiler;
there is guarantee of neither their correctness nor their completeness,
because the original compiler code is fully undocumented.
@end quotation

@menu
* compiler intro::              Introduction to the compiler.
* compiler conventions::        Coding conventions in the compiler
                                code.
* compiler cogen::              Stuff in @file{ikarus.compiler.altcogen.ss}.
@end menu

@c page
@node compiler intro
@section Introduction to the compiler


@value{PACKAGE}'s compiler supports only the Intel architecture.  The
compiler is coded in the following files

@table @file
@item ikarus.compiler.altcogen.ss
Generate assembly code in S--expression format.
@end table


How do we generate assembly code?  First we need to generate a single
line of assembly code; this is done by @func{make-asm-instr} which
accepts as first argument a Scheme symbol representing the instruction,
for example: @samp{move}, @samp{idiv}, @samp{int+}.

Then we need to generate blocks of assembly instructions: sequences of
instructions which must be executed in order.  There are two types of
blocks: the ones which at the end generate a value to be stored in a
location (register or memory), the ones which perform some operation but
do not generate a value.  The first kind are blocks which ``impose a
value'', the second kind are the ``side effects''.

@c page
@node compiler conventions
@section Coding conventions in the compiler code


Throughout the compiler code variables with the following names appear:

@table @var
@item op
Scheme symbol representing an @strong{operation} to be directly
translated into assembly.  Examples: @samp{alloc}, @samp{mref},
@samp{mref32}, @samp{bref}, @samp{logand}, @samp{logxor}, @samp{logor},
@samp{int+}, @samp{int-}, @samp{int*}, @samp{int-quotient},
@samp{int-remainder}, @samp{sll}, @samp{sra}.

@item rator
Represents a reference to an @strong{operator}: a function coded in
assembly or C language.

@item rands
Scheme list holding the @strong{operands} to which an operation must be
applied.  These operands are in such a format that can be directly used
in the assembly S--expression like:

@example
(make-set eax (car rands))
@end example

@noindent
which generate an assignment operation to store the first element of
@var{rands} into the @code{eax} processor register.
@end table

@c page
@node compiler cogen
@section Stuff in @file{ikarus.compiler.altcogen.ss}



@c page
@node missing
@appendix Missing Features


@value{PRJNAME} does not fully conform to @rnrs{6} yet.  Although it
implements most of @rnrs{6}'s macros and procedures, some are still
missing.  This appendix summarizes the set of missing features and
procedures.

@itemize
@item
@func{number->string} does not accept the third argument (precision).
Similarly, @func{string->number} and the reader do not recognize the
@code{|p} notation.
@end itemize

@c page
@node building
@appendix Building infrastructure


This appendix contains instructions on how to use and modify the
building infrastructure of @value{PACKAGE}.  The source of the package
is manage by a Git repository, so some bits of the infrastructure depend
on Git.

@menu
* building revision::           Package revision in the banner.
@end menu

@c page
@node building revision
@appendixsec Package revision in the banner


When running @value{EXECUTABLE} in a terminal, it prints a banner
showing the revision number:

@smallexample
$ vicare
Vicare Scheme version 0.1d0+ \
  (revision master/21da24720f161708372756e1324c230bd5ff6ac9, \
   build 2010-05-01)
Copyright (c) 2006-2010 Abdulaziz Ghuloum
@end smallexample

The revision specification shows the branch name and the commit hash;
they are read from the file @file{./scheme/last-revision}, which is
generated by the following chunk of code in the
@file{.git/hooks/post-commit} script:

@smallexample
LAST_REVISION_FILE=./scheme/last-revision
BRANCH_NAME=$(git branch 2>/dev/null | \
                sed -e '/^[^*]/d' -e 's/^* //')
COMMIT_HASH=$(git show | head -1 | cut -d' ' -f2)
echo "$BRANCH_NAME/$COMMIT_HASH" >$LAST_REVISION_FILE
@end smallexample

@c page
@node credits
@appendix Credits for this document


The skeleton of this document is the original ``Ikarus User's Guide'' in
XeLaTeX format, by Abdulaziz Ghulom.  That document is available in the
Ikarus distribution and is covered by the @gnu{} General Public License
version 3 as published by the Free Software Foundation.  It is available
at the following @aurl{}s:

@center @url{http://www.cs.indiana.edu/~aghuloum/ikarus/}
@center @url{https://launchpad.net/ikarus}

@c page
@node unicode
@appendix On Unicode and @utf{} encodings


As required by @rnrs{6}, the Scheme implementations must support Unicode
characters and input/output libraries must implement transcoders for
textual ports supporting encoding and decoding between Scheme characters
and @utf{}-8 and @utf{}-16.

The mandatory starting points to learn about this stuff are the
following (@aurl{}s last verified on Sep 9, 2011):

@center @url{http://www.unicode.org/faq/utf_bom.html}
@center @url{http://en.wikipedia.org/wiki/Universal_Character_Set}
@center @url{http://en.wikipedia.org/wiki/Unicode}
@center @url{http://en.wikipedia.org/wiki/Byte_order_mark}
@center @url{http://en.wikipedia.org/wiki/UTF-8}
@center @url{http://en.wikipedia.org/wiki/UTF-16}
@center @url{http://en.wikipedia.org/wiki/UTF-32}

@noindent
here we give only a brief overview of the main definitions, drawing text
from those pages.

The @dfn{Universal Character Set} (@acronym{UCS}) is a standard set of
characters upon which many character encodings are based; it contains
abstract characters, each identified by an unambiguous name and an
integer number called its ``code point''.

@dfn{Unicode} is a computing industry standard for the consistent
encoding, representation and handling of text expressed in most of the
world's writing systems.

@acronym{UCS} and Unicode have an identical repertoire and numbers: the
same characters with the same numbers exist in both standards.
@acronym{UCS} is a simple character map, Unicode adds rules for
collation, normalization of forms, and the bidirectional algorithm for
scripts.

The Unicode Consortium, the nonprofit organization that coordinates
Unicode's development, has the goal of eventually replacing existing
character encoding schemes with Unicode and its standard ``Unicode
Transformation Format'' alias ``@acronym{UCS} Transformation Format''
(@utf{}) schemes.

By convention a Unicode code point is referred to by writing @code{U+}
followed by its hexadecimal number with at least @math{4} digits
(@code{U+0044} is fine, @code{U+12} is not).

In practice, Unicode code points are exact integers in the range
@math{[0, @pounds{}x10FFFF]}, but outside the range
@math{[@pounds{}xD800, @pounds{}xDFFF]} which has special meaning in
@utf{} schemes.  A code point can be stored in @math{21} bits:

@example
(string-length (number->string #x10FFFF 2)) @result{} 21
@end example

@noindent
@rnrs{6} defines fixnums to have at least @math{24} bits, so a fixnum is
wide enough to hold a code point:

@example
(fixnum? #x10FFFF) @result{} #t
@end example

@noindent
and indeed Scheme characters are a disjoint type of value holding such
fixnums:

@example
(integer->char #x10FFFF) @result{} #\x10FFFF
@end example

@c ------------------------------------------------------------

@subsubheading @utf{}-8 scheme

@utf{}-8 is a multioctet character encoding for Unicode which can
represent every character in the Unicode set, that is it can represent
every code point in the ranges @code{[0, #xD800)} and @code{(#xDFFF,
#x10FFFF]}.

A stream of @utf{}-8 encoded characters is meant to be stored octet by
octet in fixed order (and so without the need to specify the endianness
of words).

The encoding scheme uses sequences of @math{1}, @math{2}, @math{3} or
@math{4} octets to encode a each code point as shown in the following
table; the first octet in a sequence has a unique bit pattern in the
most significant bits and so it allows the determination of the sequence
length; every octet contains a number of payload bits which must be
concatenated (bitwise inclusive OR) to reconstruct the integer
representation of a code point:

@example
| # of octets | 1st octet | 2nd octet | 3rd octet | 4th octet |
|-------------+-----------+-----------+-----------+-----------|
|     1        #b0xxxxxxx
|     2        #b110xxxxx  #b10xxxxxx
|     3        #b1110xxxx  #b10xxxxxx  #b10xxxxxx
|     4        #b11110xxx  #b10xxxxxx  #b10xxxxxx  #b10xxxxxx

| # of octets | # of payload bits |       hex range     |
|-------------+-------------------+---------------------|
|     1                         7    [#x0000,   #x007F]
|     2                5 + 6 = 11    [#x0080,   #x07FF]
|     3            4 + 6 + 6 = 16    [#x0800,   #xFFFF]
|     4        3 + 6 + 6 + 6 = 21  [#x010000, #x10FFFF]
@end example

Note that octets @code{#xFE} and @code{#xFF} cannot appear in a valid
stream of @utf{}-8 encoded characters.  The sequence of @math{3} octets
is the one that could encode (but must not) the forbidden range
@code{[#xD800, #xDFFF]}.

The first @math{128} characters of the Unicode character set correspond
one--to--one with @ascii{} and are encoded using a single octet with the
same binary value as the corresponding @ascii{} character, making valid
@ascii{} text valid @utf{}-8 encoded Unicode text as well.  Such encoded
octets have the Most Significant Bit (@acronym{MSB}) set to zero.

Although the standard does not define it, many programs start a @utf{}-8
stream with a Byte Order Mark (@acronym{BOM}) composed of the @math{3}
octets: @code{#xEF}, @code{#xBB}, @code{#xBF}.

@c ------------------------------------------------------------

@subsubheading @utf{}-16 decoding

Given a 16-bit word in a @utf{}-16 stream, represented in Scheme as a
fixnum in the range @code{[#x0000, #xFFFF]}, we can classify it on the
following axis:

@example
0000        D7FF D800    DBFF DC00      DFFF E000       FFFF
 |-------------||-----------||-------------||------------|
  single word    first in     second in      single word
  character      pair         pair           character
@end example

@noindent
or the following logic:

@example
word in [#x0000, #xD7FF] => single word character
word in [#xD800, #xDBFF] => first in surrogate pair
word in [#xDC00, #xDFFF] => second in surrogate pair
word in [#xE000, #xFFFF] => single word character
@end example

@c ------------------------------------------------------------

@iso{}/@acronym{IEC} 8859-1 also known as Latin-1

Latin-1 uses @math{1} octet per character.  The first @math{256} Unicode
code points are identical to the content of Latin-1, the first
@math{127} Latin-1 code points are identical to @ascii{}.  For an
itroduction see:

@center @url{http://en.wikipedia.org/wiki/ISO/IEC_8859-1}

Latin-1 code points are identical to their octet encoding.

Latin-1 code points in the range @math{[0, 127]} are identical to the
same code points encoded in both @ascii{} and in @utf{}-8.

Latin-1 code points in the range @math{[128, 255]} are
@strong{different} from the same code points encoded in @utf{}-8.

Every octet (that is: every fixnum in the range @math{[0, 255]}) can be
interpreted as a character in Latin-1 encoding.

@c page
@node fasl
@appendix Handling @fasl{} files


@fasl{} files are binary files in which compiled Scheme code and data is
stored; we can easily create a @fasl{} file as follows:

@example
vicare> (define filename "/tmp/marco/p.fasl")
vicare> (define p (open-file-output-port filename))
vicare> (fasl-write '(1 ciao "hello") p)
vicare> (close-port p)
vicare> (define p (open-file-input-port filename))
vicare> (fasl-read p)
(1 ciao "hello")
vicare> (close-port p)
vicare>
@end example

@menu
* fasl format::                 Binary format of a @fasl{} file.
* fasl api::                    @fasl{} files @api{}.
* fasl foreign::                Associating foreign libraries to
                                @fasl{} files.
@end menu

@c page
@node fasl format
@appendixsec Binary format of a @fasl{} file


A @fasl{} object is a header followed by one or more object fields
followed by an end--of--@fasl{} marker.  After the end--of--@fasl{}
marker the file must be at its @eof{}.

The header is the string @code{#@@IK0}, followed by @code{1} if fixnum
width is @math{30} bits, else followed by @code{2}; the end of fasl
marker is @code{@@}.

If the same object is referenced multiple times in the @fasl{} file: it
can be included only once and ``marked'' with a fixnum; such mark is
later dereferenced to insert a reference to the object in the loaded
code.

A data word is an exact signed integer of 32-bit or 64-bit depending on
the word size of the underlying platform.

An object field is a character in @ascii{} encoding, optionally followed
by data representing the serialisation of a Scheme value:

@table @asis
@item "N"
Denotes the empty list.

@item "T"
Denotes @true{}.

@item "F"
Denotes @false{}.

@item "E"
Denotes the end of file object.

@item "U"
Denotes the unspecified value (void).

@item "I" + word
A fixnum stored as a big endian word.

@item "s" + word(N) + octet ...
An @ascii{} string of @math{N} characters followed by @math{N} octets
representing the characters in @ascii{} encoding.  The data word
@math{N} must represent an exact integer in the range of fixnums.

@item "S" + word(N) + int32 ...
A Unicode string of @math{N} characters followed by @math{N} 32-bit
integers in native order representing the characters as Unicode code
points.  The data word @math{N} must represent an exact integer in the
range of fixnums.

@item "M" + symbol-name
A symbol.  @code{symbol-name} is a string field.

@item "G" + pretty-name + unique-name
A gensym.  Both @code{pretty-name} and @code{unique-name} are strings.

@item "c" + octet
A character in the @ascii{} range (@math{<= 255}).

@item "C" + int32
A character store as 32-bit integer representing a Unicode code point.

@item "P" + object1 + object2
A pair.

@item "V" + word(N) + object ...
A vector of length @math{N} followed by @math{N} object fields.  The
data word @math{N} must represent an exact integer in the range of
fixnums.

@item "v" + word(N) + octet ...
A bytevector of length @math{N} followed by @math{N} octets.  The data
word @math{N} must represent an exact integer in the range of fixnums.

@item "R" + rtd-name + rtd-symbol + field-count + name ...
A struct type descriptor.  @code{rtd-name} must be a symbol.
@code{rtd-symbol} must be a symbol.  @code{field-count} must be a word
in the fixnum range.  The @code{name} object fields must be symbols
representing the field name and there must be @code{field-count} of
them.

@item "@{" + field-count + rtd + field ...
A structure instance.  @code{field-count} must be a word in the fixnum
range.  @code{rtd} must be a struct type descriptor.  The @code{field}
object fields must be the fields of the structure instance and there
must be @code{field-count} of them.

@item "r" + denominator + numerator
Ratnum.

@item "f" + 8-byte
@ieee{} double precision flonum.  The bytes are stored: most significant
first, least significant last.

@item "b" + word(N) + octet ...
Denotes a bignum.  @var{N} is a signed integer word whose sign is the
sign of the bignum and whose modulo is the number of octets representing
the bignum.

@item "i" + real-part + imag-part
Complex numbers, both cflonum and compnum.

@item "l" + octet(N) + object ...
A list of @math{N <= 255} elements followed by the elements.

@item "L" + word(N) + object ...
A list of @math{N > 255} elements followed by the elements.

@item "h" + vector + vector
@func{eq?}  hashtable, first vector keys, second vector values.

@item "H" + vector + vector
@func{eqv?} hashtable, first vector keys, second vector values.

@item "W" + name + parent + uid + sealed? + opaque? + count + (bool + field) ...
An @rnrs{6} record type descriptor.  @code{name} must be the return
value of @func{record-type-name}.  @code{parent} must be the return
value of @func{record-type-parent}.  @code{uid} must be the return value
of @func{record-type-uid}.  @code{sealed?} must be the return value of
@func{record-type-sealed?}.  @code{opaque?} must be the return value of
@func{record-type-opaque?}.  @code{count} must be a fixnum representing
the number of fields.  Each @code{bool + field} sequence must be a
boolean representing the mutability of the record field, followed by
symbol representing the name of the record field.

@item "x"
Denotes code.

@item "Q"
Procedure; followed by code.

@item ">" + int32(I)
Mark the next object with index @math{I}.

@item "<" + int32(I)
Dereference the object marked with index @math{I}.

@item "O" + libid
Foreign library identifier.  @code{libid} must be a string representing
the foreign shared library identifier: on Unix--like systems it is
prefixed with @code{lib} and suffixed with @code{.so} to compose a
library file name.
@end table

@c page
@node fasl api
@appendixsec @fasl{} files @api{}


The following bindings are exported by the libraries @library{ikarus}
and @library{vicare}.


@defun fasl-write @var{obj} @var{port}
@defunx fasl-write @var{obj} @var{port} @var{libraries}
Serialise @var{obj} to the binary output port @var{port} prefixing it
with the @fasl{} file header.  If @var{libraries} is present: it must be
a list of strings representing foreign shared libraries to be loaded
whenever the @fasl{} file is loaded, @ref{fasl foreign} for details.
@end defun


@defun fasl-read @var{port}
Read and return a serialised object from the binary input @var{port}.
@end defun


@deffn Parameter fasl-directory
Holds a string representing the top directory under which @fasl{} files
are stored when libraries are compiled.  The default value is determined
as follows:

@enumerate
@item
Check the value of the system environment variable
@env{VICARE_FASL_DIRECTORY}: if set and its value exists as pathname,
the value is selected.  Else move to the next step.

@item
Acquire the value of the system environment variable @env{HOME}: if set
and its value exists as pathname, compose a directory pathname by
appending to the value the string:

@example
/.vicare/precompiled
@end example

Else move to the next step.

@item
Set the parameter to the empty string.  This means that a library with
pathname: @file{/@/usr/@/local/@/scheme/@/vicare/@/posix.sls}
will be compiled to
@file{/@/usr/@/local/@/scheme/@/vicare/@/posix.sls.vicare-32bit-fasl}
@end enumerate

New values for this parameter must be Scheme strings representing
existing pathnames.  The pathnames are normalised to their real
pathname, removing symbolic links and useless @code{..} components.

The default value of this parameter can be overridden by the command
line option @option{--fasl-directory}.
@end deffn


@defun fasl-path @var{filename}
Given a source file name return the associated full @fasl{} file name
using the current value of @func{fasl-directory}.  Return false if
@func{fasl-directory} is unset (which should never happen).  It is an
error if the file @var{filename} does not exist.
@end defun


@deffn Parameter fasl-search-path
@cindex @env{VICARE_FASL_PATH}, environment variable
@cindex Environment variable @env{VICARE_FASL_PATH}
Holds a list of strings representing directory pathnames.  This search
path is used to locate @fasl{} files when loading precompiled libraries.
The default value is determined as follows:

@enumerate
@item
Check the value of the system environment variable
@env{VICARE_FASL_PATH}: if set the value is selected.  Else move to the
next step.

@item
Acquire the value of the system environment variable @env{HOME}: if set
and its value exists as pathname, compose a directory pathname by
appending to the value the string:

@example
/.vicare/precompiled
@end example

@noindent
the result is put into a list and becomes the default value.
@end enumerate

Additional directories can be prepended to the search path with the
command line option @option{--fasl-path}.  If a @fasl{} target directory
is selected with the option @option{--fasl-directory}: the selected
directory is always prepended to the @fasl{} search path.
@end deffn

@c page
@node fasl foreign
@appendixsec Associating foreign libraries to @fasl{} files


@findex @func{foreign-call}


The macro @func{foreign-call}, exported by the libraries
@library{ikarus} and @library{vicare}, is expanded to compiled code
which invokes a C function from the process image; the first argument to
@func{foreign-call} is a string naming the C function.  Whenever the
code is compiled, the C pointer to the named function is retrieved with
a call to:

@example
dlsym(RTLD_DEFAULT, function_name);
@end example

@noindent
so all the public functions from the running @command{vicare} executable
are available and also all the functions from host's shared libraries
loaded with @cfunc{dlopen} using the flags @code{RTLD_NOW |
RTLD_GLOBAL}.

It is possible to associate one or more host's shared libraries to a
@fasl{} file, so that: whenever the @fasl{} file is loaded, the shared
library is loaded too and the functions required by @func{foreign-call}
are available.  This is especially useful to implement bindings to
foreign libraries without relying on the @ffi{} and making full use of
garbage collection facilities and access to Scheme values' memory
representations.

@quotation
@strong{NOTE} The mechanism described below is a temporary
implementation which may change in the future.
@end quotation

Whenever @value{PRJNAME}'s source code reader, in @code{#!vicare} mode,
finds a form like:

@example
#!(load-shared-library "vicarecre2")
@end example

@noindent
it handles it as a special comment which causes no code to be expanded
nor compiled.  Rather a foreign shared library whose identifier is
@code{vicarecre2} is immediately loaded.

If the library file containing such special comment is compiled to a
@fasl{} file, an object field with header @code{O} is written to the
@strong{beginning} of the @fasl{} file: such object will cause the
foreign library to be loaded whenever the @fasl{} file is loaded.

On Unix--like systems: the library identifier is prefixed with
@code{lib} and suffixed with @code{.so} to compose a library file name.

@c page
@node shmem
@appendix Interprocess shared memory


@menu
* shmem mmap::                  Shared memory through @func{mmap}.
@end menu

@c page
@node shmem mmap
@appendixsec Shared memory through @func{mmap}


This appendix shows some sample code describing how to exchange binary
and Scheme data among multiple @value{PRJNAME} processes through shared
memory.  It is assumed that @value{PRJNAME} is installed with the
@posix{} interface enabled.

The first example just exchanges a signed integer:

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants)
  (vicare syntactic-extensions))

(let* ((shmem.len (px.sysconf _SC_PAGESIZE))
       (shmem.ptr (px.mmap #f shmem.len
                     (fxior PROT_READ PROT_WRITE)
                     (fxior MAP_SHARED MAP_ANONYMOUS)
                     0 0)))
  (unwind-protect
      (px.fork

        ;; Parent: write a signed int, wait for the
        ;; child to exit, read the incremented int.
        (lambda (child-pid)
          (pointer-set-c-signed-int! shmem.ptr 0 234)
          (px.waitpid child-pid 0)
          (pointer-ref-c-signed-int shmem.ptr 0))

        ;; Child: wait for a while, then read a signed
        ;; int and write it back incremented by 1000;
        ;; finally exit.
        (lambda ()
          (px.nanosleep 1 0)
          (pointer-set-c-signed-int! shmem.ptr 0
            (+ 1000 (pointer-ref-c-signed-int shmem.ptr 0)))
            (exit)))

    (px.munmap shmem.ptr shmem.len)))
@result{} 1234
@end example

The second example exchanges a bytevector of known length:

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants)
  (vicare syntactic-extensions))

(let* ((shmem.len (px.sysconf _SC_PAGESIZE))
       (shmem.ptr (px.mmap #f shmem.len
                           (fxior PROT_READ PROT_WRITE)
                           (fxior MAP_SHARED MAP_ANONYMOUS)
                           0 0)))
  (unwind-protect
      (px.fork

        ;; Parent: write the bytevector, wait for the
        ;; child to exit, read back the bytevector.
        (lambda (child-pid)
          (memory-copy shmem.ptr 0
            '#vu8(0 1 2 3 4 5 6 7 8 9) 0 10)
          (px.waitpid child-pid 0)
          (let ((bv (make-bytevector 10)))
            (memory-copy bv 0 shmem.ptr 0 10)
            bv))

        ;; Child: wait for a while, read the bytevector,
        ;; increment the bytes, write the bytevector,
        ;; finally exit.
        (lambda ()
          (px.nanosleep 1 0)
          (let ((bv (make-bytevector 10)))
            (memory-copy bv 0 shmem.ptr 0 10)
            (do ((i 0 (+ 1 i)))
                ((= i 10)
                 (memory-copy shmem.ptr 0 bv 0 10)
                 (exit))
              (bytevector-u8-set! bv i
                (+ 100 (bytevector-u8-ref bv i)))))))

    (px.munmap shmem.ptr shmem.len)))
@result{} #vu8(100 101 102 103 104 105 106 107 108 109)
@end example

The third example shares a Scheme datum of length unknown by using
@func{fasl-write} and @func{fasl-read}; the number of bytes is exchanged
in the first location of shared memory, we assume that @math{16} pages
of memory are enough:

@example
#!r6rs
(import (vicare)
  (prefix (vicare posix) px.)
  (vicare platform-constants)
  (vicare syntactic-extensions))

(define data
  '(1 2 #(3 4) ciao "hello" #vu8(99 98 97)))

(let* ((shmem.len (* 16 (px.sysconf _SC_PAGESIZE)))
       (shmem.ptr (px.mmap #f shmem.len
                     (fxior PROT_READ PROT_WRITE)
                     (fxior MAP_SHARED MAP_ANONYMOUS)
                     0 0)))
  (unwind-protect
      (px.fork

         ;; Parent: wait for the child process, read the data
         ;; length, allocate a bytevector, read data.
         (lambda (child-pid)
           (px.waitpid child-pid 0)
           (let* ((bv.len (pointer-ref-c-signed-int shmem.ptr 0))
                  (bv     (make-bytevector bv.len)))
             (memory-copy bv 0 shmem.ptr SIZEOF_INT bv.len)
             (fasl-read (open-bytevector-input-port bv))))

         ;; Child: convert Scheme data into a fasl bytevector,
         ;; write data length, write data, finally exit.
         (lambda ()
           (let-values (((port getter)
                        (open-bytevector-output-port)))
             (fasl-write data port)
             (let* ((bv     (getter))
                    (bv.len (bytevector-length bv)))
               (pointer-set-c-signed-int! shmem.ptr 0 bv.len)
               (memory-copy shmem.ptr SIZEOF_INT bv 0 bv.len)
               (exit))))

    (px.munmap shmem.ptr shmem.len))))
@result{} (1 2 #(3 4) ciao "hello" #vu8(99 98 97))
@end example

@c page
@node binfmt
@appendix Launching programs directly


This appendix describes an optional feature of that activates Scheme
programs execution through the mechanism of the @code{binfmt_misc} Linux
kernel module; it is available only on Unix--like platforms running the
Linux kernel.

By default the installation of the required files is disabled; to enable
it: at configuration time we must pass the @option{--enable-binfmt}
option to the @command{configure} script.

The mechanism allows to run Scheme programs without explicitly invoking
the executable runtime program.  It is a generalisation of the mechanism
that runs shell scripts whose file begins with @code{#!/bin/sh}.

@quotation
This appendix is derived from the original @code{binfmt_misc}
documentation text file by Richard Guenther.
@end quotation

@menu
* binfmt overview::             Overview of the mechanism.
* binfmt loading::              Loading the module.
* binfmt registry::             The registry.
* binfmt using::                Using the mechanism.
* binfmt control::              Controlling the mechanism.
* binfmt hints::                Hints.
* binfmt scheme::               Running Scheme programs.
@end menu

@c page
@node binfmt overview
@appendixsec Overview of the mechanism

@cindex Binary formats, kernel support
@cindex Binary executables, kernel support

This kernel feature allows us to invoke almost every program by simply
typing its name in the shell.  This includes for example compiled Java,
Python or Emacs programs, and of course Scheme programs.

The feature is implemented in the @code{binfmt_misc} kernel module; it
recognises the binary file type by matching some bytes at the beginning
of the file with a magic byte sequence (masking out specified bits) we
have supplied; it can also recognise a filename extension.


@c page
@node binfmt loading
@appendixsec Loading the module


If the module is installed on the system, we will find it in:

@example
/lib/modules/<version>/kernel/fs/binfmt_misc.ko
@end example

@noindent
and to load it we do (as root):

@example
/sbin/modprobe binfmt_misc
@end example

@noindent
for example on a Slackware Linux installation, loading can be done by
uncommenting the relevant line in @file{/etc/rc.d/rc.modules}.

Then we add the following line to @file{/etc/fstab}:

@example
none /proc/sys/fs/binfmt_misc binfmt_misc defaults 0 0
@end example

@noindent
so that the @code{binfmt_misc} directory can be mounted and will be
mounted when booting the system.  We can freely mount and unmount this
virtual file system with (as root):

@example
$ mount  /proc/sys/fs/binfmt_misc
$ umount /proc/sys/fs/binfmt_misc
@end example

@noindent
but this is rarely useful.  There are other means of enabling and
disabling the feature.

@c page
@node binfmt registry
@appendixsec The registry


To actually register a new binary type, we have to set up a string like:

@example
:name:type:offset:magic:mask:interpreter:
@end example

@noindent
and echo it to @file{/proc/sys/fs/binfmt_misc/register}.  We can choose
the @code{:} character upon our needs and we can omit a field by simply
using an empty string; for example if we omit the offset and the mask
fields:

@example
:name:type::magic::interpreter:
@end example

Fields description follows.

@table @code
@item name
It is an identifier string.  A new @file{/proc} file will be created
with this name under @file{/proc/sys/fs/binfmt_misc}, and we can use it
to query and reset the configuration status.

@item type
It is the type of file recognition.  If set to @code{M} activates first
bytes recognition (also known as ``magic'' recognition); if set to
@code{E} activates file name extension recognition.

@item offset
It is the zero--based offset of the magic/mask in the file, counted in
bytes.  It is used only with magic recognition.  It defaults to zero.

@item magic
It is the byte sequence @code{binfmt_misc} will look for file
recognition.

The magic string may contain hex--encoded characters like @code{\x0a} or
@code{\xA4}.  When echoing the record from a shell environment, we will
have to quote the backslash: @code{\\x0a}.

If we chose filename extension matching, this is the extension to be
recognised (without the @code{.}, the @code{\x0a} specials are not
allowed).  Extension matching is case sensitive.

@item mask
It is a bitmask.  We can mask out some bits from matching by supplying a
string with the same length of @code{magic}.  The mask is ANDed with the
byte sequence from the file.  It defaults to @code{0xff}.

@item interpreter
It is the program that should be invoked with the binary as first
argument.  @strong{We have to specify the full path.}
@end table

There are some restrictions:

@itemize
@item
The whole @file{register} string may not exceed 255 characters.

@item
The magic must reside in the first @math{128} bytes of the file, i.e.
@code{offset+size(magic)} has to be less than @math{128}.

@item
The interpreter string may not exceed @math{127} characters.
@end itemize

@c page
@node binfmt using
@appendixsec Using the mechanism


We may want to add the binary formats in one of the shell scripts that
are executed at system boot time.  For example, on a Slackware Linux
system we can use @file{/etc/rc.d/rc.local}.

To do it we can add to the shell script a chunk of code like the
following, which activates the mechanism for Scheme programs compiled
with @value{PRJNAME}:

@example
if test -f /proc/sys/fs/binfmt_misc/register
then
  if test -f /proc/sys/fs/binfmt_misc/VICARE
  then echo -1 >/proc/sys/fs/binfmt_misc/VICARE
  fi
  echo \
   ':VICARE:M:0:;;;!vicare::/usr/local/bin/vicare:' \
   >/proc/sys/fs/binfmt_misc/register
fi
@end example

@noindent
which does the following:

@enumerate
@item
Verify if the @code{binfmt_misc} kernel module has been loaded by
testing the existence of the @file{register} file; if the module is not
there, nothing happens.

@item
Remove the configuration from the registry if it is already there; this
is done by testing the existence of the special file:

@example
/proc/sys/fs/binfmt_misc/VICARE
@end example

@noindent
echoing @code{-1} in it removes the @value{PRJNAME} record.

@item
echo the @value{PRJNAME} record into the registry with the following fields:

@table @code
@item VICARE
It is the name of the special file representing the record in the
registry.

@item M
Activates first bytes recognition.

@item 0
The offset of the magic string into the file.

@item ;;;!vicare
The magic string itself.

@item /usr/local/bin/vicare
The full pathname to the @value{PRJNAME} runtime system executable.
@end table
@end enumerate

We see that the @code{mask} field is set to the empty string, that is:
no mask is applied and @code{#!vicare} is matched literally.

We have to care about the order of added entries: entries added later
are matched first.

@c page
@node binfmt control
@appendixsec Controlling the mechanism


@subsubheading Overall control

We can enable/disable the mechanism by echoing @code{0} (to disable) or
@code{1} (to enable) to the special file:

@example
/proc/sys/fs/binfmt_misc/status
@end example

@noindent
that is, at the shell prompt and with superuser privileges, to enable:

@example
# echo 1 >/proc/sys/fs/binfmt_misc/status
@end example

@noindent
and to disable:

@example
# echo 0 >/proc/sys/fs/binfmt_misc/status
@end example

Applying the command @command{cat} to the @file{status} special file
tells us the current status of @code{binfmt_misc}:

@example
$ cat /proc/sys/fs/binfmt_misc/status
enabled
@end example

We can remove all the entries from the registry echoing @code{-1} to
@file{status}; at the shell prompt and with superuser privileges:

@example
# echo -1 >/proc/sys/fs/binfmt_misc/status
@end example

@noindent
removing the entries and disabling the mechanism are two distinct
operations.


@subsubheading Specific format control

We can enable/disable recognition of a single binary format by echoing
@code{0} or @code{1} to the format specific special file under
@file{/proc/sys/fs/binfmt_misc}.  For example for @code{VICARE}, at the
shell prompt and with superuser privileges, to enable:

@example
$ echo 1 >/proc/sys/fs/binfmt_misc/VICARE
@end example

@noindent
and to disable:

@example
$ echo 0 >/proc/sys/fs/binfmt_misc/VICARE
@end example

@noindent
disabled formats are @strong{not} removed from the internal table.

Applying the command @command{cat} to the format's special file tells us
the current status of that format and its configuration; for example for
@code{VICARE}, at the shell prompt:

@example
$ cat /proc/sys/fs/binfmt_misc/VICARE
@end example

We can remove a specific format entry from the registry echoing
@code{-1} to its special file; for @code{VICARE} at the shell prompt
and with superuser privileges:

@example
$ echo -1 >/proc/sys/fs/binfmt_misc/VICARE
@end example

@noindent
removing the entry and disabling the mechanism for a format are two
distinct operations.

@c page
@node binfmt hints
@appendixsec Hints


If we want to pass command line arguments to the runtime executable, we
must write a wrapper script for it.  There is no way to embed the
arguments in the registry record.

The runtime must @strong{not} look in the @env{PATH} environment
variable for the filename; the kernel passes it the full filename to
use.  Using the @env{PATH} can cause unexpected behaviour and be a
security hazard.

@c page
@node binfmt scheme
@appendixsec Running Scheme programs


The @code{binfmt_misc} mechanism can be used to run both source and
compiled programs.  @value{PRJNAME} adheres to the following rules,
which we can change by customising the files in the distribution:

@enumerate
@item
@value{PRJNAME} source programs are recognised if the file starts with
the string @code{;;;!vicare}.  Notice that we @strong{cannot} use the
sequence @code{#!vicare} because when @code{binfmt_misc} reads the
prefix @code{#!} it activates the traditional shebang processing.

@item
The @code{binfmt_misc} configuration is stored in a Bourne shell script
(@file{/bin/sh} interpreter) named @file{rc.vicare-scheme} installed in
the @code{$(sysconfdir)/rc.d} directory.  If the default configuration
is not changed, this ends up being:

@example
/usr/local/etc/rc.d/rc.vicare-scheme
@end example

The script can be executed at system boot time and again later any
number of times: at each run it resets and reinitialises the
configuration for Scheme programs.

@item
The @command{vicare} executable must be in @code{$(bindir)}, else we
must customise the @file{rc.vicare-scheme} script.
@end enumerate

@c page
@node cre2
@appendix Binding to the library @cretwo{}


@value{PRJNAME} implements an optional built in binding to the @cretwo{}
library: a C wrapper for the @retwo{} regular expressions library from
Google.  The Scheme @api{} is exported by the library @library{vicare
cre2}; it is suggested to prefix the bindings at import time with
@code{cre2}, as in the following example:

@example
(import (vicare)
  (prefix (vicare cre2) cre2.))
@end example

@noindent
the bindings do @strong{not} have the @code{cre2} prefix.

@menu
* cre2 version::                Version functions.
* cre2 regexps::                Precompiled regular expressions
                                construction.
* cre2 options::                Matching configuration.
* cre2 match::                  Matching regular expressions.
@end menu

@c page
@node cre2 version
@appendixsec Version functions


The following bindings are exported by the @library{vicare cre2}
library.


@defun enabled?
Return true if the binding to @cretwo{} was enabled in this
@value{PRJNAME} process.
@end defun


@defun version-interface-current
@defunx version-interface-revision
@defunx version-interface-age
Return a fixnum representing a component of interface version number for
@cretwo{}.  For an explanation of interface numbers as managed by @gnu{}
Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.
@end defun

@c page
@node cre2 regexps
@appendixsec Precompiled regular expressions construction


The following bindings are exported by the @library{vicare cre2}
library.


@defun make-regexp @var{pattern}
@defunx make-regexp @var{pattern} @var{opt}
Build and return a precompiled regular expression object.  The returned
object must be finalised with @func{delete-regexp}; this operation is
automatically performed when the object is garbage collected.

@var{pattern} must be a string or @utf{}-8 bytevector holding the
regular expression pattern.  When used, @var{opt} must be a
configuration options object returned by @func{make-options}.
@end defun


@defun delete-regexp @var{rex}
Finalise a precompiled regular expression object releasing all the
associated resources.  This function can be safely applied multiple
times to the same @var{rex} object: the first time the object is
finalised, the subsequent times nothing happens.
@end defun


@defun regexp? @var{obj}
Return @true{} if @var{obj} is a precompiled regular expression object,
return @false{} otherwise.
@end defun

@c page
@node cre2 options
@appendixsec Matching configuration


The following bindings are exported by the @library{vicare cre2}
library.


@defun make-options
Build and return a configuration option object initialised with default
values.  The returned object must be finalised with
@func{delete-options}; this operation is automatically performed when
the object is garbage collected.
@end defun


@defun delete-options @var{opt}
Finalise a configuration option object releasing all the associated
resources.  This function can be safely applied multiple times to the
same @var{opt} object: the first time the object is finalised, the
subsequent times nothing happens.
@end defun


@defun options? @var{obj}
Return @true{} if @var{obj} is a configuration options object, return
@false{} otherwise.
@end defun


All the following functions are setters and getters for matching
options; see the original documentation for details.


@defun set-posix-syntax! @var{opt} @var{bool}
@defunx set-longest-match! @var{opt} @var{bool}
@defunx set-log-errors! @var{opt} @var{bool}
@defunx set-literal! @var{opt} @var{bool}
@defunx set-never-nl! @var{opt} @var{bool}
@defunx set-case-sensitive! @var{opt} @var{bool}
@defunx set-perl-classes! @var{opt} @var{bool}
@defunx set-word-boundary! @var{opt} @var{bool}
@defunx set-one-line! @var{opt} @var{bool}
Configuration option setters.  @var{opt} must be configuration options
object.  @var{bool} must be true or false.
@end defun


@defun posix-syntax @var{opt}
@defunx longest-match @var{opt}
@defunx log-errors @var{opt}
@defunx literal @var{opt}
@defunx never-nl @var{opt}
@defunx case-sensitive @var{opt}
@defunx perl-classes @var{opt}
@defunx word-boundary @var{opt}
@defunx one-line @var{opt}
Configuration option setters; return @true{} if the option is set,
@false{} otherwise.  @var{opt} must be configuration options object.
@end defun


@defun set-max-mem! @var{opt} @var{dimension}
@defunx max-mem @var{opt}
Setter and getter for the maximum memory configuration option.
@var{opt} must be a configuration options object.  @var{dimension} must
be a positive exact integer fitting in a platform's @code{int} C
language data type.
@end defun

@c page
@node cre2 match
@appendixsec Matching regular expressions


Basic regular expressions matching goes as follows:

@example
#!r6rs
(import (vicare)
  (prefix (vicare cre2) cre2.))

(let ((rex (cre2.make-regexp "ciao|hello")))
  (cre2.match rex "ciao" #f #f 'unanchored))
@result{} #((0 . 4))

(let ((rex (cre2.make-regexp "ciao|hello")))
  (cre2.match rex "hello" #f #f 'unanchored))
@result{} #((0 . 5))

(let ((rex (cre2.make-regexp "ci(ao)|hello")))
  (cre2.match rex "ciao" #f #f 'unanchored))
@result{} #((0 . 4)
     (2 . 4))

(let ((rex (cre2.make-regexp "c(i(ao))|hello")))
  (cre2.match rex "ciao" #f #f 'unanchored))
@result{} #((0 . 4)
     (1 . 4)
     (2 . 4))
@end example

The following bindings are exported by the @library{vicare cre2}
library.


@defun match @var{rex} @var{text} @var{start} @var{end} @var{anchor}
Match a substring of @var{text} against the regular expression object
@var{rex}.  Return false if there is no match, else return a vector
representing the matching portions.

@var{text} must be a @utf{}-8 bytevector or a Scheme string which is
internally transformed to a @utf{}-8 bytevector.  All the indices in
@var{text} used by this function are relative to the
@strong{bytevector}, not the Scheme string.  Only when the string
contains only characters in the @ascii{} range the indices for the
@utf{}-8 bytevector equal the indices for the string.

The zero--based indices @var{start} (inclusive) and @var{end}
(exclusive) select the range of @var{text} to be examined.  As special
case: if @var{start} is @false{}, the start index is set to zero; if
@var{end} is @false{}, the end index is set to the length of the
bytevector.

@var{anchor} selects the anchor point for the matching operation, it
must be one of the symbols: @code{unanchored}, @code{start},
@code{both}.

Data about the matching groups is returned in a vector of pairs, which
will have a number of slots equal to the number of parenthetical
subexpressions in @var{rex} plus one.  Each pair selects a range of
bytes in @var{text}: the car is a non--negative fixnum representing the
inclusive start index, the cdr is a non--negative fixnum representing
the exclusive end index.

The first element of the match vector (index @math{0}) references the
full portion of the substring of @var{text} matching the pattern; the
second element of the match vector (index @math{1}) references the
portion of text matching the first parenthetical subexpression, the
third element of the match vector (index @math{2}) references the
portion of text matching the second parenthetical subexpression; and so
on.
@end defun

@c page
@include gpl-3.0.texi

@c page
@node references
@appendix Bibliography and references


@noindent
``Revised^6 Report on the Algorithmic Language Scheme.''  Michael
Sperber and R. Kent Dybvig and Matthew Flatt and Anton Van Straaten
(Editors).  2007.

@noindent
``Revised^6 Report on the Algorithmic Language Scheme---Standard
Libraries.''  Michael Sperber and R. Kent Dybvig and Matthew Flatt and
Anton Van Straaten (Editors). 2007.

@noindent
``Scheme Request for Implementation 41: Streams.''  Philip L. Bewig.
2007.  @url{http://@/srfi.schemers.org/@/srfi-41/@/srfi-41.html}

@noindent
``Guardians in a generation--based garbage collector''.  R. Kent Dybvig
and Carl Bruggeman and David Eby.  PLDI '93, pages 207--216, June 1993.
Introduces guardians and describes the implementation of guardians and
weak pairs in Chez Scheme.

@noindent
``Don't stop the BiBOP: Flexible and efficient storage management
for dynamically--typed languages.''  R. Kent Dybvig and David Eby and
Carl Bruggeman.  Technical Report 400, Indiana University, March 1994.
Describes Chez Scheme's storage management system.

@noindent
``Generation Friendly Eq Hash Tables.''  Abdulaziz Ghuloum and
R. Kent Dybvig. In ``Proceedings of the 2007 Workshop on Scheme and
Functional Programming'', pages 207--216.  Universite Laval Technical
Report DIUL-RT-0701, 2007.

@noindent
``Extending the Scope of Syntactic Abstraction.''  Oscar Waddell.
PhD thesis, Indiana University Computer Science Department, August 1999.
@url{http://www.cs.indiana.edu/@/~owaddell/@/papers/@/thesis.ps.gz}

@noindent
``Extending the Scope of Syntactic Abstraction.''  Oscar Waddell and
R. Kent Dybvig.  In ``Conference Record of POPL'99: The 26th ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages'', pages
203--213, January 1999.
@url{http://www.cs.indiana.edu/@/~dyb/@/papers/@/popl99.ps.gz}

@noindent
``Chez Scheme Version 7 User's Guide.''  R. Kent Dybvig.  Cadence
Research Systems, 2005.  User's guide and reference manual for Chez
Scheme Version 7.  @url{http://@/www.scheme.com/@/csug7/}

@noindent
``Implicit phasing for R6RS libraries.''  Abdulaziz Ghuloum and
R. Kent Dybvig.  In ``ICFP '07: Proceedings of the 2007 ACM SIGPLAN
international conference on Functional programming'', pages 303--314.
New York, NY, USA, 2007.  ACM.

@noindent
Michael D.  Adams and R.  Kent Dybvig.  ``Efficient nondestructive
equality checking for trees and graphs.''  In ICFP '08: Proceeding of
the 13th ACM SIGPLAN international conference on Functional programming,
pages 179-188.  ACM, New York, NY, USA, 2008.  ISBN
978-1-59593-919-7. doi: 10.1145/1411204.1411230.

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function

@printindex fn

@node variable index
@appendix An entry for each variable

@printindex vr

@node type index
@appendix An entry for each type

@printindex tp

@bye

@c end of file
