@node mehve
@chapter The language @library{nausicaa mehve}


@cindex @library{nausicaa mehve}, library
@cindex Library @library{nausicaa mehve}


The library @library{nausicaa mehve} implements a language in the same
way the library @library{nausicaa} does; in facts, it reexports all the
bindings of @library{nausicaa}, redefining some, and it is a possible
replacement for it.  Mehve is meant to make heavy use of multimethos.

@menu
* mehve intro::                 Using the language.
* mehve multimethods::          Generic functions and their
                                customisation.
* mehve io::                    Input/output generic functions.
* mehve numerics::              Numerics generic functions.
@end menu

@c page
@node mehve intro
@section Using the language


The library @library{nausicaa mehve} exports the language for users;
other component libraries in the hierarchy @library{nausicaa mehve
language ---} export multimethod bindings that can be used to extend the
generic functions.

Before making use of the facilities of Mehve, we @strong{must} call the
function @func{initialise-mehve}.


@defun initialise-mehve
Initialise the multimethods and the component libraries.  Calling this
function is needed because, according to @rnrs{6}, a compliant Scheme
implementation might instantiate a library only when an exported binding
is actually accessed; this behaviour does not play well with
multimethods.
@end defun

@c page
@node mehve multimethods
@section Generic functions and their customisation


There are two variants of ``generic functions'' in @library{nausicaa
mehve}, both of them are in truth syntaxes.  The first kind is the one
that generalises a function with fixed arity (fixed number of
arguments); assuming the following prelude:

@example
(import (except (nausicaa)
                sin)
  (prefix (only (nausicaa)
                sin)
          nau.))
@end example

@noindent
the function implementing the trigonometric sine is generalised with:

@example
(define-generic sin (x))

(add-method sin (<flonum>) $flsin x)
(add-method sin (<number>) nau.sin)
@end example

@noindent
and allows us to specialise it for non--@class{number} arguments, for
example:

@example
(define-method (sin (x <spine>))
  (x map sin))

(define-method (sin (x <vector>))
  (x map sin))
@end example

The other kind is a generalisation for variadic functions (which take an
undefined number of arguments); assuming the following prelude:

@example
(import (except (nausicaa)
                +)
  (prefix (only (nausicaa)
                +)
          nau.))
@end example

@noindent
the addition function @func{+} is redefined with this infrastructure:

@example
(define-syntax (+ stx)
  (syntax-case stx ()
    (?id
     (identifier? #'?id)
     #'addition)
    ((_)
     #'(addition-0))
    ((_ ?a)
     #'(addition-1 ?a))
    ((_ ?a ?b)
     #'(addition-2 ?a ?b))
    ((_ ?a ?b ?c)
     #'(addition-2 (addition-2 ?a ?b) ?c))
    ((_ . ?operands)
     #'(addition . ?operands))))

(define addition
  (case-lambda
   (()
    (addition-0))
   ((A)
    (addition-1 A))
   ((A B)
    (addition-2 A B))
   ((A B C)
    (addition-2 (addition-2 A B) C))
   ((A B C . args)
    (fold-left addition-2 (addition-2 (addition-2 A B) C) args))
   ))

(define-generic addition-0 ())
(define-generic addition-1 (a))
(define-generic addition-2 (a b))

(define-method (addition-0)
  0)

(define-method (addition-1 (a <number>))
  a)

(add-method addition-2 (<fixnum> <fixnum>) fx+)
(add-method addition-2 (<flonum> <flonum>) fl+)
(add-method addition-2 (<number> <number>) nau.+)
@end example

@noindent
and specialised methods can be added to the generic functions
@func{addition-0}, @func{addition-1} and @func{addition-2}.  In this
case @library{nausicaa mehve} exports the binding for @func{+}, but the
bindings for @func{addition-0}, @func{addition-1} and @func{addition-2}
are exported by the auxiliary library @library{nausicaa mehve language
numerics-arithmetics}.

@c ------------------------------------------------------------

@subsubheading Generalising already defined ordinary functions


If a binding @var{F} exported by @library{nausicaa mehve}, but not
generalised by it, can only be generalised by writing a custom library
which imports @library{nausicaa mehve} and reexports all its bindings
and also redefines the binding @var{F}; the faster way to do this is to
just copy and customise the source code of the library @library{nausicaa
mehve}.

This is annoying, but it is the only way of doing it because:

@itemize
@item
@rnrs{6} forbids to mutate an imported binding.

@item
It makes no sense to have all the bindings to functions in
@library{nausicaa} redefined as generics.
@end itemize

The only alternative is to import @library{nausicaa mehve} excluding the
predefined binding, and import another library with the generalised
version.

In any case requests to generalise a binding to function can be
submitted to the @value{PACKAGE} maintainer.

@c page
@node mehve io
@section Input/output generic functions


@cindex @library{nausicaa mehve language input-output}, library
@cindex Library @library{nausicaa mehve language input-output}


The component library @library{nausicaa mehve language input-output}
defines the generic functions for port input and output through ports;
we need to import it only if we desire to add specialised methods to the
input/output functions.

@menu
* mehve io simple::             Simple input/output generic functions.
@end menu

@c page
@node mehve io simple
@subsection Simple input/output generic functions


The bindings @func{display} and @func{write} exported by
@library{nausicaa mehve language input-output}, and reexported by
@library{nausicaa mehve}, generalise the corresponding functions from
@rsixlibrary{io simple}.


@deffn {Generic Function} display-1 @var{obj}
@deffnx {Generic Function} display-2 @var{obj} @var{port}
Invoked when @func{display} is applied to one or two arguments.
@end deffn


@deffn {Generic Function} write-1 @var{obj}
@deffnx {Generic Function} write-2 @var{obj} @var{port}
Invoked when @func{write} is applied to one or two arguments.
@end deffn


@deffn Method display-1 (@var{obj} @aclass{top})
@deffnx Method display-2 (@var{obj} @aclass{top}) (@var{port} @aclass{port})
Apply to the arguments the function @func{display} exported by
@rsixlibrary{io simple}, @vicareref{stdlib io simple, @func{display}}.
@end deffn


@deffn Method write-1 (@var{obj} @aclass{top})
@deffnx Method write-2 (@var{obj} @aclass{top}) (@var{port} @aclass{port})
Apply to the arguments the function @func{write} exported by
@rsixlibrary{io simple}, @vicareref{stdlib io simple, @func{write}}.
@end deffn

@c page
@node mehve numerics
@section Numerics generic functions


@menu
* mehve numerics predicates::   Numeric predicates generic functions.
* mehve numerics arithmetics::  Arithmetics generic functions.
* mehve numerics parts::        Parts generic functions.
@ignore
* mehve numerics trans::        Transcendental generic functions.
@end ignore
* mehve numerics infix::        Infix to prefix syntax.
@end menu

@c page
@node mehve numerics predicates
@subsection Numeric predicates generic functions


@cindex @library{nausicaa mehve language numerics-predicates}, library
@cindex Library @library{nausicaa mehve language numerics-predicates}


The component library @library{nausicaa mehve language
numerics-predicates} defines the generic functions behind the numeric
predicates; we need to import it only if we desire to add specialised
methods to the numeric predicates.  The numeric predicate functions are
the following:

@example
= < > <= >=
zero? positive? negative? non-negative? non-positive?
odd? even? finite? infinite? nan?
@end example

As example we look at how to specialise the comparison predicates
@func{=}, @func{<}, @func{>}, @func{<=} and @func{>=} to operate on
lists of items:

@example
#!r6rs
(import (nausicaa mehve)
  (prefix (nausicaa mehve language numerics-predicates)
          mehve.))

(define-method (mehve.equal-predicate-1 (o <spine>))
  (o for-all =))

(define-method
    (mehve.equal-predicate-2 (a <spine>) (b <spine>))
  (a for-all = b))

(define-method
    (mehve.less-than-predicate-1 (o <spine>))
  (o for-all <))

(define-method
    (mehve.less-than-predicate-2 (a <spine>) (b <spine>))
  (a for-all < b))

(define-method
    (mehve.greater-than-predicate-1 (o <spine>))
  (o for-all >))

(define-method
    (mehve.greater-than-predicate-2 (a <spine>) (b <spine>))
  (a for-all > b))

(define-method
    (mehve.less-than-or-equal-to-predicate-1 (o <spine>))
  (o for-all <=))

(define-method
    (mehve.less-than-or-equal-to-predicate-2
        (a <spine>) (b <spine>))
  (a for-all <= b))

(define-method
    (mehve.greater-than-or-equal-to-predicate-1 (o <spine>))
  (o for-all >=))

(define-method
    (mehve.greater-than-or-equal-to-predicate-2
        (a <spine>) (b <spine>))
  (a for-all >= b))

(= '(1 2 3) '(1 2 3))  @result{} (#t #t #t)
(= '(1 2 3) '(1 4 3))  @result{} (#t #f #t)
(< '(1 2 3) '(1 2 3))  @result{} (#f #f #f)
(< '(1 2 3) '(4 5 6))  @result{} (#t #t #t)
(< '(1 5 3) '(4 2 6))  @result{} (#t #f #t)
@end example

@c ------------------------------------------------------------

@subsubheading Comparison functions


@deffn {Generic Function} equal-predicate-0
@deffnx {Generic Function} equal-predicate-1 @var{A}
@deffnx {Generic Function} equal-predicate-2 @var{A} @var{B}
Used when @func{=} is invoked with zero, one or two arguments.
@end deffn


@deffn Method equal-predicate-0
@deffnx Method equal-predicate-1 (@var{A} @aclass{top})
@deffnx Method equal-predicate-2 (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method equal-predicate-2 (@var{A} @aclass{flonum}) (@var{B} @aclass{flonum})
@deffnx Method equal-predicate-2 (@var{A} @aclass{complex}) (@var{B} @aclass{complex})
When zero or one arguments are used: return @true{}.  Otherwise use the
functions @func{fx=?}, @func{fl=?} or @func{=} as appropriate for the
arguments.
@end deffn


@deffn {Generic Function} less-than-predicate-0
@deffnx {Generic Function} less-than-predicate-1 @var{A}
@deffnx {Generic Function} less-than-predicate-2 @var{A} @var{B}
Used when @func{<} is invoked with zero, one or two arguments.
@end deffn


@deffn Method less-than-predicate-0
@deffnx Method less-than-predicate-1 (@var{A} @aclass{top})
@deffnx Method less-than-predicate-2 (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method less-than-predicate-2 (@var{A} @aclass{flonum}) (@var{B} @aclass{flonum})
When zero or one arguments are used: return @false{}.  Otherwise use the
functions @func{fx<?}, @func{fl<?} or @func{<} as appropriate for the
arguments.
@end deffn


@deffn {Generic Function} greater-than-predicate-0
@deffnx {Generic Function} greater-than-predicate-1 @var{A}
@deffnx {Generic Function} greater-than-predicate-2 @var{A} @var{B}
Used when @func{>} is invoked with zero, one or two arguments.
@end deffn


@deffn Method greater-than-predicate-0
@deffnx Method greater-than-predicate-1 (@var{A} @aclass{top})
@deffnx Method greater-than-predicate-2 (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method greater-than-predicate-2 (@var{A} @aclass{flonum}) (@var{B} @aclass{flonum})
@deffnx Method greater-than-predicate-2 (@var{A} @aclass{complex}) (@var{B} @aclass{complex})
When zero or one arguments are used: return @false{}.  Otherwise use the
functions @func{fx<?}, @func{fl<?} or @func{<} as appropriate for the
arguments.
@end deffn


@deffn {Generic Function} less-than-or-equal-to-predicate-0
@deffnx {Generic Function} less-than-or-equal-to-predicate-1 @var{A}
@deffnx {Generic Function} less-than-or-equal-to-predicate-2 @var{A} @var{B}
Used when @func{<=} is invoked with zero, one or two arguments.
@end deffn


@deffn Method less-than-or-equal-to-predicate-0
@deffnx Method less-than-or-equal-to-predicate-1 (@var{A} @aclass{top})
@deffnx Method less-than-or-equal-to-predicate-2 (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method less-than-or-equal-to-predicate-2 (@var{A} @aclass{flonum}) (@var{B} @aclass{flonum})
@deffnx Method less-than-or-equal-to-predicate-2 (@var{A} @aclass{complex}) (@var{B} @aclass{complex})
When zero or one arguments are used: return @true{}.  Otherwise use the
functions @func{fx<=?}, @func{fl<=?} or @func{<=} as appropriate for the
arguments.
@end deffn


@deffn {Generic Function} greater-than-or-equal-to-predicate-0
@deffnx {Generic Function} greater-than-or-equal-to-predicate-1 @var{A}
@deffnx {Generic Function} greater-than-or-equal-to-predicate-2 @var{A} @var{B}
Used when @func{>=} is invoked with zero, one or two arguments.
@end deffn


@deffn Method greater-than-or-equal-to-predicate-0
@deffnx Method greater-than-or-equal-to-predicate-1 (@var{A} @aclass{top})
@deffnx Method greater-than-or-equal-to-predicate-2 (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method greater-than-or-equal-to-predicate-2 (@var{A} @aclass{flonum}) (@var{B} @aclass{flonum})
@deffnx Method greater-than-or-equal-to-predicate-2 (@var{A} @aclass{complex}) (@var{B} @aclass{complex})
When zero or one arguments are used: return @true{}.  Otherwise use the
functions @func{fx>=?}, @func{fl>=?} or @func{>=} as appropriate for the
arguments.
@end deffn

@c ------------------------------------------------------------

@subsubsection Sign related generic functions


@deffn {Generic Function} zero? @var{A}
@deffnx Method zero? (@var{A} @aclass{fixnum})
@deffnx Method zero? (@var{A} @aclass{flonum})
@deffnx Method zero? (@var{A} @aclass{real})
Return @true{} if the argument is zero.  Apply to the argument the
function @func{fxzero?}, @func{flzero?} or @func{zero?} as appropriate
for the argument.
@end deffn


@deffn {Generic Function} positive? @var{A}
@deffnx Method positive? (@var{A} @aclass{fixnum})
@deffnx Method positive? (@var{A} @aclass{flonum})
@deffnx Method positive? (@var{A} @aclass{real})
Return @true{} if the argument is positive.  Apply to the argument the
function @func{fxpositive?}, @func{flpositive?} or @func{positive?} as
appropriate for the argument.
@end deffn


@deffn {Generic Function} negative? @var{A}
@deffnx Method negative? (@var{A} @aclass{fixnum})
@deffnx Method negative? (@var{A} @aclass{flonum})
@deffnx Method negative? (@var{A} @aclass{real})
Return @true{} if the argument is negative.  Apply to the argument the
function @func{fxnegative?}, @func{flnegative?} or @func{negative?} as
appropriate for the argument.
@end deffn


@deffn {Generic Function} non-positive? @var{A}
@deffnx Method non-positive? (@var{A} @aclass{fixnum})
@deffnx Method non-positive? (@var{A} @aclass{flonum})
@deffnx Method non-positive? (@var{A} @aclass{real})
Return @true{} if the argument is non--positive.  Apply to the argument
the function @func{fxnonpositive?}, @func{flnonpositive?} or
@func{non-positive?} as appropriate for the argument.
@end deffn


@deffn {Generic Function} non-negative? @var{A}
@deffnx Method non-negative? (@var{A} @aclass{fixnum})
@deffnx Method non-negative? (@var{A} @aclass{flonum})
@deffnx Method non-negative? (@var{A} @aclass{real})
Return @true{} if the argument is non--negative.  Apply to the argument
the function @func{fxnonnegative?}, @func{flnonnegative?} or
@func{non-negative?} as appropriate for the argument.
@end deffn

@c ------------------------------------------------------------

@subsubheading Even and odd predicates generic functions


The generic functions @func{odd?} and @func{even?} exported by
@library{nausicaa mehve numeric-predicates}, and reexported by
@library{nausicaa mehve}, generalise the corresponding functions
exported by @rsixlibrary{base}.


@deffn {Generic Function} odd? @var{A}
@deffnx Method odd? (@var{A} @aclass{fixnum})
@deffnx Method odd? (@var{A} @aclass{flonum})
@deffnx Method odd? (@var{A} @aclass{real})
Return @true{} if the argument is odd.  Apply to the argument the
function @func{fxodd?}, @func{flodd?} or @func{odd?} as appropriate for
the argument.
@end deffn


@deffn {Generic Function} even? @var{A}
@deffnx Method even? (@var{A} @aclass{fixnum})
@deffnx Method even? (@var{A} @aclass{flonum})
@deffnx Method even? (@var{A} @aclass{real})
Return @true{} if the argument is even.  Apply to the argument the
function @func{fxeven?}, @func{fleven?} or @func{even?} as appropriate
for the argument.
@end deffn

@c ------------------------------------------------------------

@subsubheading Infinity and not--a--number predicates generic functions


We have to remember that, according to @rnrs{6}, the only values
satisfying the predicate @func{real?} and not the predicate
@func{rational?} are @samp{+inf.0}, @samp{-inf.0} and @samp{+nan.0}.


@deffn {Generic Function} finite? @var{A}
@deffnx Method finite? (@var{A} @aclass{fixnum})
@deffnx Method finite? (@var{A} @aclass{flonum})
@deffnx Method finite? (@var{A} @aclass{complex})
Return @true{} if the argument is finite and not not--a--number.
@end deffn


@deffn {Generic Function} infinite? @var{A}
@deffnx Method infinite? (@var{A} @aclass{fixnum})
@deffnx Method infinite? (@var{A} @aclass{flonum})
@deffnx Method infinite? (@var{A} @aclass{complex})
Return @true{} if the argument is infinite.
@end deffn


@deffn {Generic Function} nan? @var{A}
@deffnx Method nan? (@var{A} @aclass{fixnum})
@deffnx Method nan? (@var{A} @aclass{flonum})
@deffnx Method nan? (@var{A} @aclass{complex})
Return @true{} if the argument is not--a--number.
@end deffn

@c page
@node mehve numerics arithmetics
@subsection Arithmetics generic functions


@cindex @library{nausicaa mehve language numerics-arithmetics}, library
@cindex Library @library{nausicaa mehve language numerics-arithmetics}


The auxiliary library @library{nausicaa mehve language
numerics-arithmetics} defines the generic functions behind the
arithmetic operations; we need to import it only if we desire to add
specialised methods to arithmetic functions.  The arithmetic functions
are the following:

@example
+ - * / abs div div0 mod mod0 div-and-mod div0-and-mod0
@end example

As example we look at how to specialise the arithmetic functions
@func{+}, @func{-}, @func{*} and @func{/} to operate on lists of items:

@example
#!r6rs
(import (nausicaa mehve)
  (prefix (nausicaa mehve language numerics-arithmetics)
          mehve.))

(define-method (mehve.addition-1 (o <spine>))
  o)
(define-method (mehve.addition-2 (a <spine>) (b <spine>))
  (map + a b))

(define-method (mehve.subtraction-1 (o <spine>))
  (map - o))
(define-method (mehve.subtraction-2 (a <spine>) (b <spine>))
  (map - a b))

(define-method (mehve.multiplication-1 (o <spine>))
  o)
(define-method (mehve.multiplication-2 (a <spine>) (b <spine>))
  (map * a b))

(define-method (mehve.division-1 (o <spine>))
  (map / o))
(define-method (mehve.division-2 (a <spine>) (b <spine>))
  (map / a b))

(+ '(1 2 3))                       @result{} (1 2 3)
(+ '(1 2 3) '(4 5 6))              @result{} (5 7 9)
(+ '(1 2 3) '(4 5 6) '(-1 -1 -1))  @result{} (4 6 8)

(- '(1 2 3))                       @result{} (-1 -2 -3)
(- '(1 2 3) '(4 5 6))              @result{} (-3 -3 -3)
(- '(1 2 3) '(4 5 6) '(-1 -1 -1))  @result{} (-2 -2 -2)

(* '(1 2 3))                       @result{} (1 2 3)
(* '(1 2 3) '(4 5 6))              @result{} (4 10 18)
(* '(1 2 3) '(4 5 6) '(-1 -1 -1))  @result{} (-4 -10 -18)

(/ '(1 2 3))                       @result{} (1 1/2 1/3)
(/ '(1 2 3) '(4 5 6))              @result{} (1/4 2/5 1/2)
(/ '(1 2 3) '(4 5 6) '(-1 -1 -1))  @result{} (-1/4 -2/5 -1/2)
@end example

@noindent
notice how the methods recursively call the generic functions in their
body, this way the lists can hold any of the value types for which there
are methods.


@deffn {Generic Function} addition-0
@deffnx {Generic Function} addition-1 @var{A}
@deffnx {Generic Function} addition-2 @var{A} @var{B}
@deffnx Method addition-0
@deffnx Method addition-2 (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method addition-2 (@var{A} @aclass{flonum}) (@var{B} @aclass{flonum})
@deffnx Method addition-2 (@var{A} @aclass{number}) (@var{B} @aclass{number})
Used when @func{+} is called with zero, one or two arguments.  When no
arguments are given: return @math{0}.  When one argument is given:
return @var{A} itself.  Otherwise use the function @func{fx+},
@func{fl+} or @func{+} as appropriate for the arguments.
@end deffn


@deffn {Generic Function} subtraction-0
@deffnx {Generic Function} subtraction-1 @var{A}
@deffnx {Generic Function} subtraction-2 @var{A} @var{B}
@deffnx Method subtraction-0
@deffnx Method subtraction-2 (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method subtraction-2 (@var{A} @aclass{flonum}) (@var{B} @aclass{flonum})
@deffnx Method subtraction-2 (@var{A} @aclass{number}) (@var{B} @aclass{number})
Used when @func{-} is called with zero, one or two arguments.  When no
arguments are given: return @math{0}.  Otherwise use the function
@func{fx-}, @func{fl-} or @func{-} as appropriate for the arguments.
@end deffn


@deffn {Generic Function} multiplication-0
@deffnx {Generic Function} multiplication-1 @var{A}
@deffnx {Generic Function} multiplication-2 @var{A} @var{B}
@deffnx Method multiplication-0
@deffnx Method multiplication-2 (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method multiplication-2 (@var{A} @aclass{flonum}) (@var{B} @aclass{flonum})
@deffnx Method multiplication-2 (@var{A} @aclass{number}) (@var{B} @aclass{number})
Used when @func{*} is called with zero, one or two arguments.  When no
arguments are given: return @math{0}.  When one argument is given:
return @var{A} itself.  Otherwise use the function @func{fx*},
@func{fl*} or @func{*} as appropriate for the arguments.
@end deffn


@deffn {Generic Function} division-0
@deffnx {Generic Function} division-1 @var{A}
@deffnx {Generic Function} division-2 @var{A} @var{B}
@deffnx Method division-0
@deffnx Method division-2 (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method division-2 (@var{A} @aclass{flonum}) (@var{B} @aclass{flonum})
@deffnx Method division-2 (@var{A} @aclass{number}) (@var{B} @aclass{number})
Used when @func{/} is called with zero, one or two arguments.  When no
arguments are given: return @code{+nan.0}.  Otherwise use the function
@func{fxdiv}, @func{fl/} or @func{/} as appropriate for the arguments.
@end deffn


@deffn {Generic Function} div @var{a} @var{b}
@deffnx Method div (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method div (@var{A} @aclass{integer}) (@var{B} @aclass{integer})
@deffnx Method div (@var{A} @aclass{real}) (@var{B} @aclass{real})
Perform integer division.  Use the function @func{fxdiv}, @func{fldiv}
or @func{div} as appropriate for the arguments.
@end deffn


@deffn {Generic Function} div0 @var{a} @var{b}
@deffnx Method div0 (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method div0 (@var{A} @aclass{integer}) (@var{B} @aclass{integer})
@deffnx Method div0 (@var{A} @aclass{real}) (@var{B} @aclass{real})
Perform integer division.  Use the function @func{fxdiv0}, @func{fldiv0}
or @func{div0} as appropriate for the arguments.
@end deffn


@deffn {Generic Function} mod @var{a} @var{b}
@deffnx Method mod (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method mod (@var{A} @aclass{integer}) (@var{B} @aclass{integer})
@deffnx Method mod (@var{A} @aclass{real}) (@var{B} @aclass{real})
Compute the modulus of integer division.  Use the function @func{fxmod},
@func{flmod} or @func{mod} as appropriate for the arguments.
@end deffn


@deffn {Generic Function} mod0 @var{a} @var{b}
@deffnx Method mod0 (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method mod0 (@var{A} @aclass{integer}) (@var{B} @aclass{integer})
@deffnx Method mod0 (@var{A} @aclass{real}) (@var{B} @aclass{real})
Compute the modulus of integer division.  Use the function
@func{fxmod0}, @func{flmod0} or @func{mod0} as appropriate for the
arguments.
@end deffn


@deffn {Generic Function} div-and-mod @var{a} @var{b}
@deffnx Method div-and-mod (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method div-and-mod (@var{A} @aclass{integer}) (@var{B} @aclass{integer})
@deffnx Method div-and-mod (@var{A} @aclass{real}) (@var{B} @aclass{real})
Compute the integer division and its modulus.  Use the function
@func{fxdiv-and-mod}, @func{fldiv-and-mod} or @func{div-and-mod} as
appropriate for the arguments.
@end deffn


@deffn {Generic Function} div0-and-mod0 @var{a} @var{b}
@deffnx Method div0-and-mod0 (@var{A} @aclass{fixnum}) (@var{B} @aclass{fixnum})
@deffnx Method div0-and-mod0 (@var{A} @aclass{integer}) (@var{B} @aclass{integer})
@deffnx Method div0-and-mod0 (@var{A} @aclass{real}) (@var{B} @aclass{real})
Compute the integer division and its modulus.  Use the function
@func{fxdiv0-and-mod0}, @func{fldiv0-and-mod0} or @func{div0-and-mod0}
as appropriate for the arguments.
@end deffn


@deffn {Generic Function} abs @var{A}
@deffnx Method abs (@var{A} @aclass{fixnum})
@deffnx Method abs (@var{A} @aclass{flonum})
@deffnx Method abs (@var{A} @aclass{real})
Return the absolute value of its argument.  Use the function
@func{fxabs}, @func{flabs} or @func{abs} as appropriate for the
arguments.
@end deffn

@c page
@node mehve numerics parts
@subsection Parts generic functions


@cindex @library{nausicaa mehve language numerics-parts}, library
@cindex Library @library{nausicaa mehve language numerics-parts}


The auxiliary library @library{nausicaa mehve language numerics-parts}
defines the generic functions behind the parts operations; we need to
import it only if we desire to add specialised methods to parts
functions.  The parts functions are the following:

@example
numerator denominator rationalize sign
floor ceiling truncate round
real-part imag-part magnitude angle
make-rectangular make-polar complex-conjugate
@end example

As example we look at how to specialise the functions
@func{make-rectangular} and @func{make-polar} to operate on lists of
items:

@example
#!r6rs
(import (nausicaa mehve)
  (prefix (nausicaa mehve language numerics-parts)
          mehve.))

(define-method
    (mehve.make-rectangular (R <vector>) (I <vector>))
  (R map make-rectangular I))

(define-method
    (mehve.make-rectangular (R <spine>) (I <spine>))
  (R map make-rectangular I))

(define-method
    (mehve.make-polar (M <vector>) (A <vector>))
  (M map make-polar A))

(define-method
    (mehve.make-polar (M <spine>) (A <spine>))
  (M map make-polar A))

(make-rectangular '(1 2 3) '(4 5 6))
@result{} (1+4i 2+5i 3+6i)

(make-polar '(1 2 3) '(4 5 6))
@result{} (-0.6536436208636119-0.7568024953079282i
    0.5673243709264525-1.917848549326277i
    2.880510859951098-0.8382464945967776i)
@end example

@c ------------------------------------------------------------

@subsubheading Rational numbers generic functions


@deffn {Generic Function} numerator @var{A}
@deffnx Method numerator (@var{A} @aclass{fixnum})
@deffnx Method numerator (@var{A} @aclass{bignum})
@deffnx Method numerator (@var{A} @aclass{ratnum})
@deffnx Method numerator (@var{A} @aclass{flonum})
@deffnx Method numerator (@var{A} @aclass{integer})
@deffnx Method numerator (@var{A} @aclass{real})
Return the numerator of the argument.  Use the function
@func{numerator}; when the argument is an integer: return the argument
itself.
@end deffn


@deffn {Generic Function} denominator @var{A}
@deffnx Method denominator (@var{A} @aclass{fixnum})
@deffnx Method denominator (@var{A} @aclass{bignum})
@deffnx Method denominator (@var{A} @aclass{ratnum})
@deffnx Method denominator (@var{A} @aclass{flonum})
@deffnx Method denominator (@var{A} @aclass{integer})
@deffnx Method denominator (@var{A} @aclass{real})
Return the denominator of the argument.  Use the function
@func{denominator}; when the argument is an integer: return the fixum
@code{1}.
@end deffn


@deffn {Generic Function} rationalize @var{A} @var{B}
@deffnx Method rationalize (@var{A} @aclass{real}) (@var{B} @aclass{real})
Return a rational number representation of @var{A} which differs from it
by less than @var{B}.  Use the function @func{rationalize}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Rounding generic functions


@deffn {Generic Function} floor @var{A}
@deffnx Method floor (@var{A} @aclass{fixnum})
@deffnx Method floor (@var{A} @aclass{bignum})
@deffnx Method floor (@var{A} @aclass{flonum})
@deffnx Method floor (@var{A} @aclass{real})
Return an object representing the largest integer not larger than
@var{A}.  Use the function @func{flfloor} or @func{floor} as appropriate
for the argument; when the argument is an exact integer: return the
argument itself.
@end deffn


@deffn {Generic Function} ceiling @var{A}
@deffnx Method ceiling (@var{A} @aclass{fixnum})
@deffnx Method ceiling (@var{A} @aclass{bignum})
@deffnx Method ceiling (@var{A} @aclass{flonum})
@deffnx Method ceiling (@var{A} @aclass{real})
Return an object representing the smaller integer not larger than
@var{A}.  Use the function @func{flceiling} or @func{ceiling} as
appropriate for the argument; when the argument is an exact integer:
return the argument itself.
@end deffn


@deffn {Generic Function} truncate @var{A}
@deffnx Method truncate (@var{A} @aclass{fixnum})
@deffnx Method truncate (@var{A} @aclass{bignum})
@deffnx Method truncate (@var{A} @aclass{flonum})
@deffnx Method truncate (@var{A} @aclass{real})
Return the integer object closest to @var{A} whose absolute value is not
larger than the absolute value of @var{A}.  Use the function
@func{fltruncate} or @func{truncate} as appropriate for the argument;
when the argument is an exact integer: return the argument itself.
@end deffn


@deffn {Generic Function} round @var{A}
@deffnx Method round (@var{A} @aclass{fixnum})
@deffnx Method round (@var{A} @aclass{bignum})
@deffnx Method round (@var{A} @aclass{flonum})
@deffnx Method round (@var{A} @aclass{real})
Return the closest integer object to @var{A}.  Use the function
@func{flround} or @func{round} as appropriate for the argument; when the
argument is an exact integer: return the argument itself.
@end deffn


@deffn {Generic Function} sign @var{A}
@deffnx Method sign (@var{A} @aclass{fixnum})
@deffnx Method sign (@var{A} @aclass{bignum})
@deffnx Method sign (@var{A} @aclass{flonum})
@deffnx Method sign (@var{A} @aclass{ratnum})
@deffnx Method sign (@var{A} @aclass{real})
Return an object representing the sign of the argument.  Use the
function @func{sign} or its type--specific variants as appropriate for
the argument.
@end deffn

@c ------------------------------------------------------------

@subsubheading Complex numbers generic functions


@deffn {Generic Funcion} real-part @var{A}
@deffnx {Generic Funcion} real-part (@var{A} @aclass{fixnum})
@deffnx {Generic Funcion} real-part (@var{A} @aclass{bignum})
@deffnx {Generic Funcion} real-part (@var{A} @aclass{flonum})
@deffnx {Generic Funcion} real-part (@var{A} @aclass{ratnum})
@deffnx {Generic Funcion} real-part (@var{A} @aclass{cflonum})
@deffnx {Generic Funcion} real-part (@var{A} @aclass{compnum})
@deffnx {Generic Funcion} real-part (@var{A} @aclass{complex})
Return the real part of @var{A}.  Use the function @func{real-part} or
its type--specific variants as appropriate for the argument; when the
argument is a real number: return the argument itself.
@end deffn


@deffn {Generic Funcion} imag-part @var{A}
@deffnx {Generic Funcion} imag-part (@var{A} @aclass{fixnum})
@deffnx {Generic Funcion} imag-part (@var{A} @aclass{bignum})
@deffnx {Generic Funcion} imag-part (@var{A} @aclass{flonum})
@deffnx {Generic Funcion} imag-part (@var{A} @aclass{ratnum})
@deffnx {Generic Funcion} imag-part (@var{A} @aclass{cflonum})
@deffnx {Generic Funcion} imag-part (@var{A} @aclass{compnum})
@deffnx {Generic Funcion} imag-part (@var{A} @aclass{complex})
Return the imaginary part of @var{A}.  Use the function @func{imag-part}
or its type--specific variants as appropriate for the argument; when the
argument is a real number: return the fixnum @code{0}.
@end deffn


@deffn {Generic Funcion} magnitude @var{A}
@deffnx {Generic Funcion} magnitude (@var{A} @aclass{fixnum})
@deffnx {Generic Funcion} magnitude (@var{A} @aclass{bignum})
@deffnx {Generic Funcion} magnitude (@var{A} @aclass{flonum})
@deffnx {Generic Funcion} magnitude (@var{A} @aclass{ratnum})
@deffnx {Generic Funcion} magnitude (@var{A} @aclass{cflonum})
@deffnx {Generic Funcion} magnitude (@var{A} @aclass{compnum})
@deffnx {Generic Funcion} magnitude (@var{A} @aclass{complex})
Return the magnitude of @var{A}.  Use the function @func{magnitude} or
its type--specific variants as appropriate for the argument.
@end deffn


@deffn {Generic Funcion} angle @var{A}
@deffnx {Generic Funcion} angle (@var{A} @aclass{fixnum})
@deffnx {Generic Funcion} angle (@var{A} @aclass{bignum})
@deffnx {Generic Funcion} angle (@var{A} @aclass{flonum})
@deffnx {Generic Funcion} angle (@var{A} @aclass{ratnum})
@deffnx {Generic Funcion} angle (@var{A} @aclass{cflonum})
@deffnx {Generic Funcion} angle (@var{A} @aclass{compnum})
@deffnx {Generic Funcion} angle (@var{A} @aclass{complex})
Return the angle of @var{A}.  Use the function @func{angle} or its
type--specific variants as appropriate for the argument.
@end deffn


@deffn {Generic Funcion} make-rectangular @var{R} @var{I}
@deffnx Method make-rectangular (@var{R} @aclass{real}) (@var{I} @aclass{real})
Return a complex having real part @var{R} and imaginary part @var{I}.
Use the function @func{make-rectangular}.
@end deffn


@deffn {Generic Funcion} make-polar @var{M} @var{A}
@deffnx Method make-polar (@var{M} @aclass{real}) (@var{A} @aclass{real})
Return a complex having magnitude @var{M} and angle @var{A}.  Use the
function @func{make-polar}.
@end deffn


@deffn {Generic Funcion} complex-conjugate @var{A}
@deffnx {Generic Funcion} complex-conjugate (@var{A} @aclass{fixnum})
@deffnx {Generic Funcion} complex-conjugate (@var{A} @aclass{bignum})
@deffnx {Generic Funcion} complex-conjugate (@var{A} @aclass{flonum})
@deffnx {Generic Funcion} complex-conjugate (@var{A} @aclass{ratnum})
@deffnx {Generic Funcion} complex-conjugate (@var{A} @aclass{cflonum})
@deffnx {Generic Funcion} complex-conjugate (@var{A} @aclass{compnum})
@deffnx {Generic Funcion} complex-conjugate (@var{A} @aclass{complex})
Return the complex-conjugate of @var{A}.  Use the function
@func{complex-conjugate} or its type--specific variants as appropriate
for the argument; when the argument is real: return the argument itself.
@end deffn

@c page
@ignore
@node mehve trans
@section Transcendental generic functions


@cindex @library{nausicaa mehve transcendental}, library
@cindex Library @library{nausicaa mehve transcendental}


The auxiliary library @library{nausicaa mehve transcendental} defines
the generic functions behind the transcendental operations; we need to
import it only if we desire to add specialised methods to transcendental
functions.

@menu
* mehve trans intro::           Introduction to transcendental
                                generic functions.
* mehve trans log::             Exponentiation and logarithm
                                generic functions.
* mehve trans trig::            Trigonometric generic functions.
@end menu

@node mehve trans intro
@subsection Introduction to transcendental generic functions


The transcendental functions are the following:

@example
expt sqrt exp log sin cos tan asin acos atan
@end example

@noindent
we intend ``transcendental'' in the sense that their implementation is
exported by the library @library{nausicaa mehve transcendental}.

As example we look at how to specialise the transcendental functions
@func{sin}, @func{cos} and @func{tan} to operate on lists of items:

@example
#!r6rs
(import (nausicaa mehve)
  (prefix (nausicaa mehve transcendental) mehve.))

(define-method (mehve.sin (o <list>))
  (o.map sin))

(define-method (mehve.cos (o <list>))
  (o.map cos))

(define-method (mehve.tan (o <list>))
  (o.map tan))

(sin '(1.1 2.2 3.3))
@result{} (0.8912073600614354 0.8084964038195901 -0.1577456941432482)

(cos '(1.1 2.2 3.3))
@result{} (0.4535961214255773 -0.5885011172553458 -0.9874797699088649)

(tan '(1.1 2.2 3.3))
@result{} (1.9647596572486523 -1.3738230567687946 0.15974574766003222)
@end example

@noindent
notice how the methods recursively call the generic functions in their
body, this way the lists can hold any of the value types for which there
are methods.

@node mehve trans log
@subsection Exponentiation and logarithm generic functions


The generic functions @func{expt}, @func{sqrt} and @func{exp} exported
by @library{nausicaa mehve transcendental}, and reexported by
@library{nausicaa mehve}, generalise the corresponding functions from
@rsixlibrary{base}.

The binding @func{log} is exported by @library{nausicaa mehve} and
generalises the corresponding function from @rsixlibrary{base}; its
implementation functions @func{log-1} and @func{log-2} are exported by
@library{nausicaa mehve transcendental}.


@deffn {Generic Function} expt @var{A} @var{B}
Compute @var{A} raised to the power of @var{B}.
@end deffn


@deffn {Generic Function} sqrt @var{A}
Compute square root of @var{A}.
@end deffn


@deffn {Generic Function} exp @var{A}
Compute the base @math{e} exponential.
@end deffn


@deffn {Generic Function} log-1 @var{A}
Compute the base @math{e} logarithm.
@end deffn


@deffn {Generic Function} log-2 @var{A} @var{B}
Compute the base @var{B} logarithm of @var{A}.
@end deffn


The following are the specialised methods.


@deffn Method expt (@var{A} @aclass{flonum}) (@var{B} @aclass{flonum})
Compute @var{A} raised to the power of @var{B} using @func{flexpt} from
@rsixlibrary{arithmetic flonums}, @vicareref{stdlib arithmetic flonums,
@func{flexp}}.
@end deffn


@deffn Method expt (@var{A} @aclass{complex}) (@var{B} @aclass{complex})
Compute @var{A} raised to the power of @var{B} using @func{expt} from
@rsixlibrary{base}, @vicareref{baselib math ops exponentiation,
@func{expt}}.
@end deffn


@deffn Method sqrt (@var{A} @aclass{flonum})
Compute the square root of @var{A} using @func{flsqrt} from
@rsixlibrary{arithmetic flonums}, @vicareref{stdlib arithmetic flonums,
@func{flexp}}.
@end deffn


@deffn Method sqrt (@var{A} @aclass{complex})
Compute the square root of @var{A} using @func{sqrt} from
@rsixlibrary{base}, @vicareref{baselib math ops exponentiation,
@func{sqrt}}.
@end deffn


@deffn Method exp (@var{A} @aclass{flonum})
Compute the base @math{e} exponential using @func{flexp} from
@rsixlibrary{arithmetic flonums}, @vicareref{stdlib arithmetic flonums,
@func{flexp}}.
@end deffn


@deffn Method exp (@var{A} @aclass{complex})
Compute the base @math{e} exponential using @func{exp} from
@rsixlibrary{base}, @vicareref{baselib math ops trascend, @func{exp}}.
@end deffn


@deffn Method log-1 (@var{A} @aclass{flonum})
Compute the base @math{e} logarithm using @func{fllog} from
@rsixlibrary{arithmetic flonums}, @vicareref{stdlib arithmetic flonums,
@func{fllog}}.
@end deffn


@deffn Method log-1 (@var{A} @aclass{complex})
Compute the base @math{e} logarithm using @func{log} from
@rsixlibrary{base}, @vicareref{baselib math ops trascend, @func{log}}.
@end deffn


@deffn Method log-2 (@var{A} @aclass{flonum}) (@var{B} @aclass{flonum})
Compute the base @var{B} logarithm of @var{A} using @func{fllog} from
@rsixlibrary{arithmetic flonums}, @vicareref{stdlib arithmetic flonums,
@func{flexp}}.
@end deffn


@deffn Method log-2 (@var{A} @aclass{complex}) (@var{B} @aclass{complex})
Compute the base @var{B} logarithm of @var{A} using @func{log} from
@rsixlibrary{base}, @vicareref{baselib math ops trascend, @func{log}}.
@end deffn

@node mehve trans trig
@subsection Trigonometric generic functions


The generic functions @func{sin}, @func{cos}, @func{tan}, @func{asin}
and @func{acos} exported by @library{nausicaa mehve transcendental}, and
reexported by @library{nausicaa mehve}, generalise the corresponding
functions from @rsixlibrary{base}.

The binding @func{atan} is exported by @library{nausicaa mehve} and
generalises the corresponding function from @rsixlibrary{base}; its
implementation functions @func{atan-1} and @func{atan-2} are exported by
@library{nausicaa mehve transcendental}.


@deffn {Generic Function} sin @var{A}
@deffnx {Generic Function} cos @var{A}
@deffnx {Generic Function} tan @var{A}
Compute the sine, cosine and tangent functions.
@end deffn


@deffn {Generic Function} asin @var{A}
@deffnx {Generic Function} acos @var{A}
Compute the arc sine, arc cosine and arc tangent functions.
@end deffn


@deffn {Generic Function} atan-1 @var{A}
Compute the arc tangent function when @func{atan} is called with one
argument.
@end deffn


@deffn {Generic Function} atan-2 @var{A} @var{B}
Compute the arc tangent function when @func{atan} is called with two
arguments.
@end deffn


The following are the specialised methods.


@deffn Method sin (@var{A} @aclass{flonum})
@deffnx Method cos (@var{A} @aclass{flonum})
@deffnx Method tan (@var{A} @aclass{flonum})
Compute the sine, cosine and tangent functions using @func{flsin},
@func{flcos} and @func{fltan} from @rsixlibrary{arithmetic flonums},
@vicareref{stdlib arithmetic flonums, @func{flsin}}.
@end deffn


@deffn Method asin (@var{A} @aclass{flonum})
@deffnx Method acos (@var{A} @aclass{flonum})
@deffnx Method atan-1 (@var{A} @aclass{flonum})
@deffnx Method atan-2 (@var{A} @aclass{flonum}) (@var{B} @aclass{flonum})
Compute the arc sine, arc cosine and arc tangent functions using
@func{flasin}, @func{flacos} and @func{flatan} from
@rsixlibrary{arithmetic flonums}, @vicareref{stdlib arithmetic flonums,
@func{flasin}}.
@end deffn


@deffn Method sin (@var{A} @aclass{complex})
@deffnx Method cos (@var{A} @aclass{complex})
@deffnx Method tan (@var{A} @aclass{complex})
Compute the sine, cosine and tangent functions using @func{sin},
@func{cos} and @func{tan} from @rsixlibrary{base}, @vicareref{baselib math
ops trascend, @func{sin}}.
@end deffn


@deffn Method asin (@var{A} @aclass{complex})
@deffnx Method acos (@var{A} @aclass{complex})
@deffnx Method atan-1 (@var{A} @aclass{complex})
@deffnx Method atan-2 (@var{A} @aclass{real}) (@var{B} @aclass{real})
Compute the arc sine, arc cosine and arc tangent functions using
@func{asin}, @func{acos} and @func{atan} from @rsixlibrary{base},
@vicareref{baselib math ops trascend, @func{asin}}.
@end deffn

@end ignore

@c page
@node mehve numerics infix
@subsection Infix to prefix syntax


@cindex @library{nausicaa mehve language infix}, library
@cindex Library @library{nausicaa mehve language infix}
@findex @func{infix}


The @func{infix} syntax exported by @library{nausicaa mehve language
infix}, and reexported by @library{nausicaa mehve}, redefines the syntax
exported by @library{nausicaa} to support generic function operators.

All the bindings of @func{infix} from @library{nausicaa} are also
supported by @func{infix} from @library{nausicaa mehve}; the generic
functions used as operators have the same precedence of the
corresponding simple functions.

@c end of file
