\input texinfo.tex
@c %**start of header
@setfilename vicare-libs.info
@settitle Libraries for Vicare Scheme
@c %**end of header

@include version-libs.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Vicare specific macros.
@c ------------------------------------------------------------

@macro bub{}
@acronym{BUB}
@end macro

@macro cif{}
@acronym{CIF}
@end macro

@macro cretwo{}
@acronym{CRE2}
@end macro

@macro eol{}
@acronym{EOL}
@end macro

@macro fasl{}
@acronym{FASL}
@end macro

@macro fifo{}
@acronym{FIFO}
@end macro

@macro ikptr{}
@code{ikptr}
@end macro

@macro oob{}
@acronym{OOB}
@end macro

@macro os{}
@acronym{OS}
@end macro

@macro pcb{}
@acronym{PCB}
@end macro

@macro retwo{}
@acronym{RE2}
@end macro

@macro sel{}
@acronym{SEL}
@end macro

@macro std{}
@acronym{STD}
@end macro

@macro urldate{DATE}
(@acronym{URL} last verified \DATE\)
@end macro

@macro void{}
@code{#<void>}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set PRJNAME                    Vicare

@set TITLE                      Libraries for Vicare Scheme

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Vicare Scheme

@c To be used as @value{PACKAGE_NICKNAME} whenever we need to include
@c the nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           vicare-scheme

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2010-2013


@set TARBALLURL                 @url{http://sourceforge.net/projects/vicare-scheme/files/}
@set REPOSITORYURL              @url{http://github.com/marcomaggi/vicare/}
@set EXECUTABLE                 @command{vicare}
@set RAWEXECUTABLE              vicare

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes the libraries distributed along with version
@value{VERSION} of @value{PACKAGE}, an @rnrs{6} compliant native
compiler for the Scheme language.

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by Marco Maggi.@*
Copyright @copyright{} 2006-2010 by Abdulaziz Ghuloum.

The documentation of IrRegex is Copyright @copyright{} 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright @copyright{} 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library @library{vicare formations} is derived
from the documentation of Guile.  Copyright @copyright{} 1996-2005,
2009-2013 Free Software Foundation.

@quotation
This program is free software: you can redistribute it and/or modify it
under the terms of the @gnu{} General Public License version 3 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the @gnu{} General Public License
along with this program.  If not, see
@url{http://www.gnu.org/licenses/}.
@end quotation

Trademarks used herein are the property of their respective owners.
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* vicare-libs: (vicare-libs).   @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore


@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* lang::                        Language extension libraries.
* srfi::                        Scheme Requests For Implementation.
* platform::                    Hosting platform libraries.
* posix::                       The @posix{} interface.
* glibc::                       The @gnu{} C Library interface.
* iconv::                       The Libiconv interface.
* linux::                       The @gnu{}+Linux interface.
* args::                        Optional function arguments validation.
* cbuffers::                    Generalised C buffers and strings.
* readline::                    Extended interface to @gnu{} Readline.
* parser logic::                Defining parsers logic.
* gcc::                         A toy library interface to @gcc{}.
* flonum format::               Formatting flonums.
* flonum parse::                Parsing flonums.
* debugging::                   Debugging facilities.
* getopts::                     Parsing command line arguments.

Networking libraires

* net channels::                Interprocess connection channels.

Container libraries

* lists::                       List library.
* vectors::                     Vector library.
* strings::                     String library.
* char-sets::                   Character sets.
* bytevectors::                 Bytevectors.
* bytevector compounds::        Bytevector compounds.
* kmp::                         Knuth-Morris-Pratt searching.
* levenshtein::                 Levenshtein distance metric.
* wtables::                     Weak hashtables.
* object-properties::           Object properties.
* one-dimension::               One dimensional extended ranges.

Adapted libraries

* random::                      Sources of random bits.
* irregex::                     IrRegular expressions.
* pregexp::                     Portable regular expressions for Scheme.
* formations::                  Formatting strings.

Appendices

* cre2::                        Binding to the library @cretwo{}.
* Package License::             @gnu{} General Public License.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

External documents

* core: (vicare-scheme).        Documentation for Vicare Scheme.
* libffi: (libffi).             Libffi documentation.

@end menu
@end ifnottex

@c page
@node args
@chapter Optional function arguments validation


@cindex Library @library{vicare arguments validation}
@cindex @library{vicare arguments validation}, library


The library @library{vicare arguments validation} provides bindings to
macros that extend the Scheme language implemented by @library{vicare}
and @library{rnrs}.

@menu
* args config::                 Enabling or disabling arguments
                                validation.
* args definitions::            Defining arguments validation clauses.
* args using::                  Performing arguments validation.
* args forms::                  Optional validation forms.

* args predefined::             Predefined validation clauses.
@end menu

@c page
@node args config
@section Enabling or disabling arguments validation


@cindex @env{VICARE_ARGUMENTS_VALIDATION} environment variable
@cindex Environment variable @env{VICARE_ARGUMENTS_VALIDATION}


Global arguments validation is enabled or disabled by setting to @true{}
or @false{} the @code{arguments-validation} identifier syntax exported
by @library{vicare platform configuration}, the default is @true{}; such
value can be configured as follows:

@enumerate
@item
Argument validation is @strong{enabled} by setting to the string
@code{yes}, or the string @code{1}, the environment variable
@env{VICARE_ARGUMENTS_VALIDATION}.

@item
Argument validation is @strong{disabled} by setting to the string
@code{no}, or the string @code{0}, the environment variable
@env{VICARE_ARGUMENTS_VALIDATION}.

@item
If the environment variable @env{VICARE_ARGUMENTS_VALIDATION} is unset
or set to some string different from @code{yes}, @code{no}, @code{1},
@code{0}:

@itemize
@item
Arguments validation is @strong{enabled} if the
@option{--enable-arguments-validation} option of the @command{configure}
script was used.

@item
Arguments validation is @strong{disabled} if the
@option{--disable-arguments-validation} option of the
@command{configure} script was used.
@end itemize
@end enumerate

@c page
@node args definitions
@section Defining argument validation clauses


The following bindings are exported by the library @library{vicare
arguments validation}.


@defmac define-argument-validation (@meta{name} @meta{who} @meta{arg} ...) @meta{predicate} @meta{error-handler}
Define a validation clause to be used along with the syntax
@func{WITH-ARGUMENTS-VALIDATION}.  Example:

@example
(define-argument-validation (bytevector who bv)
  (bytevector? bv)
  (assertion-violation who
    "expected a bytevector as argument"
    bv))
@end example

We have to assume that the values @meta{arg} are evaluated multiple
times.
@end defmac

@c page
@node args using
@section Performing arguments validation


The following bindings are exported by the library @library{vicare
arguments validation}.


@defmac with-arguments-validation (@meta{who}) ((@meta{validator} @meta{arg} ...) ...) @metao{body} . @meta{body}
If arguments validation is enabled: expand to code that validates the
@meta{arg} expressions using to the @meta{validator} clause, then
evaluate the @meta{body} forms; if arguments validation is disabled:
just evaluate the @meta{body} forms.

@meta{who} must be an identifier used as argument when building a
@condition{who} condition object.

@meta{validator} must be an identifier previously used as name of
validation clause by the @func{define-argument-validation} macro.  As a
special case when @meta{validator} is the identifier @func{void},
exported by @library{vicare}, no validation is generated: the @var{arg}
values are considered always valid; this is sometimes useful when using
this macro in the expansion of another macro.

Simple example:

@example
(define-argument-validation (fixnum who obj)
  (fixnum? obj)
  (assertion-violation who
    "expected fixnum as argument"
    obj))

(define-argument-validation (integer who obj)
  (integer? obj)
  (assertion-violation who
    "expected integer as argument"
    obj))

(with-arguments-validation (who)
     ((fixnum  X)
      (integer Y))
  (do-this)
  (do-that))
@end example

@noindent
multiple clauses are evaluated from first to last, so the above example
is equivalent to:

@example
(with-arguments-validation (who)
     ((fixnum  X))
  (with-arguments-validation (who)
       ((integer Y))
    (do-this)
    (do-that)))
@end example

@noindent
which is equivalent to something like:

@example
(if (fixnum? X)
    (if (integer? X)
        (begin
          (do-this)
          (do-that))
      (assertion-violation who
        "expected integer as argument"
        obj))
  (assertion-violation who
    "expected fixnum as argument"
    obj))
@end example
@end defmac


@defmac with-dangerous-arguments-validation (@meta{who}) ((@meta{validator} @meta{arg} ...) ...) @metao{body} . @meta{body}
Like @func{with-arguments-validation}, but the validation is always
performed even when global arguments validation is disabled.
@end defmac

@c page
@node args forms
@section Optional validation forms


The following bindings are exported by the library @library{vicare
arguments validation}.


@defmac arguments-validation-forms
@defmacx arguments-validation-forms @metao{body} . @meta{body}
When used without arguments or arguments validation disabled: expand to
@code{(values)}; else expand to:

@example
(begin @metao{body} . @meta{body})
@end example
@end defmac

@c page
@node args predefined
@section Predefined validation clauses


@menu
* args predefined pairs::          Validating pairs and lists.
* args predefined booleans::       Validating booleans.
* args predefined numbers::        Validating numbers.
* args predefined fixnums::        Validating fixnums.
* args predefined exact integers:: Validating exact integers.
* args predefined keywords::       Validating keywords.
* args predefined promises::       Validating promises.
* args predefined bits::           Validating bit--sized integers.
* args predefined signed int::     Validating C language @code{int} values.
* args predefined clang::          Validating C language values.
* args predefined chars::          Validating characters.
* args predefined strings::        Validating string and
                                   related arguments.
* args predefined vectors::        Validating vector and
                                   related arguments.
* args predefined bytevectors::    Validating bytevector and related
                                   arguments.
* args predefined symbols::        Validating symbols.
* args predefined enum-sets::      Validating enum-sets.
* args predefined pointers::       Validating pointers.
* args predefined memory-blocks::  Validating @code{memory-block} values.
* args predefined flonums::        Validating flonums.
* args predefined bignums::        Validating bignums.
* args predefined ratnums::        Validating ratnums.
* args predefined reals::          Validating reals.
* args predefined compnums::       Validating compnums.
* args predefined cflonums::       Validating cflonums.
* args predefined complexes::      Validating complexes.
* args predefined ports::          Validating input/output ports.
* args predefined transcoders::    Validating port transcoders.
* args predefined procedures::     Validating procedures.
* args predefined genstrings::     Validating generalised C string
                                   arguments.
* args predefined genbuffers::     Validating generalised C buffer
                                   arguments.
* args predefined time::           Time objects.
@end menu

@c page
@node args predefined pairs
@subsection Validating pairs and lists


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} pair @var{obj}
Succeed if @var{obj} satisfies the predicate @func{pair?}.
@end deffn


@deffn {Validation Clause} list @var{obj}
Succeed if @var{obj} satisfies the predicate @func{list?}.
@end deffn

@c page
@node args predefined booleans
@subsection Validating booleans


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} boolean @var{obj}
Succeed if @var{obj} satisfies the predicate @func{boolean?}.
@end deffn

@c page
@node args predefined numbers
@subsection Validating numbers


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} number @var{obj}
Succeed if @var{obj} satisfies the predicate @func{number?}.
@end deffn

@c page
@node args predefined fixnums
@subsection Validating fixnums


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} fixnum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{fixnum?}.
@end deffn


@deffn {Validation Clause} fixnum/false @var{obj}
Succeed if @var{obj} is @false{} or it satisfies the predicate
@func{fixnum?}.
@end deffn


@deffn {Validation Clause} positive-fixnum @var{obj}
@deffnx {Validation Clause} negative-fixnum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{fixnum?} and it is
strictly positive or strictly negative.
@end deffn


@deffn {Validation Clause} non-positive-fixnum @var{obj}
@deffnx {Validation Clause} non-positive-fixnum/false @var{obj}
Succeed if @var{obj} satisfies the predicate @func{fixnum?} and it is
zero or positive.  The second clause accepts also @false{}.
@end deffn


@deffn {Validation Clause} non-negative-fixnum @var{obj}
@deffnx {Validation Clause} non-negative-fixnum/false @var{obj}
Succeed if @var{obj} satisfies the predicate @func{fixnum?} and it is
zero or negative.  The second clause accepts also @false{}.
@end deffn


@deffn {Validation Clause} fixnum-index @var{obj}
Succeed if @var{obj} satisfies the predicate @func{fixnum?} and it is
zero or positive.
@end deffn


@deffn {Validation Clause} non-zero-fixnum @var{obj}
@deffnx {Validation Clause} non-zero-fixnum/false @var{obj}
Fails if @var{obj} satisfies the predicate @func{fxzero?}.  The second
clause accepts also @false{}.
@end deffn


@deffn {Validation Clause} fixnum-in-inclusive-range @var{obj} @var{min} @var{max}
@deffnx {Validation Clause} fixnum-in-exclusive-range @var{obj} @var{min} @var{max}
Succeed if @var{obj} satisfies the predicate @func{fixnum?} and it is in
the specified range.  @var{min} and @var{max} must be fixnums.
@end deffn


@deffn {Validation Clause} even-fixnum @var{obj}
@deffnx {Validation Clause} odd-fixnum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{fixnum?} and the
predicate @func{fxeven?} or @func{fxodd?}.
@end deffn

@c page
@node args predefined exact integers
@subsection Validating exact integers


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} exact-integer @var{obj}
Succeed if @var{obj} satisfies the predicates @func{integer?} and
@func{exact?}.
@end deffn


@deffn {Validation Clause} exact-integer/false @var{obj}
Succeed if @var{obj} is @false{} or it satisfies the predicates
@func{integer?} and @func{exact?}.
@end deffn


@deffn {Validation Clause} positive-exact-integer @var{obj}
@deffnx {Validation Clause} negative-exact-integer @var{obj}
Succeed if @var{obj} satisfies the predicates @func{integer?} and
@func{exact?} and it is strictly positive or strictly negative.
@end deffn


@deffn {Validation Clause} non-positive-exact-integer @var{obj}
@deffnx {Validation Clause} non-negative-exact-integer @var{obj}
Succeed if @var{obj} satisfies the predicates @func{integer?} and
@func{exact?} and it is strictly positive or strictly negative.
@end deffn


@deffn {Validation Clause} exact-integer-in-inclusive-range @var{obj} @var{min} @var{max}
@deffnx {Validation Clause} exact-integer-in-exclusive-range @var{obj} @var{min} @var{max}
Succeed if @var{obj} satisfies the predicates @func{integer?} and
@func{exact?} and it is in the specified range.  @var{min} and @var{max}
must be exact integers.
@end deffn


@deffn {Validation Clause} even-exact-integer @var{obj}
@deffnx {Validation Clause} odd-exact-integer @var{obj}
Succeed if @var{obj} satisfies the predicates @func{integer?} and
@func{exact?} and the predicate @func{even?} or @func{odd?}.
@end deffn

@c page
@node args predefined keywords
@subsection Validating keywords


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} keyword @var{obj}
Succeed if @var{obj} is a keyword object: it satisfies the predicate
@func{keyword?} exported by @library{vicare}.
@end deffn

@c page
@node args predefined promises
@subsection Validating promises


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} promise @var{obj}
Succeed if @var{obj} is a promise object: it satisfies the predicate
@func{promise?} exported by @library{vicare}.
@end deffn


@deffn {Validation Clause} false-or-promise @var{obj}
Succeed if @var{obj} is @false{} or a promise object: it satisfies the
predicate @func{promise?} exported by @library{vicare}.
@end deffn

@c page
@node args predefined bits
@subsection Validating bit--sized integers


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} octet @var{obj}
@deffnx {Validation Clause} false-or-octet @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an octet.
@end deffn


@deffn {Validation Clause} byte @var{obj}
@deffnx {Validation Clause} false-or-byte @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an byte.
@end deffn


@deffn {Validation Clause} word-u8 @var{obj}
@deffnx {Validation Clause} word-u8/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an octet.
@end deffn


@deffn {Validation Clause} word-s8 @var{obj}
@deffnx {Validation Clause} word-s8/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of a byte.
@end deffn


@deffn {Validation Clause} word-u16 @var{obj}
@deffnx {Validation Clause} word-u16/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an unsigned @math{16}-bit integer.
@end deffn


@deffn {Validation Clause} word-s16 @var{obj}
@deffnx {Validation Clause} word-s16/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of a signed @math{16}-bit integer.
@end deffn


@deffn {Validation Clause} word-u32 @var{obj}
@deffnx {Validation Clause} word-u32/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an unsigned @math{32}-bit integer.
@end deffn


@deffn {Validation Clause} word-s32 @var{obj}
@deffnx {Validation Clause} word-s32/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of a signed @math{32}-bit integer.
@end deffn


@deffn {Validation Clause} word-u64 @var{obj}
@deffnx {Validation Clause} word-u64/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an unsigned @math{64}-bit integer.
@end deffn


@deffn {Validation Clause} word-s64 @var{obj}
@deffnx {Validation Clause} word-s64/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of a signed @math{64}-bit integer.
@end deffn


@deffn {Validation Clause} word-u128 @var{obj}
@deffnx {Validation Clause} word-u128/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an unsigned @math{128}-bit integer.
@end deffn


@deffn {Validation Clause} word-s128 @var{obj}
@deffnx {Validation Clause} word-s128/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of a signed @math{128}-bit integer.
@end deffn


@deffn {Validation Clause} word-u256 @var{obj}
@deffnx {Validation Clause} word-u256/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an unsigned @math{256}-bit integer.
@end deffn


@deffn {Validation Clause} word-s256 @var{obj}
@deffnx {Validation Clause} word-s256/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of a signed @math{256}-bit integer.
@end deffn


@deffn {Validation Clause} machine-word @var{obj}
@deffnx {Validation Clause} machine-word/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, fitting in the range of an unsigned machine word integer; a
machine word is @math{32}-bit or @math{64}-bit integer.
@end deffn

@c page
@node args predefined signed int
@subsection Validating C language @code{int} values


Exact integers in the range of the C language type @code{int} are used
often when interfacing with a foreign C language library; the library
@library{vicare platform words} provides the predicate @func{signed-int?} to
validated such values; @ref{words predicates} for details.

The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} signed-int @var{obj}
Succeed if @var{obj} satisfies the predicate @func{signed-int?}.
@end deffn


@deffn {Validation Clause} signed-int/false @var{obj}
Succeed if @var{obj} is @false{} or it satisfies the predicate
@func{signed-int?}.
@end deffn


@deffn {Validation Clause} positive-signed-int @var{obj}
@deffnx {Validation Clause} negative-signed-int @var{obj}
Succeed if @var{obj} satisfies the predicate @func{signed-int?} and it
is strictly positive or strictly negative.
@end deffn


@deffn {Validation Clause} non-positive-signed-int @var{obj}
@deffnx {Validation Clause} non-negative-signed-int @var{obj}
Succeed if @var{obj} satisfies the predicate @func{signed-int?} and it
is strictly positive or strictly negative.
@end deffn


@deffn {Validation Clause} signed-int-in-inclusive-range @var{obj} @var{min} @var{max}
@deffnx {Validation Clause} signed-int-in-exclusive-range @var{obj} @var{min} @var{max}
Succeed if @var{obj} satisfies the predicate @func{signed-int?} and it
is in the specified range.  @var{min} and @var{max} must be exact
integers.
@end deffn


@deffn {Validation Clause} even-signed-int @var{obj}
@deffnx {Validation Clause} odd-signed-int @var{obj}
Succeed if @var{obj} satisfies the predicate @func{signed-int?} and the
predicate @func{even?} or @func{odd?}.
@end deffn

@c page
@node args predefined clang
@subsection Validating C language values


The library @library{vicare platform words} provides the predicates to validate
typical values used when interfacing with foreign C language libraries;
@ref{words predicates} for details.

The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} unsigned-char @var{obj}
@deffnx {Validation Clause} unsigned-char/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{unsigned char}.
@end deffn


@deffn {Validation Clause} signed-char @var{obj}
@deffnx {Validation Clause} signed-char/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{signed char}.
@end deffn


@deffn {Validation Clause} unsigned-short @var{obj}
@deffnx {Validation Clause} unsigned-short/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{unsigned short int}.
@end deffn


@deffn {Validation Clause} signed-short @var{obj}
@deffnx {Validation Clause} signed-short/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{signed short int}.
@end deffn


@deffn {Validation Clause} unsigned-int @var{obj}
@deffnx {Validation Clause} unsigned-int/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{unsigned int}.
@end deffn


@deffn {Validation Clause} unsigned-long @var{obj}
@deffnx {Validation Clause} unsigned-long/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{unsigned long}.
@end deffn


@deffn {Validation Clause} signed-long @var{obj}
@deffnx {Validation Clause} signed-long/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{signed long}.
@end deffn


@deffn {Validation Clause} unsigned-long-long @var{obj}
@deffnx {Validation Clause} unsigned-long-long/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{unsigned long long}.
@end deffn


@deffn {Validation Clause} signed-long-long @var{obj}
@deffnx {Validation Clause} signed-long-long/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{signed long long}.
@end deffn


@deffn {Validation Clause} pointer-integer @var{obj}
@deffnx {Validation Clause} pointer-integer/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{void *}.
@end deffn


@deffn {Validation Clause} size_t @var{obj}
@deffnx {Validation Clause} size_t/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{size_t}.
@end deffn


@deffn {Validation Clause} ssize_t @var{obj}
@deffnx {Validation Clause} ssize_t/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{ssize_t}.
@end deffn


@deffn {Validation Clause} off_t @var{obj}
@deffnx {Validation Clause} off_t/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{off_t}.
@end deffn


@deffn {Validation Clause} ptrdiff_t @var{obj}
@deffnx {Validation Clause} ptrdiff_t/false @var{obj}
Succeed if @var{obj} is an exact integer, or @false{} for the second
variant, in the range of a C language type @code{ptrdiff_t}.
@end deffn

@c page
@node args predefined chars
@subsection Validating characters


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} char @var{obj}
@deffnx {Validation Clause} char/false @var{obj}
Succeed if @var{obj} is a character.  The second clause also accepts
@false{}.
@end deffn


@deffn {Validation Clause} char-in-ascii-range @var{obj}
@deffnx {Validation Clause} char-in-ascii-range/false @var{obj}
Succeed if @var{obj} is a character and its Unicode code point is in the
range @math{[0, 127]}.  The second form accepts also @false{} as value.
@end deffn

@c page
@node args predefined strings
@subsection Validating string and related arguments


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} string @var{obj}
Succeed if @var{obj} is a string.
@end deffn


@deffn {Validation Clause} string/false @var{obj}
Succeed if @var{obj} is @false{} or a string.
@end deffn


@deffn {Validation Clause} non-empty-string @var{obj}
Succeed if @var{obj} is a string and its length is greater than zero.
@end deffn


@deffn {Validation Clause} non-empty-string/false @var{obj}
Succeed if @var{obj} is @false{} or a string and its length is greater
than zero.
@end deffn


@deffn {Validation Clause} list-of-strings @var{obj}
Succeed if @var{obj} is null or a list of strings.
@end deffn


@deffn {Validation Clause} string-or-symbol @var{obj}
@deffnx {Validation Clause} string-or-symbol-or-false @var{obj}
Succeed if @var{obj} is a string or symbol; the second clause accepts
also @false{}.
@end deffn

@c ------------------------------------------------------------

@deffn {Validation Clause} index-for-string @var{str} @var{idx}
Succeed if @var{idx} is a fixnum usable as index (not out of range) for
@var{str}, which is expected to be an already validated string.
@var{idx} must satisfy the constraints:

@example
0 <= @var{idx} < (string-length @var{str})
@end example
@end deffn


@deffn {Validation Clause} one-off-index-for-string @var{str} @var{idx}
Succeed if @var{idx} is a fixnum usable as index for @var{str}, which is
expected to be an already validated string, or it is equal to the string
length.  @var{idx} must satisfy the constraints:

@example
0 <= @var{idx} <= (string-length @var{str})
@end example
@end deffn


@deffn {Validation Clause} index-and-count-for-string @var{str} @var{idx} @var{count}
Assuming that @var{str} is an already validated string: succeed if
@var{idx} is a fixnum usable as index (not out of range) for @var{str},
and @var{count} is a fixnum which can be used as characters count in
@var{str} starting and @var{idx} without going out of range.

In other words: @var{idx} and @var{count} select a substring of
@var{str}.
@end deffn


@deffn {Validation Clause} start-and-end-for-string @var{str} @var{start} @var{end}
Assuming that @var{str} is an already validated string: succeed if both
@var{start} and @var{end} are fixnums usable as indexes (not out of
range) for @var{str}, and @var{start} is less than or equal to
@var{end}.

In other words: @var{start} and @var{end} select a substring of
@var{str} by specifying inclusive limits.
@end deffn


@deffn {Validation Clause} start-and-past-for-string @var{str} @var{start} @var{past}
Assuming that @var{str} is an already validated string: succeed if both
@var{start} and @var{past} are fixnums satisfying the constraints:

@example
0 <= @var{start} <= (string-length @var{str})
@var{start} <= @var{past} <= (string-length @var{str})
@end example

In other words: @var{start} and @var{past} select a substring of
@var{str} by specifying left--inclusive and right--exclusive limits.
@end deffn

@c page
@node args predefined vectors
@subsection Validating vector and related arguments


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} vector @var{obj}
Succeed if @var{obj} is a vector.
@end deffn


@deffn {Validation Clause} vector/false @var{obj}
Succeed if @var{obj} is @false{} or a vector.
@end deffn


@deffn {Validation Clause} non-empty-vector @var{obj}
Succeed if @var{obj} is a vector and its length is greater than zero.
@end deffn


@deffn {Validation Clause} non-empty-vector/false @var{obj}
Succeed if @var{obj} is @false{} or a vector and its length is greater
than zero.
@end deffn


@deffn {Validation Clause} index-for-vector @var{vec} @var{idx}
Succeed if @var{idx} is a fixnum usable as index (not out of range) for
@var{vec}, which is expected to be an already validated vector.
@end deffn


@deffn {Validation Clause} index-and-count-for-vector @var{vec} @var{idx} @var{count}
Assuming that @var{vec} is an already validated vector: succeed if
@var{idx} is a fixnum usable as index (not out of range) for @var{vec},
and @var{count} is a fixnum which can be used as characters count in
@var{vec} starting and @var{idx} without going out of range.

In other words: @var{idx} and @var{count} select a subvector of
@var{vec}.
@end deffn


@deffn {Validation Clause} start-and-end-for-vector @var{vec} @var{start} @var{end}
Assuming that @var{vec} is an already validated vector: succeed if both
@var{start} and @var{end} are fixnums usable as indexes (not out of
range) for @var{vec}, and @var{start} is less than or equal to
@var{end}.

In other words: @var{start} and @var{end} select a subvector of
@var{vec} by specifying inclusive limits.
@end deffn


@deffn {Validation Clause} start-and-past-for-vector @var{vec} @var{start} @var{past}
Assuming that @var{vec} is an already validated vector: succeed if both
@var{start} and @var{past} are fixnums satisfying the constraints:

@example
0 <= @var{start} <= (vector-length @var{vec})
@var{start} <= @var{past} <= (vector-length @var{vec})
@end example

In other words: @var{start} and @var{past} select a subvector of
@var{vec} by specifying left--inclusive and right--exclusive limits.
@end deffn

@c page
@node args predefined bytevectors
@subsection Validating bytevector and related arguments


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} bytevector @var{obj}
Succeed if @var{obj} is a bytevector.
@end deffn


@deffn {Validation Clause} bytevector/false @var{obj}
Succeed if @var{obj} is @false{} or a bytevector.
@end deffn


@deffn {Validation Clause} non-empty-bytevector @var{obj}
Succeed if @var{obj} is a bytevector and its length is greater than
zero.
@end deffn


@deffn {Validation Clause} non-empty-bytevector/false @var{obj}
Succeed if @var{obj} is @false{} or a bytevector and its length is
greater than zero.
@end deffn


@deffn {Validation Clause} list-of-bytevectors @var{obj}
Succeed if @var{obj} is null or a list of bytevectors.
@end deffn

@c ------------------------------------------------------------

@deffn {Validation Clause} index-for-bytevector @var{bv} @var{idx}
Succeed if @var{idx} is a fixnum usable as index (not out of range) for
@var{bv}, which is expected to be an already validated bytevector.
@end deffn


@deffn {Validation Clause} bytevector-length @var{len}
Succeed if @var{len} is a non--negative fixnum usable as bytevector
length.
@end deffn


@deffn {Validation Clause} index-and-count-for-bytevector @var{bv} @var{idx} @var{count}
Assuming that @var{bv} is an already validated bytevector: succeed if
@var{idx} is a fixnum usable as index (not out of range) for @var{bv},
and @var{count} is a fixnum which can be used as characters count in
@var{bv} starting and @var{idx} without going out of range.

In other words: @var{idx} and @var{count} select a subbytevector of
@var{bv}.
@end deffn


@deffn {Validation Clause} start-and-end-for-bytevector @var{bv} @var{start} @var{end}
Assuming that @var{bv} is an already validated bytevector: succeed if
both @var{start} and @var{end} are fixnums usable as indexes (not out of
range) for @var{bv}, and @var{start} is less than or equal to
@var{end}.

In other words: @var{start} and @var{end} select a subbytevector of
@var{bv} by specifying inclusive limits.
@end deffn


@deffn {Validation Clause} start-and-past-for-bytevector @var{bv} @var{start} @var{past}
Assuming that @var{bv} is an already validated bytevector: succeed if
both @var{start} and @var{past} are fixnums satisfying the constraints:

@example
0 <= @var{start} <= (bytevector-length @var{bv})
@var{start} <= @var{past} <= (bytevector-length @var{bv})
@end example

In other words: @var{start} and @var{past} select a subbytevector of
@var{bv} by specifying left--inclusive and right--exclusive limits.
@end deffn

@c page
@node args predefined symbols
@subsection Validating symbols


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} symbol @var{obj}
Succeed if @var{obj} is a symbol.
@end deffn


@deffn {Validation Clause} symbol/false @var{obj}
Succeed if @var{obj} is @false{} or a symbol.
@end deffn

@c page
@node args predefined enum-sets
@subsection Validating enum-sets


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} enum-set @var{obj}
Succeed if @var{obj} is a enum-set.
@end deffn


@deffn {Validation Clause} enum-set/false @var{obj}
Succeed if @var{obj} is @false{} or a enum-set.
@end deffn

@c page
@node args predefined pointers
@subsection Validating pointers


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} pointer @var{obj}
Succeed if @var{obj} is a pointer.
@end deffn


@deffn {Validation Clause} pointer/false @var{obj}
Succeed if @var{obj} is @false{} or a pointer.
@end deffn


@deffn {Validation Clause} non-null-pointer @var{obj}
Succeed if @var{obj} is a pointer and it does @strong{not} represent
@cnull{}.
@end deffn


@deffn {Validation Clause} c-callback @var{obj}
Succeed if @var{obj} is a pointer object.
@end deffn


@deffn {Validation Clause} c-callback/false @var{obj}
Succeed if @var{obj} is @false{} or a pointer object.
@end deffn

@c page
@node args predefined memory-blocks
@subsection Validating @code{memory-block} values


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} memory-block @var{obj}
Succeed if @var{obj} is a memory-block.
@end deffn


@deffn {Validation Clause} memory-block/false @var{obj}
Succeed if @var{obj} is @false{} or a memory-block.
@end deffn

@c page
@node args predefined flonums
@subsection Validating flonums


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} flonum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{flonum?}.
@end deffn

@c page
@node args predefined bignums
@subsection Validating bignums


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} bignum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{bignum?}.
@end deffn

@c page
@node args predefined ratnums
@subsection Validating ratnums


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} ratnum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{ratnum?}.
@end deffn

@c page
@node args predefined reals
@subsection Validating reals


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} real @var{obj}
Succeed if @var{obj} satisfies the predicate @func{real?}.
@end deffn


@deffn {Validation Clause} real-exact @var{obj}
Succeed if @var{obj} satisfies one of the predicates @func{fixnum?},
@func{bignum?}, @func{ratnum?}.
@end deffn

@c page
@node args predefined compnums
@subsection Validating compnums


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} compnum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{compnum?}.
@end deffn

@c page
@node args predefined cflonums
@subsection Validating cflonums


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} cflonum @var{obj}
Succeed if @var{obj} satisfies the predicate @func{cflonum?}.
@end deffn

@c page
@node args predefined complexes
@subsection Validating complexes


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} complex @var{obj}
Succeed if @var{obj} satisfies the predicate @func{complex?}.
@end deffn

@c page
@node args predefined ports
@subsection Validating input/output ports


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} port @var{obj}
Succeed if @var{obj} is a port.
@end deffn


@deffn {Validation Clause} port/false @var{obj}
Succeed if @var{obj} is @false{} or a port.
@end deffn


@deffn {Validation Clause} input-port @var{obj}
@deffnx {Validation Clause} output-port @var{obj}
@deffnx {Validation Clause} input/output-port @var{obj}
Succeed if @var{obj} is an input, output or input/output port.
@end deffn


@deffn {Validation Clause} input-port/false @var{obj}
@deffnx {Validation Clause} output-port/false @var{obj}
@deffnx {Validation Clause} input/output-port/false @var{obj}
Succeed if @var{obj} is @false{} or an input, output or input/output
port.
@end deffn


@deffn {Validation Clause} textual-port @var{obj}
@deffnx {Validation Clause} binary-port @var{obj}
Succeed if @var{obj} is an textual or binary port.
@end deffn


@deffn {Validation Clause} textual-port/false @var{obj}
@deffnx {Validation Clause} binary-port/false @var{obj}
Succeed if @var{obj} is @false{} or an textual or binary port.
@end deffn


@deffn {Validation Clause} open-port @var{obj}
Succeed if @var{obj} is an open port.
@end deffn

@c page
@node args predefined transcoders
@subsection Validating port transcoders


The following bindings are extranscodered by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} transcoder @var{obj}
Succeed if @var{obj} is a transcoder.
@end deffn


@deffn {Validation Clause} transcoder/false @var{obj}
Succeed if @var{obj} is @false{} or a transcoder.
@end deffn

@c page
@node args predefined procedures
@subsection Validating procedures


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} procedure @var{obj}
Succeed if @var{obj} is a procedure.
@end deffn


@deffn {Validation Clause} procedure/false @var{obj}
Succeed if @var{obj} is @false{} or a procedure.
@end deffn

@c page
@node args predefined genstrings
@subsection Validating generalised C string arguments


@ref{cbuffers strings, Introduction to generalised C strings}, for
details on generalised C strings.

The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn Syntax general-c-string? @meta{obj}
Expand to an expression which evaluates @meta{obj} once and returns
@true{} if the result is a generalised C string.
@end deffn


@deffn {Validation Clause} general-c-string @var{obj}
Succeed if @var{obj} is a generalised C string.
@end deffn


@deffn {Validation Clause} general-c-string/false @var{obj}
Succeed if @var{obj} is @false{} or a generalised C string.
@end deffn


@deffn {Validation Clause} general-c-string.len @var{str} @var{str.len}
If @var{str} is a pointer object: succeed if @var{str.len} an exact
integer in the range of the C language type @code{size_t}.  Otherwise
succeed if @var{str.len} is @false{}.
@end deffn


@deffn {Validation Clause} general-c-string* @var{obj} @var{obj.len}
Succeed if @var{obj} is a generalised C string and @var{obj.len} its
optional length.
@end deffn


@deffn {Validation Clause} general-c-string*/false @var{obj} @var{obj.len}
Succeed if @var{obj} is a @false{} or a generalised C string and
@var{obj.len} its optional length.  If @var{obj} is @false{}:
@var{obj.len} must be false too.
@end deffn

@c page
@node args predefined genbuffers
@subsection Validating generalised C buffer arguments


@ref{cbuffers buffers, Introduction to generalised C buffers}, for
details on generalised C buffers.

The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn Syntax general-c-buffer? @meta{obj}
Expand to an expression which evaluates @meta{obj} once and returns
@true{} if the result is a generalised C buffer.
@end deffn


@deffn {Validation Clause} general-c-buffer @var{obj}
Succeed if @var{obj} is a generalised C buffer.
@end deffn


@deffn {Validation Clause} general-c-buffer/false @var{obj}
Succeed if @var{obj} is @false{} or a generalised C buffer.
@end deffn


@deffn Syntax general-c-sticky-buffer? @meta{obj}
Expand to an expression which evaluates @meta{obj} once and returns
@true{} if the result is a generalised C sticky buffer.
@end deffn


@deffn {Validation Clause} general-c-sticky-buffer @var{obj}
Succeed if @var{obj} is a generalised C sticky buffer.
@end deffn


@deffn {Validation Clause} general-c-sticky-buffer/false @var{obj}
Succeed if @var{obj} is @false{} or a generalised C sticky buffer.
@end deffn


@deffn {Validation Clause} general-c-buffer.len @var{buf} @var{buf.len}
If @var{buf} is a pointer object: succeed if @var{buf.len} an exact
integer in the range of the C language type @code{size_t}.  Otherwise
succeed if @var{buf.len} is @false{}.
@end deffn


@deffn {Validation Clause} general-c-buffer* @var{obj} @var{obj.len}
Succeed if @var{obj} is a generalised C buffer and @var{obj.len} its
optional length.
@end deffn


@deffn {Validation Clause} general-c-sticky-buffer* @var{obj} @var{obj.len}
Succeed if @var{obj} is a generalised C sticky buffer and @var{obj.len}
its optional length.
@end deffn


@deffn {Validation Clause} general-c-buffer*/false @var{obj} @var{obj.len}
Succeed if @var{obj} is a @false{} or a generalised C buffer and
@var{obj.len} its optional length.  If @var{obj} is @false{}:
@var{obj.len} must be false too.
@end deffn


@deffn {Validation Clause} general-c-sticky-buffer*/false @var{obj} @var{obj.len}
Succeed if @var{obj} is a @false{} or a generalised C sticky buffer and
@var{obj.len} its optional length.  If @var{obj} is @false{}:
@var{obj.len} must be false too.
@end deffn

@c page
@node args predefined time
@subsection Validating time objects


The following bindings are exported by the library @library{vicare
arguments validation}.


@deffn {Validation Clause} time @var{obj}
Succeed if @var{obj} is a time object: it satisfies the predicate
@func{time?} exported by @library{vicare}.
@end deffn


@deffn {Validation Clause} time/false @var{obj}
Succeed if @var{obj} is @false{} or a time object: it satisfies the
predicate @func{time?} exported by @library{vicare}.
@end deffn

@c page
@node platform
@chapter Hosting platform libraries


@menu
* platform constants::          Hosting platform constants.
* platform features::           Hosting platform features.
* platform utilities::          Hosting platform utilities.
* errno::                       More features for @code{errno}.
* words::                       Exact integer predicates and constants.
@end menu

@c page
@node platform constants
@section Hosting platform constants


@cindex Library @library{vicare platform constants}
@cindex @library{vicare platform constants}, library


The library @library{vicare platform constants} exports one syntax
identifier binding for each platform constant that makes sense to access
from Scheme.

@c page
@node platform features
@section Hosting platform features


@cindex Library @library{vicare platform features}
@cindex @library{vicare platform features}, library


The library @library{vicare platform features} exports an identifier
syntax for every @code{HAVE_} symbol defined by the configuration script
@command{configure}; such syntaxes expand to a boolean value: @true{} if
the feature is available, @false{} otherwise.

@c page
@node platform utilities
@section Hosting platform utilities


@cindex Library @library{vicare platform utilities}
@cindex @library{vicare platform utilities}, library


The library @library{vicare platform utilities} defines helper functions
to deal with platform specific issues.  The following bindings are
exported by the library @library{vicare platform utilities}.


@deffn Syntax posix-signal->symbol @var{code}
Given an integer representing an interprocess @posix{} signal code,
return the corresponding symbol; if @var{code} is not recognised as
@posix{} signal code: return @false{}.

@example
(import (rnrs)
  (vicare platform constants)
  (vicare platform utilities))

(posix-signal->symbol SIGTERM)            @result{} SIGTERM
(posix-signal->symbol (greatest-fixnum))  @result{} #f
@end example
@end deffn


@defun errno-code->symbol @var{code}
Given a fixnum representing an encoded @code{errno} value, return the
corresponding symbol; if @var{code} is not recognised as encoded
@code{errno} value: return @false{}.

@example
(import (rnrs)
  (vicare platform constants)
  (vicare platform utilities))

(errno-code->symbol EINVAL)             @result{} EINVAL
(errno-code->symbol (greatest-fixnum))  @result{} #f
@end example
@end defun

@c page
@node errno
@section More features for @code{errno}


@cindex Library @library{vicare platform errno}
@cindex @library{vicare platform errno}, library


One syntax identifier binding for each known @code{errno} value is
exported by the library @library{vicare platform errno} and reexported
by the library @library{vicare platform constants}; @vicareref{iklib
errno, Interface to @code{errno}} for details on @value{PRJNAME}
internal encoding of @code{errno} codes.  The following bindings are
exported by the library @library{vicare platform errno}.


@deffn Syntax errno-code @meta{symbol}
Verify that @meta{symbol} is one of the symbolic names of @code{errno};
if successful expand to an expression evaluating to the coded
@code{errno} value, else raise a syntax violation.
@end deffn


@deffn Syntax case-errno @meta{errno} ((@metao{code} @meta{code} ...) . @meta{cbody}) ...
@deffnx Syntax case-errno @meta{errno} ((@metao{code} @meta{code} ...) . @meta{cbody}) ... (else . @meta{ebody})
@deffnx {Auxiliary Syntax} else
Specialised @func{case} macro for @code{errno} values.  @func{else} is
the auxiliary keyword exported by @library{rnrs}.  Example:

@example
#!r6rs
(import (rnrs)
  (vicare platform errno))

(define identifier "some-port")

(case-errno (errno)
  ((EACCES EFAULT)
   (make-i/o-file-protection-error identifier))
  ((EROFS)
   (make-i/o-file-is-read-only-error identifier))
  ((EEXIST)
   (make-i/o-file-already-exists-error identifier))
  ((EIO)
   (make-i/o-error))
  ((ENOENT)
   (make-i/o-file-does-not-exist-error identifier))
  (else
   (make-irritants-condition (list identifier))))
@end example

The @meta{code} must be symbols representing @code{errno} codes, they
are @strong{not} meant to be binding identifiers.
@end deffn

@c page
@node words
@section Exact integer predicates and constants


@cindex Library @library{vicare platform words}
@cindex @library{vicare platform words}, library


It is often needed to validate exact integers agains fixed range bounds,
for example for 32-bit and 64-bit representations or some platform
specific C language type.  The library @library{vicare platform words} implements
such predicates and minimum/maximum range constants.

@menu
* words syntaxes::              Miscellaneous syntaxes.
* words sizeof::                Knowing the size of C language types.
* words predicates::            Verifying the range of integers.
* words limits::                Exact integer range limits.
@end menu

@c page
@node words syntaxes
@subsection Miscellaneous syntaxes


The following bindings are exported by the @library{vicare platform words}
library.


@deffn Syntax case-word-size ((32) . @meta{body-32}) ((64) . @meta{body-64})
If the platform word size is 32-bit expand to @meta{body-32}, else
expand to @meta{body-64}.
@end deffn


@deffn Syntax case-endianness (@meta{who} @meta{endianness}) ((little) . @meta{lit-body}) ((big) . @meta{big-body})
@deffnx Syntax case-endianness (@meta{who} @meta{endianness}) ((big) . @meta{big-body}) ((little) . @meta{lit-body})
@deffnx {Auxiliary Syntax} big
@deffnx {Auxiliary Syntax} little
If the platform endianness is little expand to @meta{lit-body}, else
expand to @meta{big-body}.
@end deffn

@c page
@node words sizeof
@subsection Knowing the size of C language types


The following bindings are exported by the @library{vicare platform words}
library.


@deffn {Identifier Syntax} SIZEOF_CHAR
Number of bytes in the C language type @code{char}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_SHORT
Number of bytes in the C language type @code{short int}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_INT
Number of bytes in the C language type @code{int}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_LONG
Number of bytes in the C language type @code{long}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_LONG_LONG
Number of bytes in the C language type @code{long long}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_SIZE_T
Number of bytes in the C language type @code{size_t}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_SSIZE_T
Number of bytes in the C language type @code{ssize_t}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_OFF_T
Number of bytes in the C language type @code{off_t}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_PTRDIFF_T
Number of bytes in the C language type @code{ptrdiff_t}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_FLOAT
Number of bytes in the C language type @code{float}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_DOUBLE
Number of bytes in the C language type @code{double}.
@end deffn


@deffn {Identifier Syntax} SIZEOF_POINTER
Number of bytes in the C language type @code{void *}.
@end deffn

@c page
@node words predicates
@subsection Verifying the range of integers


The following bindings are exported by the @library{vicare platform words}
library.


@deffn Syntax word? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum, that is an exact
integer; else return @false{}.
@end deffn


@deffn Syntax machine-word? @var{obj}
On 32-bit platforms: return @true{} if @var{obj} is a fixnum or bignum
in the 32-bit range; on 64-bit platforms: return @true{} if @var{obj} is
a fixnum or bignum in the 64-bit range; else return @false{}.
@end deffn


@deffn Syntax word-u8? @var{obj}
@deffnx Syntax word-s8? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum in the 8-bit
range; else return @false{}.
@end deffn


@deffn Syntax word-u16? @var{obj}
@deffnx Syntax word-s16? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum in the 16-bit
range; else return @false{}.
@end deffn


@deffn Syntax word-u32? @var{obj}
@deffnx Syntax word-s32? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum or bignum in
the 32-bit range; else return @false{}.
@end deffn


@deffn Syntax word-u64? @var{obj}
@deffnx Syntax word-s64? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum or bignum in
the 64-bit range; else return @false{}.
@end deffn


@deffn Syntax word-u128? @var{obj}
@deffnx Syntax word-s128? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum or bignum in
the 128-bit range; else return @false{}.
@end deffn


@deffn Syntax word-u256? @var{obj}
@deffnx Syntax word-s256? @var{obj}
Return @true{} if @var{obj} is a signed or unsigned fixnum or bignum in
the 256-bit range; else return @false{}.
@end deffn


@deffn Syntax unsigned-char? @var{obj}
@deffnx Syntax signed-char? @var{obj}
Return @true{} if @var{obj} is a fixnum in the range representable with
a platform C language type @code{signed char} or @code{unsigned char}.
@end deffn


@deffn Syntax unsigned-short? @var{obj}
@deffnx Syntax signed-short? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{signed short int} or
@code{unsigned short int}.
@end deffn


@deffn Syntax unsigned-int? @var{obj}
@deffnx Syntax signed-int? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{signed int} or
@code{unsigned int}.
@end deffn


@deffn Syntax unsigned-long? @var{obj}
@deffnx Syntax signed-long? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{signed long int} or
@code{unsigned long int}.
@end deffn


@deffn Syntax unsigned-long-long? @var{obj}
@deffnx Syntax signed-long-long? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{signed long long
int} or @code{unsigned long long int}.
@end deffn


@deffn Syntax pointer-integer? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{void *}.
@end deffn


@deffn Syntax size_t? @var{obj}
@deffnx Syntax ssize_t? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{size_t} or
@code{ssize_t} as defined by @file{stddef.h}.
@end deffn


@deffn Syntax off_t? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{off_t} as defined by
@file{stdio.h}.
@end deffn


@deffn Syntax ptrdiff_t? @var{obj}
Return @true{} if @var{obj} is a fixnum or bignum in the range
representable with a platform C language type @code{ptrdiff_t} as
defined by @file{stddef.h}.
@end deffn


The following predicates are meant to be used to validate indices in
bytevectors.


@deffn Syntax fixnum-aligned-to-2? @var{N}
@strong{Unsafe syntax: @var{N} must be a fixnum.}  Evaluate to @true{}
if @var{N} is a fixnum multiple of @math{2}; else evaluate to @false{}.
@end deffn


@deffn Syntax fixnum-aligned-to-4? @var{N}
@strong{Unsafe syntax: @var{N} must be a fixnum.}  Evaluate to @true{}
if @var{N} is a fixnum multiple of @math{4}; else evaluate to @false{}.
@end deffn


@deffn Syntax fixnum-aligned-to-8? @var{N}
@strong{Unsafe syntax: @var{N} must be a fixnum.}  Evaluate to @true{}
if @var{N} is a fixnum multiple of @math{8}; else evaluate to @false{}.
@end deffn


@deffn Syntax fixnum-aligned-to? @var{N} @var{alignment}
@strong{Unsafe syntax: @var{N} and @var{alignment} must be fixnums.}
Evaluate to @true{} if @var{N} is a fixnum multiple of @math{alignment};
else evaluate to @false{}.
@end deffn

@c page
@node words limits
@subsection Exact integer range limits


The following bindings are exported by the @library{vicare platform
words} library.

@c ------------------------------------------------------------

@subsubheading Inclusive limits


@deffn Syntax greatest-u8
@deffnx Syntax greatest-s8
@deffnx Syntax least-u8
@deffnx Syntax least-s8
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 8-bit range.
@end deffn


@deffn Syntax greatest-u16
@deffnx Syntax greatest-s16
@deffnx Syntax least-u16
@deffnx Syntax least-s16
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 16-bit range.
@end deffn


@deffn Syntax greatest-u32
@deffnx Syntax greatest-s32
@deffnx Syntax least-u32
@deffnx Syntax least-s32
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 32-bit range.
@end deffn


@deffn Syntax greatest-u64
@deffnx Syntax greatest-s64
@deffnx Syntax least-u64
@deffnx Syntax least-s64
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 64-bit range.
@end deffn


@deffn Syntax greatest-s128
@deffnx Syntax greatest-u128
@deffnx Syntax least-u128
@deffnx Syntax least-s128
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 128-bit range.
@end deffn


@deffn Syntax greatest-s256
@deffnx Syntax greatest-u256
@deffnx Syntax least-u256
@deffnx Syntax least-s256
Evaluate to the greatest or least, signed or unsigned, exact integer in
the 256-bit range.
@end deffn


@deffn Syntax greatest-machine-word
@deffnx Syntax least-machine-word
On 32-bit platforms: evaluate to the greatest or least unsigned exact
integer in the 32-bit range.

On 64-bit platforms: evaluate to the greatest or least unsigned exact
integer in the 64-bit range.
@end deffn


@deffn Syntax greatest-c-unsigned-char
@deffnx Syntax greatest-c-signed-char
@deffnx Syntax least-c-unsigned-char
@deffnx Syntax least-c-signed-char
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{char} range.
@end deffn


@deffn Syntax greatest-c-unsigned-short
@deffnx Syntax greatest-c-signed-short
@deffnx Syntax least-c-unsigned-short
@deffnx Syntax least-c-signed-short
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{short int} range.
@end deffn


@deffn Syntax greatest-c-unsigned-int
@deffnx Syntax greatest-c-signed-int
@deffnx Syntax least-c-unsigned-int
@deffnx Syntax least-c-signed-int
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{int} range.
@end deffn


@deffn Syntax greatest-c-unsigned-long
@deffnx Syntax greatest-c-signed-long
@deffnx Syntax least-c-unsigned-long
@deffnx Syntax least-c-signed-long
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{long} range.
@end deffn


@deffn Syntax greatest-c-unsigned-long-long
@deffnx Syntax greatest-c-signed-long-long
@deffnx Syntax least-c-unsigned-long-long
@deffnx Syntax least-c-signed-long-long
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{long long} range.
@end deffn


@deffn Syntax greatest-c-pointer
@deffnx Syntax least-c-pointer
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{void *} range.
@end deffn


@deffn Syntax greatest-c-size_t
@deffnx Syntax least-c-size_t
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{size_t} range.
@end deffn


@deffn Syntax greatest-c-ssize_t
@deffnx Syntax least-c-ssize_t
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{ssize_t} range.
@end deffn


@deffn Syntax greatest-c-off_t
@deffnx Syntax least-c-off_t
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{off_t} range.
@end deffn


@deffn Syntax greatest-c-ptrdiff_t
@deffnx Syntax least-c-ptrdiff_t
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{ptrdiff_t} range.
@end deffn

@c ------------------------------------------------------------

@subsubheading Exclusive limits


@deffn Syntax greatest-u8*
@deffnx Syntax greatest-s8*
@deffnx Syntax least-u8*
@deffnx Syntax least-s8*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 8-bit range.
@end deffn


@deffn Syntax greatest-u16*
@deffnx Syntax greatest-s16*
@deffnx Syntax least-u16*
@deffnx Syntax least-s16*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 16-bit range.
@end deffn


@deffn Syntax greatest-u32*
@deffnx Syntax greatest-s32*
@deffnx Syntax least-u32*
@deffnx Syntax least-s32*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 32-bit range.
@end deffn


@deffn Syntax greatest-u64*
@deffnx Syntax greatest-s64*
@deffnx Syntax least-u64*
@deffnx Syntax least-s64*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 64-bit range.
@end deffn


@deffn Syntax greatest-s128*
@deffnx Syntax greatest-u128*
@deffnx Syntax least-u128*
@deffnx Syntax least-s128*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 128-bit range.
@end deffn


@deffn Syntax greatest-s256*
@deffnx Syntax greatest-u256*
@deffnx Syntax least-u256*
@deffnx Syntax least-s256*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the 256-bit range.
@end deffn


@deffn Syntax greatest-machine-word*
@deffnx Syntax least-machine-word*
On 32-bit platforms: evaluate to the greatest--plus--1 or
least--minus--1 unsigned exact integer in the 32-bit range.

On 64-bit platforms: evaluate to the greatest--plus--1 or
least--minus--1 unsigned exact integer in the 64-bit range.
@end deffn


@deffn Syntax greatest-c-unsigned-char*
@deffnx Syntax greatest-c-signed-char*
@deffnx Syntax least-c-unsigned-char*
@deffnx Syntax least-c-signed-char*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{char} range.
@end deffn


@deffn Syntax greatest-c-unsigned-short*
@deffnx Syntax greatest-c-signed-short*
@deffnx Syntax least-c-unsigned-short*
@deffnx Syntax least-c-signed-short*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{short int} range.
@end deffn


@deffn Syntax greatest-c-unsigned-int*
@deffnx Syntax greatest-c-signed-int*
@deffnx Syntax least-c-unsigned-int*
@deffnx Syntax least-c-signed-int*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{int} range.
@end deffn


@deffn Syntax greatest-c-unsigned-long*
@deffnx Syntax greatest-c-signed-long*
@deffnx Syntax least-c-unsigned-long*
@deffnx Syntax least-c-signed-long*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{long} range.
@end deffn


@deffn Syntax greatest-c-unsigned-long-long*
@deffnx Syntax greatest-c-signed-long-long*
@deffnx Syntax least-c-unsigned-long-long*
@deffnx Syntax least-c-signed-long-long*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{long long} range.
@end deffn


@deffn Syntax greatest-c-pointer*
@deffnx Syntax least-c-pointer*
Evaluate to the greatest--plus--1 or least--minus--1, signed or
unsigned, exact integer in the C language @code{void *} range.
@end deffn


@deffn Syntax greatest-c-size_t*
@deffnx Syntax least-c-size_t*
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{size_t*} range.
@end deffn


@deffn Syntax greatest-c-ssize_t*
@deffnx Syntax least-c-ssize_t*
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{ssize_t*} range.
@end deffn


@deffn Syntax greatest-c-off_t*
@deffnx Syntax least-c-off_t*
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{off_t} range.
@end deffn


@deffn Syntax greatest-c-ptrdiff_t*
@deffnx Syntax least-c-ptrdiff_t*
Evaluate to the greatest or least, signed or unsigned, exact integer in
the C language @code{ptrdiff_t} range.
@end deffn

@c page
@node cbuffers
@chapter Generalised C buffers and strings


When interfacing a C language foreign library with @value{PRJNAME}, it
is often needed to convert Scheme objects to raw memory blocks, possibly
containing @asciiz{} strings.

@menu
* cbuffers buffers::            Introduction to generalised C buffers.
* cbuffers strings::            Introduction to generalised C strings.
* cbuffers api::                Programming interface to generalised
                                C buffers and strings.
@end menu

@c page
@node cbuffers buffers
@section Introduction to generalised C buffers


Generalised C buffers are meant to be used in interfaces to foreign C
language libraries, when a pointer to raw data is required as argument.

A @dfn{generalised C buffer} is an object capable of holding an array of
mutable bytes referenced by a pointer; such Scheme objects are:
bytevectors, pointer objects, instances of @code{memory-block}.

A @dfn{generalised C sticky buffer} is an object capable of holding an
array of mutable bytes referenced by a pointer, whose data area is never
moved around by the garbage collector; such Scheme objects are: pointer
objects, instances of @code{memory-block}.  Sticky buffers are meant to
be used when calling out to C functions that call back to Scheme.

@vicareref{iklib memory blocks, Memory blocks} for details on memory
blocks.

Two arguments to function are usually needed to represent a generalised
C buffer: the buffer value itself and an optional length.

@enumerate
@item
The buffer argument is meant to be either bytevector, or
@code{memory-block} instance, or pointer object.

@item
The length argument is meant to be @false{} or an exact integer in the
range of the C language type @code{size_t}.  When the buffer argument is
a pointer object: the length argument must represent the number of bytes
available in the referenced memory block; otherwise the length argument
is ignored.
@end enumerate

Here is an example function accepting a generalised C buffer argument
@var{buf} and its optional length argument @var{buf.len}:

@example
(define fun
  (case-lambda
    ((buf)
     (fun buf #f))
    ((buf buf.len)
     (define who 'fun)
     (with-arguments-validation (who)
         ((general-c-buffer     buf)
          (general-c-buffer.len buf buf.len))
       (do-something-with buf buf.len)))))
@end example

@c page
@node cbuffers strings
@section Introduction to generalised C strings


Generalised C strings are meant to be used in interfaces to foreign C
language libraries, when a pointer to C string or input buffer is
required as argument.

A @dfn{generalised C string} is an object capable of holding the
representation of a C language string; such Scheme objects are: strings,
bytevectors, pointer objects, instances of @code{memory-block}.
@vicareref{iklib memory blocks, Memory blocks} for details on memory
blocks.

When a Scheme string is used as generalised C string: the application
must take care of converting the Scheme string into a C string
representation, for example using @func{string->ascii}.

When using generalised C strings we have to remember that:

@itemize
@item
A run of the garbage collector may move the data area of Scheme
bytevectors; for this reason Scheme bytevectors and Scheme strings
converted to bytevectors are not suitable as arguments to Scheme
functions interfacing to C functions that call back to Scheme.

@item
If a Scheme string is used as argument: the C function cannot modify it
by using it as output buffer.
@end itemize

@noindent
in these cases we should use generalised C buffers, @ref{cbuffers
buffers, Introduction to generalised C buffers}.

Two arguments to function are usually needed to represent a generalised
C string: the string value itself and an optional length.

@enumerate
@item
The string argument is meant to be either a string, or bytevector, or
@code{memory-block} instance, or pointer object.

@item
The length argument is meant to be @false{} or an exact integer in the
range of the C language type @code{size_t}.  When the string argument is
a pointer object: the length argument must represent the number of bytes
available in the referenced memory block; otherwise the length argument
is ignored.
@end enumerate

Here is an example function accepting a generalised C string argument
@var{str} and its optional length argument @var{str.len}, the string is
converted to bytevector with @func{string->ascii}:

@example
(define fun
  (case-lambda
    ((str)
     (fun str #f))
    ((str str.len)
     (define who 'fun)
     (with-arguments-validation (who)
         ((general-c-string     str)
          (general-c-string.len str str.len))
       (with-general-c-strings
           ((str^         str))
         (do-something-with str^ str.len))))))
@end example

@c page
@node cbuffers api
@section Programming interface to generalised C buffers and strings


@cindex Library @library{vicare arguments general-c-buffers}
@cindex @library{vicare arguments general-c-buffers}, library


The @api{} dealing with generalised C buffers and strings, is composed
of syntaxes used to validate and normalise the arguments before handing
them to the foreign function.

@ref{args predefined genbuffers, Validating generalised C buffer
arguments} for details on how to validation generalised C buffer
arguments.

@ref{args predefined genstrings, Validating generalised C string
arguments} for details on how to validation generalised C string
arguments.


The following bindings are exported by the library @library{vicare
arguments general-c-buffers}.


@defun general-c-buffer-len @var{buf} @var{buf.len}
Return the number of bytes in a generalised C buffer object.

@var{buf} must be a bytevector, pointer object or @code{memory-block}
struct instance.

When @var{buf} is a pointer object: @var{buf.len} must be an exact
integer (in the range of the C language type @code{size_t}) representing
the number of bytes available in the referenced memory block.  Otherwise
@var{buf.len} is ignored.
@end defun


@deffn Syntax with-general-c-strings ((@meta{str} @meta{expr}) ...) (string-to-bytevector @meta{string->bytevector}) @metao{body} . @meta{body}
@deffnx Syntax with-general-c-strings ((@meta{str} @meta{expr}) ...) @metao{body} . @meta{body}
@deffnx {Auxiliary Syntax} string-to-bytevector
Prepare some generalised C strings to be used by a chunk of code
expecting access to raw memory holding a C language string or input
buffer.

The values @meta{str} must be identifiers, unique according to
@func{bound-identifier=?}.

The values @meta{expr} must be expressions which will always be
evaluated only once.

The value @meta{string->bytevector} must be an expression evaluating to
a procedure which converts a string to a bytevector, for example
@func{string->ascii}.  In the second form of the syntax use:
@meta{string->bytevector} defaults to @func{string->ascii}.

For each couple @meta{str} and @meta{expr} do the following:

@itemize
@item
If the result of evaluating @meta{expr} is a bytevector, pointer object
or @code{memory-block} instance bind it to @meta{str}.

@item
If the result of evaluating @meta{expr} is a string: convert it to a
bytevector using the procedure result of evaluating
@meta{string->bytevector}, then bind it to @meta{str}.
@end itemize

Evaluate the @meta{body} forms in the region in which such bindings are
effective.  Return the return value of the last @meta{body} form.
@end deffn


@deffn Syntax with-general-c-strings/false ((@meta{str} @meta{expr}) ...) (string-to-bytevector @meta{string->bytevector}) @metao{body} . @meta{body}
@deffnx Syntax with-general-c-strings/false ((@meta{str} @meta{expr}) ...) @metao{body} . @meta{body}
@deffnx {Auxiliary Syntax} string-to-bytevector
Like @func{with-general-c-strings} but if a @meta{expr} evaluates
to @false{} accept the value.
@end deffn


@deffn Syntax with-general-c-pathnames ((@meta{ptn} @meta{expr}) ...) @metao{body} . @meta{body}
Prepare some generalised C strings to be used by a chunk of code
expecting access to raw memory holding a C language string representing
a file system pathname.

The values @meta{ptn} must be identifiers, unique according to
@func{bound-identifier=?}.

The values @meta{expr} must be expressions which will always be
evaluated only once.

For each couple @meta{ptn} and @meta{expr} do the following:

@itemize
@item
If the result of evaluating @meta{expr} is a bytevector, pointer object
or @code{memory-block} instance bind it to @meta{ptn}.

@item
If the result of evaluating @meta{expr} is a string: convert it to a
bytevector using the function referenced by the parameter
@func{string->pathname-func}, then bind it to @meta{ptn}.
@end itemize

Evaluate the @meta{body} forms in the region in which such bindings are
effective.  Return the return value of the last @meta{body} form.
@end deffn


@deffn Syntax with-general-c-pathnames/false ((@meta{ptn} @meta{expr}) ...) @metao{body} . @meta{body}
Like @func{with-general-c-pathnames} but if a @meta{expr} evaluates to
@false{} accept the value.
@end deffn


As example, let's say we have loaded C language code exposing a function
@cfunc{ikptr_posix_file_size}, which given a file pathname returns its
size; we can interface it as follows:

@example
#!r6rs
(import (vicare)
  (vicare arguments validation))

(define (file-size pathname)
  (define who 'file-size)
  (with-arguments-validation (who)
      ((general-c-string pathname))
    (with-general-c-pathnames ((pathname^ pathname))
      (foreign-call "ikptr_posix_file_size" pathname^))))
@end example

@c page
@node readline
@chapter Extended interface to @gnu{} Readline


@cindex Library @library{vicare readline}
@cindex @library{vicare readline}, library


The library @library{vicare readline} extends the basic readline @api{}
exported by @library{vicare} (@vicareref{iklib readline, Readline
interface}) with features specific to the @gnu{} Readline library.  The
following bindings:

@example
readline-enabled?
readline
make-readline-input-port
@end example

@noindent
exported by @library{vicare} are reexported by @library{vicare
readline}.


@defun rl-version
If support for readline is enabled and the linked library is @gnu{}
Readline: return an exact integer representing the @gnu{} Readline
version number as encoded in the C symbol @code{RL_READLINE_VERSION};
else return @false{}.  When this function returns @false{}: no other
@gnu{} Readline functions must be called, lest the process be aborted.
@end defun

@c page
@node parser logic
@chapter Defining parsers logic


@cindex Library @library{vicare parser-logic}
@cindex @library{vicare parser-logic}, library


The library @library{vicare parser-logic} defines an infrastructure to
declare the logic of a parser for sequences of characters; such logic
can be specialised for different underlying devices.  The library
heavily relies on macros.

@menu
* parser logic intro::          Introductory examples.
* parser logic operators::      The logic of parser operators.
* parser logic api::            Programming interface to
                                parser definition.
@end menu

@c page
@node parser logic intro
@section Introductory examples


@subsubheading Parsing a string of selected characters

As first usage example, let's see a simple parser using a full Scheme
string as argument and accepting lexemes being the empty string or
strings of characters @samp{#\a} and @samp{\#b}; the result of a call to
the parser is the list of characters or @false{} if the input is
invalid:

@example
#!r6rs
(import (vicare)
  (vicare parser-logic))

(module (parse-abba)

  (define (parse-abba input-string)
    (assert (string? input-string))
    (%parse-string input-string
                   (string-length input-string)
                   0    ;start index
                   '()  ;start value for ACCUMULATOR
                   ))

  (define-parser-logic define-string->abba-parser ch next fail
    (%parse-string (accumulator)
       ((:end-of-input)
        (reverse accumulator))
       ((#\a #\b)
        (next %parse-string (cons ch accumulator)))))

  (define-string->abba-parser string->token-or-false
    (%parse-string))

  #| end of module |# )

(parse-abba "")         @result{} ()
(parse-abba "a")        @result{} (#\a)
(parse-abba "b")        @result{} (#\b)
(parse-abba "1")        @result{} #f)
(parse-abba "ciao")     @result{} #f)
(parse-abba "abb")      @result{} (#\a #\b #\b)
@end example

@noindent
notice the use of @func{next} to recursively tail--call
@func{parse-string}.

The macro @func{string->token-or-false} is exported by @library{vicare
parser-logic}; it implements the device logic for a full input Scheme
string representing a lexeme; it is to be used in a parser returning
@false{} when the input is invalid.

The macros in the module combine their output and expand to the
definition of a function @func{%parse-string} equivalent to the
following:

@example
(define (%parse-string input.string input.length input.index
                       accumulator)
  (if (fx=? input.index input.length)
      (reverse accumulator)
    (let ((ch (string-ref input.string input.index)))
      (cond ((or (char=? #\a ch)
                 (char=? #\b ch))
             (%parse-string input.string input.length
                            (fx+ 1 input.index)
                            (cons ch accumulator)))
            (else #f)))))
@end example

@c ------------------------------------------------------------

@subsubheading Parsing a string of intermixed selected characters

Let's see a parser using a full Scheme string as argument and accepting
lexemes being the empty string or strings of characters @samp{#\a} and
@samp{\#b}:

@itemize
@item
@samp{#\a} can be followed only by @samp{#\b} or end--of--input.

@item
@samp{#\b} can be followed only by @samp{#\a} or end--of--input.
@end itemize

@noindent
the result of a call to the parser is the list of characters or @false{}
if the input is invalid:

@example
#!r6rs
(import (vicare)
  (vicare parser-logic))

(module (parse-abab)

  (define (parse-abab input-string)
    (assert (string? input-string))
    (%parse-string input-string
                   (string-length input-string)
                   0    ;start index
                   '()  ;start value for ACCUMULATOR
                   ))

  ;;Parser logic to convert a string of intermixed
  ;;#\a and #\b into a list of characters.
  (define-parser-logic define-string->abab-parser ch next fail
    (%parse-string (accumulator)
       ((:end-of-input)
        (reverse accumulator))
       ((#\a #\b)
        (if (or (null? accumulator)
                (case ch
                  ((#\a) (char=? #\b (car accumulator)))
                  ((#\b) (char=? #\a (car accumulator)))))
            (next %parse-string (cons ch accumulator))
          (fail)))))

  ;;Actual parser drawing characters from an input string.
  (define-string->abab-parser string->token-or-false
    (%parse-string))

  #| end of module |# )

(parse-abab "")         @result{} ()
(parse-abab "a")        @result{} (#\a)
(parse-abab "b")        @result{} (#\b)
(parse-abab "1")        @result{} #f
(parse-abab "ciao")     @result{} #f
(parse-abab "abb")      @result{} #f
(parse-abab "baa")      @result{} #f
(parse-abab "abab")     @result{} (#\a #\b #\a #\b)
(parse-abab "baba")     @result{} (#\b #\a #\b #\a)
@end example

@noindent
notice the use of @func{fail} to signal an input error from inside an
operator clause.

The macros in the module combine their output and expand to the
definition of a function @func{%parse-string} equivalent to the
following:

@example
(define (%parse-string input.string input.length input.index
                       accumulator)
  (if (fx=? input.index input.length)
      (reverse accumulator)
    (let ((ch (string-ref input.string input.index)))
      (cond ((or (char=? #\a ch)
                 (char=? #\b ch))
             (if (or (null? accumulator)
                     (case ch
                       ((#\a) (char=? #\b (car accumulator)))
                       ((#\b) (char=? #\a (car accumulator)))))
                 (%parse-string input.string input.length
                                (fx+ 1 input.index)
                                (cons ch accumulator))
               #f))
            (else #f)))))
@end example

@c ------------------------------------------------------------

@subsubheading Parsing exact integers in base @math{10}

Let's see a parser using a full Scheme string as argument and accepting
lexemes representing exact integers in base @math{10}; the result of a
call to the parser is the exact integer object or @false{} if the input
is invalid:

@example
#!r6rs
(import (vicare)
  (vicare parser-logic))

(define (parse-integer input-string)

  (define (%digit ch)
    ;;Given a character argument: return the corresponding
    ;;fixnum if the character is between #\0 and #\9, else
    ;;return false.
    ;;
    (let ((N (fx- (char->integer ch) (char->integer #\0))))
      (and (fx>= N 0)
           (fx<  N 10)
           N)))

  ;;Parser logic to convert a string into an exact integer
  ;;in base 10.
  (define-parser-logic define-string->integer-parser ch next fail
    (%parse-integer ()
       ((%digit) => D
        (next %parse-digit+ D)))
    (%parse-digit+ (accumulator)
       ((:end-of-input)
        accumulator)
       ((%digit) => D
        (next %parse-digit+ (+ D (* 10 accumulator))))))

  ;;Actual parser drawing characters from an input string.
  (define-string->integer-parser string->token-or-false
    (%parse-integer))

  (assert (string? input-string))
  (%parse-integer input-string (string-length input-string) 0))

(parse-integer "")              @result{} #f
(parse-integer "1")             @result{} 1
(parse-integer "123")           @result{} 123
(parse-integer "ciao")          @result{} #f
(parse-integer "123ciao")       @result{} #f
@end example

The macros in the body of @func{parse-integer} combine their output and
expand to the definition of two functions @func{%parse-integer} and
@func{%parse-digit+} equivalent to the following:

@example
(define (%parse-integer input.string input.length input.index)
  (if (fx=? input.index input.length)
      #f
    (let ((ch (string-ref input.string input.index)))
      (cond ((%digit ch)
             => (lambda (D)
                  (%parse-digit+ input.string input.length
                                 (fx+ 1 input.index) D)))
            (else #f)))))

(define (%parse-digit+ input.string input.length input.index
                       accumulator)
  (if (fx=? input.index input.length)
      accumulator
    (let ((ch (string-ref input.string input.index)))
      (cond ((%digit ch)
             => (lambda (D)
                  (%parse-digit+ input.string input.length
                                 (fx+ 1 input.index)
                                 (+ D (* 10 accumulator)))))
            (else #f)))))
@end example



@c page
@node parser logic operators
@section The logic of parser operators


After all the macros have been expanded, the parser is a set of
@dfn{operator functions} extracting characters from an input device with
the purpose of producing a token.  Some operators are ``entry points''
to the parser: public functions we can call to start parsing; other
operators are for internal use only.  Each operator is meant to either:
tail--call another operator, terminate parsing by raising an exception,
terminate parsing by returning an error value, terminate parsing
successfully by returning a token value.

@quotation
@strong{NOTE} Operator functions are just ordinary Scheme functions
playing a special role in a parser; they are given a name with the only
purpose of letting us talk about them, and it happens that such name is
``operator''.
@end quotation

Operators are generated by macros from a symbolic expression specifying
an abstract parser:

@example
(define-parser-logic define-parser ch next fail . @meta{operators})
@end example

@noindent
and containing a subexpression for each operator.  Access to the input
device is specified by another macro which must implement a set of
@func{syntax-rules}:

@example
(define-syntax device-logic
  (syntax-rules (:introduce-device-arguments
                 :generate-end-of-input-or-char-tests
                 :unexpected-end-of-input
                 :generate-delimiter-test
                 :invalid-input-char)
    ((_ :introduce-device-arguments          ---) ---)
    ((_ :generate-end-of-input-or-char-tests ---) ---)
    ((_ :unexpected-end-of-input             ---) ---)
    ((_ :generate-delimiter-test             ---) ---)
    ((_ :invalid-input-char                  ---) ---)))
@end example

Concrete parsers are defined by combining the parser logic with the
device logic:

@example
(define-parser device-logic (@meta{operator-name} ...))
@end example

@noindent
we can define any number of concrete parsers using the same parser logic
and different device logics; at the end of the expansion, the input
device forms are hard coded into the operator.  The list of
@meta{operator-name} is a list of identifiers bound to the operators
being entry points to the parser.

To understand the semantics of operators, let's consider one accepting
only the characters @samp{#\X} or @samp{#\Y} and rejecting the
end--of-input:

@example
(define (operator-1 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (error-form))
          ((char=? X ch)
           (a-clause-form))
          ((char=? Y ch)
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
such operator would be specified by the following @meta{operator}
symbolic subexpression:

@example
(operator-1 (parser-state)
  ((#\X)
   (a-clause-form))
  ((#\Y)
   (another-clause-form)))
@end example

@noindent
notice how the end--of--input test is automatically generated.  The
operator has some arguments representing the input device state and
other arguments representing the parser state; the list of input device
arguments comes first and is specified by the device logic, discussed
later; the list of parser state arguments comes last and is specified in
the @meta{operator} symbolic expression.

An operator function accepting characters @samp{#\X}, @samp{#\Y} or
@samp{#\Z}, with @samp{#\Y} and @samp{#\Z} to be processed in the same
way, and rejecting the end--of-input looks like this:

@example
(define (operator-2 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (error-form))
          ((char=? #\X ch)
           (a-clause-form))
          ((or (char=? #\Y ch)
               (char=? #\Z ch))
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
such operator would be specified by the following @meta{operator}
symbolic subexpression:

@example
(operator-2 (parser-state)
  ((#\X)
   (a-clause-form))
  ((#\Y #\Z)
   (another-clause-form)))
@end example

An operator function accepting characters @samp{#\X} or @samp{#\Y}, but
also the end--of--input from the device, looks like this:

@example
(define (operator-3 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (end-of-input-form))
          ((char=? #\X ch)
           (a-clause-form))
          ((char=? #\Y ch)
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
and is specified in the parser logic as the following @meta{operator}
symbolic subexpression:

@example
(operator-3 (parser-state)
  ((:end-of-input)
   (end-of-input-form))
  ((#\X)
   (a-clause-form))
  ((#\Y)
   (another-clause-form)))
@end example

An operator function accepting characters @samp{#\X} or @samp{#\Y}, the
end--of--input from the device, and also a set of end--of--lexeme
delimiter characters, looks like this:

@example
(define (operator-4 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (end-of-input-form))
          ((char=? #\X ch)
           (a-clause-form))
          ((char=? #\Y ch)
           (another-clause-form))
          ((end-of-lexeme-delimiter? ch)
           (end-of-input-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
notice how the @code{end-of-input-form} is used for both the proper
end--of--input state and the end--of--lexeme state; such operator is
specified in the parser logic as the following @meta{operator} symbolic
subexpression:

@example
(operator-4 (parser-state)
  ((:end-of-input)
   (end-of-input-form))
  ((X)
   (a-clause-form))
  ((Y)
   (another-clause-form)))
@end example

@noindent
notice that processing of the end--of--lexeme state is not specified in
the parser logic: its generation is completely delegated to the device
logic.

Sometimes it is useful to apply a test function or macro to an input
character and collect the result for further processing; this can be
done as follows:

@example
(define (the-test ch arg1 arg2 arg3)
  ---)

(define (operator-5 input-device parser-state)
  (let ((ch (get-next-char)))
    (cond ((end-of-input? ch)
           (error-form))
          ((the-test ch 1 2 3)
           => (lambda (result)
                (a-clause-form)))
          ((char=? #\Y ch)
           (another-clause-form))
          (else ;invalid input char
           (error-form)))))
@end example

@noindent
and is specified in the parser logic as the symbolic subexpression:

@example
(operator-5 (parser-state)
  ((the-test 1 2 3) => result
   (a-clause-form))
  ((#\Y)
   (another-clause-form)))
@end example

@noindent
where @func{=>} is the auxiliary syntax exported by @rsixlibrary{base}.

@c page
@node parser logic api
@section Programming interface to parser definition


The following bindings are exported by the library @library{vicare
parser-logic}.


@deffn Syntax define-parser-logic @meta{definer} @meta{ch} @meta{next} @meta{fail} . @meta{operators}
@deffnx {Auxiliary Syntax} :end-of-input
Define an abstract parser specifying the rules for parsing the input
characters through calls to a set of operator functions; the result of
the expansion is a syntax definition which can be used to instantiate a
concrete parser by combining the parser logic with the input device
logic.

The input arguments are:

@table @asis
@item @meta{definer}
It must be an identifier.  It is bound to the generated syntax
definition; such syntax is used as follows:

@example
(@meta{definer} @meta{device-logic} (@meta{operator-name} @dots{}))
@end example

@noindent
where: @meta{device-logic} is the identifier bound to the device logic
syntax; the @meta{operator-name} are identifiers among the public
operator function names.

@item @meta{ch}
It must be an identifier.  When a character is successfully extracted
from the input device, it is bound to this identifier and made available
to the operator clauses.

@item @meta{next}
It must be an identifier.  The device logic rule
@code{:generate-end-of-input-or-char-tests} must bind it to a syntax;
such syntax must expand to a tail--call to an operator processing the
next input character.  @meta{next} is used as follows in the operator
clauses:

@example
(next @meta{operator-name} @meta{operator-arg} @dots{})
@end example

@noindent
and it should expand to something like:

@example
(@meta{operator-name} @meta{device-arg} @dots{} @meta{operator-arg} @dots{})
@end example

@noindent
where: @meta{device-arg} are the arguments representing the input device
state; @meta{operator-arg} are the arguments representing the parser
state as specified in the @meta{operator-spec}.

@item @meta{fail}
It must be an identifier.  The device logic rule
@code{:generate-end-of-input-or-char-tests} must bind it to a syntax;
such syntax is used to handle parsing errors detected by the operator
clauses.  @meta{fail} is simply used as @code{(@meta{fail})}.
@end table

Each @meta{operator-spec} must have the form:

@example
(@meta{operator-name} (@meta{operator-arg} @dots{}) @meta{operator-clause} @dots{})
@end example

@noindent
where:

@table @asis
@item @meta{operator-name}
Must be an identifier.  It is bound to a generated operator function.

There is no difference in the way public operators and private ones are
specified; the public operators names are listed in the concrete parser
definition.  An operator can be public in a concrete parser and private
in another concrete parser.

@item @meta{operator-arg}
Must be identifiers bound to the formal arguments associated to the
parser state.

@item @meta{operator-clause}
Are symbolic expressions specifying the input accepted by the operator.
@end table

Each @meta{operator-clause} must have one of the formats:

@table @code
@item ((@metao{char} @meta{char} @dots{}) @metao{body} @meta{body} @dots{})
Each @meta{char} must be an expression evaluating to a Scheme character
object.  The @meta{body} forms are evaluated if the input character
bound to @meta{ch} is equal, according to @func{char=?}, to one among
the @meta{char} characters.

@item ((@meta{func} @meta{expr} @dots{}) => @meta{ret} @metao{body} @meta{body} @dots{})
@meta{func} must be an expression evaluating to a function; the
@meta{expr} must be expressions; @meta{ret} must be an identifier.  The
@meta{body} forms are evaluated if the form:

@example
(@meta{func} @meta{ch} @meta{expr} @dots{})
@end example

@noindent
evaluates to a true value; such true value is bound to @meta{ret} prior
to evaluating the @meta{body}.

@item ((:end-of-input) @metao{body} @meta{body} @dots{})
The @meta{body} forms are evaluated if no more characters are available
from the input device.  This clause is to be used by operators accepting
the end--of--input state as valid; if such rule is not present: the
end--of--input will cause an error and the device logic is used to
handle it.
@end table
@end deffn

@c ------------------------------------------------------------

@deffn {Auxiliary Syntax} :introduce-device-arguments
@deffnx {Auxiliary Syntax} :generate-end-of-input-or-char-tests
@deffnx {Auxiliary Syntax} :unexpected-end-of-input
@deffnx {Auxiliary Syntax} :generate-delimiter-test
@deffnx {Auxiliary Syntax} :invalid-input-char
Identifiers used to specify device logic syntax rules; they must be used
in a syntax definition like:

@example
(define-syntax device-logic
  (syntax-rules (:introduce-device-arguments
                 :generate-end-of-input-or-char-tests
                 :unexpected-end-of-input
                 :generate-delimiter-test
                 :invalid-input-char)
    ((_ :introduce-device-arguments          ---) ---)
    ((_ :generate-end-of-input-or-char-tests ---) ---)
    ((_ :unexpected-end-of-input             ---) ---)
    ((_ :generate-delimiter-test             ---) ---)
    ((_ :invalid-input-char                  ---) ---)))
@end example

@noindent
the rules have the following syntax:

@table @code
@item :introduce-device-arguments
The input form is:

@example
(_ :introduce-device-arguments @meta{kont} . @meta{rest})
@end example

@noindent
this rule introduces a list of identifiers used as device--specific
arguments; they will be the first arguments for each parser operator
function.  The output form must be:

@example
(@meta{kont} (@meta{device-arg} @dots{}) . @meta{rest})
@end example

@noindent
where the @meta{device-arg} are identifiers.

@item :generate-end-of-input-or-char-tests
The input form is:

@example
(_ :generate-end-of-input-or-char-tests
   @meta{ch} @meta{next} @meta{fail}
   (@meta{device-arg} @dots{})
   @meta{end-of-input-kont} @meta{parse-input-char-kont})
@end example

@noindent
this rule is used to generate the input device tests for an operator
function.  The expanded code must first test for the end--of--input
state and then proceed to evaluate code for the input character; in
pseudocode the output form should be:

@example
(if (end-of-input? @meta{device-arg} ...)
    @meta{end-of-input-kont}
  (let ((@meta{ch} (get-next-char @meta{device-arg} ...)))
    @meta{parse-input-char-kont}))
@end example

@meta{ch} is an identifier.  The input character must be bound to it
before evaluating @meta{parse-input-char-kont}.

@meta{next} is an identifier.  This rule must bind it to a syntax used
to tail--call another operator using @meta{device-arg} as first
arguments; for example:

@example
(define-syntax @meta{next}
  (syntax-rules ()
    ((_ ?operator-name ?operator-arg ...)
     (?operator-name @meta{device-arg} ... ?operator-arg))))
@end example

@meta{fail} is an identifier.  This rule must bind it to a syntax used
to signal an error detected by an operator clause; for example:

@example
(define-syntax @meta{fail}
  (syntax-rules ()
    ((_)
     (error #f "invalid input character"
       @meta{device-arg} ...))))
@end example

The @meta{device-arg} are the identifiers introduced by
@code{:introduce-device-arguments}.

@meta{end-of-input-kont} is a form to be evaluated whenever the
end--of--input is detected.

@meta{parse-input-char-kont} is a form to be evaluated whenever a
character is extracted from the input device.

@item :unexpected-end-of-input
The input form is:

@example
(_ :unexpected-end-of-input (@meta{device-arg} @dots{}))
@end example

@noindent
whenever the end--of--input is found by an operator that does not accept
it as valid, this rule is used to decide what to do.

The @meta{device-arg} are the identifiers introduced by
@code{:introduce-device-arguments}.

The output form can return a value or raise an exception; the returned
value becomes the return value of the call to the parser.

@item :generate-delimiter-test
The input form is:

@example
(_ :generate-delimiter-test
   @meta{ch}
   @meta{ch-is-delimiter-kont}
   @meta{ch-is-not-delimiter-kont})
@end example

@noindent
this rule is used for input devices for which the lexeme string is
embedded into a sequence of other characters, so there exists a set of
characters that delimit the end--of--lexeme.  The parser delegates to
the device the responsibility of knowing which characters are
delimiters, if any.

@meta{ch} is an identifier bound to the input character.
@meta{ch-is-delimiter-kont} is a form to be evaluated whenever @meta{ch}
is a delimiter character.  @meta{ch-is-not-delimiter-kont} is a form to
be evaluated whenever @meta{ch} is not a delimiter character.

For parsers accepting a full Scheme string as lexeme: there are no
delimiters,3 the end--of--lexeme is the end--of--input; such parsers
should just use @meta{ch-is-not-delimiter-kont} as output form.

For parsers having delimiter characters, for example, recognised by a
function like:

@example
(define (delimiter? ch)
  (or (char=? ch #\space)
      (char=? ch #\linefeed)))
@end example

@noindent
the output form should be something like:

@example
(if (delimiter? @meta{ch})
    @meta{ch-is-delimiter-kont}
  @meta{ch-is-not-delimiter-kont})
@end example

@item :invalid-input-char
The input form is:

@example
(_ :invalid-input-char (@meta{device-arg} @dots{}) @meta{ch})
@end example

@noindent
whenever an input character is not accepted by an operator function this
rule is used to decide what to do.

The @meta{device-arg} are the identifiers introduced by
@code{:introduce-device-arguments}; @meta{ch} is an identifier bound to
the invalid input character.

The output form can return a value or raise an exception; the returned
value becomes the return value of the call to the parser.
@end table
@end deffn

@c ------------------------------------------------------------

@deffn Syntax string->token-or-false @meta{keyword} @meta{arg} ...
Define the device logic to parse a lexeme from a full Scheme string
object as in @func{string->number}.  It is implemented as follows:

@example
(define-syntax string->token-or-false
  (syntax-rules (:introduce-device-arguments
                 :generate-end-of-input-or-char-tests
                 :unexpected-end-of-input
                 :generate-delimiter-test
                 :invalid-input-char)
    ((_ :introduce-device-arguments
        ?kont . ?rest)
     (?kont (input.string input.length input.index) . ?rest))

    ((_ :invalid-input-char
        (?input.string ?input.length ?input.index)
        ?ch)
     #f)

    ((_ :unexpected-end-of-input
        (?input.string ?input.length ?input.index))
     #f)

    ((_ :generate-delimiter-test
        ?ch ?ch-is-delimiter-kont ?ch-is-not-delimiter-kont)
     ?ch-is-not-delimiter-kont)

    ((_ :generate-end-of-input-or-char-tests
        ?ch ?next ?fail
        (?input.string ?input.length ?input.index)
        ?end-of-input-kont ?parse-input-char-kont)
     (let-syntax
         ((?fail (syntax-rules ()
                   ((_) #f)))
          (?next (syntax-rules ()
                   ((_ ?operator-name ?operator-arg (... ...))
                    (?operator-name ?input.string ?input.length
                                    (fx+ 1 ?input.index)
                                    ?operator-arg (... ...))))))
       (if (fx=? ?input.index ?input.length)
           ?end-of-input-kont
         (let ((?ch (string-ref ?input.string ?input.index)))
           ?parse-input-char-kont))))
    ))
@end example
@end deffn

@c page
@node gcc
@chapter A toy library interface to @gcc{}


@cindex Library @library{vicare gcc}
@cindex @library{vicare gcc}, library


The library @library{vicare gcc} is installed along with
@value{PRJNAME}; it implements a toy interface to @command{gcc}, the
@gnu{} C Compiler.  Its purpose is to build, at runtime, a C language
shared library from possibly dynamically constructed C code; then load
the library and access a C function as @ffi{} callout.

@library{vicare gcc} must be considered as a toy to demonstrate the
features of @value{PRJNAME}; it is installed only if the @posix{},
@gnu{} C library and Libffi @api{}s are enabled at package configuration
time.

The following is an example of function to increment an integer:

@example
#!r6rs
(import (vicare)
  (prefix (vicare gcc) gcc.))

(gcc.initialise "/usr/local/bin/gcc" "/home/marco/var/tmp/")

(gcc.define-c-function
  signed-int incr (signed-int)
  "#include <stdio.h>
   int incr (int a) @{
     return 1+a;
   @}")

(incr 1)        @result{} 2
@end example

@noindent
the code creates a shared library @code{libincr.so} in a subdirectory of
the given initialisation directory, then load it and access the symbol
@code{incr}.

@library{vicare gcc} depends upon the following libraries:

@example
(vicare ffi)
(vicare posix)
(vicare glibc)
(vicare platform constants)
(vicare language-extensions syntaxes)
@end example


@defun initialise @var{gcc} @var{tmpdir}
Initialise the library.  @var{gcc} must be the string full filename of
the @gcc{} executable.  @var{tmpdir} must be the string pathname of an
existing directory on a partition with executable permissions; it is
used to create temporary files, including the shared libraries.

Temporary files go in a subdirectory of @var{tmpdir}; it is the
responsibility of the system administrator to clean up regularly such
subdirectories.
@end defun


@deffn Syntax define-c-function @meta{retval} @meta{name} @meta{args} @meta{code}
Define a new Scheme function wrapping a C function from a shared
library.  @meta{name} must be an identifier representing the name of the
function.

@meta{retval} must be a symbol selecting the type of the return value;
@meta{args} must be a list of symbols selecting the types of the
arguments; @vicareref{ffi call types, Specifying native types} for
details.

@meta{code} must be a Scheme string representing the C code to be
compiled.
@end deffn


@deffn Parameter COMPILE-FLAGS
References a list of string.  Base options for the compiler, it is
initialised to @code{("-c")}.
@end deffn


@deffn Parameter LINK-FLAGS
References a list of string.  Base options for the linker, it is
initialised to @code{("-pipe" "-shared" "-fPIC")}.
@end deffn


@deffn Parameter CFLAGS
References a list of string.  Additional options for the compiler, it is
initialised to @code{("-O2")}.
@end deffn


@deffn Parameter LDFLAGS
References a list of string.  Additional options for the linker, it is
initialised to nil.
@end deffn

@c page
@node wtables
@chapter Weak hashtables


@cindex Library @library{vicare containers weak-hashtables}
@cindex @library{vicare containers weak-hashtables}, library


Weak hashtables are associative containers whose keys are held by weak
references: registering a key into a weak hashtable does not prevent its
garbage collection.  A weak hashtable is a Scheme vector holding nulls
or associative lists; each vector slot is called @dfn{bucket}; the
associative lists have the spine composed of strong pairs, while the
entries are weak pairs:

@example
|-----|-----|-----|-----|-----| vector of buckets
         |
         v
      |-----|-----|strong pair
         |      |
         |       ------------> |-----|-----|strong pair
         |                        |     |
      |-----|-----|weak pair      |      -------> null
        key  value                v
                               |-----|-----| weak pair
                                 key  value
@end example

Whenever a key in a weak hashtable is garbage collected: the
corresponding location in the weak pair is set to the @acronym{BWP}
object (a special unique object that has this exact purpose); whenever a
bucket is accessed, it is first cleared of weak pairs holding
@acronym{BWP} in key position.

@quotation
@strong{NOTE} Immediate values (those that fit into a single machine
word: @true{}, @false{}, nil, fixnums, characters, etc.)@: and interned
symbols are @strong{never} garbage collected.  If we use them as weak
hashtable keys: the associated entries will never be removed from the
table unless we explicitly do it with @func{weak-hashtable-delete!}  or
@func{weak-hashtable-clear!}.
@end quotation

When the number of collected objects equals the number of buckets
(whatever the distribution of elements), the table is enlarged doubling
the number of buckets; the table is @strong{never} restricted by
reducing the number of buckets.

At present, weak hashtables are subjected to the following constraints:

@itemize
@item
The number of buckets is always an exact power of @math{2}.

@item
The maximum number of buckets is the value of @code{(greatest-fixnum)}.

@item
The maximum number of entries is the value of @code{(greatest-fixnum)}.
@end itemize

The @api{} of weak hashtables is similar to the @api{} of @rnrs{6}
hashtables.  The following bindings are exported by the library
@library{vicare containers weak-hashtables}.


@defun make-weak-hashtable @var{hash-function} @var{equiv-function}
@defunx make-weak-hashtable @var{hash-function} @var{equiv-function} @var{dimension}
Build and return a new weak hashtable using @var{hash-function} as hash
function for keys and @var{equiv-function} as comparison function
between keys.  When @var{dimension} is used: it is approximately the
initial number of buckets; when not used it defaults to @math{16}.
@end defun


@defun weak-hashtable? @var{obj}
Return @true{} if @var{obj} is a weak hashtable, otherwise @false{}.
Weak hashtables are disjoint values.
@end defun


@deffn {Validation Clause} weak-hashtable @var{obj}
Validation clause to be used with the facilities of the library
@library{vicare arguments validation}.  Succeed if @var{obj} is an
instance of @code{weak-hashtable}.
@end deffn


@defun weak-hashtable-set! @var{table} @var{key} @var{value}
Add an entry to @var{table} holding @var{key} and @var{value}.  Return
unspecified values.
@end defun


@defun weak-hashtable-ref @var{table} @var{key} @var{default}
Search for @var{key} in @var{table}; if found: return the corresponding
value, else return @var{default}.
@end defun


@defun weak-hashtable-contains? @var{table} @var{key}
Return @true{} if @var{table} contains an entry for @var{key}, else
return @false{}.
@end defun


@defun weak-hashtable-delete! @var{table} @var{key}
If @var{key} is in @var{table}: remove it, else do nothing.  Return
unspecified values.
@end defun


@defun weak-hashtable-size @var{table}
Return the approximate number of entries in @var{table}.  The returned
value can be incorrect if some keys have been garbage collected but the
corresponding entries in the table are not yet removed.
@end defun


@defun weak-hashtable-clear! @var{table}
Remove all the entries from @var{table}.  The number of buckets is reset
to the its initial value.  Return unspecified values.
@end defun


@defun weak-hashtable-keys @var{table}
Return a vector holding the keys in @var{table}.
@end defun


@defun weak-hashtable-entries @var{table}
Return two values: a vector holding the keys in @var{table}, a vector
holding the values in @var{table}.
@end defun


@defun weak-hashtable-update! @var{table} @var{key} @var{proc} @var{default}
If no entry exists for @var{key} in @var{table}: create a new entry
associating @var{key} to the result of applying @var{proc} to
@var{default}.

If an entry exists for @var{key} in @var{table}: replace its value with
the result of applying @var{proc} to the old value.
@end defun

@c page
@node flonum format
@chapter Formatting flonums


@cindex Library @library{vicare numerics flonum-formatter}
@cindex @library{vicare numerics flonum-formatter}, library


The following bindings are exported by the library @library{vicare
numerics flonum-formatter}.


@defun format-flonum @var{positive?} @var{digits} @var{exponent}
Given a list of characters @var{digits} and a fixnum @var{exponent}
compose a string representing the corresponding flonum.  @var{positive?}
determines the sign.

@example
#!r6rs
(import (vicare)
  (vicare numerics flonum-formatter))

(define digits
  '(#\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9))

(format-flonum #t digits 0)     @result{} "0.123456789"
(format-flonum #t digits 1)     @result{} "1.23456789"
(format-flonum #t digits 2)     @result{} "12.3456789"
(format-flonum #t digits 3)     @result{} "123.456789"
(format-flonum #t digits 8)     @result{} "12345678.9"
(format-flonum #t digits 9)     @result{} "123456789.0"
(format-flonum #t digits 10)    @result{} "1.23456789e9"

(format-flonum #t digits -1)    @result{} "0.0123456789"
(format-flonum #t digits -2)    @result{} "0.00123456789"
(format-flonum #t digits -3)    @result{} "0.000123456789"
(format-flonum #t digits -4)    @result{} "1.23456789e-5"

(format-flonum #f digits 1)     @result{} "-1.23456789"
(format-flonum #f digits 2)     @result{} "-12.3456789"
(format-flonum #f digits 3)     @result{} "-123.456789"
(format-flonum #f digits 8)     @result{} "-12345678.9"
(format-flonum #f digits 9)     @result{} "-123456789.0"
(format-flonum #f digits 10)    @result{} "-1.23456789e9"

(format-flonum #f digits -1)    @result{} "-0.0123456789"
(format-flonum #f digits -2)    @result{} "-0.00123456789"
(format-flonum #f digits -3)    @result{} "-0.000123456789"
(format-flonum #f digits -4)    @result{} "-1.23456789e-5"
@end example
@end defun

@c page
@node flonum parse
@chapter Parsing flonums


@cindex Library @library{vicare numerics flonum-parser}
@cindex @library{vicare numerics flonum-parser}, library


The following bindings are exported by the library @library{vicare
numerics flonum-parser}.


@defun parse-flonum @var{flonum} @var{real-func} @var{unreal-func}
Parse the @var{flonum} its components for string formatting.

If @var{flonum} is representable as real number, apply the function
@var{real-func} to @math{3} arguments: a boolean, true if @var{flonum}
is positive; a list of characters representing the digits of
@var{flonum}; a fixnum representing the exponent of @var{flonum}.
Return the result of the application.

If @var{flonum} is not representable as real number, apply the function
@var{unreal-func} to a single argument being the string representation
of @var{flonum}.  Return the result of the application.

Notice how the arguments handed to @var{real-func} match the argument of
@func{format-flonum} from @library{vicare flonum-formatter}.

@example
#!r6rs
(import (vicare)
  (vicare numerics flonum-parser))

(parse-flonum 1.23456789
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (real #t
    (#\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
     #\0 #\0 #\0 #\0 #\0 #\0 #\0 #\1)
    1)

(parse-flonum 12.34e5
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (real #t (#\1 #\2 #\3 #\4) 7)

(parse-flonum -12.34e5
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (real #f (#\1 #\2 #\3 #\4) 7)

(parse-flonum +inf.0
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (unreal "+inf.0")

(parse-flonum +nan.0
              (lambda args (cons 'real args))
              (lambda args (cons 'unreal args)))
@result{} (unreal "+nan.0")
@end example
@end defun

@c page
@node debugging
@chapter Debugging facilities


@menu
* debugging compiler::          Inspecting the compiler internals.
@end menu

@c page
@node debugging compiler
@section Inspecting the compiler internals


@cindex Library @library{vicare debugging compiler}
@cindex @library{vicare debugging compiler}, library


The following bindings are exported by the library @library{vicare
debugging compiler}.

@c page
@node bytevector compounds
@chapter Bytevector compounds


@cindex Library @library{vicare containers bytevector-compounds}
@cindex @library{vicare containers bytevector-compounds}, library


A @dfn{bytevector compound} is a sequence of octets split into a
sequence of bytevectors.  Bytevector compounds have a special @api{} to
handle the sequence of octets as a First--in First--out queue.
Bytevector compounds are defined by the library @library{vicare
containers bytevector-compounds}.

@menu
* bytevector compounds types::    Data type definitions.
* bytevector compounds inspect::  Inspecting bytevector compounds.
* bytevector compounds queue::    Queue programming interface.
* bytevector compounds access::   Accessors and mutators.
@end menu

@c page
@node bytevector compounds types
@section Data type definitions


The following bindings are exported by the library @library{vicare
containers bytevector-compounds}.


@deftp {@rnrs{6} Record Type} bytevector-compound
@cindex Argument @var{bvcom}
@cindex Function argument @var{bvcom}
@cindex @var{bvcom}, function argument
Record type representing a bytevector compound.  When instances of this
type are used as arguments to functions: this documentation identifies
them as @var{bvcom}.
@end deftp


@defun bytevector-compound? @var{obj}
Return @true{} if @var{obj} is an instance of
@code{bytevector-compound}, else return @false{}.
@end defun

@c ------------------------------------------------------------

@subsubheading Validation clauses

The following bindings are to be used with the facilities of the library
@library{vicare arguments validation}, @ref{args, Optional function
arguments validation}.


@deffn {Validation Clause} bytevector-compound @var{obj}
@deffnx {Validation Clause} false-or-bytevector-compound @var{obj}
Succeed if @var{obj} is an instance of @code{bytevector-compound}.  The
second clause accepts also @false{}.
@end deffn


@deffn {Validation Clause} bytevector-compound/filled @var{obj}
Succeed if @var{obj} is an instance of @code{bytevector-compound} and it
contains at least one octet.
@end deffn

@c page
@node bytevector compounds inspect
@section Inspecting bytevector compounds


The following bindings are exported by the library @library{vicare
containers bytevector-compounds}.


@defun bytevector-compound-empty? @var{bvcom}
Return @true{} if @var{bvcom} has no octets in it, else return @false{}.
@end defun


@defun bytevector-compound-filled? @var{bvcom}
Return @true{} if @var{bvcom} has at least one octet in it, else return
@false{}.
@end defun


@defun bytevector-compound-length @var{bvcom}
Return a non--negative exact integer representing the number of octets
currently in @var{bvcom}.
@end defun


@defun bytevector-compound-total-length @var{bvcom}
Return a non--negative exact integer representing the number of octets
in @var{bvcom}, including the ones in the bytevectors that have been
already dequeued.
@end defun


@defun bytevector-compound-data @var{bvcom}
Return the list of bytevectors in @var{bvcom}.  Mutating the return
value results in undefined behaviour.
@end defun

@c page
@node bytevector compounds queue
@section Queue programming interface


The following bindings are exported by the library @library{vicare
containers bytevector-compounds}.


@defun bytevector-compound-enqueue! @var{bvcom} @var{item}
Enqueue the bytevector @var{item} into @var{bvcom}.  Return unspecified
values.
@end defun


@defun bytevector-compound-dequeue! @var{bvcom}
Dequeue the next bytevector from @var{bvcom} and return it; return
@false{} if @var{bvcom} is empty.
@end defun

@c page
@node bytevector compounds access
@section Accessors and mutators


The following bindings are exported by the library @library{vicare
containers bytevector-compounds}.


@defun bytevector-compound-u8-set! @var{bvcom} @var{idx} @var{octet}
@defunx bytevector-compound-u8-ref @var{bvcom} @var{idx}
Accessor and mutator for non-negative exact integers in the range
@math{[0, 255]}.
@end defun


@defun bytevector-compound-s8-set! @var{bvcom} @var{idx} @var{byte}
@defunx bytevector-compound-s8-ref @var{bvcom} @var{idx}
Accessor and mutator for non-negative exact integers in the range
@math{[-128, 127]}.
@end defun

@c page
@node getopts
@chapter Parsing command line arguments


@cindex @library{vicare getopts}, library
@cindex Library @library{vicare getopts}


The library @library{vicare getopts} implements basic parsing of
Unix--style command line arguments.  It is meant to be used as
low--level module in an infrastructure for command line interface
programs (@acronym{CLI}).  It is alternative to @ansrfi{37}, @ref{srfi
args-fold, @ansrfi{37} a program argument processor}.

It is suggested to import this library with the prefix @samp{getopts.},
as in:

@example
(import (vicare)
  (prefix (vicare getopts) getopts.))
@end example

@menu
* getopts intro::               Introduction.
* getopts types::               Type definitions.
* getopts config::              Parser configuration.
* getopts parser::              Parsing arguments.
* getopts conditions::          Exceptions and condition objects.
@end menu

@c page
@node getopts intro
@section Introduction


Command line arguments are available through the @func{command-line}
function from the @rsixlibrary{programs} library.  For the purposes of
this documentation, command line arguments are divided into three
categories:

@table @asis
@item Option without value
A string selecting a configuration option that can be turned on or off.
It can be a single character (brief option) or a full--word (long
option).

@item Option with value
A string selecting a value for a configuration option; an option's value
is a string of any length, including the empty string.

@item Non--option
A value to be passed to the program.
@end table

Let's assume that:

@itemize
@item
@option{-v}, @option{-i} and @option{-h} are brief options that do not
require a value.

@item
@option{-f}, @option{-o} and @option{-I} are brief options that do
require a value.

@item
@option{--verbose}, @option{--interactive} and @option{--help} are long
options that do not require a value.

@item
@option{--file}, @option{--output} and @option{--include} are long
options that do require a value.
@end itemize

@noindent
the following command line chunks are so interpreted:

@table @code
@item -vh -o green -i -Iwhite -f red
The @option{-v}, @option{-h} and @option{-i} options without value; the
@option{-o} option with value @samp{green}; the @option{-I} option with
value @samp{white}; the @option{-f} option with value @samp{red}.

@item --verbose --help --output=green --interactive
@itemx --include white --file=red
The @option{--verbose}, @option{--help} and @option{--interactive}
options without value; the @option{--output} option with value
@samp{green}; the @option{--include} option with value @samp{white}; the
@option{--file} option with value @samp{red}.
@end table

The argument @code{--} is recognised as ``end of options'' marker: all
the arguments following it are interpreted as non--options, even if
their string starts with a dash or double dash.

Chains of brief options are allowed: the options @option{-v},
@option{-i} and @option{-h} can be selected with the single argument
@code{-vih}.  Notice, though, that only options with no value can be
chained; an option with value can appear only as last in the train, with
no value attached.  For example:

@example
-vihI white
@end example

@noindent
is interpreted as the options @option{-v}, @option{-i} and @option{-h}
with no value followed by the option @option{-I} with value
@samp{white}; the following:

@example
-vihIwhite              ;forbidden
@end example

@noindent
could be made possible but, being unreadable, it is forbidden.

Notice that a single dash, @samp{-}, is a valid non--option argument.

@c page
@node getopts types
@section Type definitions


@deftp {@rnrs{6} Record Type} command-line-option
Type of records representing command line options.
@end deftp


@defcv {Immutable Field} command-line-option brief
A Scheme character representing a dash plus single character (brief)
option selector; to specify an option with no brief selector, we can set
this field to @false{}.
@end defcv


@defcv {Immutable Field} command-line-option long
A Scheme string representing a long option selector, without the
double--dash prefix; to specify an option with no long selector, we can
set this field to @false{}.
@end defcv


@defcv {Immutable Field} command-line-option requires-argument?
Boolean, true if this option requires an argument.
@end defcv


@defcv {Immutable Field} command-line-option description
Scheme string describing this option, to be used in help screens.
@end defcv


@defcv {Immutable Field} command-line-option action
Semantic action, a closure to be invoked when this option is found on
the command line.

@itemize
@item
If the field @code{requires-argument?} is set to @false{}: the closure
is applied to a single value being the @code{command-line-option} record
representing the option.

@item
If the field @code{requires-argument?} is set to @true{}: the closure is
applied to two values being the @code{command-line-option} record
representing the option and the Scheme string representing the option's
value.
@end itemize

We have to remember that @code{command-line-option} records can be
compared with @func{eq?}.
@end defcv


@defun make-command-line-option @var{brief} @var{long} @var{requires-argument?} @var{description} @var{action}
Build and return a new @code{command-line-option} record.
@end defun


@defun command-line-option? @var{obj}
Return @true{} if @var{obj} is a record of type
@code{command-line-option}, otherwise return @false{}.
@end defun


@deffn Syntax define-command-line-option @meta{name} @meta{clause} ...
@deffnx {Auxiliary Syntax} brief @meta{char}
@deffnx {Auxiliary Syntax} long @meta{string}
@deffnx {Auxiliary Syntax} requires-argument @meta{bool}
@deffnx {Auxiliary Syntax} description @meta{string}
@deffnx {Auxiliary Syntax} action @meta{function}
Build a new @code{command-line-option} record and bind it to
@meta{name}, which must be a Scheme symbol.  All the @meta{clause}
arguments must be subforms with an auxiliary syntactic keyword as first
element.  Example:

@example
(define-command-line-option interactive
  (brief               #\i)
  (long                "interactive")
  (requires-argument   #f)
  (description         "ask the user first")
  (action              (lambda (option) ---)))
@end example
@end deffn


@defun command-line-option-brief @var{opt}
@defunx command-line-option-long @var{opt}
@defunx command-line-option-requires-argument? @var{opt}
@defunx command-line-option-description @var{opt}
@defunx command-line-option-action @var{opt}
Accessors for the fields of a @code{command-line-option} record.
@end defun

@c page
@node getopts config
@section Parser configuration


@deftp Enumeration getopts-configuration
Enumeration to be used to configure the @func{getopts} parser.  It
contains the following symbols:

@table @code
@item delayed
If given, action closures invocations are returned in a list rather that
immediately evaluated; this allows @func{getopts} to parse the whole
command line without changing the state of the program.

The returned list has a thunk for each semantic action, in the same
order in which the corresponding arguments appear on the command line.
We can evaluate the thunks with:

@example
(let ((thunks (getopts ---)))
  (for-each (lambda (T) (T)) thunks))
@end example

@item ignore-multiple-double-dashes
The first double--dash argument, @samp{--}, always marks the end of
options.  If this option is given, multiple @samp{--} after the first
are all ignored; else they are interpreted as non--option arguments.
@end table
@end deftp


@deffn Syntax getopts-options @var{symbol} ...
Expand into an enumerated set of symbols to be used to configure the
operations of the @func{getopts} parser.
@end deffn

@c page
@node getopts parser
@section Parsing arguments


@defun getopts @var{command-line} @var{options} @var{argument-action}
@defunx getopts @var{command-line} @var{options} @var{argument-action} @var{config-options}
Parse the Scheme strings in the list @var{command-line} as command line
arguments, according to the options described by the list @var{options}
of @code{command-line-option} records.  If the configuration option
@code{delayed} is not used, the return value is @false{}.

@var{argument-action} must be a Scheme function accepting a single
argument: a Scheme string representing a command line non--option.

The optional @var{config-options} must be an enumerated set of values
from the @code{getopts-configuration} enumeration.
@end defun


Meaningless usage example:

@example
(import (vicare)
  (vicare getopts)
  (only (vicare language-extensions syntaxes)
        set-cons!))

(define result #f)

(define (register-with opt val)
  (set-cons! result (list (command-line-option-long opt) val)))

(define (register-without opt)
  (set-cons! result (list (command-line-option-long opt))))

(define (register-non-option arg)
  (set-cons! result arg))

(define-command-line-option interactive
  (brief               #\i)
  (long                "interactive")
  (requires-argument   #f)
  (description         "ask the user first")
  (action              register-without))

(define-command-line-option force
  (brief               #\f)
  (long                "force")
  (requires-argument   #f)
  (description         "hurt me plenty")
  (action              register-without))

(define-command-line-option help
  (brief               #\h)
  (long                "help")
  (requires-argument?  #f)
  (description         "print help screen")
  (action              register-without))

(define-command-line-option file
  (brief               #\F)
  (long                "file")
  (requires-argument   #t)
  (description         "input file")
  (action              register-with))

(define-command-line-option archive
  (brief               #\A)
  (long                "archive")
  (requires-argument   #t)
  (description         "output archive")
  (action              register-with))

(getopts (command-line)
         (list interactive force help file archive)
         register-non-option
         (getopts-options ignore-multiple-double-dashes))
@end example

@c page
@node getopts conditions
@section Exceptions and condition objects


When @func{getopts} detects an error in the input command line
arguments, it raises a continuable exception; returning from the
exception is possible and makes @func{getopts} go on parsing with the
next argument.  It is not always advisable to continue parsing after an
error has been signaled.

The raised exception values are compound condition of the types
described below.

@c ------------------------------------------------------------

@subsubheading Base condition object


@deftp {Condition Type} &getopts
Base type for all the condition objects thrown by @func{getopts}; it is
derived from @condition{error}.  It has no fields.
@end deftp


@defun make-getopts-condition
@defunx getopts-condition? @var{obj}
Constructor and predicate for the @condition{getopts} condition object.
@end defun

@c ------------------------------------------------------------

@subsubheading Option data object


@deftp {Condition Type} &option
Data condition type used to hold records of type
@code{command-line-option} describing an option involved in an error; it
is derived from @condition{condition}.
@end deftp


@defun make-option-condition @var{option-record}
@defunx option-condition? @var{obj}
Constructor and predicate for the @condition{option} condition object.
@end defun


@defun condition-option @var{option-condition}
Accessor for the @code{option} field of a @condition{option} condition
object.
@end defun

@c ------------------------------------------------------------

@subsubheading Argument data object


@deftp {Condition Type} &argument
Data condition type used to hold Scheme strings representing command
line arguments involved in an error; it is derived from
@condition{condition}.
@end deftp


@defun make-argument-condition @var{argument-string}
@defunx argument-condition? @var{obj}
Constructor and predicate for the @condition{argument} condition object.
@end defun


@defun condition-argument @var{argument-condition}
Accessor for the @code{argument} field of a @condition{argument} condition
object.
@end defun

@c ------------------------------------------------------------

@subsubheading Option selector data object


@deftp {Condition Type} &brief/long
Data condition type used to hold Scheme strings or characters
representing option selectors involved in an error; it is derived from
@condition{condition}.
@end deftp


@defun make-brief/long-condition @var{brief/long-string}
@defunx brief/long-condition? @var{obj}
Constructor and predicate for the @condition{brief/long} condition object.
@end defun


@defun condition-brief/long @var{brief/long-condition}
Accessor for the field of a @condition{brief/long} condition object.
@end defun

@c ------------------------------------------------------------

@subsubheading Unknown option error


@deftp {Condition Type} &unknown-option
Condition type used to signal an ``unknown option'' error; it is derived
from @condition{getopts}.  It has no fields.
@end deftp


@defun make-unknown-option-condition
@defunx unknown-option-condition? @var{obj}
Constructor and predicate for @condition{unknown-option} condition objects.
@end defun


@defun raise-unknown-option @var{who} @var{brief/long} @var{argument} @var{message}
Raise a continuable exception describing an ``unknown option'' error;
the raised object is a compound condition with components of the
following types: @condition{who}, @condition{brief/long}, @condition{argument},
@condition{message}.
@end defun

@c ------------------------------------------------------------

@subsubheading Option requires value error


@deftp {Condition Type} &option-requires-value
Condition type used to signal an ``option requires value'' error; it is
derived from @condition{getopts}.  It has no fields.
@end deftp


@defun make-option-requires-value-condition
@defunx option-requires-value-condition? @var{obj}
Constructor and predicate for @condition{option-requires-value} condition
objects.
@end defun


@defun raise-option-requires-value @var{who} @var{option} @var{argument} @var{message}
Raise a continuable exception describing an ``option requires value''
error; the raised object is a compound condition with components of the
following types: @condition{who}, @condition{option}, @condition{argument},
@condition{message}.
@end defun

@c ------------------------------------------------------------

@subsubheading Option requires no value error


@deftp {Condition Type} &option-requires-no-value
Condition type used to signal an ``option requires no value'' error; it
is derived from @condition{getopts}.  It has no fields.
@end deftp


@defun make-option-requires-no-value-condition
@defunx option-requires-no-value-condition? @var{obj}
Constructor and predicate for @condition{option-requires-no-value} condition
objects.
@end defun


@defun raise-option-requires-no-value @var{who} @var{option} @var{argument} @var{message}
Raise a continuable exception describing an ``option requires no value''
error; the raised object is a compound condition with components of the
following types: @condition{who}, @condition{option}, @condition{argument},
@condition{message}.
@end defun

@c ------------------------------------------------------------

@subsubheading Invalid option error


@deftp {Condition Type} &invalid-option
Condition type used to signal an ``invalid option'' error; it is derived
from @condition{getopts}.  It has no fields.
@end deftp


@defun make-invalid-option-condition
@defunx invalid-option-condition? @var{obj}
Constructor and predicate for @condition{invalid-option} condition objects.
@end defun


@defun raise-invalid-option @var{who} @var{option} @var{argument} @var{message}
Raise a continuable exception describing an ``invalid option'' error;
the raised object is a compound condition with components of the
following types: @condition{who}, @condition{option},
@condition{argument}, @condition{message}.
@end defun

@c end of file


@c end of file


@c page

@include lang.texi
@include srfi.texi
@include posix.texi
@include glibc.texi
@include iconv.texi
@include linux.texi

@include libs-net-channels.texi

@include libs-lists.texi
@include libs-vectors.texi
@include libs-strings.texi
@include libs-char-sets.texi
@include libs-bytevectors.texi
@include knuth-morris-pratt.texi
@include levenshtein.texi
@include object-properties.texi
@include one-dimension.texi

@include libs-randomisations.texi

@include irregex.texi
@include pregexp.texi
@include formations.texi

@include cre2.texi

@include gpl-3.0.texi

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function

@printindex fn

@node variable index
@appendix An entry for each variable

@printindex vr

@node type index
@appendix An entry for each type

@printindex tp

@bye

@c end of file
