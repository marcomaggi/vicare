\input texinfo.tex
@c %**start of header
@setfilename vicare.info
@settitle Vicare Scheme User's Guide
@c %**end of header

@include version.texi

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@macro version{}
@value{VERSION}
@end macro

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro


@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro class{NAME}
@code{<\NAME\>}
@end macro

@macro aclass{NAME}
<\NAME\>
@end macro

@macro cclass{NAME}
<\NAME\>
@end macro

@macro objtype{NAME}
@code{\NAME\}
@end macro

@macro condition{NAME}
@code{&\NAME\}
@end macro

@macro rtd{}
@acronym{RTD}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro csv{}
@acronym{CSV}
@end macro

@macro eof{}
@acronym{EOF}
@end macro

@macro fifo{}
@acronym{FIFO}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro oob{}
@acronym{OOB}
@end macro

@macro os{}
@acronym{OS}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro rfc{}
@acronym{RFC}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro

@c ------------------------------------------------------------
@c Software acronyms.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro ip{}
@acronym{IP}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro func{NAME}
@code{\NAME\}
@end macro

@macro snull{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@c @macro rsixref{NODE, TITLE}
@c @ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@c @end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro

@macro autoconfref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,autoconf}
@end macro

@macro vicareref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,vicare}
@end macro

@macro nauref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa}
@end macro

@macro naumoreref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa-more}
@end macro

@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@c The following macro does not work.  It appears that it is not
@c possible to use "@cindex" in the expansion of a macro because the DVI
@c output will not work.  Texinfo output would work, though.  Tested
@c with "texi2dvi" version 1.135 (GNU Texinfo 4.13).
@c
@c @macro cindexRsixlibrary{THING}
@c @cindex @rsixlibrary{\THING\}, library
@c @cindex Library, @rsixlibrary{\THING\}
@c @end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@c ------------------------------------------------------------
@c To be used in normal text.

@macro meta{THING}
<\THING\>
@end macro

@macro metao{THING}
<\THING\0>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@macro metan{THING}
<\THING\N>
@end macro

@macro metani{THING}
<\THING\N+1>
@end macro

@c ------------------------------------------------------------
@c To be used inside @example environment and @samp directives.

@macro cmeta{THING}
<\THING\>
@end macro

@macro cmetao{THING}
<\THING\0>
@end macro

@macro cmetai{THING}
<\THING\1>
@end macro

@macro cmetaii{THING}
<\THING\2>
@end macro

@macro cmetaiii{THING}
<\THING\3>
@end macro

@macro cmetan{THING}
<\THING\N>
@end macro

@macro cmetani{THING}
<\THING\N+1>
@end macro

@c ------------------------------------------------------------
@c To be used inside argument lists.

@macro ameta{THING}
<\THING\>
@end macro

@macro ametao{THING}
<\THING\0>
@end macro

@macro ametai{THING}
<\THING\1>
@end macro

@macro ametaii{THING}
<\THING\2>
@end macro

@macro ametaiii{THING}
<\THING\3>
@end macro

@macro ametan{THING}
<\THING\N>
@end macro

@macro ametani{THING}
<\THING\N+1>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro varo{THING}
@var{\THING\0}
@end macro

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro

@c ------------------------------------------------------------

@macro void{}
@code{#<void>}
@end macro


@macro eol{}
@acronym{EOL}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set PRJNAME                    Vicare

@set TITLE                      Vicare Scheme User's Guide

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Vicare Scheme

@c To be used as @value{PACKAGE_NICKNAME} whenever we need to include
@c the nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           vicare

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Abdulaziz Ghuloum

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{aghuloum@@cs.indiana.edu}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2010-2011


@set TARBALLURL                 @url{http://github.com/marcomaggi/vicare/downloads}
@set REPOSITORYURL              @url{http://github.com/marcomaggi/vicare/}
@set EXECUTABLE                 @command{vicare}
@set RAWEXECUTABLE              vicare

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, an
@rnrs{6} compliant native compiler for the Scheme language producing
single threaded programs running on Intel x86 32-bit processors, with
experimental support for 64-bit machines.  @emph{Vicare} is pronounced
the etruscan way.

The Vicarus Scheme package is distributed under the terms of the @gnu{}
General Public License (@gpl{}) and can be downloaded from:

@center @url{http://github.com/marcomaggi/vicare/downloads}

@noindent
the home page of the project is at:

@center @url{http://marcomaggi.github.com/vicare.html}

@noindent
development takes place at:

@center @url{http://github.com/marcomaggi/vicare/}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by Marco Maggi.@*
Copyright @copyright{} 2006-2010 by Abdulaziz Ghuloum.

This document is derived from the original Ikarus documentation by the
@value{PACKAGE} contributors.

@quotation
This program is free software: you can redistribute it and/or modify it
under the terms of the @gnu{} General Public License version 3 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the @gnu{} General Public License
along with this program.  If not, see
@url{http://www.gnu.org/licenses/}.
@end quotation

Trademarks used herein are the property of their respective owners.
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@shortcontents
@contents

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* vicare: (vicare).             @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore


@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of Vicare Scheme.
* using::                       Using the program.
* iklib::                       Extensions library.
* posix::                       The @posix{} interface.
* glibc::                       The @gnu{} C Library interface.
* linux::                       The @gnu{}+Linux interface.
* syslib::                      Low level, fast, unsafe operations.
* capi::                        C language programming interface.

Internals

* objects::                     Built in objects.
* debug int::                   Debug mode.
* compiler::                    Wild notes on the compiler internals.

Appendices

* missing::                     Missing Features.
* building::                    Building infrastructure.
* credits::                     Credits for this document.
* package license::             @gnu{} General Public License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

External documents

* libffi: (libffi).             Libffi documentation.

@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of Vicare Scheme


Scheme is a statically scoped and properly tail--recursive dialect of
the Lisp programming language invented by Guy Lewis Steele Jr.  and
Gerald Jay Sussman.  It was designed to have an exceptionally clear and
simple semantics and few different ways to form expressions.

The ``Revised^6 Report on the Algorithmic Language Scheme'' (@rnrs{6})
gives a defining description of the programming language Scheme.  The
report is the work of many people in the course of many years; revision
6 was edited by Michael Sperber, R. Kent Dybvig, Matthew Flatt and Anton
Van Straaten.

Ikarus Scheme is an almost @rnrs{6} compliant implementation of the
Scheme programming language; it is the creation of Abdulaziz Ghuloum.

Vicare Scheme is an @rnrs{6} compliant fork of Ikarus Scheme, aiming at
becoming a native compiler producing single threaded programs running on
Intel x86 32-bit processors, with experimental support for 64-bit
machines.  @emph{Vicare} is pronounced the etruscan way.

@menu
* overview original::           Original Ikarus Scheme.
* overview tech::               Technology overview.
* overview resources::          Resources.
* overview system::             System requirements.
* overview install::            Installation and uninstallation.
* overview restrictions::       Implementation restrictions.
* overview repl::               The read-eval-print loop.
@end menu

@c page
@node overview original
@section Original Ikarus Scheme


The original Ikarus Scheme package is distributed under the terms of the
@gnu{} General Public License (@gpl{}) and can be downloaded from:

@center @url{http://www.ikarus-scheme.org/}

@noindent
or:

@center @url{https://launchpad.net/ikarus}

It was developed by Abdulaziz Ghuloum until the beginning of year 2010;
at that time the Vicare fork was started.

@c page
@node overview tech
@section Technology overview


@value{PRJNAME} Scheme provides the programmer with many advantages:

@table @strong

@item Optimizing code generator
The compiler's backend employs state of the art technologies in code
generation that produce fast, efficient, machine code.  When developing
computationally intensive programs, one is not constrained by using a
slow interpreter.

@item Fast incremental compilation
Every library and script is quickly compiled to native machine code.
When developing large software, one is not constrained by how slow the
batch compiler runs.

@item Robust and fine--tuned standard libraries
The standard libraries are written such that they perform as much error
checking as required to provide a safe and fast runtime environment.

@item Multi--generational garbage collector
The BiBOP based garbage collector used in @value{PRJNAME} allows the runtime
system to expand its memory footprint as needed.  The entire 32-bit
virtual address space could be used and unneeded memory is released back
to the operating system.

@item Supports many operating systems
@value{PRJNAME} runs on the most popular and widely used operating systems for
servers and personal computers.  The supported systems include Mac OS X,
@gnu{}+Linux, FreeBSD, NetBSD, and Microsoft Windows (under Cygwin).
@end table

@c page
@node overview resources
@section Resources


The @value{PACKAGE} package is distributed under the terms of the @gnu{}
General Public License (@gpl{}) and can be downloaded from:

@center @value{TARBALLURL}

@noindent
the home page of the project is at:

@center @url{http://marcomaggi.github.com/vicare.html}

@noindent
development takes place at:

@center @value{REPOSITORYURL}

Newcomers to Scheme should refer to @url{http://@/www.schemers.org},
which contains listings of tutorials and books that are helpful in
learning the language.

This document is a supplement to the @emph{Revised^6 Report on the
Algorithmic Language Scheme}, found at @url{http://@/www.r6rs.org}.
Kent Dybvig's @emph{The Scheme Programming Language}, Fourth Edition, is
an excellent tutorial and reference for @rnrs{6}.  Some extended
features of @value{PRJNAME} have been inspired by similar features in
@emph{Chez Scheme}; the @emph{Chez Scheme User's Guide} can be found at
the same site.

@c page
@node overview system
@section System requirements


To run @value{PACKAGE}, we will need a system with a relatively recent
Intel @emph{x86} processor; @value{PRJNAME} requires a Unix/Linux
operating system (or emulation), and some prerequisite libraries.

@menu
* overview system hardware::    Hardware requirements.
* overview system software::    Software requirements.
@end menu

@c page
@node overview system hardware
@subsection Hardware requirements


@value{PACKAGE} runs on the IA-32 (@emph{x86}) architecture supporting
@acronym{SSE2} extensions.  This includes the Athlon 64, Sempron 64, and
Turion 64 processors from @acronym{AMD} and the Pentium 4, Xeon,
Celeron, Pentium M, Core, and Core2 processors from Intel.  The system
does not run on Intel Pentium III or earlier processors.

The @value{PRJNAME} compiler generates @acronym{SSE2} instructions to
handle Scheme's @acronym{IEEE} floating point representation
(@emph{flonums}) for inexact numbers.


@subsubheading Operating systems

@value{PRJNAME} is tested under the following operating systems; in
general, any later version of one of these systems should be usable:

@itemize
@item
Mac OS X version 10.4 and 10.5.

@item
Linux 2.6.18 (Debian, Fedora, Gentoo, and Ubuntu).

@item
FreeBSD version 6.2.

@item
NetBSD version 3.1.

@item
Microsoft Windows XP, using Cygwin 1.5.24 (@url{http://@/cygwin.org}).
@end itemize

@c page
@node overview system software
@subsection Software requirements


We will need some additional libraries and tools to build
@value{PACKAGE}.

@table @strong
@item GMP
@value{PRJNAME} uses the @gnu{} Multiple Precision Arithmetic Library
(@gmp{}) for some bignum arithmetic operations.  To build
@value{PRJNAME} from scratch, @gmp{} version 4.2 or better must be
installed along with the required header files.  Pre--built @gmp{}
packages are available for most operating systems.  Alternatively,
@gmp{} can be downloaded from @url{http://@/gmplib.org/}.

The @gmp{} web page points out that @gmp{} has revealed subtle bugs in
many C compilers.  Although the @gmp{} build process includes a
comprehensive self--test (which we absolutely must run if building it
ourselves), we may still prefer to obtain a prebuilt binary version for
our system, if one is available.

@quotation
@strong{NOTE} @value{PRJNAME} runs in 32-bit mode only.  To run it in
64-bit environments, we will have to obtain the 32-bit version of
@gmp{}, or compile it ourselves after adding @code{ABI=32} to its
configuration options.
@end quotation

@item libffi
We will probably need @code{libffi}, a C library that simplifies
run--time calls to arbitrary C functions.  @value{PRJNAME} will operate
without @code{libffi}, but will not be able to call foreign procedures
(those written in C).  @code{libffi} can be downloaded from
@url{http://@/sourceware.org/@/libffi}.

@item GCC
The @gnu{} C Compiler is required to build the @value{PRJNAME}
executable (e.g. the garbage collector, loader, and OS--related
runtime).  @gcc{} versions 4.1 and 4.2 were successfully used to build
@value{PRJNAME}.  It may be possible to build @value{PRJNAME} using
other C compilers.

@item Autoconf and Automake
The @gnu{} Autoconf (version 2.61) and @gnu{} Automake (version 1.10)
tools are required if one wishes to modify the @value{PRJNAME} source
base.  They are not required to build the official release of
@value{PRJNAME}.

Prebuilt packages for these tools have been created for most Unix/Linux
systems; if we prefer, we can download the source code from
@url{http://@/www.gnu.org/@/software/@/autoconf} and
@url{http://@/www.gnu.org/@/software/@/automake} respectively, and build
them ourselves.

@item Texinfo
This document is provided in Texinfo format.  Texinfo is available as an
installable package for most Unix/Linux systems.  Alternatively, we can
download the source package
@url{http://@/www.gnu.org/@/software/@/texinfo}.
@end table

@c page
@node overview install
@section Installation and uninstallation


@cindex Installing @value{PRJNAME}
@cindex Uninstalling @value{PRJNAME}
@cindex Disinstalling @value{PRJNAME}
@cindex @value{PRJNAME}, installing
@cindex @value{PRJNAME}, uninstalling
@cindex @value{PRJNAME}, disinstalling


There are two ways to install @value{PACKAGE} on our system: we can
either install a prebuilt package, if one is available for our operating
system, or we can build it from source.  There are two reasons to prefer
the ``build from source'' approach: first, not all Unix/Linux package
repositories have an @value{PACKAGE} package at all; second, prebuilt
packages often lag current revisions to the system by a considerable
amount.  Therefore, the version we install from a package repository
might not even have some of the features documented in this manual.

We will assume in this section that we are building @value{PACKAGE}
ourselves.  @value{PRJNAME} uses the standard installation method found
in most other Unix software.  Thus we will follow the usual steps.

@enumerate
@item
Download the software.

@item
Set configuration options.

@item
Build and install
@end enumerate

@menu
* overview install quick::              Quick installation guide.
* overview install prerequisites::      Installing the prerequisites.
* overview install details::            Installation details.
* overview install uninstall::          Uninstalling @value{PRJNAME}.
@end menu

@c page
@node overview install quick
@subsection Quick installation guide


If familiar with installing Unix software on our system, then all we
need to know is that @value{PRJNAME} uses the standard installation
method found in most other Unix software.  Simply run the following
commands from the shell:

@example
$ tar -xvzf vicare-n.n.n.tar.gz
$ cd vicare-n.n.n
$ ./configure [--prefix=path] [CFLAGS=-I/dir] [LDFLAGS=-L/dir]
$ make
$ make install
@end example

@noindent
@ref{overview install details} for how to enable the foreign functions
interface.

To uninstall @value{PACKAGE}, use the following steps:

@example
$ cd path/to/vicare-n.n.n
$ make uninstall
@end example

The rest of this section gives more detail on building, installing, and
uninstalling @value{PACKAGE}.

@c page
@node overview install prerequisites
@subsection Installing the prerequisites


The first step is to ensure that we have @gmp{} and Libffi installed; we
should generally use our system's package manager for these.  Note where
the include (@code{.h}) and library (@code{.a}) files for each of these
packages are installed.  (Typically this will be in either
@file{/usr/@/include} and @file{/usr/@/lib}, or
@file{/usr/@/local/@/include} and @file{/usr/@/local/@/lib}.)

If we choose to download these as source and build them ourselves, refer
to the installation instructions found in each package.  If we are
installing @gmp{} from source, it is @emph{essential} that we run the
self--tests after building, and verify that no errors were detected.  We
do this by issuing the command @command{make check}; see the
documentation for details.

@c page
@node overview install details
@subsection Installation details


We have two choices for downloading the @value{PACKAGE} source: we can
either download a distribution from:

@center @value{TARBALLURL}

@noindent
or we can checkout a revision from the GitHub repository:

@center @value{REPOSITORYURL}

@itemize
@item
@value{PACKAGE} source distributions are tarballs named
@file{vicare-@-@var{@var{n.n.n}}.tar.gz}, where @file{@var{n.n.n}} is a
3--component ID indicating the current revision.

If we downloaded a distribution, unpack it.  From the shell prompt:

@example
$ tar -xvzf vicare-@var{n.n.n}.tar.gz
@end example

@noindent
this creates the base directory @file{vicare-@var{n.n.n}}.

@item
If we downloaded a bleeding--edge snapshot, no unpacking is needed.
@end itemize

We configure the build system by running the @command{configure} script
located in the base directory.  To do this, type the following commands:

@example
$ cd vicare-@var{n.n.n}
$ ./configure
checking build system type... i386-apple-darwin8.10.1
checking host system type... i386-apple-darwin8.10.1
...
configure: creating ./config.status
config.status: creating Makefile
config.status: creating src/Makefile
config.status: creating scheme/Makefile
config.status: creating doc/Makefile
config.status: executing depfiles commands
@end example

This configures the system to be built then installed in the
system--wide location (binaries are normally installed in
@file{/usr/@/local/@/bin}).  To install it in another location (e.g. in
your home directory), provide a @option{--prefix} location to
@command{configure} as follows:

@example
$ ./configure --prefix=/opt/sw
@end example

@noindent
this will install the executable in @file{/opt/@/sw/@/bin}, libraries in
@file{/opt/@/sw/@/lib/@/ikarus}, and documentation in
@file{/opt/@/sw/@/share/@/doc/@/ikarus}.

To install @value{PACKAGE} for personal use (thus not requiring root
permissions to install), specify @code{--prefix=$HOME/local}, which
installs everything in a @file{local} directory of our home directory.

@command{configure} allows us to fine--tune where things are installed,
though this is rarely necessary or useful.  Do
@code{./configure@tie{}--help} for a full list of options.

The most common @command{configure} options are as follows.

@table @asis
@item @option{--prefix}
Specify the location in the file system where @value{PACKAGE} will be
installed.

@item @option{--enable-ffi}
Include @value{PACKAGE}'s Foreign Function Interface, so that
@value{PRJNAME} code can invoke C code, and vice versa; requires Libffi.

@item @option{--disable-arguments-validation}
Disable arguments validation for the functions in Vicare's boot image;
use with care: an invalid argument will cause undefined behaviour (most
likely a process crash).

@item @env{CFLAGS}
Specify options to be used while compiling @value{PRJNAME}'s C code.

@item @env{CPPFLAGS}
Specify options to be used while preprocessing @value{PRJNAME}'s C code.

@item @env{LDFLAGS}
Specify options to be used while linking @value{PRJNAME}.
@end table

@command{configure} will fail if it cannot find the location where
@gmp{} is installed.  The script will also fail if we have specified
@option{--enable-ffi} and it can't find Libffi.  If running
@command{configure} fails to locate either of these libraries, we will
need to provide their locations.  Use the @env{CPPFLAGS} and
@env{LDFLAGS} options to specify the locations of the header and library
files.

For example, assume that we have installed @gmp{} and Libffi in
subdirectories of @file{/opt/sw}, and we wish to support foreign
functions.@footnote{The @command{configure} command shown here is very
imposing, and anyone can easily make mistakes.  In general, it's a good
idea to create a shell script that has the sequence of
@command{configure} and @command{make} commands needed to configure,
build, and install a package; this not only allows us to re--install
easily, but also gives us a concrete indication of what options we used
to build the software the last time.  Of course, we should put this
script somewhere other than in the actual @value{PRJNAME} software
directory!}

@example
./configure                                                  \
  --prefix=$HOME/local                                       \
  --enable-ffi                                               \
  CPPFLAGS="-I/opt/sw/gmp/include -I/opt/sw/libffi/include"  \
  LDFLAGS="-L/opt/sw/gmp/lib -L/opt/sw/libffi/lib"
@end example

We can use the @env{CFLAGS} and @env{LDFLAGS} variables to select more
specialized compilation and linking options; refer to the compiler
documentation for more details.

We can now build the system by running the command @command{make}, with
no arguments; this performs two tasks:

@enumerate
@item
It builds the @command{vicare} executable from the C files located in
the @file{src} directory.

@item
It uses the @command{vicare} executable and the pre--built
@file{ikarus.boot.orig} boot file to rebuild the Scheme boot image file
@file{vicare.boot} from the Scheme sources located in the @file{scheme}
directory.
@end enumerate

The final stage is to install @value{PRJNAME} via the command
@command{make install}.  If we're installing @value{PRJNAME} in a
system--wide location, we probably need to have administrator privileges
(use the @command{sudo} or @command{su} commands); if that's not
feasible, then we need to reconfigure to install within a directory tree
under our home directory.

Finally, try a small session, to verify that everything installed
properly.

@example
$ vicare
Vicare Scheme version 0.1d0+ \
  (revision master/d844c006eb9ada1a047be3893d0dd40f8ae6204a, \
  build 2010-05-02)
Copyright (c) 2006-2010 Abdulaziz Ghuloum and contributors

> (display "hello, world!\n")
hello, world!
> (define twice (lambda (f) (lambda (x) (f (f x)))))
> ((twice add1) 3)
5
@end example

If we get the first @code{>} prompt, then @value{PRJNAME} was
successfully installed on the system.  We may need to update the
@env{PATH} variable in environment to contain the directory in which the
@command{vicare} executable was installed.

Finally, do @command{make clean} to get rid of executables, object
files, and other build products in the @file{vicare-@var{n.n.n}}
directory.  Do not delete the directory itself: it will be needed if we
ever want to uninstall @value{PRJNAME}.

@c page
@node overview install uninstall
@subsection Uninstalling @value{PRJNAME}


@cindex @value{PRJNAME}, uninstalling
@cindex @value{PRJNAME}, disinstalling
@cindex Disinstalling @value{PRJNAME}
@cindex Uninstalling @value{PRJNAME}


To uninstall @value{PACKAGE}, go to the directory we built
@value{PRJNAME} in (not the directory where you installed it), and do
@command{make uninstall}.

@example
$ cd path/to/vicare-@var{n.n.n}
$ make uninstall
@end example

@c page
@node overview restrictions
@section Implementation restrictions


Here is a list of implementations constraints which may be
non--compliant with @rnrs{6}.

@enumerate
@item
Scheme strings can hold at most @code{(greatest-fixnum)} characters; the
length of a string and all the valid indexes into strings are
representable as fixnums.

@item
Scheme bytevectors can hold at most @code{(greatest-fixnum)} bytes; the
length of a bytevector and all the valid indexes into bytevectors are
representable as fixnums.

@item
The last argument to @func{apply} can be a list of at most @math{8192}
values.  This is an artificially set limit to avoid problems with huge
values (it could be greater than this).  As comparison: LispWorks for
Unix sets this value to 300, LispWorks for Windows and LispWorks for
Linux set this value to 255 (last verified from its online documenattion
in November, 2011).
@end enumerate

@c page
@node overview repl
@section The read-eval-print loop


Scheme implementations compliant with @rnrs{6} live in a somewhat uneasy
tension with a standard Scheme @acronym{REPL} (read--eval--print loop),
which the Report effectively does not define.

In particular, the effect of reimporting a module, as you might do when
reloading and rerunning a program, isn't well--defined by @rnrs{6}.
This is a limitation caused by the particular design choices made in
@rnrs{6}.

Accordingly, the interactive mode is intended for quick experimenting
with the built in features.  It is intended neither for developing
applications nor for writing any substantial piece of code.

@c page
@node using
@chapter Using @value{PRJNAME}


Once @value{PACKAGE} is properly installed, we can invoke it either in
an interactive terminal session or as the interpreter for invoking a
script.

@cindex Command line
@cindex Invoking @value{PRJNAME}

@menu
* using interactive::           Interactive sessions.
* using invoking::              Command line arguments.
* using script::                Using @command{scheme-script}.
* using libraries::             @rnrs{6} libraries.
@end menu

@c page
@node using interactive
@section Interactive sessions


If we want an interactive session, use a bare @value{EXECUTABLE}
command, with no options.

@example
$ @value{RAWEXECUTABLE}
Vicare Scheme version 0.1d0+ \
  (revision master/d844c006eb9ada1a047be3893d0dd40f8ae6204a, \
   build 2010-05-02)
Copyright (c) 2006-2010 Abdulaziz Ghuloum and contributors

> (+ 2 2)
4
@end example

@noindent
end--of--file (@key{Ctrl-D} in a typical terminal window) will terminate
the session.

@c page
@node using invoking
@section Command line arguments


The synopsis of the @value{EXECUTABLE} program is as follows:

@smallexample
@value{RAWEXECUTABLE} [@var{OPTIONS}] [PROGRAM]                      [-- [@var{PROGRAM OPTS}]]
@value{RAWEXECUTABLE} [@var{OPTIONS}] --r6rs-script PROGRAM          [-- [@var{PROGRAM OPTS}]]
@value{RAWEXECUTABLE} [@var{OPTIONS}] --r6rs-repl PROGRAM            [-- [@var{PROGRAM OPTS}]]
@value{RAWEXECUTABLE} [@var{OPTIONS}] --script CODE                  [-- [@var{PROGRAM OPTS}]]
@value{RAWEXECUTABLE} [@var{OPTIONS}] --compile-dependencies PROGRAM [-- [@var{PROGRAM OPTS}]]
@end smallexample

@noindent
the @var{OPTIONS} are interpreted by @value{EXECUTABLE}, @var{PROGRAM
OPTS} can be obtained using the @func{command-line} procedure in the
@library{rnrs programs} library; when running the @repl{}: the first
element of the returned list will be the string @samp{*interactive*},
corresponding to the script name in @rnrs{6}--script mode.

Some options cause code to be evaluated in the interaction environment:
it initially contains all the bindings exported from the
@library{ikarus} library.

The @value{EXECUTABLE} executable recognises a few command line switches
that influence how @value{PACKAGE} starts; the following are the main
options, driving the execution mode.  It is an error to put on the
command line two or more of these options.

@table @code
@item --r6rs-script @var{PROGRAM}
Start Vicare in @rnrs{6}--script mode.  The @var{PROGRAM} file is handled
as an @rnrs{6} program.  Example:

@example
$ cat test.sps
(import (rnrs))
(write (command-line))
(newline)

$ @value{RAWEXECUTABLE} --r6rs-script test.sps hi there
("test.sps" "hi" "there")
@end example

@item --r6rs-repl @var{PROGRAM}
Start Vicare in @rnrs{6}-script mode.  Act as if the
@option{--r6rs-script} option had been used but, after the program
execution, enter the @repl{} rather than exiting.  This allows
inspection of bindings and state left behind by the program.

@item --script @var{CODEFILE}
Start Vicare in evaluation mode.  The @var{CODEFILE} is handled as a
sequence of @rnrs{6} expressions: such expressions are used as first
argument for @func{eval} under the interaction environment.  Example:

@example
$ cat test.sps
(write (command-line))
(newline)

$ @value{RAWEXECUTABLE} --script test.sps hi there
("test.sps" "hi" "there")
@end example

@item --compile-dependencies @var{IMPORTS-FILE}
Load the @rnrs{6} program @var{IMPORTS-FILE}, compile all the libraries
upon which it depends and store them in the FASL repository.
@var{IMPORTS-FILE} itself is not evaluated.
@end table

When none of these options is given, but a standalone @var{PROGRAM}
argument is present on the command line: act as if the
@option{--r6rs-script} option had been used with the given file name.
If no standalone @var{PROGRAM} argument is present: enter the @repl{}.

The rest of the command line arguments are recognised by the standard
Scheme run time system.

@table @code
@item -b path/to/boot/file.boot
@itemx --boot path/to/boot/file.boot
Use the specified boot file as the initial system boot file.  The boot
file is a binary file that contains all the code and data of the Scheme
system.  In the absence of the @option{-b} flag, the executable will use
the default boot file.  Running @value{EXECUTABLE} with the @option{-h}
option shows the location where the default boot file was installed.

@item --no-rcfile
Disable loading of run--command files.

@item --rcfile @var{FILE}
Load and evaluate @var{FILE} as an @rnrs{6} program at startup, before
loading libraries, evaluating codes and running the main script.  This
option can be used multiple times.

@item -l @var{LIBFILE}
@itemx --load-library @var{LIBFILE}
Load @var{libfile} expecting it to contain one or more @rnrs{6}
libraries; after executing the RC files, load the libraries in the
internal collection, but do not add them to any environment.  This
option can be used multiple times.

@item -f @var{CODEFILE}
@itemx --eval-file @var{CODEFILE}
Load @var{CODEFILE} expecting it to contain valid @rnrs{6} expressions;
after instantiating the libraries hand the code to @func{eval} under the
interaction environment.  Bindings left behind by this code are
available if we enter the @repl{}.  This option can be used multiple
times.

@item -e @var{EXPRESSION}
@itemx --eval-expr @var{EXPRESSION}
After instantiating the libraries hand the @var{EXPRESSION} to
@func{eval} under the interaction environment.  Bindings left behind by
this code are available if we enter the @repl{}. This option can be used
multiple times.

@item -L @var{DIRECTORY}
@itemx --search-path @var{DIRECTORY}
Add @var{directory} to the library search path.  This option can be used
multiple times.

@item --more-file-extensions
Rather than searching only libraries with extension @samp{.vicare.sls}
and @samp{.sls}, search also for @samp{.vicare.ss}, @samp{.ss},
@samp{.vicare.scm}, @samp{.scm} and the @samp{main} file.  @ref{using
libraries searching} for more details.

@item --prompt @var{STRING}
Use @var{STRING} as prompt for the @repl{}.  Defaults to @samp{vicare},
to which the character @samp{>} is appended for each nested @repl{}
level.  @ref{iklib cafe} for more details.

@item -d
@itemx --debug
Turn on debugging mode.  With this unhandled exceptions in the program
will result in starting the debugger, which allows stack trace
inspection.

@item -nd
@itemx --no-debug
Turn off debugging mode.

@item -O0
@itemx -O1
@itemx -O2
Turn on various levels of compile optimisations (currently unsupported).

@item --print-assembly
Print to the current error port the assembly instructions generated when
compiling code.

@item --print-optimizer
@itemx --print-optimiser
Print to the current error port a symbolic expression which results from
running the optimiser.

@item -V
@itemx --version
Display the version message then exit.

@item --version-only
Display only the version number on the standard error port, followed by
a newline, then exit.

@item --license
Display the license message then exit.

@item -h
Display the help message then exit.

@item --
Mark the end of @value{EXECUTABLE} options; all the arguments after this
marker can be obtained by calling the @func{command-line} procedure.
@end table

@cindex @env{VICARE_RC_FILES}
If neither the @option{--no-rcfile} nor the @option{--rcfile} options
are used: a list of run--command files is read from the environment
variable @env{VICARE_RC_FILES}, which must contain a colon separated
list of pathnames.  If the enviroment variable is empty or unset, by
default the file @file{.vicarerc} is used searching it in the directory
selected by the @env{HOME} environment variable.

@c page
@node using script
@section Using @command{scheme-script}


Scheme scripts can be executed using the following command:

@example
@value{RAWEXECUTABLE} @var{PROGRAM}
@end example

@noindent
@value{PACKAGE} does @strong{not} follow the @rnrs{6} recommendations
and does not install a wrapper program called @command{scheme-script} to
avoid conflicts with other Scheme implementations.

Here is a sample script (Pig Latin---``Igpay Atinlay''---is a code that
was at one time popular among very young North American children).

@example
(import (rnrs))

;;; Convert a string to its Pig Latin equivalent.
;;;
;;; If the first character is a vowel, append "yay".
;;; "egg" -> "eggyay"
;;;
;;; If the first character is a consonant, remove it,
;;; and append it plus "ay" to the string.
;;; "foo" -> "oofay"

(define pig-latin
  (lambda (str)
    (let ((first (string-ref str 0)))
      (if (memv first '(#\a #\e #\i #\o #\u))
	  (string-append str "yay")
	  (string-append
 	    (substring str 1 (string-length str))
	    (string first) "ay")))))

(display
 (map pig-latin
     (cdr (command-line))))
(newline)
@end example

Assuming we have stored the script in the file @file{demo.sps}, we can
invoke this script via @value{EXECUTABLE}:

@example
$ @value{RAWEXECUTABLE} --r6rs-script demo.sps ice cream after dinner
(iceyay reamcay afteryay innerday)
@end example

On Unix/Linux systems, scripts generally start with a ``shebang'' line
(@emph{sh}arp plus @emph{bang}) which names an interpreter for the
script.  All modern systems have the @command{env} command which
searches for a command in the user's path.

@example
#!/usr/bin/env @value{RAWEXECUTABLE} --r6rs-script
(import (rnrs))

...
@end example

Now we can make the file executable, and use it directly.

@example
$ chmod +x demo.sps
$ ./demo.sps ice cream after dinner
(iceyay reamcay afteryay innerday)
@end example

There are a few fine points.

@itemize
@item
If the first two bytes of a script represent the sequence @samp{#!} in
@ascii{} encoding: the first line is discarded and not parsed as Scheme
code.  This allows scripts on Unix systems to start with the command
line needed to use them; notice that this will discard valid sharp--bang
comments (like @code{#!r6rs}) if the are at the very beginning of a
file.

@item
Under Mac OS X, if a script name ends with the @code{.command}
extension, then it can be executed from the Finder by double--clicking
on it.  This brings up a terminal window in which the script is
executed.  The @code{.command} extension can be hidden from the
@emph{Get Info} item from the Finder's File menu.
@end itemize

@c page
@node using libraries
@section @rnrs{6} libraries


A library exports features that can be imported into programs; a library
is named by a list, e.g., @library{yoyodyne
block-transfer-computations}.  The core features of the language is
provided in the library @library{rnrs}.

@menu
* using libraries intro::       Introduction to @value{PRJNAME} libraries.
* using libraries searching::   How @value{PRJNAME} finds libraries.
* using libraries summary::     Library search summary.
* using libraries examples::    Examples of libraries usage.
@end menu

@c page
@node using libraries intro
@subsection Introduction to libraries


A library consists of a ``file'' (some assemblage of text) that contains
a library form, which might look like this:

@example
(library (sample)
  (export cube)
  (import (rnrs))
  (define cube
    (lambda (x)
      (* x x x))))
@end example

@noindent
notice the @func{import} clause; libraries have no predefined namespace,
and therefore at least @library{rnrs} must be imported.

We can import @library{sample} into another library, a script, or a
@value{PRJNAME} top--level session:

@example
> (import (sample))
> (cube 3)
27
@end example

Library names are lists, thus allowing the writer of one or more
libraries to group related libraries together.  For example, as well as
@library{yoyodyne block-transfer-computations}, we might also have
@library{yoyodyne tardis navigation} and @library{yoyodyne tardis
diagnostics}.  Leaving the parentheses off a single--component library
name is a common error.

@c page
@node using libraries searching
@subsection How @value{PRJNAME} finds libraries


In @value{PRJNAME}, a library is a file with the same name as the last
component of the library name.  For example, the library
@library{sample} will correspond to a file named @file{sample.sls}
somewhere in the file system.  The file extension @code{.sls} stands for
``Scheme library source''; although @value{PRJNAME} will also accept the
extensions @code{.ss} and @code{.scm} when the command line option
@option{--more-file-extensions} is used, these really indicate scripts
rather than libraries.

@value{PRJNAME} has a search algorithm for libraries that is similar to
those used in other languages.  Its search path comprises a series of
directories.  When we try to import a library whose name contains just
one component, @value{PRJNAME} will examine each directory in the search
path for a file with a matching name.  Importing a library whose name is
a list of components causes @value{PRJNAME} to match to a series of
subdirectories with matching names.

Here is an example of each case:

@itemize
@item
Importing @library{sample} causes @value{PRJNAME} to look in each
directory on the path for a file named @file{sample.sls}.

@item
Importing @library{yoyodyne sample} causes @value{PRJNAME} to look in
each directory on the path for a directory named @file{yoyodyne}, and
within that a file named @file{sample.sls}.  The @func{library} form for
this library must still specify the library name as @library{yoyodyne
sample}, not @library{sample}.
@end itemize

@cindex @env{VICARE_LIBRARY_PATH}
@value{PRJNAME} always places its own libraries at the end of the search
path.  Other library directories can be added to the search path in two
ways: by modifying an environment variable, or by setting
@value{PRJNAME}'s @func{library-path} parameter.  @value{PRJNAME}
consults the environment variable @env{VICARE_LIBRARY_PATH} at the
beginning of execution, and places each of the directories there into
its search path.  The search path is then set to the value of the
parameter @func{library-path}, which can be updated as necessary.

@example
$ export VICARE_LIBRARY_PATH=$HOME/scheme:/tmp/library
$ echo $VICARE_LIBRARY_PATH
/home/someuser/scheme:/tmp/library
$ @value{RAWEXECUTABLE}
...

> (library-path)
("/home/someuser/scheme" "/tmp/library"
  "/home/someuser/local/lib/vicare")
> (library-path (cons "/opt/sw/extra-libraries" (library-path)))
> (library-path)
("/opt/sw/extra-libraries" "/home/someuser/scheme"
  "/tmp/library" "/home/someuser/local/lib/vicare")
@end example

@noindent
In this example, the user sets @env{VICARE_LIBRARY_PATH} before the
session; the settings are reflected in the value of
@code{(library-path)}.  A further directory is then set during the
session.

In programs intended to be distributed, you should resist the urge to
set @code{(library-path)}, as the user's file hierarchies might not
match yours.  For most libraries, simply telling the user to install the
library in one of the libraries on the search path is good enough.

There are two refinements of the library search algorithm, which are
performed when the @option{--more-file-extensions} command line option
is used.

@itemize
@item
A common pattern is to distribute a main library along with a number of
additional extensions: we might have a main library named @library{lib},
and additional optional extensions named @library{lib extras} and
@library{lib frills}.

Although the previous packaging method can be used, @value{PRJNAME}
allows you to use a simpler technique where the main library is stored
in @file{lib/main.sls}, and the extensions are stored in
@file{lib/extras.sls} and @file{lib/frills.sls}, respectively.

@item
@value{PRJNAME} will also look in @file{lib/main.vicare.sls} before
trying @file{lib/main.sls}.  This allows you to provide a
@value{PRJNAME}--specific implementation as well as a generic
implementation.
@end itemize

@c page
@node using libraries summary
@subsection Library search algorithm summary


By default, @value{PRJNAME} attempts to import the library @library{a b
c} as follows, for each directory in the search path:

@enumerate
@item
Build the rootname @file{a/b/c}.

@item
Append each of the following strings to the rootname, in order, until a
matching file is found:

@example
.vicare.sls
.sls
@end example
@end enumerate

When the the command line option @option{--more-file-extensions} is
used, for each directory in the search path:

@enumerate
@item
Build the rootname @file{a/b/c}.

@item
Append each of the following strings to the rootname, in order, until a
matching file is found:

@example
/main.vicare.sls
/main.vicare.ss
/main.vicare.scm
/main.sls
/main.ss
/main.scm
.vicare.sls
.vicare.ss
.vicare.scm
.sls
.ss
.scm
@end example
@end enumerate

If there is no match, then the import request is in error.

@c page
@node using libraries examples
@subsection Examples of library usage


Consider a program using @func{pretty-print} procedure to format some
code, and suppose further that pretty printing is just a nice add--on
(e.g. using @file{write} suffices, but pretty--printing is @emph{just
prettier}).

@value{PRJNAME} exports a good pretty--printing facility in its
@library{ikarus} library.  However, since @func{pretty-print} is not a
standard procedure, a program that uses it would be rendered unportable
to other @rnrs{6} Scheme implementations.

The programmer can put the @code{.vicare.*} extensions to use in this
situation, by writing two versions of a @library{pretty-printing}
library: one for use by @value{PRJNAME}, and one portable for other
implementations.

@example
;; pretty-printing.vicare.ss --
;;
;; Can be used only by @value{PRJNAME} Scheme.

(library (pretty-printing)
  (export pretty-print)
  (import (only (ikarus) pretty-print)))

;;; end of file
@end example

@example
;; pretty-printing.sls --
;;
;; For any other Scheme implementation, portable though
;; not very pretty.

(library (pretty-printing)
  (export pretty-print)
  (import (rnrs))
  (define (pretty-print x port)
    (write x port)
    (newline port)))

;;; end of file
@end example

@c page
@node iklib
@chapter Extensions library


In addition to the libraries listed in the @rnrs{6} standard,
@value{PRJNAME} offers the @library{ikarus} and @library{vicare}
libraries which provide additional features; @library{ikarus} is a
composite library, it exports a superset of all the supported bindings
of @rnrs{6}; @library{vicare} exports the same bindings of
@library{ikarus}.

@menu
* iklib conditions::            Additional condition types.
* iklib reader::                Extensions to the reader.
* iklib expander::              Interface to the expander.
* iklib shared::                Shared structures graph notation.
* iklib environment::           Environments.
* iklib cafe::                  Cafe.
* iklib structs::               Structures and type descriptors.
* iklib lists::                 Additional list functions.
* iklib bytevectors::           Additional bytevector functions.
* iklib strings::               Additional string functions.
* iklib vectors::               Additional vector functions.
* iklib symbols::               Additional symbol functions.
* iklib numerics::              Additional functions on numbers.
* iklib load::                  Loading source files.
* iklib import::                Local library imports.
* iklib modules::               Local modules.
* iklib parameters::            Parameters.
* iklib gensym::                Gensyms.
* iklib printing::              Printing.
* iklib tracing::               Tracing.
* iklib timing::                Timing.
* iklib guardians::             Guardians and garbage collection.
* iklib io::                    Input/output library.
* iklib foreign::               Foreign interface library.
* iklib misc::                  Miscellaneous functions.
@end menu

@c page
@node iklib conditions
@section Additional condition types


@menu
* iklib conditions spos::       Scheme source code position.
* iklib conditions eagain::     Reporting @code{EAGAIN} exceptions.
@end menu

@c page
@node iklib conditions spos
@subsection Scheme source code position


The following bindings are exported by the @library{ikarus} library.


@deftp {Condition Type} &source-position
Condition type used to represent a position in Scheme source code read
from a textual input port; it is derived from @condition{condition}.  It
has the following fields:

@table @code
@item port-id
A Scheme string representing the port identifier, for example the file
name.

@item byte
An exact non--negative zero--based integer representing the byte offset
of the position in the source.

@item character
An exact non--negative zero--based integer representing the character
offset of the position in the source.

@item line
An exact non--negative one--based integer representing the line offset
of the position in the source.

@item column
An exact non--negative one--based integer representing the column offset
of the position in the source.
@end table
@end deftp


@defun make-source-position-condition @var{port-id} @var{character}
Build and return a new condition object of type
@condition{source-position}.
@end defun


@defun source-position-condition? @var{obj}
Return true if @var{obj} is a condition object with type
@condition{source-position}.
@end defun


@defun source-position-port-id @var{spos}
@defunx source-position-character @var{spos}
Accessors for the fields of condition objects of type
@condition{source-position}.
@end defun

@c page
@node iklib conditions eagain
@subsection Reporting @code{EAGAIN} exceptions


The following bindings are exported by the @library{ikarus} library.


@deftp {Condition Type} &i/o-eagain
Used to signal that a system call returned with @code{errno} set to
@code{EAGAIN}.  It is derived from @condition{i/o}.
@end deftp


@defun make-i/o-eagain
Return a new condition object of type @condition{i/o-eagain}.
@end defun


@defun i/o-again-error? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{i/o-eagain}.
@end defun

@c page
@node iklib reader
@section Reader


@menu
* iklib reader mode::           Textual input port modes.
* iklib reader bv::             Additional bytevector syntaxes.
* iklib reader stx::            Miscellaneous additional syntaxes.
* iklib reader fun::            Additional reader functions.
@end menu

@c page
@node iklib reader mode
@subsection Textual input port modes


@deffn {Reader Syntax} {#!vicare}
@deffnx {Reader Syntax} {#!ikarus}
@value{PRJNAME} extends Scheme's lexical syntax (@rnrs{6} Chapter 4) in
a variety of ways including:

@itemize
@item
End--of--file marker, @code{#!eof}.

@item
Gensym syntax, @code{#@{gensym@}}.

@item
Shared structures graph notation: @code{#nn=}, @code{#nn#}.
@end itemize

The syntax extensions are made available by default on all input ports,
until the @code{#!r6rs} token is read.  Thus, reading the @code{#!r6rs}
token disables all extensions to the lexical syntax on the specific
port, and the @code{#!vicare} enables them again.

When writing code that is intended to be portable across different
Scheme implementations, we should add the @code{#!r6rs} token to the top
of every script and library that we write; this allows @value{PRJNAME}
to alert us when using non--portable features.  When writing code that's
intended to be @value{PRJNAME}--specific, we should add the
@code{#!vicare} token in order to get an immediate error when the code
is run under other implementations.

The comment @code{#!ikarus} is accepted for backwards compatibility with
Ikarus Scheme.
@end deffn


@deffn Procedure port-mode @var{input-port}
Accept an input port as argument and return a symbol among: @code{r6rs},
@code{vicare}.  All input ports start under @code{vicare} mode and thus
accept @value{PRJNAME}--specific reader extensions.  When the
@code{#!r6rs} token is read from a port, its mode changes to
@code{r6rs}.

@example
> (port-mode (current-input-port))
vicare
> #!r6rs (port-mode (current-input-port))
r6rs
> #!vicare (port-mode (current-input-port))
vicare
@end example
@end deffn


@deffn Procedure set-port-mode! @var{input-port} @var{mode}
Modifiy the lexical syntax accepted by subsequent calls to @func{read}
on the input port.  The mode is a symbol among @code{r6rs} and
@code{vicare}.  The effect of setting the port mode is similar to
that of reading the @code{#!r6rs} or @code{#!vicare} token from that
port.

@example
> (set-port-mode! (current-input-port) 'r6rs)
> (port-mode (current-input-port))
r6rs
@end example
@end deffn

@c page
@node iklib reader bv
@subsection Additional bytevector syntaxes


The following syntaxes are available only when the input port mode is
set to @code{vicare}.


@deffn {Reader Syntax} {#vs8(@var{byte} ...)}
Read a bytevector as @code{#vu8(@var{octect} ...)} would do, but allow
@var{byte} to be in the range @math{[-128, 127]}.
@end deffn


@deffn {Reader Syntax} {#vu16l(@var{word} ...)}
@deffnx {Reader Syntax} {#vu16b(@var{word} ...)}
@deffnx {Reader Syntax} {#vu16n(@var{word} ...)}
Read a bytevector of 16-bit unsigned words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vs16l(@var{word} ...)}
@deffnx {Reader Syntax} {#vs16b(@var{word} ...)}
@deffnx {Reader Syntax} {#vs16n(@var{word} ...)}
Read a bytevector of 16-bit signed words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vu32l(@var{word} ...)}
@deffnx {Reader Syntax} {#vu32b(@var{word} ...)}
@deffnx {Reader Syntax} {#vu32n(@var{word} ...)}
Read a bytevector of 32-bit unsigned words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vs32l(@var{word} ...)}
@deffnx {Reader Syntax} {#vs32b(@var{word} ...)}
@deffnx {Reader Syntax} {#vs32n(@var{word} ...)}
Read a bytevector of 32-bit signed words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vu64l(@var{word} ...)}
@deffnx {Reader Syntax} {#vu64b(@var{word} ...)}
@deffnx {Reader Syntax} {#vu64n(@var{word} ...)}
Read a bytevector of 64-bit unsigned words stored in little, big and
native endianness.
@end deffn


@deffn {Reader Syntax} {#vs64l(@var{word} ...)}
@deffnx {Reader Syntax} {#vs64b(@var{word} ...)}
@deffnx {Reader Syntax} {#vs64n(@var{word} ...)}
Read a bytevector of 64-bit signed words stored in little, big and
native endianness.
@end deffn

@c page
@node iklib reader stx
@subsection Miscellaneous additional syntaxes


The following syntaxes are available only when the input port mode is
set to @code{vicare}.


@deffn {Reader Syntax} {|@var{symbol}|}
The vertical bars can be used to specify symbols whose name do not
comply with the @rnrs{6} specifications; this syntax is available only
when the port mode is @code{#!vicare}.  Examples:

@example
(define port (open-string-input-port "|123|"))
(set-port-mode! port 'vicare)
(define sym (read port))

(symbol? sym)           @result{} #t
(symbol->string sym)    @result{} "123"
@end example

@noindent
backslash sequences are allowed in bar symbols:

@example
(define port (open-string-input-port "|123-\x41;\x42;\x43;|"))
(set-port-mode! port 'vicare)
(define sym (read port))

(symbol? sym)           @result{} #t
(symbol->string sym)    @result{} "123-\x41;\x42;\x43;"
@end example

@noindent
notice that the sequence of characters @code{|ciao|hello|} is split into
@code{ciao}, @code{hello}, @code{|} and the ending vertical bar would
cause an error if read:

@example
(define port (open-string-input-port "|ciao|hello|"))
(set-port-mode! port 'vicare)

(read port)             @result{} ciao
(read port)             @result{} hello
(port-eof? port)        @result{} #f
(get-char port)         @result{} #\|
(port-eof? port)        @result{} #t
@end example
@end deffn


@deffn {Reader Syntax} {#!eof}
The end--of--file marker, @code{#!eof}, is an extension to the @rnrs{6}
syntax.  The primary utility of the @code{#!eof} marker is to stop the
reader (e.g. @func{read} and @func{get-datum}) from reading the rest of
the file.

@example
(import (ikarus))
<some code>
(display "goodbye\n")

#!eof
<some junk>
@end example

The @code{#!eof} marker also serves as a datum in @value{PRJNAME}, much
like @true{} and @false{}, when it is found inside other expressions.

@example
> (eof-object)
#!eof
> (read (open-input-string ""))
#!eof
> (read (open-input-string "#!eof"))
#!eof
> (quote #!eof)
#!eof
> (eof-object? '#!eof)
#t
> #!r6rs #!eof
Unhandled exception
Condition components:
  1. &error
  2. &who: tokenize
  3. &message: "invalid syntax: #!e"
> #!vicare #!eof
$
@end example
@end deffn

@c page
@node iklib reader fun
@subsection Additional reader functions


The following bindings are exported by the @library{ikarus} library.


@defun get-annotated-datum @var{port}
Like @func{get-datum}, but rather than returning a datum return a
hierarchy of @code{annotation} objects with the same hierarchy of the
datum and embedding the datum itself.
@end defun

@c page
@node iklib expander
@section Interface to the expander


The following bindings are exported by the @library{ikarus} library.


@defun expand
Undocumented.
@end defun


@defun core-expand
Undocumented.
@end defun


@defun expand/optimize
Undocumented.
@end defun


@defun expand/scc-letrec
Undocumented.
@end defun

@c page
@node iklib shared
@section Shared structures graph notation


This feature of the reader is derived from the @srfi{} 38 ``External
Representation for Data With Shared Structure'':

@center @url{http://srfi.schemers.org/srfi-38/srfi-38.html}

This graph notation allows the reader to build symbolic expressions with
graph structure including cycles.  @strong{Shared structures must always
be used inside quoted datums}; if we create a cycle in a symbolic
expression passed as code to the expander: the result will be an
infinite loop.  Graph notation is available only when the textual input
port is configured in @code{#!vicare} mode.

Graph notation extends the @rnrs{6} syntax with these additional cases:

@example
<lexeme>                -> <r6rs lexeme>
                         | <defining datum>
                         | <defined datum>
<defining datum>        -> #<indexnum>=<r6rs lexeme>
<defined datum>         -> #<indexnum>#
<indexnum>              -> <digit>+
@end example

@noindent
where @code{<r6rs lexeme>} is the lexeme definition in @rnrs{6}.


@deffn Parameter print-graph
@deffnx Parameter print-graph #t
@deffnx Parameter print-graph #f
The graph notation is a way of marking and referencing parts of a data
structure and, consequently, creating shared and cyclic data structures
at read time instead of resorting to explicit mutation at run time.  The
@code{#n=} marks the following data structure with mark @var{n}, where
@var{n} is a nonnegative integer.  The @code{#n#} references the data
structure marked @var{n}.  Marks can be assigned and referenced in any
order but each mark must be assigned to exactly once in an expression.

@example
> (let ([x '#0=(1 2 3)])
    (eq? x '#0#))
#t
> (let ([x '#0#] [y '#0=(1 2 3)])
    (eq? x y))
#t
> (eq? (cdr '(12 . #1#)) '#1=(1 2 3))
#t
> (let ([x '#1=(#1# . #1#)])
    (and (eq? x (car x))
         (eq? x (cdr x))))
#t
@end example

The @func{print-graph} parameter controls how the writers (e.g.
@func{pretty-print} and @func{write}) handle shared and cyclic data
structures.  In @value{PRJNAME}, all writers detect cyclic data structures and
they all terminate on all input, cyclic or otherwise.

If the value of @func{print-graph} is set to @false{} (the default),
then the writers do not attempt to detect shared data structures.  Any
part of the input that is shared is printed as if no sharing is present.
If the value of @func{print-graph} is set to @true{}, all sharing of
data structures is marked using the @code{#n=} and @code{#n#} notation.

@example
> (parameterize ([print-graph #f])
    (let ([x (list 1 2 3 4)])
      (pretty-print (list x x x))))
((1 2 3 4) (1 2 3 4) (1 2 3 4))

> (parameterize ([print-graph #t])
    (let ([x (list 1 2 3 4)])
      (pretty-print (list x x x))))
(#0=(1 2 3 4) #0# #0#)

> (parameterize ([print-graph #f])
    (let ([x (list 1 2)])
      (let ([y (list x x x x)])
        (set-car! (last-pair y) y)
        (pretty-print (list y y)))))
(#0=((1 2) (1 2) (1 2) #0#) #0#)

> (parameterize ([print-graph #t])
    (let ([x (list 1 2)])
      (let ([y (list x x x x)])
        (set-car! (last-pair y) y)
        (pretty-print (list y y)))))
(#0=(#1=(1 2) #1# #1# #0#) #0#)
@end example
@end deffn

@c page
@node iklib environment
@section Environments


@cindex Environment, interaction


The following bindings are exported by the @library{ikarus} library.


@defun environment?
Undocumented.
@end defun


@defun interaction-environment
Return an environment object representing the environment active at the
@repl{}.  To be used as argument for @func{eval}.
@end defun


@defun new-interaction-environment
Undocumented.
@end defun


@defun environment-symbols
Undocumented.
@end defun

@c page
@node iklib cafe
@section Cafe


The following bindings are exported by the @library{ikarus} library.


@defun new-cafe
@defunx new-cafe @var{eval}
Start a new read--eval--print loop (@repl{}) inside the current cafe (if
one exists).  It prompts the user for an expression, evaluates it,
prints the result back, and repeats the process.  If @func{new-cafe} is
called with an argument, @var{eval}, then that argument must be a
procedure that takes a single argument.  The @var{eval} procedure will
be used to evaluate the expressions.

Every time a new cafe is started, the prompt is changed to reflect the
depth of the current cafe (i.e. how many eof objects is takes to exit
the outermost cafe).

Input and output performed by the cafe can be changed by the
@func{console-input-port} and @func{console-output-port} parameters.

If an error occurs during reading, evaluating, or printing an
expression, then the error message is printed to the error--port and the
operations of the cafe resume as normal.

To exit from a cafe we can write the @eof{} object.
@end defun

@c page
@node iklib structs
@section Structures and type descriptors


A data structure is like a lightweight record as defined by @rnrs{6}.
@ref{syslib structs} for more informations on the internals of data
structures.

@menu
* iklib structs rtd::           Structure type descriptors.
* iklib structs using::         Using data structures.
* iklib structs inspect::       Inspecting data structures.
@end menu

@c page
@node iklib structs rtd
@subsection Structure type descriptors


The following bindings are exported by the @library{ikarus} library.


@deffn Syntax define-struct @meta{name} (@meta{field} ...)
Define a new data structure type.  This macro is embedded in the
expander.

@meta{name} must be a symbol representing the name of the structure; it
is used to build names for the constructor, predicate, field accessors
and mutators.  The @meta{field} values must be symbols representing the
names of the fields; they are used to build names for the accessors and
mutators.

The following definition:

@example
(define-struct color
  (red green blue))
@end example

@noindent
expands to the definition of the following bindings:

@table @code
@item color
An identifier syntax bound to a pair whose car is the symbol @samp{$rtd}
and whose cdr is the return value of @func{make-struct-type} applied to
the name of the structure and the list of fields.

@item make-color @var{red} @var{green} @var{blue}
A structure constructor accepting as much arguments as there are fields.
The constructor makes use of the @func{$struct} low level operation.

@item color? @var{obj}
A predicate to distinguish between references to @code{color} structures
and other values.  This predicate makes use of the @func{$struct/rtd?}
low level operation.

@item color-red @var{stru}
@itemx color-green @var{stru}
@itemx color-blue @var{stru}
Accessors for the fields of the structure.  These accessors make use of
the @func{$struct/rtd?} low level operation to validate the argument and
if successful they use @func{$struct-ref} to extract the value; if the
argument is of invalid type: an assertion violation is raised.

@item set-color-red! @var{stru} @var{red}
@itemx set-color-green! @var{stru} @var{green}
@itemx set-color-blue! @var{stru} @var{blue}
Mutators for the fields of the structure.  These mutators make use of
the @func{$struct/rtd?} low level operation to validate the argument and
if successful they use @func{$struct-set!} to extract the value; if the
argument is of invalid type: an assertion violation is raised.
@end table
@end deffn


@defun make-struct-type @var{name} @var{fields}
@defunx make-struct-type @var{name} @var{fields} @var{uid}
Build and return a new structure type descriptor.  @var{name} must be a
string representing the type name.  @var{fields} must be a list of
symbols representing the field names.

The optional @var{uid} argument must be a symbol uniquely identifying
this type; when not supplied, a symbol is automatically generated.  The
@func{$symbol-value} field of @var{uid} is set to the newly created RTD;
if @var{uid} already has a symbol value: such value must be a struct
descriptor equal to the newly created RTD.
@end defun


@deffn Syntax type-descriptor @meta{name}
Evaluate to the type descriptor of the data structure @meta{name}, which
must be the first argument to a previous use of @func{define-struct}.
@end deffn


@defun struct-type-name @var{rtd}
Return a string represnting the name of structures of type @var{rtd}.
@end defun


@defun struct-type-symbol @var{rtd}
Return a symbol uniquely identifying the data structure type @var{RTD}.
@end defun


@defun struct-type-field-names @var{rtd}
Return a list of symbols representing the names of fields in structures
of type @var{rtd}.
@end defun


@defun set-rtd-printer! @var{rtd} @var{printer}
Select the procedure @var{printer} as printer for data structures of
type @var{rtd}.  The printer accepts as @math{3} arguments: the
structure to be printed, the port to which write a string represention
of the structure with @func{display}, a function to be optionally
applied to the field values to print them.
@end defun

@c page
@node iklib structs using
@subsection Using data structures


The following bindings are exported by the @library{ikarus} library.


@defun struct-constructor @var{rtd}
Return a constructor function for data structures of type @var{rtd}.
The constructor accepts as many arguments as fields defined by @var{rtd}
and returns a new structure instance.
@end defun


@defun struct-predicate @var{rtd}
Return a predicate function for structures of type @var{rtd}.
@end defun


@defun struct-field-accessor @var{rtd} @var{index}
Return an accessor function for the field at @var{index} of data
structures of type @var{rtd}.
@end defun


@defun struct-field-mutator @var{rtd} @var{index}
Return a mutator function for the field at @var{index} of data
structures of type @var{rtd}.
@end defun

@c page
@node iklib structs inspect
@subsection Inspecting data structures


The following bindings are exported by the @library{ikarus} library.


@defun struct? @var{stru}
@defunx struct? @var{stru} @var{rtd}
When no @var{rtd} argument is given return true if @var{stru} is a data
structure.  When @var{rtd} is given: return true if @var{stru} is a data
structure and it is of type @var{rtd}.
@end defun


@defun struct-rtd @var{stru}
Return the @var{rtd} of the data structure @var{stru}.
@end defun


@defun struct-length @var{stru}
Return the number of fields in the data structure @var{stru}.
@end defun


@defun struct-name @var{stru}
Return a string representing the name of the data structure @var{stru}.
@end defun


@defun struct-printer @var{stru}
Return the procedure being the printer function for the data structure
@var{stru}.
@end defun


@defun struct-ref @var{stru} @var{index}
Return the value of field at @var{index} in the data structure
@var{stru}.
@end defun


@defun struct-set! @var{stru} @var{index} @var{value}
Store @var{value} in the field at @var{index} in the data structure
@var{stru}.
@end defun

@c page
@node iklib lists
@section Additional list functions


@menu
* iklib lists weak::            Weak pairs.
@end menu

@c page
@node iklib lists weak
@subsection Weak pairs


Weak references do not cause the referenced value to be considered used
by the garbage collector.  The following bindings are exported by the
@library{ikarus} library.


@defun weak-cons @var{A} @var{D}
Like @func{cons} build and return a new pair, but holding weak
references to @var{A}; notice that the reference to @var{D} is not weak.
This function allows to build a non--weak list spine holding weak
references to values.
@end defun


@defun weak-pair? @var{obj}
Return true if @var{obj} is a weak pair.
@end defun


@defun bwp-obejct? @var{obj}
Return true if @var{obj} is a weak reference to a value which has been
already garbage collected.  Example:

@example
vicare> (define x (weak-cons (cons 1 2) #f))
vicare> x
((1 . 2) . #f)
vicare> (bwp-object? (car x))
#f
vicare> (collect)
vicare> x
 (#!bwp . #f)
vicare> (bwp-object? (car x))
#t
@end example
@end defun

@c page
@node iklib bytevectors
@section Additional bytevector functions


The description of bytevectors uses the term @emph{byte} for an exact
integer object in the interval @math{(-128, @dots{}, 127)} and the term
@emph{octet} for an exact integer object in the interval @math{(0,
@dots{}, 255)}.  A byte corresponds to its two's complement
representation as an octet.

@menu
* iklib bytevectors sub::       Building subbytevectors.
* iklib bytevectors conv::      Converting bytevectors.
* iklib bytevectors generic::   Generic bytevectors operations.
@end menu

@c page
@node iklib bytevectors sub
@subsection Building subbytevectors


The following bindings are exported by the @library{ikarus} library.


@defun subbytevector-u8 @var{bv} @var{start}
@defunx subbytevector-u8 @var{bv} @var{start} @var{end}
Build and return a new bytevector holding the bytes in @var{bv} from
index @var{start} (inclusive) to index @var{end} (exclusive).  The start
and end indexes must be such that:

@example
0 <= @var{start} <= @var{end} <= (bytevector-length @var{bv})
@end example
@end defun


@defun subbytevector-u8/count @var{bv} @var{start} @var{count}
Build and return a new bytevector holding @var{count} bytes in @var{bv}
from index @var{start} (inclusive).  The start index and the byte count
must be such that:

@example
0 <= @var{start} <= @var{start} + @var{count} <= (bytevector-length @var{bv})
@end example
@end defun


@defun subbytevector-s8 @var{bv} @var{start}
@defunx subbytevector-s8 @var{bv} @var{start} @var{end}
Build and return a new bytevector holding the bytes in @var{bv} from
index @var{start} (inclusive) to index @var{end} (exclusive).  The start
and end indexes must be such that:

@example
0 <= @var{start} <= @var{end} <= (bytevector-length @var{bv})
@end example
@end defun


@defun subbytevector-s8/count @var{bv} @var{start} @var{count}
Build and return a new bytevector holding @var{count} bytes in @var{bv}
from index @var{start} (inclusive).  The start index and the byte count
must be such that:

@example
0 <= @var{start} <= @var{start} + @var{count} <= (bytevector-length @var{bv})
@end example
@end defun

@c page
@node iklib bytevectors conv
@subsection Converting bytevectors


These conversion functions work like @func{bytevector->u8-list} and
@func{u8-list->bytevector}.  The following bindings are exported by the
@library{ikarus} library.


@defun {bytevector->s8-list} @var{bytevector}
@defunx {s8-list->bytevector} @var{list}
Convert between a list of signed bytes and a bytevector.
@end defun


@defun s16l-list->bytevector @var{list}
@defunx s16b-list->bytevector @var{list}
@defunx s16n-list->bytevector @var{list}
@defunx u16l-list->bytevector @var{list}
@defunx u16b-list->bytevector @var{list}
@defunx u16n-list->bytevector @var{list}
@defunx bytevector->s16l-list @var{bytevector}
@defunx bytevector->s16b-list @var{bytevector}
@defunx bytevector->s16n-list @var{bytevector}
@defunx bytevector->u16l-list @var{bytevector}
@defunx bytevector->u16b-list @var{bytevector}
@defunx bytevector->u16n-list @var{bytevector}
Convert between a list of signed or unsigned 16-bit words and a
bytevector in which the words are stored in little, big or native
endianness.
@end defun


@defun s32l-list->bytevector @var{list}
@defunx s32b-list->bytevector @var{list}
@defunx s32n-list->bytevector @var{list}
@defunx u32l-list->bytevector @var{list}
@defunx u32b-list->bytevector @var{list}
@defunx u32n-list->bytevector @var{list}
@defunx bytevector->s32l-list @var{bytevector}
@defunx bytevector->s32b-list @var{bytevector}
@defunx bytevector->s32n-list @var{bytevector}
@defunx bytevector->u32l-list @var{bytevector}
@defunx bytevector->u32b-list @var{bytevector}
@defunx bytevector->u32n-list @var{bytevector}
Convert between a list of signed or unsigned 32-bit words and a
bytevector in which the words are stored in little, big or native
endianness.
@end defun


@defun s64l-list->bytevector @var{list}
@defunx s64b-list->bytevector @var{list}
@defunx s64n-list->bytevector @var{list}
@defunx u64l-list->bytevector @var{list}
@defunx u64b-list->bytevector @var{list}
@defunx u64n-list->bytevector @var{list}
@defunx bytevector->s64l-list @var{bytevector}
@defunx bytevector->s64b-list @var{bytevector}
@defunx bytevector->s64n-list @var{bytevector}
@defunx bytevector->u64l-list @var{bytevector}
@defunx bytevector->u64b-list @var{bytevector}
@defunx bytevector->u64n-list @var{bytevector}
Convert between a list of signed or unsigned 64-bit words and a
bytevector in which the words are stored in little, big or native
endianness.
@end defun

@c page
@node iklib bytevectors generic
@subsection Generic bytevectors operations


The following bindings are exported by the @library{ikarus} library.


@defun bytevector-append @var{bytevector} ...
Concatenate the bytevector arguments and return the result.  If no
arguments are given: return the empty bytevector.
@end defun

@c page
@node iklib strings
@section Additional string functions


The following bindings are exported by the @library{ikarus} library.


@defun string-copy! @var{src.str} @var{src.start} @var{dst.str} @var{dst.start} @var{count}
Copy @var{count} characters from @var{src.str} starting at
@var{src.start} (inclusive) to @var{dst.str} starting at
@var{dst.start}.  Return unspecified values.
@end defun


@defun string->latin1 @var{string}
@defunx latin1->string @var{bytevevctor}
Convert to and from a Scheme string and a Scheme bytevector holding the
Latin-1 encoding of the characters.
@end defun


@defun string->utf16le @var{string}
@defunx string->utf16be @var{string}
@defunx string->utf16n @var{string}
@defunx utf16le->string @var{bytevector}
@defunx utf16be->string @var{bytevector}
@defunx utf16n->string @var{bytevector}
Convert to and from a Scheme string and a Scheme bytevector holding the
@utf{}-16 encoding of the characters under little, big or native
endianness respectively.
@end defun


@defun uuid
Attempt to build a unique string and return it.  If an internal error
occurs because of impossible generation: raise an error.
@end defun

@c page
@node iklib vectors
@section Additional vector functions


The following bindings are exported by the @library{ikarus} library.


@defun subvector @var{vec} @var{start} @var{end}
@var{vec} must be a vector, and @var{start} and @var{end} must be exact
integer objects satisfying:

@example
0 <= @var{start} <= @var{end} <= (vector-length @var{vec})
@end example

Return a newly allocated vector formed from the items of @var{vec}
beginning with index @var{start} (inclusive) and ending with index
@var{end} (exclusive).
@end defun


@defun vector-append @var{vec} ...
Return a newly allocated vector whose items form the concatenation of
the given vectors.
@end defun


@defun vector-copy @var{vec}
Return a newly allocated copy of the given vector.
@end defun


@defun vector-copy! @var{src.vec} @var{src.start} @var{dst.vec} @var{dst.start} @var{count}
Copy @var{count} items from @var{src.vec} starting at @var{src.start}
(inclusive) to @var{dst.vec} starting at @var{dst.start}.  Return
unspecified values.
@end defun

@c page
@node iklib symbols
@section Additional symbol functions


@menu
* iklib symbols value::         Symbol values.
* iklib symbols plists::        Property lists.
@end menu

@c page
@node iklib symbols value
@subsection Symbol values


Symbol values have miscellaneous uses: when a symbol is the unique
identifier for a data structure, its symbol value field is set to the
type descriptor of the data structure; when a symbol is the unique label
of a binding in the expander, its symbol value is a reference to the
binding.  @ref{syslib symbols} for more details on symbol values.

The following bindings are exported by the @library{ikarus} and the
@library{ikarus symbols} libraries.


@defun set-symbol-value! @var{sym} @var{value}
Store @var{value} in the @func{$symbol-value} field of the symbol
@var{sym}.
@end defun


@defun symbol-value @var{sym}
Return the value in the @func{$symbol-value} field of the symbol
@var{sym}.
@end defun


@defun symbol-bound? @var{sym}
Return true if @var{sym} is a symbol and its @func{$symbol-value} field
is set to the special ``unbound'' machine word value.
@end defun

@c page
@node iklib symbols plists
@subsection Property lists


Property lists are associations key/value that can be attached to any
Scheme symbol.  The following bindings are exported by the
@library{ikarus} and the @library{ikarus symbols} libraries.

@example
#!ikarus
(import (ikarus))

(putprop 'ciao 'british 'hello)
(putprop 'ciao 'spanish 'hola)

(getprop 'ciao 'british)        @result{} hello
(getprop 'ciao 'spanish)        @result{} hola

(remprop 'ciao 'british)
(getprop 'ciao 'british)        @result{} #f

(property-list 'ciao)           @result{} ((spanish . hola))
@end example


@defun putprop @var{symbol} @var{key} @var{value}
Add a new property @var{key} with @var{value} to the property list of
@var{symbol}.  @var{key} must be a symbol, @var{value} can be any value.

If @var{key} is already set: the old entry is mutated to reference the
new @var{value}.
@end defun


@defun getprop @var{symbol} @var{key}
Return the value of the property @var{key} in the property list of
@var{symbol}; if @var{key} is not set return false.  @var{key} must be a
symbol.
@end defun


@defun remprop @var{symbol} @var{key}
Remove property @var{key} from the list associated to @var{symbol}.
@end defun


@defun property-list @var{symbol}
Return a new association list representing the property list of
@var{symbol}.  The order of the entries is the same as the property
creation order.
@end defun

@c page
@node iklib numerics
@section Additional functions on numbers


@menu
* iklib numerics preds::        Additional numeric predicates.
* iklib numerics flonums::      Additional flonum functions.
@end menu

@c page
@node iklib numerics preds
@subsection Additional numeric predicates


The following bindings are exported by the @library{ikarus} and
@library{vicare} libraries.


@defun bignum? @var{obj}
Return true if @var{obj} is an exact integer represented by a big
number.
@end defun


@defun ratnum? @var{obj}
Return true if @var{obj} is an exact rational number.
@end defun


@defun cflonum? @var{obj}
Return true if @var{obj} is a complex number having flonums as both real
and imaginary parts.
@end defun


@defun compnum? @var{obj}
Return true if @var{obj} is a complex number having any possible
combination of number representations as real and imaginary parts, but
not both flonums.
@end defun

@c page
@node iklib numerics flonums
@subsection Additional flonum functions


The following bindings are exported by the @library{ikarus} and
@library{vicare} libraries.


@defun fllog1p @var{fl}
Return a flonum equivalent to @math{log(1 + @var{fl})}.
@end defun


@defun flexpm1 @var{fl}
Return a flonum equivalent to @math{exp(@var{fl}) - 1}.
@end defun


@c page
@node iklib load
@section Loading source files


Loading of source files can be done explicitly or by requesting a
library with the @func{import} form.  Here we see how to load files by
specifying their pathname on the file system.


@defun load @var{pathname}
@defunx load @var{pathname} @var{eval-proc}
Read and evaluate the file selected by the string @var{pathname}.

If @var{eval-proc} is given: it must be a procedure that takes a single
argument, an annotated form, and evaluates it.  The default
@var{eval-proc} looks like this:

@example
(define (load-handler x)
  (eval x (interaction-environment)))
@end example

The format of the annotated source is the one which is comprehensible by
@func{eval}.
@end defun

@c page
@node iklib import
@section Local library imports


@deffn Syntax import import-spec* ...
The @func{import} keyword which is exported from the @library{ikarus}
library can be used anywhere definitions can occur: at a script body,
library's top--level, or in internal definitions context.  The syntax of
the local @func{import} form is similar to the @func{import} that
appears at the top of a library or a script form, and carries with it
the same restrictions: no identifier name may be imported twice unless
it denotes the same identifier; no identifier may be both imported and
defined; and imported identifiers are immutable.

Local @func{import} forms are useful for two reasons: (1) they minimize
the namespace clutter that usually occurs when many libraries are
imported at the top level, and (2) they limit the scope of the import
and thus help modularize a library's dependencies.

Suppose you are constructing a large library and at some point you
realize that one of your procedures needs to make use of some other
library for performing a specific task.  Importing that library at top
level makes it available for the entire library.  Consequently, even if
that library is no longer used anywhere in the code (say when the code
that uses it is deleted), it becomes very hard to delete the import
without first examiniming the entire library body for potential usage
leaks.  By locally importing a library into the appropriate scope, we
gain the ability to delete the @func{import} form when the procedure
that was using it is deleted.
@end deffn

@c page
@node iklib modules
@section Local modules


Modules are somewhat like libraries in that they define a set of
bindings in a ``private namespace''; bindings can be exported from a
module and imported into other modules and libraries.  The main
difference between modules and @rnrs{6} libraries is that modules are
defined in a single form nested into a library; so, in a way, they are
sub--libraries.

@quotation
@strong{NOTE} In the official documentation of @value{PRJNAME} 0.0.3+
(revision 1648) modules are yet not documented.  Please refer to Section
10.5 of Chez Scheme User's Guide, Chapter 3 of Oscar Waddel's Ph.D
Thesis, and its POPL99 paper for details on using the @func{module} and
@func{import} keywords.  @value{PRJNAME}'s internal module system is
similar in spirit to that of Chez Scheme.
@end quotation

@menu
* iklib modules examples::      Usage example for modules.
* iklib modules api::           Modules programming interface.
@end menu

@c page
@node iklib modules examples
@subsection Usage example for modules


@menu
* iklib modules examples anonymous:: Anonymous modules.
* iklib modules examples named::     Named modules.
* iklib modules examples utils::     Utilities examples.
@end menu

@c page
@node iklib modules examples anonymous
@subsubsection Anonymous modules


The following example defines an anonymous module, without expressions,
and invokes its functions from the enclosing environment (which is the
top level):

@example
(import (ikarus))

(module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (cons 'three (hidden)))
    (define (hidden)    'hidden))

(printf "calling anonymous: ~s ~s ~s~%" (one) (two) (three))
@end example

@noindent
notice that the @func{hidden} function is visible inside the module but
not in the enclosing environment.

The following example defines a module, with expressions, and invokes
its functions from the enclosing environment (which is the top level):

@example
(import (ikarus))

(module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (cons 'three (hidden)))
    (define (hidden)    'hidden)

    (printf "defining an anonymous module~%"))

(printf "calling anonymous: ~s ~s ~s~%" (one) (two) (three))
@end example

@noindent
notice that when the enclosing environment is the top level: the
expressions at the end of a module are evaluated @strong{after} the
expressions at the top level; so the output from the example is:

@example
calling anonymous: one two (three . hidden)
defining an anonymous module
@end example

@noindent
this can lead to undesired results if the module's expressions are meant
to initialise the state of the module, and the expressions at the top
level invoke the module's functions (before initialisation).  On the
other hand: this behaviour allows the module to access definitions from
the enclosing environment and the top level environment despite their
placement in the file; see below for an example.  The same behaviour is
shown by named modules.

The following example defines a module, with expressions, and invokes
its functions from the enclosing environment (which is a @func{let}
form):

@example
(import (ikarus))

(let ()
  (module (one two three)
      (define (one)       'one)
      (define (two)       'two)
      (define (three)     (cons 'three (hidden)))
      (define (hidden)    'hidden)

      (printf "defining an anonymous module~%"))

  (printf "calling anonymous: ~s ~s ~s~%" (one) (two) (three)))
@end example

@noindent
notice that when the enclosing environment is @strong{not} the top
level: the expressions at the end of a module are evaluated
@strong{before} the expressions in the body of the enclosing
environment; so the output from the example is:

@example
defining an anonymous module
calling anonymous: one two (three . hidden)
@end example

@noindent
so the state of the module can be correctly initialised before its
functions are invoked.  The same behaviour is shown by named modules.

The following example shows that bindings from the enclosing environment
and the top level environment are accessible from the modules:

@example
(import (ikarus))

(define (top-level-before) 'top-level-before)

(let ()

  (define (outer-before) 'outer-before)

  (module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (list 'three
                              (outer-before)
                              (outer-after)
                              (top-level-before)
                              (top-level-after))))

  (define (outer-after) 'outer-after)

  (printf "calling anonymous: ~s ~s ~s~%" (one) (two) (three)))

(define (top-level-after) 'top-level-after)
@end example

@noindent
this happens both when the enclosing environment is the top level and
when the enclosing environment is not the top level.  The same behaviour
is shown by named modules.

@c page
@node iklib modules examples named
@subsubsection Named modules


The following example defines a module named @code{blue} and invokes
functions from it in the top level environment:

@example
(import (ikarus))

[module blue (blue-one blue-two blue-three)
    (define (blue-one)          'blue-one)
    (define (blue-two)          'blue-two)
    (define (blue-three)        (cons 'blue-three (hidden)))
    (define (hidden)            'blue-hidden)]

(import blue)
(printf "calling blue: ~s ~s ~s~%"
        (blue-one) (blue-two) (blue-three))
@end example

@noindent
notice that bindings from a named module are accessible only if imported
in the enclosing environment.

The following example defines two modules named @code{green} and
@code{red}, then it imports their bindings in different environments:

@example
(import (ikarus))

(let ()

  [module green (one two three)
    (define (one)       'green-one)
    (define (two)       'green-two)
    (define (three)     (cons 'green-three (hidden)))
    (define (hidden)    'green-hidden)]

  [module red (one two three)
    (define (one)       'red-one)
    (define (two)       'red-two)
    (define (three)     (cons 'red-three (hidden)))
    (define (hidden)    'red-hidden)]

  (import green)

  [let ()
    (import red)
    (printf "calling red: ~s ~s ~s~%" (one) (two) (three))]

  (printf "calling green: ~s ~s ~s~%" (one) (two) (three)))
@end example

The following example shows that modules in the same enclosing
environment can import their bindings:

@example
(import (ikarus))

(let ()

  [module green (one two)
    (define (one)       'one)
    (define (two)       'two)]

  [module red (f g)
    (import green)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two)))]

  (import red)
  (printf "calling red: ~s ~s~%" (f) (g)))
@end example

@noindent
while the following example shows that bindings from an anonymous module
are automatically available in modules defined in the same enclosing
environment:

@example
(import (ikarus))

(let ()

  [module (one two)
    (define (one)       'one)
    (define (two)       'two)]

  [module red (f g)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two)))]

  (import red)
  (printf "calling red: ~s ~s~%" (f) (g)))
@end example

@noindent
and the following example shows that the order of module definitions
does not matter in determining visibility of bindings from
@strong{anonymous} modules:

@example
(import (ikarus))

(let ()

  [module red (f g)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two)))]

  [module (one two)
    (define (one)       'one)
    (define (two)       'two)]

  (import red)
  (printf "calling red: ~s ~s~%" (f) (g)))
@end example

@noindent
the following is an @strong{error} because it tries to import bindings
from a @strong{named} module before its definition:

@example
(import (ikarus))

(let ()

  [module red (f g)
    (import green)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two)))]

  [module green (one two)
    (define (one)       'one)
    (define (two)       'two)]

  (import red)
  (printf "calling red: ~s ~s~%" (f) (g)))
@end example

@c page
@node iklib modules examples utils
@subsubsection Utilities examples


The following example shows how syntactic abstractions can be used to
access definitions in a module without using the @func{import} form:

@example
(import (ikarus))

(let ()

  (define-syntax in-module
    (syntax-rules ()
      [(_ ?module ?expr ...)
       (let () (import ?module) ?expr ...)]))

  [module red (one two)
    (define (one arg)   (cons 'red-one arg))
    (define (two arg)   (cons 'red-two arg))]

  [module green (one two)
    (define (one arg)   (cons 'green-one arg))
    (define (two arg)   (cons 'green-two arg))]

  (printf "calling ones: ~s ~s~%"
          [(in-module red one)   123]
          [(in-module green one) 456]))
@end example

@c page
@node iklib modules api
@subsection Modules programming interface


@deffn Syntax module @var{interface} @var{definitions} ... @var{expressions} ...
@deffnx Syntax module @var{name} @var{interface} @var{definitions} ... @var{expressions} ...
Define a new local module.  The first form defines an @emph{anonymous}
module, while the second form defines a @emph{named} module called
@var{name}, which must be a symbol.

@var{interface} is a list of symbols that select bindings from this
module to be exported.  Every listed symbol must be bound in this
module's @var{definitions}, otherwise an error is raised.

@var{definitions} is a set of bindings like the one that may appear at
the beginning of a @func{let} body, with the addition of @func{import}
forms that may import bindings from libraries and other modules.

@var{expressions} is a set of expressions that is evaluated at module's
definition time.

Modules ``exist'' only in the enclosing region, bindings exported from a
module are not accessible outside of the enclosing region.  Modules can
be nested and import/export relations are possible according to the
regions nesting hierarchy.

Bindings in the @var{interface} declared by anonymous modules are
imported by default in the enclosing region: there is no need to use
@func{import}.  Bindings in the @var{interface} declared by named
modules are visible only in regions that @func{import} the module.

@var{definitions} and @var{expressions} have no default access to the
bindings in the enclosing region; only imported bindings are visible
from the module.
@end deffn

@c page
@node iklib parameters
@section Parameters


Parameters in @value{PRJNAME}@footnote{Parameters are found in many Scheme
implementations such as Chez Scheme and MzScheme.} are intended for
customizing the behavior of a procedure during the dynamic execution of
some piece of code.  Parameters are first class entities (represented as
procedures) that hold the parameter value.  A parameter procedure
accepts either zero or one argument.  If given no arguments, it returns
the current value of the parameter.  If given a single argument, it must
set the state to the value of the argument.

Parameters replace the older concept of using starred @code{*global*}
customization variables.  For example, instead of writing:

@example
(define *screen-width* 72)
@end example

@noindent
and then mutating the variable @code{*screen-width*} with @code{set!},
we could wrap the variable @code{*screen-width*} with a
@code{screen-width} parameter as follows:

@example
(define *screen-width* 72)
(define screen-width
   (case-lambda
     [()  *screen-width*]
     [(x) (set! *screen-width* x)]))
@end example

The value of @code{screen-width} can now be passed as argument, returned
as a value, and exported from libraries.


@deffn Procedure make-parameter @var{x}
@deffnx Procedure make-parameter @var{x} @var{f}
As parameters are common in @value{PRJNAME}, the procedure @func{make-parameter}
is defined to model the common usage pattern of parameter construction.

@code{(make-parameter x)} constructs a parameter with @var{x} as the
initial value.  For example, the code above could be written succinctly
as:

@example
(define screen-width (make-parameter 72))
@end example

@code{(make-parameter x f)} constructs a parameter which filters the
assigned values through the procedure @var{f}.  The initial value of the
parameter is the result of calling @code{(f x)}.  Typical uses of the
filter procedure include checking some constraints on the passed
argument or converting it to a different data type.  The
@code{screen-width} parameter may be constructed more robustly as:

@example
(define screen-width
  (make-parameter 72
    (lambda (w)
      (assert (and (integer? w) (exact? w)))
      (max w 1))))
@end example

This definition ensures, through @func{assert}, that the argument passed
is an exact integer.  It also ensures, through @func{max} that the
assigned value is always positive.
@end deffn


@deffn Syntax parameterize ([lhs* rhs*] ...) body body* ...
Parameters can be assigned to by simply calling the parameter procedure
with a single argument.  The @func{parameterize} syntax is used to set
the value of a parameter within the dynamic extent of the @code{body
body* ...} expressions.

The @code{lhs* ...} are expressions, each of which must evaluate to a
parameter.  Such parameters are not necessarily constructed by
@func{make-parameter}---any procedure that follows the parameters
protocol works.

The advantage of using @func{parameterize} over explicitly assigning to
parameters (same argument applies to global variables) is that you're
guaranteed that whenever control exits the body of a @func{parameterize}
expression, the value of the parameter is reset back to what it was
before the body expressions were entered.  This is true even in the
presence of @func{call/cc}, errors, and exceptions.

The following example shows how to set the text property of a terminal
window.  The parameter @code{terminal-property} sends an @ansi{} escape
sequence to the terminal whenever the parameter value is changed.  The
use of @code{terminal-property} within @func{parameterize} changes the
property before @code{(display "RED!")} is called and resets it back to
normal when the body returns.

@example
(define terminal-property
  (make-parameter "0"
    (lambda (x)
      (display "\x1b;[")
      (display x)
      (display "m")
      x)))

(display "Normal and ")
(parameterize ([terminal-property "41;37"])
  (display "RED!"))
(newline)
@end example
@end deffn

@c page
@node iklib gensym
@section Gensyms


Gensym stands for @emph{generated symbol}---a fresh symbol that is
generated at run time and is guaranteed to be @emph{not} @func{eq?} to
any other symbol present in the system.  Gensyms are useful in many
applications including expanders, compilers, and interpreters when
generating an arbitrary number of unique names is needed.

@value{PRJNAME} is similar to Chez Scheme in that the readers (including the
@func{read} procedure) and writers (including @func{write} and
@func{pretty-print}) maintain the read/write invariance on gensyms.
When a gensym is written to an output port, the system automatically
generates a random unique identifier for the gensym.  When the gensym is
read back though the @code{#@{gensym@}} read syntax, a new gensym is
@emph{not} regenerated, but instead, it is looked up in the global
symbol table.

A gensym's name is composed of two parts: a @emph{pretty} string and a
@emph{unique} string.  The Scheme procedure @func{symbol->string}
returns the pretty string of the gensym and not its unique string.
Gensyms are printed by default as @code{#@{pretty-string unique-string@}}.


@deffn Procedure gensym
@deffnx Procedure gensym @var{string}
@deffnx Procedure gensym @var{symbol}
Construct a new gensym.  If passed no arguments, construct a gensym with
no pretty name.  The pretty name is constructed when and if the pretty
name of the resulting gensym is needed.  If @func{gensym} is passed a
string, that string is used as the pretty name.  If @func{gensym} is
passed a symbol, the pretty name of the symbol is used as the pretty
name of the returned gensym.  See @func{gensym-prefix} and
@func{gensym-count} for details.

@example
> (gensym)
#@{g0 |y0zf>GlFvcTJE0xw|@}
> (gensym)
#@{g1 |U%X&sF6kX!YC8LW=|@}
> (eq? (gensym) (gensym))
#f
@end example

@code{(gensym string)} constructs a new gensym with @var{string} as its
pretty name.  Similarly, @code{(gensym symbol)} constructs a new gensym
with the pretty name of @var{symbol}, if it has one, as its pretty name.

@example
> (gensym "foo")
#@{foo |>VgOllCM&$dSvRN=|@}
> (gensym 'foo)
#@{foo |!TqQLmtw2hoEYfU>|@}
> (gensym (gensym 'foo))
#@{foo |N2C>5O0>C?OROUBU|@}
@end example
@end deffn


@deffn Procedure gensym? @var{x}
Return @true{} if its argument is a gensym, return @false{} otherwise.

@example
> (gensym? (gensym))
#t
> (gensym? 'foo)
#f
> (gensym? 12)
#f
@end example
@end deffn


@deffn Procedure gensym->unique-string @var{gensym}
Return the unique name associated with the gensym argument.

@example
> (gensym->unique-string (gensym))
"YukrolLMgP?%ElcR"
@end example
@end deffn


@deffn {Reader Syntax} {#@{gensym@}}
@deffnx {Reader Syntax} {#@{unique-name@}}
@deffnx {Reader Syntax} {#@{pretty-name unique-name@}}
@deffnx {Reader Syntax} {#:pretty-name}
@value{PRJNAME}'s @func{read} and @func{write} procedures extend the lexical
syntax of Scheme by the ability to read and write gensyms using one of
these three forms.

@code{#@{unique-name@}} constructs, at read time, a gensym whose unique
name is the one specified.  If a gensym with the same unique name
already exists in the system's symbol table, that gensym is returned.

@example
> '#@{some-long-name@}
#@{g0 |some-long-name|@}
> (gensym? '#@{some-long-unique-name@})
#t
> (eq? '#@{another-unique-name@} '#@{another-unique-name@})
#t
@end example

The two--part @code{#@{pretty-name unique-name@}} gensym syntax is
similar to the syntax shown above with the exception that if a new
gensym is constructed (that is, if the gensym did not already exist in
the symbol table), the pretty name of the constructed gensym is set to
@code{pretty-name}.

@example
> '#@{foo unique-identifier@}
#@{foo |unique-identifier|@}
> '#@{unique-identifier@}
#@{foo |unique-identifier|@}
> '#@{bar unique-identifier@}
#@{foo |unique-identifier|@}
@end example

The @code{#:pretty-name} form constructs, at read time, a gensym whose
pretty name is @code{pretty-name} and whose unique name is fresh.  This
form guarantees that the resulting gensym is not @func{eq?} to any other
symbol in the system.

@example
> '#:foo
#@{foo |j=qTGlEwS/Zlp2Dj|@}
> (eq? '#:foo '#:foo)
#f
@end example
@end deffn


@c ------------------------------------------------------------

@subsection An example


@noindent
The @library{rnrs syntax-case} library provides a
@func{generate-temporaries} procedure, which takes a syntax object
(representing a list of things) and returns a list of fresh identifiers.
Using @func{gensym}, that procedure can be defined as follows:

@example
(define (generate-temporaries* stx)
  (syntax-case stx ()
    [(x* ...)
     (map (lambda (x)
            (datum->syntax #'unimportant
              (gensym
                (if (identifier? x)
                    (syntax->datum x)
                    't))))
          #'(x* ...))]))
@end example

The above definition works by taking the input @var{stx} and
destructuring it into the list of syntax objects @code{x* ...}.  The
inner procedure maps each @var{x} into a new syntax object (constructed
with @func{datum->syntax}).  The datum is a gensym, whose name is the
same name as @var{x} if @var{x} is an identifier, or the symbol @code{t}
if @var{x} is not an identifier.  The output of
@func{generate-temporaries*} generates names similar to their input
counterpart:

@example
> (print-gensym #f)
> (generate-temporaries* #'(x y z 1 2))
(#<syntax x> #<syntax y> #<syntax z> #<syntax t> #<syntax t>)
@end example

@c page
@node iklib printing
@section Printing


@deffn Procedure pretty-print @var{datum}
@deffnx Procedure pretty-print @var{datum} @var{output-port}
The procedure @func{pretty-print} is intended for printing Scheme data,
typically Scheme programs, in a format close to how a Scheme programmer
would write it.  Unlike @func{write}, which writes its input all in one
line, @func{pretty-print} inserts spaces and new lines in order to
produce more pleasant output.

@example
(define fact-code
  '(letrec ([fact (lambda (n)
                    (if (zero? n)
                        1
                      (* n (fact (- n 1)))))])
     (fact 5)))

> (pretty-print fact-code)
(letrec ((fact
          (lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))))
  (fact 5))
@end example

The second argument to @func{pretty-print}, if supplied, must be an
output port.  If not supplied, the @func{current-output-port} is used.

@quotation
@emph{Limitations:} As shown in the output above, the current
implementation of @func{pretty-print} does not handle printing of square
brackets properly.
@end quotation
@end deffn


@deffn Parameter pretty-width
@deffnx Parameter pretty-width @var{n}
The parameter @func{pretty-width} controls the number of characters
after which the @func{pretty-print} starts breaking long lines into
multiple lines.  The initial value of @func{pretty-width} is set to 60
characters, which is suitable for most terminals and printed material.

@example
> (parameterize ([pretty-width 40])
     (pretty-print fact-code))
(letrec ((fact
          (lambda (n)
            (if (zero? n)
                1
                (* n (fact (- n 1)))))))
  (fact 5))
@end example

Note that @func{pretty-width} does not guarantee that the output will
not extend beyond the specified number.  Very long symbols, for
examples, cannot be split into multiple lines and may force the printer
to go beyond the value of @func{pretty-width}.
@end deffn


@deffn Procedure format @var{fmt-string} @var{args} ...
The procedure @func{format} produces a string formatted according to
@func{fmt-string} and the supplied arguments.  The format string
contains markers in which the string representation of each argument is
placed.  The markers include:

@table @code
@item ~s
instructs the formatter to place the next argument as if the procedure
@func{write} has printed it; if the argument contains a string, the
string will be quoted and all quotes and backslashes in the string will
be escaped; similarly, characters will be printed using the @code{#\x}
notation;

@item ~a
instructs the formatter to place the next argument as if the procedure
@func{display} has printed it; strings and characters are placed as they
are in the output;

@item ~b
instructs the formatter to convert the next argument to its binary (base
2) representation; the argument must be an exact number;

@item ~o
is similar to @code{~b} except that the number is printed in octal (base
8);

@item ~x
is similar to @code{~b} except that the number is printed in hexadecimal
(base 16);

@item ~d
outputs the next argument, which can be an exact or inexact number, in
its decimal (base 10) representation;

@item ~~
instructs the formatter to place a tilde character, @code{~}, in the
output without consuming an argument;

@item ~%
instructs the formatter to place a newline character in the output
without consuming an argument.
@end table

Note that the @code{#b}, @code{#o}, and @code{#x} numeric prefixes are
not added to the output when @code{~b}, @code{~o}, and @code{~x} are
used.

@example
> (format "message: ~s, ~s, and ~s" 'symbol "string" #\c)
"message: symbol, \"string\", and #\\c"

> (format "message: ~a, ~a, and ~a" 'symbol "string" #\c)
"message: symbol, string, and c"
@end example
@end deffn


@deffn Procedure printf @var{fmt-string} @var{args} ...
The procedure @func{printf} is similar to @func{format} except that the
output is sent to the @code{current-output-port} instead of being
collected in a string.

@example
> (let ([n (+ (expt 2 32) #b11001)])
    (printf "~d = #b~b = #x~x\n" n n n))
4294967321 = #b100000000000000000000000000011001 = #x100000019
@end example
@end deffn


@deffn Procedure fprintf @var{output-port} @var{fmt-string} @var{args} ...
The procedure @func{fprintf} is similar to @func{printf} except that the
output port to which the output is sent is specified as the first
argument.
@end deffn


@deffn Parameter print-unicode
@deffnx Parameter print-unicode #t
@deffnx Parameter print-unicode #f
If set to true: print Scheme Unicode characters outside of the printable
@ascii{} range in hex format, else print them using the encoding of the
output port.  The default is false.
@end deffn


@deffn Parameter print-gensym
@deffnx Parameter print-gensym #t
@deffnx Parameter print-gensym #f
@deffnx Parameter print-gensym 'pretty
The parameter @code{print-gensym} controls how gensyms are printed by
the various writers.

If the value of @code{print-gensym} is @false{}, then gensym syntax is
suppressed by the writers and only the gensyms' pretty names are
printed.  If the value of @code{print-gensym} is @true{}, then the full
@code{#@{pretty unique@}} syntax is printed.  Finally, if the value of
@code{print-gensym} is the symbol @code{pretty}, then gensyms are
printed using the @code{#:pretty} notation.

@example
> (parameterize ([print-gensym #f])
    (pretty-print (list (gensym) (gensym))))
(g0 g1)

> (parameterize ([print-gensym #t])
    (pretty-print (list (gensym) (gensym))))
(#@{g2 |KR1M2&CTt1<B0n/m|@} #@{g3 |FBAb&7NC6&=c82!O|@})

> (parameterize ([print-gensym 'pretty])
    (pretty-print (list (gensym) (gensym))))
(#:g4 #:g5)
@end example

The initial value of @code{print-gensym} is @true{}.

@end deffn


@deffn Parameter gensym-prefix
@deffnx Parameter gensym-prefix @var{string}
The parameter @code{gensym-prefix} specifies the string to be used as
the prefix to generated pretty names.  The default value of
@code{gensym-prefix} is the string @code{g}, which causes generated
strings to have pretty names in the sequence @code{g0}, @code{g1},
@code{g2}, etc.

@example
> (parameterize ([gensym-prefix "var"]
                 [print-gensym #f])
     (pretty-print (list (gensym) (gensym) (gensym))))
(var0 var1 var2)
@end example

Beware that the @code{gensym-prefix} controls how pretty names are
generated, and has nothing to do with how @func{gensym} constructs a new
gensym.  In particular, notice the difference between the output in the
first example with the output of the examples below:

@example
> (pretty-print
    (parameterize ([gensym-prefix "var"] [print-gensym #f])
      (list (gensym) (gensym) (gensym))))
(g3 g4 g5)

> (let ([ls (list (gensym) (gensym) (gensym))])
    (parameterize ([gensym-prefix "var"] [print-gensym #f])
      (pretty-print ls)))
(var5 var6 var7)
@end example
@end deffn


@deffn Parameter gensym-count
@deffnx Parameter gensym-count @var{n}
The parameter @code{gensym-count} determines the number which is
attached to the @code{gensym-prefix} when gensyms' pretty names are
generated.  The initial value of @code{gensym-count} is 0 and is
incremented every time a pretty name is generated.  It might be set to
any non-negative integer value.

@example
> (let ([x (gensym)])
    (parameterize ([gensym-count 100] [print-gensym #f])
      (pretty-print (list (gensym) x (gensym)))))
(g100 g101 g102)
@end example
@end deffn

Notice from all the examples so far that pretty names are generated in
the order at which the gensyms are printed, not in the order in which
gensyms were created.

@c page
@node iklib tracing
@section Tracing


@deffn Syntax trace-define (name . args) body body* ...
@deffnx Syntax trace-define name expression
The @func{trace-define} syntax is similar to @func{define} except that
the bound value, which must be a procedure, becomes a traced procedure.
A traced procedure prints its arguments when it is called and prints its
values when it returns.

@example
> (trace-define (fact n)
    (if (zero? n) 1 (* n (fact (- n 1)))))
> (fact 5)
|(fact 5)
| (fact 4)
| |(fact 3)
| | (fact 2)
| | |(fact 1)
| | | (fact 0)
| | | 1
| | |1
| | 2
| |6
| 24
|120
120
@end example

The tracing facility in @value{PRJNAME} preserves and shows tail recursion and
distinguishes it from non--tail recursion by showing tail calls starting
at the same line in which their parent was called.

@example
> (trace-define (fact n)
    (trace-define (fact-aux n m)
      (if (zero? n) m (fact-aux (- n 1) (* n m))))
    (fact-aux n 1))
> (fact 5)
|(fact 5)
|(fact-aux 5 1)
|(fact-aux 4 5)
|(fact-aux 3 20)
|(fact-aux 2 60)
|(fact-aux 1 120)
|(fact-aux 0 120)
|120
120
@end example

Moreover, the tracing facility interacts well with continuations and
exceptions.

@example
> (call/cc
    (lambda (k)
      (trace-define (loop n)
        (if (zero? n)
            (k 'done)
            (+ (loop (- n 1)) 1)))
      (loop 5)))
|(loop 5)
| (loop 4)
| |(loop 3)
| | (loop 2)
| | |(loop 1)
| | | (loop 0)
done
@end example
@end deffn


@deffn Syntax trace-lambda name args body body* ...
The @func{trace-lambda} macro is similar to @func{lambda} except that
the resulting procedure is traced: it prints the arguments it receives
and the results it returns.
@end deffn


@deffn Procedure make-traced-procedure @var{name} @var{proc}
The procedure @func{make-traced-procedure} takes a name (typically a
symbol) and a procedure.  It returns a procedure similar to @var{proc}
except that it traces its arguments and values.

@example
> (define (fact n)
    (if (zero? n)
        (lambda (k) (k 1))
        (lambda (k)
          ((fact (- n 1))
           (make-traced-procedure `(k ,n)
             (lambda (v)
               (k (* v n))))))))
> (call/cc
    (lambda (k)
      ((fact 5) (make-traced-procedure 'K k))))
|((k 1) 1)
|((k 2) 1)
|((k 3) 2)
|((k 4) 6)
|((k 5) 24)
|(K 120)
120
@end example
@end deffn

@c page
@node iklib timing
@section Timing


This section describes some of @value{PRJNAME}'s timing facilities which may be
useful for benchmarking and performance tuning.


@deffn Syntax time @var{expression}
The @func{time} macro performs the following: it evaluates
@var{expression}, then prints a summary of the run time statistics, then
returns the values returned by @var{expression}.  The run--time summary
includes the number of bytes allocated, the number of garbage collection
runs, and the time spent in both the mutator and the collector.

@example
> (let ()                                   ;;; 10 million
    (define ls (time (vector->list (make-vector 10000000))))
    (time (append ls ls))
    (values))
running stats for (vector->list (make-vector 10000000)):
    3 collections
    672 ms elapsed cpu time, including 547 ms collecting
    674 ms elapsed real time, including 549 ms collecting
    120012328 bytes allocated
running stats for (append ls ls):
    4 collections
    1536 ms elapsed cpu time, including 1336 ms collecting
    1538 ms elapsed real time, including 1337 ms collecting
    160000040 bytes allocated
@end example

@quotation
@emph{Note:} The output listed above is @emph{just a sample} that was
taken at some point on some machine.  The output on your machine at the
time you read this may vary.
@end quotation
@end deffn


@deffn Procedure time-it @var{who} @var{thunk}
The procedure @func{time-it} takes a datum denoting the name of the
computation and a thunk (i.e. a procedure with no arguments), invokes
the thunk, prints the stats, and returns the values obtained from
invoking the thunk.  If the value of @var{who} is non--false, @var{who}
is used when displaying the run--time statistics.  If the value of
@var{who} is @false{}, then no name for the computation is displayed.

@example
> (time-it "a very fast computation"
    (lambda () (values 1 2 3)))
running stats for a very fast computation:
    no collections
    0 ms elapsed cpu time, including 0 ms collecting
    0 ms elapsed real time, including 0 ms collecting
    24 bytes allocated
1
2
3

> (time-it #f (lambda () 12))
running stats:
    no collections
    0 ms elapsed cpu time, including 0 ms collecting
    0 ms elapsed real time, including 0 ms collecting
    0 bytes allocated
12
@end example
@end deffn


@defun time-and-gather @var{gather} @var{thunk}
Like @func{time-it} evaluate the procedure @var{thunk} timing its
execution; return the return values of @var{thunk}.  Build two objects
of type @code{stats} and apply the procedure @var{gather} to them: the
first represents the statistics before @var{thunk} evaluation, the
second represents the statistics after @var{thunk} evaluation.
@end defun


@defun stats? @var{obj}
Return true if @var{obj} is an object of type @code{stats}.
@end defun


All the fields of a @code{stats} object hold fixnums.


@defun stats-user-secs @var{stats}
Return the user seconds field of @var{stats}.
@end defun


@defun stats-user-usecs @var{stats}
Return the user microseconds field of @var{stats}.
@end defun


@defun stats-sys-secs @var{stats}
Return the system seconds field of @var{stats}.
@end defun


@defun stats-sys-usecs @var{stats}
Return the system microseconds field of @var{stats}.
@end defun


@defun stats-real-secs @var{stats}
Return the real seconds field of @var{stats}.
@end defun


@defun stats-real-usecs @var{stats}
Return the real microseconds field of @var{stats}.
@end defun


@defun stats-collection-id @var{stats}
Return the collection identifier field of @var{stats}.
@end defun

@defun stats-gc-user-secs @var{stats}
Return the garbage collection user seconds field of @var{stats}.
@end defun


@defun stats-gc-user-usecs @var{stats}
Return the garbage collection user microseconds field of @var{stats}.
@end defun


@defun stats-gc-sys-secs @var{stats}
Return the garbage collection system seconds field of @var{stats}.
@end defun


@defun stats-gc-sys-usecs @var{stats}
Return the garbage collection system microseconds field of @var{stats}.
@end defun


@defun stats-gc-real-secs @var{stats}
Return the garbage collection real seconds field of @var{stats}.
@end defun


@defun stats-gc-real-usecs @var{stats}
Return the garbage collection real microseconds field of @var{stats}.
@end defun


@defun stats-bytes-minor @var{stats}
Return the garbage collection bytes minor field of @var{stats}.
@end defun


@defun stats-bytes-major @var{stats}
Return the garbage collection bytes major field of @var{stats}.
@end defun

@c page
@node iklib guardians
@section Guardians and garbage collection


Guardians are available in the @library{ikarus} library; quoting
@bibref{DYBGUA}:

@quotation
Guardians provide a means to protect objects from destruction by the
garbage collector.  A guardian is an object with which objects can be
registered for preservation and from which objects actually saved from
destruction can be retrieved, one at a time, at the convenience of the
program.
@end quotation


@defun collect
Run the garbage collector.  If post--garbage collection hooks are
registered, they are run.  This binding is exported by the
@library{ikarus} library.
@end defun


@menu
* iklib guardians examples::    Usage examples for guardians.
* iklib guardians api::         Guardians programming interface.
@end menu

@c page
@node iklib guardians examples
@subsection Usage examples for guardians


Let's say that we use the @value{PRJNAME} @ffi{} to handle some memory
block (@ref{iklib foreign} for details on the @ffi{}); memory blocks
allocated with @func{malloc} are not released by the @value{PRJNAME}
garbage collector: we have to explicitly apply @func{free} to the
pointer value referencing them.

If we use the blocks synchronously with the evaluation of forms, we do
(assuming we do not use continuations, so this use of
@func{dynamic-wind} is fine):

@example
(import (ikarus)
  (ikarus foreign))

(define (do-something-with . args)
  (display args)
  (newline))

(let ((p        #f)
      (size     4096))
  (dynamic-wind
      (lambda ()
        (set! p (malloc size))
        (unless p (error #f "memory allocation")))
      (lambda ()
        (do-something-with p))
      (lambda ()
        (free p))))
@end example

@noindent
and we can define a syntax for it:

@example
(import (ikarus)
  (ikarus foreign))

(define (do-something-with . args)
  (display args)
  (newline))

(define-syntax with-block
  (syntax-rules ()
    ((_ ?pointer ?size ?body ...)
     (let ((?pointer    #f))
       (dynamic-wind
           (lambda ()
             (set! ?pointer (malloc ?size))
             (unless ?pointer (error #f "memory allocation")))
           (lambda ()
             ?body ...)
           (lambda ()
             (free ?pointer)))))))

(with-block p 2048
  (do-something-with p))

(with-block p 4096
  (do-something-with p))

(with-block p 8192
  (do-something-with p))
@end example

If we need the block in an event driven program: we will probably need
to use it asynchronously with the evaluation of forms.  For example, we
store the pointer value that references a block in a thunk (a closure
that takes no arguments):

@example
(import (ikarus)
  (ikarus foreign))

(define *event-source* '())

(define (enqueue-event event)
  (set! *event-source*
        (reverse (cons event (reverse *event-source*)))))

(define (pop-event)
  (if (null? *event-source*)
      #f
    (let ((event (car *event-source*)))
      (set! *event-source* (cdr *event-source*))
      event)))

;; Usage:

(define (do-something-with . args)
  (display args)
  (newline))

(let ((p (malloc 4096)))
  (unless p (error #f "memory allocation"))
  (enqueue-event (lambda ()
                   (do-something-with p)))
  (enqueue-event (lambda ()
                   (do-something-with 123)))
  (enqueue-event (lambda ()
                   (do-something-with p))))

(do ((event (pop-event) (pop-event)))
    ((not event))
  (event))
@end example

@noindent
once the thunks have been evaluated, the pointer value is garbage
collected, but the allocated memory block becomes leaked memory.  We
need a way to be notified of the pointer value garbage collection, so
that we can apply @func{free} to it; this is the job for guardians.

The following script shows the usage of a guardian to free a memory
block:

@example
(import (ikarus)
  (ikarus foreign))

(define g (make-guardian))

(let ((a (malloc (expt 2 20))))
  (unless p (error #f "memory allocation"))
  (g a)
  (printf "value ~s~%" a))

(printf "value from guardian ~s~%" (g))

;; This triggers a garbage collection.
(collect)

(let ((p (g)))
  (printf "value from guardian ~s~%" p)
  (free p))
@end example

In an event driven program what we have to do is to register the pointer
into the guardian, and then periodically enqueue as event a call to the
guardian:

@example
(import (ikarus)
  (ikarus foreign))

;; Event source handling.

(define *event-source* '())

(define (enqueue-event event)
  (set! *event-source*
        (reverse (cons event (reverse *event-source*)))))

(define (pop-event)
  (if (null? *event-source*)
      #f
    (let ((event (car *event-source*)))
      (set! *event-source* (cdr *event-source*))
      event)))

;; Block guardian.

(define block-guardian (make-guardian))

(define (run-block-guardian)
  (do ((p (block-guardian) (block-guardian)))
      ((not p))
    (printf "collecting ~s~%" p)
    (free p)))

;; Application follows.

(define (do-something-with . args)
  (display args)
  (newline))

(let ((p (malloc (expt 2 20))))
  (unless p (error #f "memory allocation"))
  (block-guardian p)
  (enqueue-event (lambda () (do-something-with p)))
  (enqueue-event (lambda () (do-something-with 123)))
  (enqueue-event (lambda () (do-something-with p)))
  (enqueue-event (lambda () (do-something-with 456))))

(do ((event (pop-event) (pop-event))
     (i 1 (+ i 1)))
    ((= i 20))
  (when event
    (event))
  (when (= 0 (modulo i 10))
    (collect)
    (enqueue-event run-block-guardian)))
@end example

@c page
@node iklib guardians api
@subsection Guardians programming interface


@defun make-guardian
Build and return a new guardian object: a closure that can be called
with one or zero arguments, and that is interfaced with the garbage
collector of the Scheme implementation (in a non--portable way).

The guardian works like this:

@itemize
@item
when the closure is called with one argument: it adds the argument to an
internal set of ``guarded values'', accessible to the garbage collector;

@item
when the garbage collector detects no other references to a value in the
set of guarded values: the guardian removes it from the set and appends
it to an internal queue (@acronym{FIFO});

@item
when the closure is called with zero arguments: it removes the first
value from the internal queue and returns it; if no values are in the
queue it returns @false{}.
@end itemize

After an object has been returned by the guardian, it is no more
``guarded'' so it will be garbage collected when it will become
inaccessible (unsless it is registered in a guardian).

@quotation
@emph{Note:} it is possible to register an object in more than one
guardian, when the object is found inaccessible all the guardian
closures that have it will return it to the caller.  This may lead to
invalid finalisation operations, it is the responsibility of the
programmer to avoid this.
@end quotation

@quotation
@emph{Note:} it is possible to register an object multiple times in the
same guardian, when the object is found inaccessible the guardian
closure that has it will return it to the caller multiple times.  This
may lead to invalid finalisation operations, it is the responsibility of
the programmer to avoid this.
@end quotation
@end defun


@deffn Parameter post-gc-hooks
Hold a list of thunks evaluated after each garbage collection run.  It
can be used to run a guardian cleanup function like this (using the
example in the previous section):

@example
(define (run-block-guardian)
  (do ((p (block-guardian) (block-guardian)))
      ((not p))
    (free p)))

(post-gc-hooks
 (cons run-block-guardian
  (post-gc-hooks)))
@end example
@end deffn

@c page
@node iklib io
@section Input/output library


@menu
* iklib io filename::           File pathname handling.
* iklib io codecs::             Transcoders and additional codecs.
* iklib io binary::             Additional binary port features.
* iklib io textual::            Additional textual port features.
* iklib io buffer::             Buffer size customisation.
* iklib io socket::             Using network sockets.
* iklib io non-block::          Non--blocking mode for ports.
* iklib io misc::               Miscellaneous port functions.
@end menu

@c page
@node iklib io filename
@subsection File pathname handling


All the file--related functions defined by @rnrs{6} accept a Scheme
string as representing a file pathname; internally such string is
converted to a bytevector to be handed to the underlying operating
system.  The following bindings are exported by the @library{ikarus}
library.


@deffn Parameter string->filename-func
In @value{PRJNAME} the string--to--filename conversion is performed by
the function returned by @func{string->filename-func}, which defaults to
@func{string->utf8}.
@end deffn


@deffn Parameter filename->string-func
In @value{PRJNAME} the filename--to--string conversion is performed by
the function returned by @func{filename->string-func}, which defaults to
@func{utf8->string}.
@end deffn

@c page
@node iklib io codecs
@subsection Transcoders and additional codecs


The following bindings are exported by the @library{ikarus} library.


@deffn Parameter native-transcoder
@findex open-input-file
@findex with-input-from-file
@findex call-with-input-file
@findex open-output-file
@findex with-output-to-file
@findex call-with-output-file
The function @func{native-transcoder} defined by @rnrs{6} returns a
transcoder representing acceptable defaults for the platform on which
the Scheme implementation is running.  Under @value{PRJNAME} such
default is:

@example
(make-transcoder (utf-8-codec) 'none 'replace)
@end example

@noindent
and additionally the function is a parameter, so the default can be
configured.  Notice that the following functions create Scheme ports
using the transcoder returned by @func{native-transcoder}:

@example
open-input-file         open-output-file
with-input-from-file    with-output-to-file
call-with-input-file    call-with-output-file
@end example
@end deffn


The codec returned by @func{utf-16-codec}, defined by @rnrs{6}, has
different semantics depending upon the type of the port:

@itemize
@item
For output and input/output ports it defaults to @utf{}-16 big endian
(which seems mandated by the Unicode Consortium).

@item
For input ports the endianness is left unspecified until the first bytes
are read: such bytes must be a valid @utf{}-16 Byte Order Mark which
dynamically configures the port.@footnote{The big endian @acronym{BOM}
for @utf{}-16 is the sequence of bytes @code{#xFE #xFF}; the little
endian @acronym{BOM} for @utf{}-16 is the sequence of bytes @code{#xFF
#xFE}.}
@end itemize


@deffn Procedure utf-16le-codec
@deffnx Procedure utf-16be-codec
Codecs for the @utf{}-16 encoding schemes, little endian and big endian.
A call to any of these procedures returns a value that is equal in the
sense of @func{eqv?} to the result of any other call to the same
procedure.
@end deffn


@deffn Procedure utf-16n-codec
Return a codec for the @utf{}-16 encoding scheme, with endianness equal
to the one returned by @func{(native-endianness)}.  A call to this
procedure returns a value that is equal in the sense of @func{eqv?} to
the result of any other call to the same procedure.
@end deffn


@deffn Procedure utf-bom-codec
Codec for @utf{} encoding schemes whose data open with a Byte Order
Mark.  A call to this procedure returns a value that is equal in the
sense of @func{eqv?} to the result of any other call to the same
procedure.

At present this codec is supported only by input ports.
@end deffn

@c page
@node iklib io binary
@subsection Additional binary port features


The following bindings are exported by the @library{ikarus} library.


@defun lookahead-two-u8 @var{port}
Like @func{lookahead-u8} but peeks at @math{2} octets and return two
values: the @eof{} object or a fixnum representing first octet, the
@eof{} object or a fixnum representing the second octet.
@end defun


@defun console-input-port
Return the default value of the @func{current-input-port} parameter.  It
is used by the @repl{} and the debugger.
@end defun


@defun console-output-port
Return the default value of the @func{current-outptu-port} parameter.
It is used by the @repl{} and the debugger.
@end defun


@defun console-error-port
Return the default value of the @func{current-error-port} parameter.  It
is used by the @repl{} and the debugger.
@end defun


@defun make-binary-file-descriptor-input-port @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-output-port @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-input/output-port @var{fd} @var{identifier}
Build and return binary Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  Closing the Scheme ports will close the file
descriptors too.
@end defun


@defun make-binary-file-descriptor-input-port* @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-output-port* @var{fd} @var{identifier}
@defunx make-binary-file-descriptor-input/output-port* @var{fd} @var{identifier}
Build and return binary Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  Closing the Scheme ports will @strong{not} close the
file descriptors.
@end defun


@defun make-binary-socket-input/output-port @var{sock} @var{identifier}
Build and return a binary Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  Closing the Scheme port will close the
socket descriptor too.
@end defun


@defun make-binary-socket-input/output-port* @var{sock} @var{identifier}
Build and return a binary Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  Closing the Scheme port will @strong{not}
close the socket descriptor.
@end defun

@c page
@node iklib io textual
@subsection Additional textual port features


The following bindings are exported by the @library{ikarus} library.


@defun open-string-input-port @var{string}
@defunx open-string-input-port @var{string} @var{eol-style}
As defined by @rnrs{6}: return a textual input port whose characters are
drawn from @var{string}.  When @var{eol-style} is given: it must be a
symbol selecting an end--of--line style conversion, as accepted by
@func{eol-style}; such conversion is applied to the characters drawn
from @var{string}.

If @var{string} is modified after @func{open-string-input-port} has been
called, the effect on the returned port is unspecified.
@end defun


@defun open-string-input-port/id @var{string} @var{id}
@defunx open-string-input-port/id @var{string} @var{id} @var{eol-style}
Like @func{open-string-input-port} but allows the specification of a
customised port identifier @var{id}, which must be a Scheme string.
@end defun


@defun open-string-output-port
@defunx open-string-output-port @var{eol-style}
As defined by @rnrs{6}, return two values: a textual output port and an
extraction procedure; the output port accumulates the characters written
to it for later extraction by the procedure.

As a @value{PRJNAME} extension, when @var{eol-style} is given: it must
be a symbol selecting an end--of--line style conversion, as accepted by
@func{eol-style}; such conversion is applied to the characters written
to the port.
@end defun


@defun get-output-string @var{port}
Return the string accumulated in the @var{port} opened by
@func{open-string-output-port}.  This function can be called also when
the port has been closed.
@end defun


@defun get-char-and-track-textual-position @var{port}
Like @func{get-char} but track the textual position.  Recognise only
linefeed characters as line-ending.
@end defun


@defun port-textual-position @var{port}
Given a textual port, return the current textual position as a condition
object of type @condition{source-position}.
@end defun


@defun make-textual-file-descriptor-input-port @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-output-port @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-input/output-port @var{fd} @var{identifier} @var{transcoder}
Build and return textual Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  @var{transcoder} must be a transcoder object.  Closing
the Scheme ports will close the file descriptors too.
@end defun


@defun make-textual-file-descriptor-input-port* @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-output-port* @var{fd} @var{identifier} @var{transcoder}
@defunx make-textual-file-descriptor-input/output-port* @var{fd} @var{identifier} @var{transcoder}
Build and return textual Scheme ports using the platform file descriptor
@var{fd} as device.  @var{identifier} must be a string used for better
error reporting.  @var{transcoder} must be a transcoder object.  Closing
the Scheme ports will @strong{not} close the file descriptors.
@end defun


@defun make-textual-socket-input/output-port @var{sock} @var{identifier} @var{transcoder}
Build and return a textual Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  @var{transcoder} must be a transcoder
object.  Closing the Scheme port will close the socket descriptor too.
@end defun


@defun make-textual-socket-input/output-port* @var{sock} @var{identifier} @var{transcoder}
Build and return a textual Scheme port using the platform socket
descriptor @var{sock} as device.  @var{identifier} must be a string used
for better error reporting.  @var{transcoder} must be a transcoder
object.  Closing the Scheme port will @strong{not} close the socket
descriptor.
@end defun

@c page
@node iklib io buffer
@subsection Buffer size customisation


The following bindings are exported by the @library{ikarus} library.


@deffn Parameter bytevector-port-buffer-size
@deffnx Parameter bytevector-port-buffer-size @var{fixnum}
Hold the buffer size for bytevector ports, like the one returned by
@func{open-bytevector-output-port}.  It is initialised to @math{16384}.
@end deffn


@deffn Parameter string-port-buffer-size
@deffnx Parameter string-port-buffer-size @var{fixnum}
Hold the buffer size for string ports, like the one returned by
@func{open-string-output-port}.  It is initialised to @math{256}.
@end deffn


@deffn Parameter input-file-buffer-size
@deffnx Parameter input-file-buffer-size @var{fixnum}
Hold the buffer size for input file ports, like the one returned by
@func{open-input-file}.  It is initialised to @math{16384}.
@end deffn


@deffn Parameter output-file-buffer-size
@deffnx Parameter output-file-buffer-size @var{fixnum}
Hold the buffer size for output file ports, like the one returned by
@func{open-output-file}.  It is initialised to @math{16384}.
@end deffn


@deffn Parameter input/output-file-buffer-size
@deffnx Parameter input/output-file-buffer-size @var{fixnum}
Hold the buffer size for input/output file ports, like the one returned
by @func{open-file-input/output-prot}.  It is initialised to
@math{16384}.
@end deffn


@deffn Parameter input/output-socket-buffer-size
@deffnx Parameter input/output-socket-buffer-size @var{fixnum}
Hold the buffer size for socket ports.  It is initialised to
@math{16384}.
@end deffn

@c page
@node iklib io socket
@subsection Using network sockets


@menu
* iklib io socket client::      Establishing client network
                                connections.
* iklib io socket server::      Opening server network services.
@end menu

@c page
@node iklib io socket client
@subsubsection Establishing client network connections


The following bindings are exported by the @library{ikarus} library.


@defun tcp-connect @var{hostname} @var{service}
@defunx udp-connect @var{hostname} @var{service}
@defunx tcp-connect-nonblocking @var{hostname} @var{service}
@defunx udp-connect-nonblocking @var{hostname} @var{service}
Establish a network connection using the @tcp{} or @udp{} protocol, to
the host selected by the string @var{hostname}, port/service selected by
the string @var{service}.  The @code{-nonblocking} version sets the
underlying socket descriptor to non--blocking mode (@ref{iklib io
non-block}).  Upon success, return a port; if an error occurs an
exception is raised.

@var{hostname} can be a dotted decimal address for IPv4, or a
hexadecimal string for IPv6, or a network address.

@var{service} can be a numerical string representing the port, or the
``official'' name of a service, like @code{smtp} or @code{pop3}.

@quotation
@forunix{} These functions use of the @cfunc{socket}, @cfunc{connect}
and @cfunc{get@-addr@-info} system functions.

@glibcref{Creating a Socket, Creating a Socket}@*
@glibcref{Connecting, Making a Connection}@*
See the @cfunc{getaddrinfo} manual page.@*
See the @file{/etc/services} configuration file.
@end quotation
@end defun

@c page
@node iklib io socket server
@subsubsection Opening server network services


The following bindings are exported by the @library{ikarus} library.


@defun tcp-server-socket @var{server-port-number}
@defunx tcp-server-socket-nonblocking @var{server-port-number}
Build a new @tcp{} server object for the selected port number (which
must be an exact integer).  The @code{-nonblocking} versions set the
underlying socket descriptor to non--blocking mode (@ref{iklib io
non-block}).  Upon success, return a server--object; if an error occurs
an exception is raised.

@quotation
@forunix{} These functions make use of the @cfunc{socket},
@cfunc{setsockopt}, @cfunc{bind} and @cfunc{listen} system functions.
The socket is configured with the @code{AF_INET}, @code{INADDR_ANY},
@code{SO_REUSEADDR} values and options (@value{PRJNAME} version 0.0.3+, checkout
1468).

@glibcref{Creating a Socket, Creating a Socket}@*
@glibcref{Socket Option Functions, Socket Option Functions}@*
@glibcref{Setting Address, Setting the Address of a Socket}@*
@glibcref{Listening, Listening for Connections}
@end quotation
@end defun


@defun accept-connection @var{server-object}
@defunx accept-connection-nonblocking @var{server-object}
Accept the next incoming connection to the selected server.  If success
return two values:

@enumerate
@item
an output port to be used to send data;

@item
an input port to be used to receive data;
@end enumerate

@noindent
if an error occurs: an exception is raised.  The @code{-nonblocking}
versions set the underlying socket descriptor to non--blocking mode
(@ref{iklib io non-block}).

If the server socket was configured as blocking: this function suspends
the process waiting for an incoming connection.

@quotation
@fixme{What happens when the server socket is configured as
non--blocking?}
@end quotation

@quotation
@forunix{} These functions make use of the @cfunc{accept} system call.

@glibcref{Accepting Connections, Accepting Connections}
@end quotation
@end defun


@defun close-tcp-server-socket @var{server-object}
Close a server socket causing it to stop listening.

@quotation
@forunix{} this function makes use of the @cfunc{shutdown} system
function.

@glibcref{Closing a Socket, Closing a Socket}
See also the @cfunc{shutdown} manual page.
@end quotation
@end defun


@defun register-callback @var{server-object} @var{proc}
Register a callback function to be invoked whenever a new incoming
connection request happens on @var{server-object}.  The callback will be
invoked by the @value{PRJNAME} event loop.

@quotation
@fixme{What are the parameters that get passed to @var{proc}?  Look for
@func{make-t} and @func{t-proc} in @file{ikarus.io.sls}.}
@end quotation
@end defun


@deffn Parameter input-socket-buffer-size
Select the size in bytes of the input buffer for server sockets.  The
value must be a fixnum greater or equal to 128.
@end deffn


@deffn Parameter output-socket-buffer-size
Select the size in bytes of the output buffer for server sockets.  The
value must be a fixnum greater than zero.
@end deffn

@c page
@node iklib io non-block
@subsection Non--blocking mode for ports


@forunix{} Non--blocking mode is setup with a call like:

@example
fcntl(fd, F_SETFL, O_NONBLOCK);
@end example

@noindent
@glibcref{Control Operations, Control Operations}@*
@glibcref{Open-time Flags, Open-time Flags}

@c page
@node iklib io misc
@subsection Miscellaneous port functions


The following bindings are exported by the @library{ikarus} library.


@defun port-fd @var{port}
If @var{port} is a port with a file descriptor as device: return a
fixnum representing the device, else return @false{}.
@end defun


@defun port-id @var{port}
Return a Scheme string representing the identifier of @var{port}.
@end defun


@defun set-port-buffer-mode! @var{port} @var{buffer-mode}
Reset the port buffer mode to @var{buffer-mode}, which must be one of
the arguments accepted by @func{buffer-mode}.  It is an error to select
@code{line} mode if @var{port} is a binary port.
@end defun


@defun port-dump-status @var{port}
To be used for debugging purposes.  Write to the current error port some
informations on the internals of @var{port}.
@end defun

@c page
@node iklib foreign
@section The @library{vicare foreign} library


This chapter describes the facilities through which @value{PRJNAME}
interfaces with the host operating system and other external libraries.
The facilities of the @library{vicare foreign} library give the Scheme
program unrestricted access to the computer memory, allowing one to
allocate, access, modify, and free memory as needed.  The facilities
also allow the Scheme program to @emph{call out} to system procedures as
well as allow the native procedures to @emph{call back} into Scheme.

@ignore
An original paragraph giving an overview of this chapter contents was
omitted because with the menu above it is useless, and because it looked
outdated.
@end ignore

@quotation
@emph{Note:} @value{PRJNAME} version @code{0.0.4} is the first version
of @value{PRJNAME} to support the described foreign interfaces.
@end quotation

@quotation
@emph{Caveat emptor:} Preparing each call out and call back procedure
leaks a small amount of memory.  This is because the system cannot track
such pointers that go into native code (which may retain such pointers
indefinitely).  Use judiciously.
@end quotation

@menu
* iklib foreign overview::  Overview of the foreign functions
                                interface.
* iklib foreign memory::    Memory management.
* iklib foreign memops::    Memory operations.
* iklib foreign dl::        Accessing foreign objects from Scheme.
* iklib foreign call out::  Calling out to foreign procedures.
* iklib foreign call back:: Calling back to Scheme.
@end menu

@c page
@node iklib foreign overview
@subsection Overview of the foreign functions interface


In order to make full use of the computer, it is important for a
programming environment (e.g., @value{PRJNAME} Scheme) to facilitate
access to the underlying architecture on which it runs.  The underlying
architecture includes the @api{} provided by the host operating system
kernel (e.g., Linux), the system libraries (e.g., @code{libc}), and
other site--installed libraries (e.g., @code{sqlite3}).

Providing direct access to such @api{} from within Scheme allows the
programmer to write Scheme libraries that have few or no dependencies on
external programs (such as @code{C} development toolchain).  When
dealing with system libraries, the programmer must have a thorough
understanding of many aspects of the targeted system.  This section
attempts to provide answers to many questions that are frequently
encountered when interfacing to external libraries.

@c ------------------------------------------------------------

@subsubheading Libffi


Currently (Sat May 1, 2010) @value{PRJNAME} implements the foreign
functions interface (@ffi{}) using an extenal library: Libffi,
originally by Anthony Green.  Libffi can be found at:

@center @url{http://sourceware.org/libffi/}

@noindent
and it is distributed under a liberal license (look for it at the site,
basically we can do everything but remove the original copyright
notice).

On Unix--like systems, we can install Libffi with the traditional
sequence:

@example
$ ./configure [options]
$ make
$ make install
@end example

@noindent
and the makefile supports the @env{DESTDIR} environment variable for
installation under a different directory prefix.

@quotation
@emph{Note:} Libffi version 3.0.6 installs its header files under:

@example
$@{prefix@}/lib/libffi-3.0.6/include
@end example

@noindent
and trying to use the @option{--includedir} option to
@command{configure} will @strong{not} work in changing this.  It means
that when configuring @value{PRJNAME} for installation we have to specify where
the Libffi headers are to be found; @ref{overview install} for details.
@end quotation

@c page
@node iklib foreign memory
@subsection Memory management


@value{PRJNAME} Scheme is a managed environment.  Like in many
programming environments, @value{PRJNAME} manages its own memory.
Scheme objects are allocated in a special memory region (the Scheme
heap) and have type--specific object layouts; this allows the run time
system to distinguish object types and the garbage collector to locate
all potentially live objects, and reclaim the memory of dead objects.
Scheme objects are also @emph{opaque} in the sense that the data
structures used to represent Scheme objects (e.g., pairs) are not
exposed to the programmer, who can only interact with objects through an
interface (e.g., @code{car}, @code{cdr}).

Unmanaged environments, such as the operating system on which
@value{PRJNAME} runs, require that the programmer manages the allocation
and deallocation of system resources herself.  Memory regions, file
handles, external devices, the screen, etc., are all examples of
resources whose management must be coordinated among the different parts
of the system, and this becomes the responsibility of the programmer who
is wiring the different subsystems together.

Memory, from a system's point of view, is @emph{transparent}.  A pointer
is an integer denoting an address of memory.  This memory address may
contain a value that requires interpretation.  At the lowest--level,
each byte of memory contains eight bits, each of which may be toggled on
or off.  A level higher, contiguous sequences of bytes are grouped
together and are interpreted as integers, floating point numbers, or
pointers to other memory addresses.  These are the basic data types that
are often interpreted atomically.  Yet a level higher, groups of basic
types form data structures such as arrays, linked lists, trees, and so
on.  Objects, as found in object--oriented programming languages, are at
an even higher level of abstraction since they are treated as opaque
references that retain state and know how to respond to messages.

The procedures in the @library{vicare foreign} library are meant to
provide a way to interface with the low level memory operations such as
setting and getting bytes from specific locations in memory.  Although
they do not provide high--level operations, the basic procedures make
implementing high--level operations (such as the Objective--C system)
possible.  Programmers are encouraged to define their own abstractions
that are most suitable for the specific target library rather than using
the low--level operations directly.  This results in writing more robust
and more easily maintainable libraries.  To put it more boldly:
@strong{Do not sprinkle your code with low--level memory operations}.

@c page
@node iklib foreign memops
@subsection Memory operations


@menu
* iklib foreign memops alloc::    Allocating and freeing memory.
* iklib foreign memops pointer::  Handling pointer values.
* iklib foreign memops poke::     Poking values.
* iklib foreign memops peek::     Peeking values.
@end menu

@c page
@node iklib foreign memops alloc
@subsubsection Allocating and freeing memory


@deffn Procedure malloc @var{number-of-bytes}
Allocate a block of memory and return a pointer to it.  The
@func{malloc} Scheme procedure is implemented using the host--provided
@cfunc{malloc} system procedure (often found in @code{libc}).  The
number of bytes must be a positive exact integer.

@example
> (malloc 10)
#<pointer #x00300320>
> (malloc 10000)
#<pointer #x01800400>
@end example

In case of failure allocating memory: the return value is @false{}.
@end deffn


@deffn Procedure free @var{pointer-to-memory-block}
Release the memory region at the given address.  The memory region must
have been allocated with @cfunc{malloc}, @cfunc{calloc}, or a similar
system procedure.  Once freed, memory operations on the given address
are invalid and may cause the system to crash at unpredictable times.
@value{PRJNAME} cannot check for such errors since the memory may be freed by
procedures that are external to @value{PRJNAME}.
@end deffn

@c page
@node iklib foreign memops pointer
@subsubsection Handling pointer values


The result of calling the procedures @func{eq?}, @func{eqv?} and
@func{equal?} on pointer values is unspecified.


@deffn Procedure pointer->integer @var{pointer}
Convert the value of @var{pointer} to an exact integer value.  The
result may be a fixnum or a bignum depending on the pointer.
@end deffn


@deffn Procedure integer->pointer @var{exact-integer}
Convert @var{exact-integer} to a pointer value.  The lower 32 bits (or
64 bits on 64-bit systems) of the argument are significant in computing
the pointer value.  It is guaranteed that @code{(integer->pointer
(pointer->integer p))} points to the same address as @var{p}.
@end deffn


@deffn Procedure pointer? @var{x}
Return @true{} if the value of @var{x} is a pointer, return @false{}
otherwise.
@end deffn


@deffn Procedure pointer-size
Return the number of bytes required to hold a pointer on the underlying
platform.
@end deffn

@c page
@node iklib foreign memops poke
@subsubsection Poking values


With all the following functions: the @var{pointer} argument must be a
valid pointer; the @var{offset} and @var{value} arguments must be exact
integers.  When adding an offset to a pointer: all the following
functions @strong{do not} scale the offset to the size of the poked
value.  Pointer arithmetics is performed with byte offsets.


@macro poker{BYTENUM,BITNUM}
Set to @var{value} the \BYTENUM\ of memory located at @var{offset} from
@var{pointer}.  Only the \BITNUM\ lowermost bits of @var{value} are used
in the operation and the remaining bits are ignored.
@end macro


@c ------------------------------------------------------------

@subsubheading Poking exact integers


@deffn Procedure pointer-set-c-char! @var{pointer} @var{offset} @var{value}
@poker{single byte,8}
@end deffn


@deffn Procedure pointer-set-c-short! @var{pointer} @var{offset} @var{value}
@poker{two bytes,16}
@end deffn


@deffn Procedure pointer-set-c-int! @var{pointer} @var{offset} @var{value}
@poker{four bytes,32}
@end deffn


@deffn Procedure pointer-set-c-long! @var{pointer} @var{offset} @var{value}
On 64-bit systems: @poker{eight bytes,64}

On 32-bit systems: perform the same task as @func{pointer-set-c-int!}.
@end deffn


@deffn Procedure pointer-set-c-long-long! @var{pointer} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{long
long} type located at @var{offset} from @var{pointer}.
@end deffn


@c ------------------------------------------------------------

@subsubheading Poking floating point numbers


@deffn Procedure pointer-set-c-float! @var{pointer} @var{offset} @var{flonum}
Convert the Scheme floating point number @var{flonum} (represented in
@value{PRJNAME} as an @ieee{} 754 double precision floating point number) to a
float (an @ieee{} 754 single precision floating point number) and store
the result in the four bytes at @var{offset} from @var{pointer}.
@end deffn


@deffn Procedure pointer-set-c-double! @var{pointer} @var{offset} @var{flonum}
Store the double precision @ieee{} 754 floating point value of the
Scheme @var{flonum} in the eight bytes at @var{offset} from
@var{pointer}.
@end deffn


@c ------------------------------------------------------------

@subsubheading Poking pointers


@deffn Procedure pointer-set-c-pointer! @var{pointer} @var{offset} @var{value}
On 64-bit systems: set the eight bytes at @var{offset} from
@var{pointer} to the 64-bit pointer @var{value}.

On 32-bit systems: set the four bytes at @var{offset} from @var{pointer}
to the 32-bit pointer @var{value}.
@end deffn

@c page
@node iklib foreign memops peek
@subsubsection Peeking values


With all the following functions: the @var{pointer} argument must be a
valid pointer; the @var{offset} argument must be an exact integer.  When
adding an offset to a pointer: all the following functions @strong{do
not} scale the offset to the size of the poked value.  Pointer
arithmetics is performed with byte offsets.


@c ------------------------------------------------------------

@subsubheading Peeking exact integers


@deffn Procedure pointer-ref-c-signed-char @var{pointer} @var{offset}
Peek the single byte located at @var{offset} from @var{pointer} and
return an exact integer representing the sign--extended integer value of
that byte. The resulting value is in the inclusive range @code{[-128,
127]}.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-char @var{pointer} @var{offset}
Peek the single byte located at @var{offset} from @var{pointer} and
return an exact integer representing the unsigned integer value of that
byte.  The resulting value is in the inclusive range @code{[0, 255]}.
@end deffn


The following example shows the difference between the two functions
above:

@example
> (let ([p (malloc 3)])
    (pointer-set-c-char! p 0 #b01111111)
    (pointer-set-c-char! p 1 #b10000000)
    (pointer-set-c-char! p 2 #b11111111)
    (let ([result
           (list (pointer-ref-c-signed-char p 0)
                 (pointer-ref-c-signed-char p 1)
                 (pointer-ref-c-signed-char p 2)
                 (pointer-ref-c-unsigned-char p 0)
                 (pointer-ref-c-unsigned-char p 1)
                 (pointer-ref-c-unsigned-char p 2))])
      (free p)
      result))
(127 -128 -1 127 128 255)
@end example


@deffn Procedure pointer-ref-c-signed-short @var{pointer} @var{offset}
Peek two bytes at @var{offset} from @var{pointer} and return an exact
integer representing the sign--extended integer value of the sequence.
The resulting value is in the inclusive range @code{[-32768, 32767]}.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-short @var{pointer} @var{offset}
Peek two bytes at @var{offset} from @var{pointer} and return an exact
integer representing the unsigned integer value of the sequence.  The
resulting value is in the inclusive range @code{[0, 65535]}.
@end deffn


@deffn Procedure pointer-ref-c-signed-int @var{pointer} @var{offset}
Peek four bytes at @var{offset} from @var{pointer} and return an exact
integer in the inclusive range @code{[-2^31, 2^31-1]}.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-int @var{pointer} @var{offset}
Peek four bytes at @var{offset} from @var{pointer} and return an exact
integer in the inclusive range @code{[0, 2^32-1]}.
@end deffn


@deffn Procedure pointer-ref-c-signed-long @var{pointer} @var{offset}
On 64-bit systems: peek eight bytes at @var{offset} from @var{pointer}
and return an integer in the inclusive range @code{[-2^63, 2^63-1]}.

On 32-bit systems, perform the same task as
@func{pointer-ref-c-signed-int}.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-long @var{pointer} @var{offset}
On 64-bit systems: peek eight bytes at @var{offset} from @var{pointer}
and return an integer in the inclusive range @code{[0, 2^64-1]}.

On 32-bit systems: perform the same task as
@func{pointer-ref-c-unsigned-int}.
@end deffn


@deffn Procedure pointer-ref-c-signed-long-long @var{pointer} @var{offset}
Peek a number of bytes corresponding to the native @code{long long} type
at @var{offset} from @var{pointer} and return an integer.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-long-long @var{pointer} @var{offset}
Peek a number of bytes corresponding to the native @code{unsigned long
long} type at @var{offset} from @var{pointer} and return an integer.
@end deffn

@c ------------------------------------------------------------

@subsubheading Peeking floating point numbers


@deffn Procedure pointer-ref-c-float @var{pointer} @var{offset}
Return the four--byte float (represented as @ieee{} 754 single precision
floating point number) stored at @var{offset} from @var{pointer}.  The
value is extended to an @ieee{} 754 double precision floating point
number that @value{PRJNAME} uses to represent inexact numbers.
@end deffn


@deffn Procedure pointer-ref-c-double @var{pointer} @var{offset}
Return the eight--byte float (represented as @ieee{} 754 double
precision floating point number) stored at @var{offset} from
@var{pointer}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Peeking pointers


@deffn Procedure pointer-ref-c-pointer @var{pointer} @var{offset}
Return the pointer stored at @var{offset} from @var{pointer}.  The size
of the pointer (also the number of bytes loaded) depends on the
architecture: it is 4 bytes on 32-bit systems and 8 bytes on 64-bit
systems.
@end deffn

@c page
@node iklib foreign dl
@subsection Accessing foreign objects from Scheme


@deffn Procedure dlopen
@deffnx Procedure dlopen @var{library-name}
@deffnx Procedure dlopen @var{library-name} @var{lazy?} @var{global?}
Take the string @var{library-name} representing a system library and
call the system procedure @cfunc{dlopen} which dynamically loads the
given library into the running process.

The name of the library is system--dependent and must include the
appropriate suffix (e.g. @code{*.so} on Linux, @code{*.dylib} on Darwin
and @code{*.dll} on Cygwin).  @var{library-name} may include a full path
which identifies the location of the library, or it may just be the name
of the library in which case the system will lookup the library name
using the @env{LD_LIBRARY_PATH} environment variable.

The argument @var{lazy?} specifies how library dependencies are loaded.
If true, @func{dlopen} delays the resolution and loading of dependent
libraries until they are actually used.  If false, all library
dependencies are loaded before the call to @func{dlopen} returns.

The argument @func{global?} specifies the scope of the symbols exported
from the loaded library.  If true, all exported symbols become part of
the running image, and subsequent @func{dlsym} calls may not need to
specify the library from which the symbol is loaded.  If false, the
exported symbols are not global and the library pointer needs to be
specified for @func{dlsym}.

Calling @code{(dlopen library-name)} is equivalent to @code{(dlopen
library-name #f #f)}.  Calling @code{(dlopen)} without arguments returns
a pointer to the current process.

If succesful, @func{dlopen} returns a pointer to the external library
which can be used subsequently by @func{dlsym} and @func{dlclose}.  If
the library cannot be loaded, @func{dlopen} returns @false{} and the
procedure @func{dlerror} can be used to obtain the cause of the failure.

Consult the @code{dlopen(3)} page in your system manual for further
details.
@end deffn


@deffn Procedure dlclose @var{library-pointer}
A wrapper for the system procedure of the same name.  It receives a
library pointer (e.g. one obtained from @func{dlopen}) and releases the
resources loaded from that library.  Closing a library renders all
symbols and static data structures that the library exports invalid and
the program may crash or corrupt its memory if such symbols are used
after a library is closed.

Most system implementations of dynamic loading employ reference counting
for @func{dlopen} and @func{dlclose} in that library resources are not
freed until the number of calls to @func{dlclose} matches the number of
calls to @func{dlopen}.

The procedure @func{dlclose} returns a boolean value indicating whether
the success status of the operation.  If @func{dlclose} returns
@false{}, the procedure @func{dlerror} can be used to obtain the cause
of the error.

Consult the @code{dlclose(3)} page in your system manual for further
details.
@end deffn


@deffn Procedure dlsym @var{library-pointer} @var{string}
Take a library pointer (e.g. one obtained by a call to @func{dlopen})
and a string representing the name of a symbol that the library exports
and return a pointer to the location of that symbol in memory.  If
@func{dlsym} fails, it returns @false{} and the cause of the error can
be obtained using the procedure @code{dlerror}.

Consult the @code{dlsym(3)} page in your system manual for further
details.
@end deffn


@deffn Procedure dlerror
If any of the dynamic loading operations (i.e., @func{dlopen},
@func{dlclose}, @func{dlsym}) fails, the cause of the error can be
obtained by calling @func{dlerror} which returns a string describing the
error.  The procedure @func{dlerror} returns @false{} if there was no
dynamic loading error.

Consult the @code{dlerror(3)} page in your system manual for further
details.
@end deffn

@c page
@node iklib foreign call out
@subsection Calling out to foreign procedures


@value{PRJNAME} provides the means to call out from Scheme to foreign
procedures.  This allows the programmers to extend @value{PRJNAME} to
access system--specific facilities that are available on the host
machine.

@menu
* iklib foreign call out api::      Interface to foreign functions.
* iklib foreign call out types::    Type specifiers.
* iklib foreign call out example::  C language call out example.
@end menu

@c page
@node iklib foreign call out api
@subsubsection Interface to foreign functions


In order to call out to a foreign procedure, one must provide two pieces
of information: the signature of the foreign procedure (e.g. its type
declaration if it is a C language procedure) and the address of the
procedure in memory.  The address of the procedure can be easily
obtained using @func{dlsym} if the name of the procedure and its
exporting library are known.  The signature of the procedure cannot, in
general, be obtained dynamically, and therefore must be hard coded into
the program.

The signature of the foreign procedure is required for proper linkage
between the Scheme system and the foreign system.  Using the signature,
@value{PRJNAME} determines how Scheme values are converted into native values,
and where (e.g. in which registers and stack slots) to put these
arguments.  The signature also determines where the returned values are
placed and how they are converted from the system data types to the
corresponding Scheme data types.

A procedure's signature is composed of two parts: the return type and
the parameter types:

@itemize
@item
the return type is a symbol that can be any one of the type specifiers
listed in @ref{iklib foreign call out types};

@item
the parameter types is a list of type specifier symbols; if the foreign
function takes no arguments: the parameter types must be the empty list;
@end itemize

@noindent
the symbol @code{void} can appear as a return type but cannot appear as
a parameter type.


@deffn Procedure make-c-callout @var{return-type} @var{parameter-types}
The procedure @func{make-c-callout} is the primary facility for making
foreign procedures callable from Scheme.  It works as follows:

@enumerate
@item
@func{make-c-callout} receives two arguments denoting the signature of
the procedure to be called; it prepares a bridge that converts from
Scheme's calling conventions and data structures to their foreign
counterparts; it returns a procedure @func{p1};

@item
the procedure @func{p1} accepts a pointer to a foreign procedure
(e.g. one obtained from @func{dlsym}) and returns a Scheme procedure
@func{p2} that encapsulates the foreign procedure;

@item
the final procedure @func{p2} can be called with as many arguments as
the ones specified in the @var{parameter-types}; the parameters supplied
to @func{p2} must match the types supplied as the @var{parameter-types}
according to the ``Valid Scheme types'' column in the table in
@ref{iklib foreign call out types};

@item
the procedure @func{p2} converts the parameters from Scheme types to
native types, calls the foreign procedure, obtains the result, and
converts it to the appropriate Scheme value (depending on the
@var{return-type}).
@end enumerate

The interface of @func{make-c-callout} is broken down into three stages
in order to accomodate common usage patterns.  Often a function
signature can be used by many foreign procedures and therefore,
@func{make-c-callout} can be called once per signature and each
signature can be used multiple times.  Similarly, separating the foreign
procedure preparation from parameter passing allows for preparing the
foreign procedure once and calling it many times.

The list of types in the table in @ref{iklib foreign call out types} is
restricted to basics and provides no automatic conversion from composite
Scheme data structures (such as strings, symbols, vectors, and lists) to
native types.  The restriction is intentional in order for
@value{PRJNAME} to avoid making invalid assumptions about the memory
management of the target library.

@quotation
For example, while @value{PRJNAME} @emph{can} convert a Scheme string to a native
byte array (e.g. use @func{string->bytevector} to decode the string,
then use @func{malloc} to allocate a temporary buffer, then copy the
bytes from the bytevector to the allocated memory), it cannot decide
when this allocated byte array is no longer needed and should be freed.
This knowledge is library--dependent and is often procedure--dependent.
Therefore, @value{PRJNAME} leaves it to the programmer to manage all memory
related issues.
@end quotation

Outgoing parameters to foreign procedures are checked against the
declared types.  For example, if a callback is prepared to expect a
parameter of type @code{signed-int}, only exact integers are allowed to
be passed out.  For integer types, only a fixed number of bits is used
and the remaining bits are ignored.  For floating point types, the
argument is checked to be a Scheme flonum.  No implicit conversion
between exact and inexact numbers is performed.
@end deffn

@c page
@node iklib foreign call out types
@subsubsection Type specifiers


The following table lists valid type specifiers that can be used in
callout and callback signatures.  Specifiers with ``4/8 bytes'' have
size that depends on the system: it is 4 bytes on 32-bit systems and 8
bytes on 64-bit systems.  The @code{void} specifier can only be used as
a return value specifier to mean ``no useful value is returned''.


@multitable {@code{unsigned-short}} {4/8 bytes} {Valid Scheme types} {Corresponding C types}
@headitem Type specifier @tab Size @tab Valid Scheme types @tab Corresponding C types
@item
@code{signed-char} @tab 1 byte @tab exact integer @tab @code{char}
@item
@code{unsigned-char} @tab 1 byte @tab exact integer @tab @code{unsigned char}
@item
@code{signed-short} @tab 2 bytes @tab exact integer @tab @code{short}
@item
@code{unsigned-short} @tab 2 bytes @tab exact integer @tab @code{unsigned short}
@item
@code{signed-int} @tab 4 bytes @tab exact integer @tab @code{int}
@item
@code{unsigned-int} @tab 4 bytes @tab exact integer @tab @code{unsigned int}
@item
@code{signed-long} @tab 4/8 bytes @tab exact integer @tab @code{long}
@item
@code{unsigned-long} @tab 4/8 bytes @tab exact integer @tab @code{unsigned long}
@item
@code{float} @tab 4 bytes @tab flonum @tab @code{float}
@item
@code{double} @tab 8 bytes @tab flonum @tab @code{double}
@item
@code{pointer} @tab 4/8 bytes @tab pointer @tab @code{void*}, @code{char*}, @code{int*}, @code{int**}, etc
@item
@code{void} @tab --- @tab --- @tab @code{void}
@end multitable



@c page
@node iklib foreign call out example
@subsubsection C language call out example


The following example illustrates the use of the @func{make-c-callout}
procedure in combination with @func{dlopen} and @func{dlsym}; the
session was run on a 32-bit @value{PRJNAME} running under Mac OS X 10.4:

@enumerate
@item
the @file{libc.dylib} foreign library is loaded and is bound to the
variable @code{libc};

@item
we obtain a pointer to the @cfunc{atan} foreign procedure that is
defined in @code{libc}; the native procedure @cfunc{atan} takes a
@code{double} as an argument and returns a @code{double} and that's the
signature that we use for @func{make-c-callout};

@item
we call the foreign procedure interface with one argument, @code{1.0},
which is a flonum and thus matches the required parameter type; the
native procedure returns a @code{double} value which is converted to the
Scheme flonum with value @code{0.7853981633974483}.
@end enumerate

@example
> (import (ikarus foreign))
> (define libc (dlopen "libc.dylib"))
> libc
#<pointer #x00100770>
> (define libc-atan-ptr (dlsym libc "atan"))
> libc-atan-ptr
#<pointer #x9006CB1F>
> (define libc-atan
    ((make-c-callout 'double '(double)) libc-atan-ptr))
> libc-atan
#<procedure>
> (libc-atan 1.0)
0.7853981633974483
> (libc-atan 1)
Unhandled exception
 Condition components:
    1. &assertion
    2. &who: callout-procedure
    3. &message: "argument does not match type double"
    4. &irritants: (1)
@end example


@c page
@node iklib foreign call back
@subsection Calling back to Scheme


In order to provide full interoperability with native procedures,
@value{PRJNAME} allows native procedures to call back into Scheme just
as it allows Scheme to call out to native procedures.  This is important
for many system libraries that provide graphical user interfaces with
event handling (e.g. Cocoa, GTK+, GLUT, etc.), database engines
(e.g. libsqlite, libmysql, etc.), among others.

The native calling site for the call back is compiled with a specific
callback signature encoding the expected parameter types and return
type.  Therefore, a Scheme procedure used for a call back must be
wrapped with a proper adapter that converts the incoming parameters from
native format to Scheme values as well as convert the value that the
Scheme procedure returns back to native format.  The signature format is
similar to the one used for call outs (@ref{iklib foreign call out
types} for details).


@deffn Procedure make-c-callback @var{return-type} @var{parameter-types}
The procedure @func{make-c-callback} is similar to the procedure
@func{make-c-callout} except that it provides a bridge from native
procedures back into Scheme.  While the procedure @func{make-c-callout}
takes a native pointer and returns a Scheme procedure,
@func{make-c-callback} takes a Scheme procedure and returns a native
pointer.  The native pointer can be called by foreign procedures.  The
native parameters are converted to Scheme data (according to
@var{parameter-types}), the Scheme procedure is called with these
parameters, and the returned value is converted back into native format
(according to @var{return-type}) before control returns to the native
call site.

Note that the native procedure pointer obtained from
@func{make-c-callback} is indistinguishable from other native procedures
that are obtained using @func{dlsym} or similar means.  In particular,
such native pointers can be passed to @func{make-c-callout} resulting in
a Scheme procedure that calls out to the native procedure that in turn
calls back into Scheme.  The following segment illustrates a very
inefficient way of extracting the lowermost 32 bits from an exact
integer.

@example
> (format "~x"
    (((make-c-callout 'unsigned-int '(unsigned-int))
      ((make-c-callback 'unsigned-int '(unsigned-int))
       values))
     #xfedcba09876543210fedcba09876543210))
"76543210"
@end example
@end deffn



@c page
@node iklib misc
@section Miscellaneous functions


@defun void
Return the void value.  It is the value returned by forms that do not
return a meaningful value.
@end defun


@defun host-info
Return a string being the value @gnu{} Autoconf assigned to the
@code{target} variable.  Example: @code{i686-pc-linux-gnu}.
@end defun


@defun apropos @var{key}
Given a string or symbol @var{key}, search among the internally
installed libraries all the exported bindings having @var{key} as
substring of their name and print a report to the standard output port.
Useful when using the @repl{}.  Example:

@example
vicare> (apropos "-length")
*** in library (ikarus):
(bitwise-length bytevector-length string-length
  struct-length vector-length)

*** in library (rnrs):
(bitwise-length bytevector-length string-length
  vector-length)

*** in library (rnrs arithmetic bitwise):
(bitwise-length)

*** in library (rnrs base):
(string-length vector-length)

*** in library (rnrs bytevectors):
(bytevector-length)

*** in library (vicare):
(bitwise-length bytevector-length string-length
  struct-length vector-length)

vicare>
@end example
@end defun

@c page
@node posix
@chapter The @posix{} interface


The @posix{} functions are exported by the @library{vicare posix},
@library{ikarus} and @library{vicare} libraries.  The @api{} attempts to
create a one--to--one Scheme functions mapping towards @posix{}
functions, keeping the same semantics as much as possible; the
platform's own documentation is relevant at the Scheme level.

All the constants needed to use the interface are available as
identifier syntaxes exported by the @library{vicare platform-constants}
library; if a constant value is not exported file a feature request for
the project.  If a constant is not defined on a platform: its value is
set to @false{}.

@menu
* posix conventions::           Conventions about the @posix{} @api{}.
* posix conditions::            Condition object types.
* posix env::                   Operating system environment variables.
* posix pid::                   Process identifier functions.
* posix process::               Spawning processes and the like.
* posix status::                Process termination status.
* posix signal::                Delivering signals to processes.
* posix stat::                  File system inspection.
* posix file::                  Interfacing with the file system.
* posix link::                  Hard and symbolic links.
* posix dir::                   File system directories.
* posix fd::                    File descriptors.
* posix socket::                Network sockets.
* posix users::                 Users and groups.
* posix job::                   Job control.
* posix time::                  Time related functions.
* posix misc::                  Miscellaneous functions.
@end menu

@c page
@node posix conventions
@section Conventions about the @posix{} @api{}


The following common arguments are specified:

@table @var
@item fd
It must be a non--negative fixnum repsesenting a platform's file
descriptor.

@item pathname
@itemx filename
@itemx dirname
It must be a string or bytevector representing a file system entry.

@item stat
It must be an instance of @code{struct-stat} data structure, @ref{posix
stat} for details.
@end table

The proper data type for file system pathnames is the bytevector; all
the functions requiring a pathname as argument accept both a bytevector
and a string for convenience.  String pathnames are converted to and
from bytevectors using the functions referenced by the parameters
@func{string->filename-func} and @func{filename->string-func}.

Whenever a system call returns a file system pathname: two functions are
provided by the @posix{} @api{}, one returning a bytevector and one
returning a string; the one returning a string has name ending with the
suffix @samp{/string}.

Whenever a function in the @posix{} @api{} fails: it raises an exception
with compound condition type @condition{error}, @condition{who},
@condition{message}, @condition{irritants}; if the error is described by
an @code{errno} value, an additional @condition{errno} component is
present; if the function involves a file, an additional type
@condition{i/o-filename} is present.

Values of the @code{errno} C language variable are negated and encoded
as fixnums.  Values of the @code{h_errno} C language variable are
negated and encoded as fixnums.

@c page
@node posix conditions
@section Condition object types


@deftp {Condition Type} &errno
Condition object type representing system errors described by an encoded
@code{errno} value; it is derived from @condition{condition}.
@end deftp


@defun make-errno-condition @var{errno}
Build and return a new @condition{errno} condition object holding the
given encoded @code{errno} value.
@end defun


@defun errno-condition? @var{obj}
Return @true{} if @var{obj} is an instance of @condition{errno}.
@end defun


@defun condition-errno @var{obj}
Accessor for the encoded @code{errno} value in @var{obj}, which must be
an instance of @condition{errno}.
@end defun


@deftp {Condition Type} &h_errno
Condition object type representing system errors described by an encoded
@code{h_errno} value; it is derived from @condition{condition}.
@end deftp


@defun make-h_errno-condition @var{h_errno}
Build and return a new @condition{h_errno} condition object holding the
given encoded @code{h_errno} value.
@end defun


@defun h_errno-condition? @var{obj}
Return @true{} if @var{obj} is an instance of @condition{h_errno}.
@end defun


@defun condition-h_errno @var{obj}
Accessor for the encoded @code{h_errno} value in @var{obj}, which must be
an instance of @condition{h_errno}.
@end defun

@c page
@node posix env
@section Interfacing with the execution environment


The Scheme level representation of environment variables names and
values is a string, but internally it is a bytevector; strings are
internally converted to bytevectors using @func{string->utf8}.


@defun getenv @var{varname}
Interface to the C function @cfunc{getenv}, @glibcref{Environment
Access, getenv}.  Retrieve the value of environment variables.
@var{variable} must reference a string object representing the name of
the environment variable.  If the environment variable is set: return a
string representing its value; else return false.

@example
(getenv "PATH")
@result{} "/usr/local/bin:/usr/bin:/bin"
@end example
@end defun


@defun setenv @var{variable} @var{value} @var{overwrite}
Interface to the C function @cfunc{setenv}, @glibcref{Environment
Access, setenv}.  Set a new value for an environment variable.

@var{variable} must reference a string object representing the name of
the environment variable; @var{value} must reference a string object
representing the new value.  If @var{overwrite} is false and the
environment variable already exists: the environment variable is left
untouched; else the new value is set, either creating a new environment
variable or replacing the old value.

If successful return true, if an error occurs in @cfunc{setenv} return
false.
@end defun


@defun unsetenv @var{variable}
Interface to the C function @cfunc{unsetenv}, @glibcref{Environment
Access, unsetenv}.  Unset an environment variable.  @var{variable} must
reference a string object representing the name of the environment
variable.  Return true if @var{variable} has the correct format, else
return false; there is no way to know if a variable was actually unset.
@end defun


@defun environ
Interface to the global C variable @code{environ}, @glibcref{Environment
Access, unsetenv}.  Retrieve the full environment.  Return a list of
strings representing the contents of the @code{environ} array; if the
environment is empty (no environment variables set) return nil.
@end defun


@defun environ-table
Internally invoke @func{environ} and convert the alist of strings into a
hashtable; return the hashtable.  Both keys and values are strings.
@end defun


@defun environ->table @var{environ}
@defunx table->environ @var{table}
Convert between an alist in ``environ'' format and a hashtable.
@end defun

@c page
@node posix pid
@section Process identifier functions


@defun getpid
Return the process identifier as a fixnum.
@end defun


@defun getppid
Return the process identifier of the parent as a fixnum.
@end defun

@c page
@node posix process
@section Spawning processes and the like


@defun system @var{command}
Interface to the C function @cfunc{system}, @glibcref{Running a Command,
system}.  Execute a command through the system shell; @var{command} must
be a string holding the command to execute.  If successful return the
termination status of the executed process, @ref{posix status} for
details; if an error occurs: an exception is raised.

@example
(system "ls -l")
@end example
@end defun


@defun fork
@defunx fork @var{parent-proc} @var{child-thunk}
Interface to the C function @cfunc{fork}, @glibcref{Creating a Process,
fork}.

When called with no arguments: create a new process by forking the
current one; if successful return a non--negative fixnum representing
the the return value of @cfunc{fork}, else raise an exception.

When called with two arguments: create a new process by forking the
current one; if successful the parent process applies @var{parent-proc}
to a fixnum representing the child process pid and return its return
value; if successful: the child process evaluates the @var{child-thunk}
and returns its return value; if an error occurs: an exception is
raised.

@example
(fork
  (lambda (child-pid)
    (printf "in parent, child pid = ~s\n" child-pid))
  (lambda ()
    (printf "in child\n")
    (exit)))

(printf "here we are in the parent\n")
@end example
@end defun


@defun execv @var{filename} @var{argv}
Interface to the C function @cfunc{execv}, @glibcref{Executing a File,
execv}.  @var{filename} must be the pathname of an executable file;
@var{argv} must be a list of strings representing command line
arguments.  Execute the command; if the function returns: an error has
occurred, an exception is raised.
@end defun


@defun execve @var{filename} @var{argv} @var{env}
Interface to the C function @cfunc{execve}, @glibcref{Executing a File,
execve}.  @var{filename} must the pathname of an executable file;
@var{argv} must be a list of strings representing command line
arguments; @var{env} must be a list of strings representing environment
variables assignments.  Execute the command; if the function returns: an
error has occurred, an exception is raised.
@end defun


@defun execvp @var{filename} @var{argv}
Interface to the C function @cfunc{execvp}, @glibcref{Executing a File,
execvp}.  @var{filename} must be the pathname of an executable file
reachable in the current @env{PATH}; @var{argv} must be a list of
strings representing command line arguments.  Execute the command; if
the function returns: an error has occurred, an exception is raised.
@end defun


@defun execl @var{filename} @varo{arg} @var{arg} ...
Like @func{execv} but allows the arguments to be given expliticly.
@end defun


@defun execle @var{filename} @var{argv} @var{env} ...
Like @func{execve} but allows the environment to be given expliticly.
@end defun


@defun execlp @var{filename} @varo{arg} @var{arg} ...
Like @func{execvp} but allows the arguments to be given expliticly.
@end defun

@c page
@node posix status
@section Process termination status.


@defun waitpid @var{pid} @var{options}
Interface to the C function @cfunc{waitpid}, @glibcref{Process
Completion, waitpid}.  Request status informations on a process or group
of processes knowing the identifier.  If successful return a fixnum
representing the status; if an error occurs: an exception is raised.

The fixnum @var{pid} selects the target of the request; the fixnum
@var{options} must be the logical OR (@func{fxior}) of platform specific
constants specifying how to wait for the availability of the status.
@end defun


@defun wait
Interface to the C function @cfunc{wait}, @glibcref{Process Completion,
wait}.  Request status informations on any process or group of
processes.  If successful return a fixnum representing the status; if an
error occurs: an exception is raised.
@end defun


The following functions accept as argument a fixnum representing the
process termination status, for example the return value of
@func{system} or the status acquired by @func{waitpid}.


@defun WIFEXITED @var{status}
Interface to the C macro @cfunc{WIFEXITED}, @glibcref{Process Completion
Status, WIFEXITED}.  Return true if the process terminated normally with
@cfunc{exit}.
@end defun


@defun WEXITSTATUS @var{status}
Interface to the C macro @cfunc{WEXITSTATUS}, @glibcref{Process
Completion Status, WEXITSTATUS}.  If @func{WIFEXITED} applied to
@var{status} would return true: return the low--order @math{8} bits from
the exit status, which is the process exit status selected with
@cfunc{exit}.
@end defun


@defun WIFSIGNALED @var{status}
Interface to the C macro @cfunc{WIFSIGNALED}, @glibcref{Process
Completion Status, WIFSIGNALED}.  Return true if the process terminated
because it received an interprocess signal which was not handled.
@end defun


@defun WTERMSIG @var{status}
Interface to the C macro @cfunc{WTERMSIG}, @glibcref{Process Completion
Status, WTERMSIG}.  If @func{WIFSIGNALED} applied to @var{status} would
return true: return the number of the interprocess signal that
terminated the process.
@end defun


@defun WCOREDUMP @var{status}
Interface to the C macro @cfunc{WCOREDUMP}, @glibcref{Process Completion
Status, WCOREDUMP}.  Return true if the process terminated and produced
a core dump.
@end defun


@defun WIFSTOPPED @var{status}
Interface to the C macro @cfunc{WIFSTOPPED}, @glibcref{Process
Completion Status, WIFSTOPPED}.  Return true if the process is stopped.
@end defun


@defun WSTOPSIG @var{status}
Interface to the C macro @cfunc{WSTOPSIG}, @glibcref{Process Completion
Status, WSTOPSIG}.  If @func{WIFSTOPPED} applied to @var{status} would
return true: return the number of the interprocess signal that caused
the process to stop.
@end defun

@c page
@node posix signal
@section Delivering signals to processes


@defun raise-signal @var{signum}
Interface to the C function @cfunc{raise}, @glibcref{Signaling Yourself,
raise}.  Send the selected signal to the calling process.  If successful
return zero, else raise an exception.
@end defun


@defun kill @var{pid} @var{signum}
Interface to the C function @cfunc{kill}, @glibcref{Signaling Another
Process, kill}.  Send the selected signal to selected process.  If
successful return zero, else raise an exception.
@end defun


@defun pause
Interface to the C function @cfunc{pause}, @glibcref{Using Pause,
pause}.  Suspend the process until a signal is received; return the void
object.
@end defun

@c page
@node posix stat
@section File system inspection


@deftp {Data Structure} struct-stat
Data structure type representing at the Scheme level the C structure
@code{struct stat}, @glibcref{Attribute Meanings, stat}.
@end deftp


@defun make-struct-stat @var{mode} @var{ino} @var{dev} @var{nlink} @var{uid} @var{gid} @var{size} @var{atime} @var{atime_usec} @var{mtime} @var{mtime_usec} @var{ctime} @var{ctime_usec} @var{blocks} @var{blksize}
Build and return a new @code{struct-stat} instance.
@end defun



@defun struct-stat? @var{obj}
Return true if @var{obj} is an instance of @code{struct-stat}.
@end defun


@defun struct-stat-st_mode @var{stat}
@defunx struct-stat-st_ino @var{stat}
@defunx struct-stat-st_dev @var{stat}
@defunx struct-stat-st_nlink @var{stat}
@defunx struct-stat-st_uid @var{stat}
@defunx struct-stat-st_gid @var{stat}
@defunx struct-stat-st_size @var{stat}
@defunx struct-stat-st_atime @var{stat}
@defunx struct-stat-st_atime_usec @var{stat}
@defunx struct-stat-st_mtime @var{stat}
@defunx struct-stat-st_mtime_usec @var{stat}
@defunx struct-stat-st_ctime @var{stat}
@defunx struct-stat-st_ctime_usec @var{stat}
@defunx struct-stat-st_blocks @var{stat}
@defunx struct-stat-st_blksize @var{stat}
Accessors for the field of @code{struct-stat} instances.
@end defun


@defun stat @var{pathname}
@defunx lstat @var{pathname}
Interfaces to the C functions @cfunc{stat} and @cfunc{lstat},
@glibcref{Reading Attributes, stat}.  Inspect the file system entry
selected by @var{pathname} and return an instance of @code{struct-stat}.
If an error occurs: an exception is raised.
@end defun


@defun fstat @var{fd}
Interface to the C function @cfunc{fstat}, @glibcref{Reading Attributes,
fstat}.  Inspect the file system entry associated to the file descriptor
@var{fd}, which must be a fixnum, and return an instance of
@code{struct-stat}.  If an error occurs: an exception is raised.
@end defun


@defun file-is-directory? @var{pathname} @var{follow-symlinks?}
@defunx file-is-char-device? @var{pathname} @var{follow-symlinks?}
@defunx file-is-block-device? @var{pathname} @var{follow-symlinks?}
@defunx file-is-regular-file? @var{pathname} @var{follow-symlinks?}
@defunx file-is-symbolic-link? @var{pathname} @var{follow-symlinks?}
@defunx file-is-socket? @var{pathname} @var{follow-symlinks?}
@defunx file-is-fifo? @var{pathname} @var{follow-symlinks?}
@defunx file-is-message-queue? @var{pathname} @var{follow-symlinks?}
@defunx file-is-semaphore? @var{pathname} @var{follow-symlinks?}
@defunx file-is-shared-memory? @var{pathname} @var{follow-symlinks?}
Return @true{} or @false{} if the file system entry selected by
@var{pathname} is of the specified type; if an error occurs: an
exception is raised.  When @var{follow-symlinks?} is true: @cfunc{stat}
is used to inspect the entry, else @cfunc{lstat} is used.
@end defun


@defun S_ISDIR @var{st_mode}
@defunx S_ISCHR @var{st_mode}
@defunx S_ISBLK @var{st_mode}
@defunx S_ISREG @var{st_mode}
@defunx S_ISLNK @var{st_mode}
@defunx S_ISSOCK @var{st_mode}
@defunx S_ISFIFO @var{st_mode}
Return @true{} or @false{} if the argument is associated to a file
system entry of the specified type.  @var{st_mode} must be the value of
the @code{st_mode} field of a @code{struct-stat} instance.
@end defun


@defun access @var{pathname} @var{how}
Interface to the C function @cfunc{access}, @glibcref{Testing File
Access, access}.  Test the access mode selected by @var{how}, which must
be a fixnum, for the file system entry selected by @var{pathname}.
Return @true{} or @false{} if the access is possible or not; if an error
occurs: an exception is raised.
@end defun


@defun file-readable? @var{pathname}
@defunx file-writable? @var{pathname}
@defunx file-executable? @var{pathname}
Return @true{} or @false{} if the file system entry selected by
@var{pathname} is accessible in the specified mode.  These functions are
equivalent but slower, respectively, to the following calls:

@example
(access pathname R_OK)
(access pathname W_OK)
(access pathname X_OK)
@end example
@end defun


@defun file-size @var{filename}
Determine the size of the file selected by @var{filename} relying on a
call to @cfunc{stat}.  If successful: return an exact integer
representing the size, else raise an exception.
@end defun


@defun file-atime @var{pathname}
@defunx file-mtime @var{pathname}
@defunx file-ctime @var{pathname}
Return an exact integer representing the access, modification and
creation times for @var{pathname}.  If an error occurs: raise an
exception.
@end defun

@c page
@node posix file
@section Interfacing with the file system


@defun chown @var{pathname} @var{owner} @var{group}
Interface to the C function @cfunc{chown}, @glibcref{File Owner, chown}.
Changes the owner and group of the file system entry selected by
@var{pathname}.  @var{owner} and @var{group} must be fixnums.  If
successful return zero, else raise an exception.
@end defun


@defun fchown @var{fd} @var{owner} @var{group}
Interface to the C function @cfunc{fchown}, @glibcref{File Owner,
fchown}.  Changes the owner and group of the file system entry selected
by @var{fd}, which must be a fixnum representing a platform file
descriptor.  @var{owner} and @var{group} must be fixnums.  If successful
return zero, else raise an exception.
@end defun


@defun chmod @var{pathname} @var{mode}
Interface to the C function @cfunc{chmod}, @glibcref{Setting
Permissions, chmod}.  Change to @var{mode}, which must be a fixnum, the
access permissions for the file system entry selected by @var{pathname}.
If successful return zero, else raise an exception.
@end defun


@defun fchmod @var{fd} @var{mode}
Interface to the C function @cfunc{fchmod}, @glibcref{Setting
Permissions, fchmod}.  Change to @var{mode}, which must be a fixnum, the
access permissions for the file system entry associated to @var{fd},
which must be a fixnum representing a platform file descriptor.  If
successful return zero, else raise an exception.
@end defun


@defun umask @var{mask}
Interface to the C function @cfunc{umask}, @glibcref{Setting
Permissions, umask}.  Set the current file creation mask to @var{mask},
which must be a fixnum, and return the previous mask as a fixnum.
@end defun


@defun getumask
Interface to the C function @cfunc{getumask}, @glibcref{Setting
Permissions, getumask}.  Return the current file creation mask as a
fixnum.
@end defun


@defun utime @var{pathname} @var{atime_sec} @var{mtime_sec}
Interface to the C function @cfunc{utime}, @glibcref{File Times, utime}.
Set the access and modification times of the file system entry selected
by @var{pathname} to the specified counts of seconds; both
@var{atime_sec} and @var{mtime_sec} must be fixnums.  If successful
return zero, else raise an exception.
@end defun


@defun utimes @var{pathname} @var{atime_sec} @var{atime_usec} @var{mtime_sec} @var{mtime_usec}
@defunx lutimes @var{pathname} @var{atime_sec} @var{atime_usec} @var{mtime_sec} @var{mtime_usec}
Interface to the C functions @cfunc{utimes} and @cfunc{lutimes},
@glibcref{File Times, utimes}.  Set the access and modification times of
the file system entry selected by @var{pathname} to the specified counts
of seconds and microseconds; all the numeric arguments must be fixnums.
If successful return zero, else raise an exception.
@end defun


@defun futimes @var{fd} @var{atime_sec} @var{atime_usec} @var{mtime_sec} @var{mtime_usec}
Interface to the C function @cfunc{futimes}, @glibcref{File Times,
futimes}.  Set the access and modification times of the file system
entry associated to @var{fd} to the specified counts of seconds and
microseconds; all the numeric arguments must be fixnums.  If successful
return zero, else raise an exception.
@end defun

@c page
@node posix link
@section Hard and symbolic links


@defun link @var{old_pathname} @var{new_pathname}
Interface to the C function @cfunc{link}, @glibcref{Hard Links, link}.
Create a hard link @var{new_pathname} to the source file system entry
@var{old_pathname}.  If successful return zero, else raise an exception.
@end defun


@defun symlink @var{file_pathname} @var{link_pathname}
Interface to the C function @cfunc{symlink}, @glibcref{Symbolic Links,
symlink}.  Create a symbolic link @var{link_pathname} to the source file
system entry @var{file_pathname}.  If successful return zero, else raise
an exception.
@end defun


@defun readlink @var{link_pathname}
@defunx readlink/string @var{link_pathname}
Interface to the C function @cfunc{readlink}, @glibcref{Symbolic Links,
readlink}.  If @var{pathname} references a symbolic link: follow it once
and return the referenced pathname; if an error occurs raise an
exception.  @func{readlink} returns a bytevector; @func{readlink/string}
returns a string.
@end defun


@defun realpath @var{pathname}
@defunx realpath/string @var{pathname}
Interface to the C function @cfunc{realpath}, @glibcref{Symbolic Links,
realpath}.  If @var{pathname} references a symbolic link: follow it and
return the real canonicalised pathname; if an error occurs: an exception
is raised.  @func{realpath} returns a bytevector; @func{realpath/string}
returns a string.
@end defun


@defun unlink @var{pathname}
Interface to the C function @cfunc{unlink}, @glibcref{Deleting Files,
unlink}.  Delete the file system entry referenced by @var{pathname},
which must reference a file.  If successful return unspecified values,
else raise an exception.

This function is the same of @func{delete-file} defined by @rnrs{6}.
@end defun


@defun posix-remove @var{pathname}
Interface to the C function @cfunc{remove}, @glibcref{Deleting Files,
remove}.  Delete the file system entry referenced by @var{pathname},
which can reference a file or directory.  If successful return
unspecified values, else raise an exception.
@end defun


@defun rename @var{old-pathname} @var{new-pathname}
Interface to the C function @cfunc{rename}, @glibcref{Renaming Files,
rename}.  Rename the file system entry @var{old-pathname} to
@var{new-pathname}.  If successful return unspecified values, else
return an encoded @code{errno} value.
@end defun

@c page
@node posix dir
@section File system directories


@defun mkdir @var{pathname} @var{mode}
Interface to the C function @cfunc{mkdir}, @glibcref{Creating
Directories, mkdir}.  Create a new directory file system entry with name
@var{pathname}; @var{mode} must be a fixnum specifying access
permissions.  If successful return unspecified values, else raise an
exception.
@end defun


@defun mkdir/parents @var{pathname} @var{mode}
Create a new directory file system entry with name @var{pathname} and
all its parents if they do not exist; @var{mode} must be a fixnum
specifying access permissions for all the components.  If successful
return unspecified values, else raise an exception.
@end defun


@defun rmdir @var{pathname}
Interface to the C function @cfunc{rmdir}, @glibcref{Creating
Directories, rmdir}.  Remove the directory file system entry selected by
@var{pathname}.  If successful return unspecified values, else raise an
exception.
@end defun


@defun getcwd
@defunx getcwd/string
Interface to the C function @cfunc{getcwd}, @glibcref{Working Directory,
getcwd}.  Acquire the pathname of the current working directory.  If
successful @func{getcwd} returns a bytevector holding the pathname,
@func{getcwd/string} returns a string holding the pathname; else an
exception is raised.
@end defun


@defun chdir @var{pathname}
Interface to the C function @cfunc{chdir}, @glibcref{Working Directory,
chdir}.  Change the current working directory to the file system entry
selected by @var{pathname}.  If successful return unspecified values,
else raise an exception.
@end defun


@defun fchdir @var{fd}
Interface to the C function @cfunc{fchdir}, @glibcref{Working Directory,
fchdir}.  Change the current working directory to the file system entry
associated to @var{fd}, which must be a fixnum representing a file
descriptor.  If successful return unspecified values, else raise an
exception.
@end defun


@deftp {Structure Type} directory-stream
Opaque data structure type used in the inspection of file system
directory entries.  Instances of this type can be destroyed by
@func{closedir}, but they are also automatically and correctly destroyed
by the garbage collector.  It has the following fields:

@table @code
@item pathname
False or a string representing the pathname.

@item pointer
A pointer object referencing the directory.

@item fd
False or a fixnum representing the file descriptor associated to the
directory.

@item closed?
A boolean, true if this stream has already been closed.
@end table
@end deftp


@defun make-directory-stream @var{pathname} @var{pointer} @var{fd} @var{closed?}
Constructor for @code{directory-stream}.
@end defun


@defun directory-stream? @var{obj}
Return true if @var{obj} is an instance of @code{directory-stream}.
@end defun


@defun directory-stream-pathname @var{stream}
@defunx directory-stream-pointer @var{stream}
@defunx directory-stream-fd @var{stream}
@defunx directory-stream-closed? @var{stream}
Accessors for the fields of @code{directory-stream}.
@end defun


@defun opendir @var{pathname}
Interface to the C function @cfunc{opendir}, @glibcref{Opening a
Directory, opendir}.  Open a directory stream for the inspection of the
file system entry @var{pathname}.  If successful return an instance of
@code{directory-stream}, else raise an exception.
@end defun


@defun fdopendir @var{fd}
Interface to the C function @cfunc{fdopendir}, @glibcref{Opening a
Directory, fdopendir}.  Open a directory stream for the inspection of
the file system entry associated to @var{fd}, which must be a fixnum
representing a file descriptor.  If successful return an instance of
@code{directory-stream}, else raise an exception.
@end defun


@defun readdir @var{stream}
@defunx readdir/string @var{stream}
Interface to the C function @cfunc{readdir}, @glibcref{Reading/Closing
Directory, readdir}.  Acquire the next entry from a directory stream
referenced by @var{stream}, which must be an instance of
@code{directory-stream}.  If successful and an entry is available:
@func{readdir} returns a pathname as a bytevector, @func{readdir/string}
returns a pathname as a string; if successful and no more entries are
available: return @false{}; else raise an exception.

When no more entries are available or an error occurs: the directory
stream is closed.
@end defun


@defun closedir @var{stream}
Interface to the C function @cfunc{closedir}, @glibcref{Reading/Closing
Directory, closedir}.  Close the directory stream referenced by
@var{stream}, which must be an instance of @code{directory-stream}.  If
successful return unspecified values, else raise an exception.

This function has no effect if @var{stream} has been already closed.
@end defun


@defun rewinddir @var{stream}
Interface to the C function @cfunc{rewinddir}, @glibcref{Random Access
Directory, rewinddir}.  Rewind to the beginning the directory stream
referenced by @var{stream}, which must be an instance of
@code{directory-stream}.  Return unspecified values.
@end defun


@defun telldir @var{stream}
Interface to the C function @cfunc{telldir}, @glibcref{Random Access
Directory, telldir}.  Return an exact integer representing the current
position in the directory stream referenced by @var{stream}, which must
be an instance of @code{directory-stream}.
@end defun


@defun seekdir @var{pointer} @var{pos}
Interface to the C function @cfunc{seekdir}, @glibcref{Random Access
Directory, seekdir}.  Set to @var{pos} the position of the directory
stream referenced by @var{stream}, which must be an instance of
@code{directory-stream}; @var{pos} must be the return value of a
previous call to @func{telldir}.  Return unspecified values.
@end defun

@c page
@node posix fd
@section File descriptors


@defun open @var{pathname} @var{flags} @var{mode}
Interface to the C function @cfunc{open}, @glibcref{Opening and Closing
Files, open}.  Open a file descriptor for the file system entry
@var{pathname}; @var{flags} and @var{mode} must be fixnums.  If
successful return a fixnum representing the file descriptor, else raise
an exception.

Example:

@example
#!r6rs
(import (vicare)
  (vicare platform-constants))

(define fd
  (open "name.ext"
        (fxior O_CREAT O_EXCL O_RDWR)
        (fxior S_IRUSR S_IWUSR)))
@end example
@end defun


@defun close @var{fd}
Interface to the C function @cfunc{close}, @glibcref{Opening and Closing
Files, close}.  Close a file descriptor represented by @var{fd}, which
must be a fixnum.  If successful return unspecified values, else raise
an exception.
@end defun


@defun posix-read @var{fd} @var{buffer}
@defunx posix-read @var{fd} @var{buffer} @var{size}
Interface to the C function @cfunc{read}, @glibcref{I/O Primitives,
read}.  Read bytes from the file descriptor @var{fd} and store them in
the bytevector @var{buffer}; if @var{size} is a fixnum, read @var{size}
bytes; if @var{size} is false or not given, read a number of bytes equal
to the length of @var{buffer}.  If successful return a non--negative
fixnum representing the number of bytes read, else raise an exception.
@end defun


@defun pread @var{fd} @var{buffer} @var{size} @var{off}
Interface to the C function @cfunc{pread}, @glibcref{I/O Primitives,
pread}.  Like @func{posix-read}, but start reading at offset @var{off}
from the start of the file; @var{off} must be a non--negative exact
integer.
@end defun


@defun posix-write @var{fd} @var{buffer}
@defunx posix-write @var{fd} @var{buffer} @var{size}
Interface to the C function @cfunc{write}, @glibcref{I/O Primitives,
write}.  Write bytes to the file descriptor @var{fd} from the bytevector
@var{buffer}; if @var{size} is a fixnum, read @var{size} bytes; if
@var{size} is false or not given, read a number of bytes equal to the
length of @var{buffer}.  If successful return a non--negative fixnum
representing the number of written bytes, else raise an exception.
@end defun


@defun pwrite @var{fd} @var{buffer} @var{size} @var{off}
Interface to the C function @cfunc{pwrite}, @glibcref{I/O Primitives,
pwrite}.  Like @func{posix-write}, but start writing at offset @var{off}
from the start of the file; @var{off} must be a non--negative exact
integer.
@end defun


@defun lseek @var{fd} @var{off} @var{whence}
Interface to the C function @cfunc{lseek}, @glibcref{File Position
Primitive, lseek}.  Change the file position of the file descriptor
@var{fd} to @var{off} from @var{whence}; @var{whence} must a fixnum,
@var{off} must be an exact integer.  If successful return a
non--negative exact integer representing the number of bytes from the
beginning of the file, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun readv @var{fd} @var{buffers}
Interface to the C function @cfunc{readv}, @glibcref{Scatter-Gather,
readv}.  Read bytes from the file descriptor @var{fd} and store them
into the list of bytevectors referenced by @var{buffers}.  If successful
return a non--negative exact integer representing the number of bytes
actually read, else raise an exception.
@end defun


@defun writev @var{fd} @var{buffers}
Interface to the C function @cfunc{writev}, @glibcref{Scatter-Gather,
writev}.  Write bytes to the file descriptor @var{fd} from the list of
bytevectors referenced by @var{buffers}.  If successful return a
non--negative exact integer representing the number of bytes actually
written, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun select @var{nfds} @var{read-fds} @var{write-fds} @var{except-fds} @var{sec} @var{usec}
Interface to the C function @cfunc{select}, @glibcref{Waiting for I/O,
select}.  Wait for read, write or exceptional events on selected lists
of file descriptors.

@var{nfds} must be false or a non--negative fixnum, when false it
defaults to the maximum file descriptor value in the given lists; it is
the maximum file descriptor number in the sets to be checked for events,
plus one.  @var{read-fds}, @var{write-fds} and @var{except-fds} must be
nil or lists of file descriptors to be checked for events.  @var{sec}
and @var{usec} must be fixnums representing timeout seconds and
microseconds.

If the timeout expires before any event arrives: return 3 values all
being nil.  If an error occurs: raise an exception.  Else return 3
values being lists of file descriptors, respectively, ready for reading,
writing or an exceptional condition.
@end defun


@defun select-fd @var{fd} @var{sec} @var{usec}
Interface to the C function @cfunc{select}, @glibcref{Waiting for I/O,
select}.  Wait for read, write or exceptional events on the single file
descriptor @var{fd}.  @var{sec} and @var{usec} must be fixnums
representing timeout seconds and microseconds.

If the timeout expires before any event arrives: return 3 values all
being false.  If an error occurs: raise an exception.  Else return 3
values being false or @var{fd}, respectively, if @var{fd} is ready for
reading, writing or an exceptional condition.
@end defun

@c ------------------------------------------------------------

@defun fcntl @var{fd} @var{command}
@defunx fcntl @var{fd} @var{command} @var{arg}
Interface to the C function @cfunc{fcntl}, @glibcref{Control Operations,
fcntl}.  Perform the operation specified by @var{command} on the file
descriptor @var{fd} using @var{arg}; @var{fd} and @var{command} must be
fixnums; @var{arg} must be @false{}, a fixnum, a bytevector or a
pointer, if it is @false{} or not given no argument is handed to
@cfunc{fcntl}.  If successful return a fixnum representing the return
value of @cfunc{fcntl}, else raise an exception.
@end defun


@defun ioctl @var{fd} @var{command}
@defunx ioctl @var{fd} @var{command} @var{arg}
Interface to the C function @cfunc{ioctl}, @glibcref{IOCTLs, ioctl}.
Perform the operation specified by @var{command} on the file descriptor
@var{fd} using @var{arg}; @var{fd} and @var{command} must be fixnums;
@var{arg} must be @false{}, a fixnum, a bytevector or a pointer, if it
is @false{} or not given no argument is handed to @cfunc{ioctl}.  If
successful return a fixnum representing the return value of
@cfunc{ioctl}, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun dup @var{fd}
Interface to the C function @cfunc{dup}, @glibcref{Duplicating
Descriptors, dup}.  Duplicate the file descriptor @var{fd}.  If
successful return a non--negative fixnum representing the new
descriptor, else raise an exception.
@end defun


@defun dup2 @var{old} @var{new}
Interface to the C function @cfunc{dup2}, @glibcref{Duplicating
Descriptors, dup}.  Duplicate the file descriptor @var{old} to
@var{new}.  If successful return unspecified values, else raise an
exception.
@end defun


@defun pipe
Interface to the C function @cfunc{pipe}, @glibcref{Creating a Pipe,
pipe}.  Create a pair of file descriptors connected through a pipe.  If
successful return two values being fixnums representing the file
descriptors, else raise an exception.

Simple example of process writing to itself through a pipe:

@example
#!r6rs
(import (vicare))

(let-values (((in ou) (pipe)))
  (posix-write ou '#vu8(1 2 3 4) 4)
  (let ((bv (make-bytevector 4)))
    (posix-read in bv 4)
    bv))
@result{} #vu8(1 2 3 4)
@end example

@noindent
here is how to fork a process and setup stdin and stdout in the children
to use newly created pipe file descriptors to communicate with the
parent:

@example
#!r6rs
(import (vicare))

(let-values
    (((child-stdin       parent-to-child) (pipe))
     ((parent-from-child child-stdout)    (pipe)))
  (fork

    (lambda (pid) ;parent
      (let ((buf (make-bytevector 1)))
        (posix-read  parent-from-child buf 1)
        (posix-write parent-to-child '#vu8(2) 1)
        buf))

    (lambda () ;child
      (begin ;setup stdin
        (close-input-port (current-input-port))
        (dup2 child-stdin 0)
        (close child-stdin))

      (begin ;setup stdout
        (close-output-port (current-output-port))
        (dup2 child-stdout 1)
        (close child-stdout))

      (let ((buf (make-bytevector 1)))
        (posix-write 1 '#vu8(1) 1)
        (posix-read  0 buf 1)
        (exit 0)))))
@result{} #vu8(1)
@end example

@noindent
here is how to fork a process and setup stdin and stdout in the children
to use newly created pipe file descriptors, through Scheme ports, to
communicate with the parent:

@example
#!r6rs
(import (vicare))

(let-values (((child-stdin       parent-to-child) (pipe))
             ((parent-from-child child-stdout)    (pipe)))
  (fork
   (lambda (pid)        ;parent
     (let* ((inp (make-textual-file-descriptor-input-port
                  parent-from-child "in" (native-transcoder)))
            (oup (make-textual-file-descriptor-output-port
                  parent-to-child "out" (native-transcoder)))
            (buf (get-string-n inp 4)))
       (display "hello" oup)
       (flush-output-port oup)
       buf))

   (lambda ()           ;child

     (begin      ;setup stdin
       (close-input-port (current-input-port))
       (current-input-port
        (make-textual-file-descriptor-input-port
         child-stdin "*stdin*" (native-transcoder))))

     (begin ;setup stdout
       (close-output-port (current-output-port))
       (current-output-port
        (make-textual-file-descriptor-output-port
         child-stdout "*stdout*" (native-transcoder))))

     (display "ciao")
     (flush-output-port (current-output-port))
     (get-string-n (current-input-port) 5)
     (exit 0))))
@result{} "ciao"
@end example
@end defun


@defun mkfifo @var{pathname} @var{mode}
Interface to the C function @cfunc{mkfifo}, @glibcref{FIFO Special
Files, mkfifo}.  Create a FIFO special file with name @var{pathname} and
mode @var{mode}, which must be a fixnum.  If successful return
unspecified values, else raise an exception.
@end defun

@c page
@node posix socket
@section Network sockets


With the purpose of keeping at the Scheme level the same semantics of
the C level @posix{} @api{}, socket--related data structures are stored
in bytevectors; such raw manipulation can cause the process to crash if
we mishandle the values.

@menu
* posix socket addresses::      Network address structures.
* posix socket hosts::          Network hosts database.
* posix socket protocols::      Network protocols database.
* posix socket services::       Network services database.
* posix socket networks::       Networks database.
* posix socket socket::         Network sockets operations.
* posix socket misc::           Error and miscellaneous functions.
* posix socket examples::       Examples of clients and servers.
* posix socket oob::            Notes on transmission of @oob{} data.
@end menu

@c page
@node posix socket addresses
@subsection Network address structures


@menu
* posix socket addresses local:: Local addresses.
* posix socket addresses in::    @ip{}v4 addresses.
* posix socket addresses in6::   @ip{}v6 addresses.
* posix socket addresses rep::   @ascii{} address representations.
* posix socket addresses info::  Host address informations.
@end menu

@c page
@node posix socket addresses local
@subsubsection Local addresses


Instances of @code{struct sockaddr_un} can be handled at the Scheme
level as follows:

@example
(import (vicare))

(define sockaddr
  (make-sockaddr_un "/tmp/the-unix-socket"))

(sockaddr_un.pathname/string sockaddr)
@result{} "/tmp/the-unix-socket"
@end example

@noindent
care must be taken when handling such raw values.


@defun make-sockaddr_un @var{pathname}
Given a @var{pathname} representing the pathname of a local socket,
build and return a bytevector holding the @code{struct sockaddr_un}
representing it.
@end defun


@defun sockaddr_un.pathname @var{socket_address}
@defunx sockaddr_un.pathname/string @var{socket_address}
Given a bytevector @var{socket_address}, which must be the return value
of a previous call to @func{make-sockaddr_un}, holding a @code{struct
sockaddr_un}: @func{sockaddr_un.pathname} builds and returns a
bytevector holding the corresponding socket pathname,
@func{sockaddr_un.pathname/string} builds and returns a string holding
the corresponding socket pathname.  If the data in @var{socket_address}
is invalid: an exception is raised.
@end defun

@c page
@node posix socket addresses in
@subsubsection @ip{}v4 addresses


Instances of @code{struct sockaddr_in} can be handled at the Scheme
level as follows:

@example
(import (vicare))

(define sockaddr
  (make-sockaddr_in '#vu8(1 2 3 4) 88))

(sockaddr_in.in_addr sockaddr)  @result{} #vu8(1 2 3 4)
(sockaddr_in.in_port sockaddr)  @result{} 88
@end example

@noindent
and we can use constant values to initialise the fields:

@example
(import (vicare)
  (vicare platform-constants))

(define addr (make-bytevector 4))
(bytevector-u32-set! bv 0 INADDR_LOOPBACK (endianness big))

(define sockaddr (make-sockaddr_in addr 88))

(sockaddr_in.in_addr sockaddr)  @result{} #vu8(127 0 0 1)
(sockaddr_in.in_port sockaddr)  @result{} 88
@end example

@noindent
care must be taken when handling such raw values.


@defun make-sockaddr_in @var{host-address} @var{port}
Given a bytevector @var{host-address} holding a @code{struct in_addr}
and a fixnum @var{port} representing a network port number, build and
return a bytevector holding a @code{struct sockaddr_in} initialised with
this data.
@end defun


@defun sockaddr_in.in_addr @var{socket-address}
@defunx sockaddr_in.in_port @var{socket-address}
Given a bytevector @var{socket-address} holding a @code{struct
sockaddr_in}, extract the @code{in_addr} and @code{in_port} fields and
return them as bytevector holding the corresponding @code{struct
in_addr} and as fixnum.  If the data in @var{socket_address} is invalid:
an exception is raised.
@end defun

@c page
@node posix socket addresses in6
@subsubsection @ip{}v6 addresses


Instances of @code{struct sockaddr_in6} can be handled at the Scheme
level as follows:

@example
#!vicare
(import (vicare))

(define sockaddr
  (make-sockaddr_in6 '#vu16b(1 2 3 4  5 6 7 8) 88))

(sockaddr_in6.in6_addr sockaddr) @result{} #vu16b(1 2 3 4  5 6 7 8)
(sockaddr_in6.in6_port sockaddr) @result{} 88
@end example

@noindent
care must be taken when handling such raw values.


@defun make-sockaddr_in6 @var{host-address} @var{port}
Given a bytevector @var{host-address} holding a @code{struct in6_addr}
and a fixnum @var{port} representing a network port number, build and
return a bytevector holding a @code{struct sockaddr_in6} initialised
with this data.
@end defun


@defun sockaddr_in6.in6_addr @var{socket-address}
@defunx sockaddr_in6.in6_port @var{socket-address}
Given a bytevector @var{socket-address} holding a @code{struct
sockaddr_in6}, extract the @code{in6_addr} and @code{in6_port} fields
and return them as bytevector holding the corresponding @code{struct
in6_addr} and as fixnum.  If the data in @var{socket_address} is
invalid: an exception is raised.
@end defun

@c ------------------------------------------------------------

@defun in6addr_loopback
@defunx in6addr_any
Build and return a bytevector holding the constant structures of type
@code{struct in6_addr} defined by @code{in6addr_loopback} and
@code{in6addr_any}.
@end defun

@c page
@node posix socket addresses rep
@subsubsection @ascii{} address representations


Dotted quad address representations can be handled as follows:

@example
(import (vicare))

(inet-aton "127.0.0.1") @result{} #vu8(127 0 0 1)
(inet-aton "ciao")      @error{} invalid argument

(inet-ntoa/string '#vu8(127 0 0 1))
@result{} "127.0.0.1"
@end example

@noindent
care must be taken when handling such raw values.


@defun inet-aton @var{dotted-quad}
@ascii{} to number.  Given the bytevector @var{dotted-quad} holding the
@ascii{} dotted quad representation of a host address, build and return
a bytevector holding the corresponding @code{struct in_addr}.  If
@var{dotted-quad} is invalid: an exception is raised.
@end defun


@defun inet-ntoa @var{host-address}
@defunx inet-ntoa/string @var{host-address}
Number to @ascii{}.  Given the bytevector @var{host-address} holding a
@code{struct in_addr}: @func{inet-ntoa} builds and returns a bytevector
holding the corresponding @ascii{} dotted quad representation,
@func{inet-ntoa/string} builds and returns a string holding the
corresponding @ascii{} dotted quad representation.
@end defun

@c ------------------------------------------------------------

Addresses in presentation format can be handled as follows:

@example
#!vicare
(import (vicare)
  (vicare platform-constants))

(inet-pton AF_INET "127.0.0.1") @result{} #vu8(127 0 0 1)
(inet-pton AF_INET "ciao")      @error{} invalid arguments

(inet-pton AF_INET6 "1:2:3:4:5:6:7:8")
@result{} #vu16b(1 2 3 4 5 6 7 8)

(inet-ntop/string AF_INET '#vu8(127 0 0 1))
@result{} "127.0.0.1"

(inet-ntop/string AF_INET6 '#vu16b(1 2 3 4 5 6 7 8))
@result{} "1:2:3:4:5:6:7:8"
@end example

@noindent
care must be taken when handling such raw values.


@defun inet-pton @var{af} @var{presentation}
Given the fixnum @var{af}, being @code{AF_INET} or @code{AF_INET6}, and
the string or bytevector @var{presentation} holding the @ascii{}
presentation of an Internet address, build and return a bytevector
holding the corresponding @code{struct in_addr} or @code{struct
in6_addr}.  If either @var{af} or @var{presentation} is invalid: raise
an exception.
@end defun


@defun inet-ntop @var{af} @var{host-address}
@defunx inet-ntop/string @var{af} @var{host-address}
Given the fixnum @var{af}, being @code{AF_INET} or @code{AF_INET6}, and
the bytevector @var{host-address} holding a @code{struct in_addr} or
@code{struct in6_addr}: @func{inet-ntop} builds and returns a bytevector
holding the corresponding @ascii{} presentation of the Internet address,
@func{inet-ntop/string} builds and returns a string holding the
corresponding @ascii{} presentation of the Internet address.  If the
arguments are invalid: an exception is raised.
@end defun

@c page
@node posix socket addresses info
@subsubsection Host address informations


@deftp {Structure Type} struct-addrinfo
Scheme level representation of @code{struct addrinfo}.  It has the
following fields:

@table @code
@item ai_flags
Fixnum.

@item ai_family
Fixnum, specifies the Internet address family; @code{AF_INET},
@code{AF_INET6} of @code{AF_UNSPEC}.

@item ai_socktype
Fixnum, specifies the socket type; @code{SOCK_STREAM}, @code{SOCK_DGRAM}
or other @code{SOCK_} value.

@item ai_protocol
Fixnum, specifies the protocol of the socket address.

@item ai_addrlen
Fixnum, the number of bytes in the bytevector referenced by
@code{ai_addr}.

@item ai_addr
Bytevector, holds an instance of @code{struct sockaddr} of
@code{ai_addrlen} bytes.

@item ai_canonname
False or bytevector, represents the canoncal name of the host when
available.
@end table
@end deftp


@defun make-struct-addrinfo @var{flags} @var{family} @var{socktype} @var{protocol} @var{addrlen} @var{addr} @var{canonname}
Build and return an instance of @code{struct-addrinfo}.
@end defun


@defun struct-addrinfo? @var{obj}
Return true if @var{obj} is an instance of @code{struct-addrinfo}.
@end defun


@defun struct-addrinfo-ai_flags @var{addrinfo}
@defunx struct-addrinfo-ai_family @var{addrinfo}
@defunx struct-addrinfo-ai_socktype @var{addrinfo}
@defunx struct-addrinfo-ai_protocol @var{addrinfo}
@defunx struct-addrinfo-ai_addrlen @var{addrinfo}
@defunx struct-addrinfo-ai_addr @var{addrinfo}
@defunx struct-addrinfo-ai_canonname @var{addrinfo}
Accessors for the fields of @code{struct-addrinfo}.
@end defun


@defun getaddrinfo @var{node} @var{service} @var{hints}
Interface to the C function @cfunc{getaddrinfo}, see the manual page
@code{getaddrinfo(3)}.  Given the strings or bytevectors @var{node} and
@var{service} identifying an Internet host and a service, build a list
of @code{struct-addrinfo} instances representing addresses to which
sockets can be bound or connected.

Both @var{node} and @var{service} can be false, in which case the
corresponding arguments handed to the C function are @code{NULL}.
@var{hints} must be an instance of @code{struct-addrinfo} used to select
matching hosts.

If successful: return the list of data structures, else raise an
exception.

@example
(getaddrinfo "github.com" "smtp" #f)
@result{} (#["struct-addrinfo"
        ai_flags=40             ai_family=AF_INET
        ai_socktype=SOCK_DGRAM  ai_protocol=17
        ai_addrlen=16
        ai_addr=#vu8(2 0 0 25 207 97 227 239 0 0 0 0 0 0 0 0)
        ai_canonname=#f]
    #["struct-addrinfo"
        ai_flags=40             ai_family=AF_INET
        ai_socktype=SOCK_STREAM ai_protocol=6
        ai_addrlen=16
        ai_addr=#vu8(2 0 0 25 207 97 227 239 0 0 0 0 0 0 0 0)
        ai_canonname=#f])
@end example
@end defun

@c page
@node posix socket hosts
@subsection Network hosts database


@deftp {Struct Type} struct-hostent
Data structure type used to represent at the Scheme level @code{struct
hostent} values.  It has the following fields:

@table @code
@item h_name
Bytevector, the official host name.

@item h_aliases
List of bytevectors, host name aliases.

@item h_addrtype
Fixnum, @code{AF_INET} or @code{AF_INET6}.

@item h_length
Fixnum, number of bytes in each host address bytevector.

@item h_addr_list
List of bytevectors each holding @code{struct in_addr} or @code{struct
in6_addr}.

@item h_addr
Bytevector, it is the first in the list @code{h_addr_list}.
@end table
@end deftp


@defun gethostbyname @var{hostname}
Interface to the C function @cfunc{gethostbyname}, @glibcref{Host Names,
gethostbyname}.  Given the string or bytevector @var{hostname} holding
the @ascii{} representation of a host name, build and return an instance
of @code{struct-hostent}.  If an error occurs, return an encoded
@code{h_errno} value.

@example
(import (vicare))

(gethostbyname "github.com")
@result{} #["struct-hostent"
       h_name="github.com"
       h_aliases=()
       h_addrtype=AF_INET
       h_length=4
       h_addr_list=(#vu8(207 97 227 239))
       h_addr=#vu8(207 97 227 239)]

(gethostbyname "google.com")
@result{} #["struct-hostent"
       h_name="google.com"
       h_aliases=()
       h_addrtype=AF_INET
       h_length=4
       h_addr_list=(#vu8(209 85 148 103)
                    #vu8(209 85 148 99)
                    #vu8(209 85 148 104)
                    #vu8(209 85 148 105)
                    #vu8(209 85 148 106)
                    #vu8(209 85 148 147))
       h_addr=#vu8(209 85 148 103)]
@end example
@end defun


@defun gethostbyaddr @var{addr}
Interface to the C function @cfunc{gethostbyaddr}, @glibcref{Host Names,
gethostbyaddr}.  Given the bytevector @var{addr} holding a @code{struct
in_addr} or a @code{struct in6_addr}, build and return an instance of
@code{struct-hostent}; the type of address is automatically inferred
from the length of the bytevector.  If an error occurs: an exception is
raised.
@end defun


@defun host-entries
Interface to the C functions @cfunc{sethostent}, @cfunc{gethostent} and
@cfunc{endhostent}, @glibcref{Host Names, gethostbyaddr}.  Build and
return a list of @code{struct-hostent} representing the entries in the
hosts database.
@end defun

@c page
@node posix socket protocols
@subsection Network protocols database


@deftp {Structure Type} struct-protoent
Scheme level representation of @code{struct protoent}.  It has the
following fields:

@table @code
@item p_name
Bytevector, the @ascii{} coding of the official protocol name.

@item p_aliases
Null or list of bytevectors, the @ascii{} codings of protocol name
aliases.

@item p_proto
Fixnum, the protocol number.
@end table
@end deftp


@defun make-struct-protoent @var{name} @var{aliases} @var{proto}
Build and return an instance of @code{struct-protoent}.
@end defun


@defun struct-protoent-p_name @var{protoent}
@defunx struct-protoent-p_aliases @var{protoent}
@defunx struct-protoent-p_proto @var{protoent}
Accessors for the fields of @code{struct-protoent}.
@end defun


@defun getprotobyname @var{name}
Interface to the C function @cfunc{getprotobyname}, @glibcref{Protocols
Database, getprotobyname}.  Given a string or bytevector @var{name}
holding the @ascii{} coding of a network protocol name, query the
network protocols database and build an instance of
@code{struct-protoent} mirroring the resulting @code{struct protoent}
entry.  If successful return the data structure, else raise an
exception.

@example
(getprotobyname "udp")
@result{} #["struct-protoent"
        p_name="udp"
        p_aliases=(UDP)
        p_proto=17]
@end example
@end defun


@defun getprotobynumber @var{proto_num}
Interface to the C function @cfunc{getprotobynumber},
@glibcref{Protocols Database, getprotobynumber}.  Given a fixnum
@var{proto_num} being the number of a network protocol, query the
network protocols database and build an instance of
@code{struct-protoent} mirroring the resulting @code{struct protoent}
entry.  If successful return the data structure, else raise an
exception.

@example
(getprotobynumber 17)
@result{} #["struct-protoent"
        p_name="udp"
        p_aliases=(UDP)
        p_proto=17]
@end example
@end defun


@defun protocol-entries
Interface to the C functions @cfunc{setprotoent}, @cfunc{getprotoent}
and @cfunc{endprotoent}, @glibcref{Protocols Database, setprotoent}.
Scan the network protocol database and build a list of
@code{struct-protoent} mirroring the resulting @code{struct protoent}
entries.  Return the list of structures.
@end defun

@c page
@node posix socket services
@subsection Network services database


@deftp {Structure Type} struct-servent
Scheme level representation of @code{struct servent}.  It has the
following fields:

@table @code
@item s_name
Bytevector, the @ascii{} coding of the official service name.

@item s_aliases
Null or list of bytevectors, the @ascii{} codings of service name
aliases.

@item s_port
Fixnum, the port number.

@item s_proto
Bytevector, @ascii{} coding of the associated protocol name.
@end table
@end deftp


@defun make-struct-servent @var{name} @var{aliases} @var{port} @var{proto}
Build and return an instance of @code{struct-servent}.
@end defun


@defun struct-servent-s_name @var{servent}
@defunx struct-servent-s_aliases @var{servent}
@defunx struct-servent-s_proto @var{servent}
@defunx struct-servent-s_port @var{servent}
Accessors for the fields of @code{struct-servent}.
@end defun


@defun getservbyname @var{name} @var{protocol}
Interface to the C function @cfunc{getservbyname}, @glibcref{Services
Database, getservbyname}.  Given the strings or bytevectors @var{name}
and @var{protocol} holding the @ascii{} coding of a network service name
and protocol, query the network services database and build an instance
of @code{struct-servent} mirroring the resulting @code{struct servent}
entry.  If successful return the data structure, else raise an
exception.

@example
(getservbyname "smtp" "tcp")
@result{} #["struct-servent"
        s_name="smtp"
        s_aliases=(mail)
        s_port=25
        s_proto=tcp]

(getservbyname "ntp" "udp")
@result{} #["struct-servent"
        s_name="ntp"
        s_aliases=()
        s_port=123
        s_proto=udp]
@end example
@end defun


@defun getservbynumber @var{port} @var{protocol}
Interface to the C function @cfunc{getservbynumber}, @glibcref{Services
Database, getservbynumber}.  Given a fixnum @var{port} and a string or
bytevector @var{protocol} being the port number and protocol name of a
network service, query the network services database and build an
instance of @code{struct-servent} mirroring the resulting @code{struct
servent} entry.  If successful return the data structure, else raise an
exception.

@example
(getservbyport 80 "tcp")
@result{} #["struct-servent"
        s_name="http"
        s_aliases=(www-http www)
        s_port=80
        s_proto=tcp]
@end example
@end defun


@defun service-entries
Interface to the C functions @cfunc{setservent}, @cfunc{getservent} and
@cfunc{endservent}, @glibcref{Services Database, setservent}.  Scan the
network service database and build a list of @code{struct-servent}
mirroring the resulting @code{struct servent} entries.  Return the list
of structures.
@end defun

@c page
@node posix socket networks
@subsection Networks database


@deftp struct-netent
Scheme level representation of @code{struct netent}.  It has the
following fields:

@table @code
@item n_name
Bytevector, @ascii{} coding of the official network name.

@item n_aliases
List of bytevectors, alias names for the network.

@item n_addrtype
Fixnum, the network type.

@item n_net
32-bit bytevector, the network number in network byte order.
@end table
@end deftp


@defun make-struct-netent @var{name} @var{aliases} @var{addrtype} @var{net}
Build and return a new instance of @code{struct-netent}.
@end defun


@defun struct-netent-n_name @var{netent}
@defunx struct-netent-n_aliases @var{netent}
@defunx struct-netent-n_addrtype @var{netent}
@defunx struct-netent-n_net @var{netent}
Accessors for the fields of @code{struct-netent}.
@end defun


@defun struct-netent? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-netent}.
@end defun


@defun getnetbyname @var{name}
Interface to the C function @cfunc{getnetbyname}, @glibcref{Networks
Database, getnetbyname}.  Given the bytevector @var{name} holding the
@ascii{} coding of a network name, query the networks database and build
an instance of @code{struct-netent} mirroring the resulting @code{struct
netent} entry.  If successful return the data structure, else raise an
exception.

@example
(getnetbyname "loopback")
@result{} #["struct-netent"
        n_name="loopback"
        n_aliases=()
        n_addrtype=AF_INET
        n_net=#vu8(127 0 0 0)]
@end example
@end defun


@defun getnetbyaddr @var{net} @var{type}
Interface to the C function @cfunc{getnetbyaddr}, @glibcref{Networks
Database, getnetbyaddr}.  Given an exact integer or bytevector @var{net}
representing a network number and the fixnum @var{type} representing a
network type, query the networks database and build an instance of
@code{struct-netent} mirroring the resulting @code{struct netent} entry.
If successful return the data structure, else raise an exception.

@example
(getnetbyaddr '#vu8(127 0 0 0) AF_INET)
@result{} #["struct-netent"
        n_name="loopback"
        n_aliases=()
        n_addrtype=AF_INET
        n_net=#vu8(127 0 0 0)]
@end example
@end defun


@defun network-entries
Interface to the C functions @cfunc{setnetent}, @cfunc{getnetent} and
@cfunc{endnetent}, @glibcref{Networks Database, setnetent}.  Scan the
networks database and build a list of @code{struct-netent} mirroring the
resulting @code{struct netent} entries.  Return the list of structures.
@end defun

@c page
@node posix socket socket
@subsection Network sockets operations


@defun socket @var{namespace} @var{style} @var{protocol}
Interface to the C function @cfunc{socket}, @glibcref{Creating a Socket,
socket}.  Create a new socket descriptor and return it as non--negative
fixnum; if an error occurs raise an exception.  All the arguments must
be fixnums.
@end defun


@defun shutdown @var{sock} @var{how}
Interface to the C function @cfunc{shutdown}, @glibcref{Closing a
Socket, shutdown}.  Close the socket @var{sock} according to @var{how},
which can be one of the constants @code{SHUT_RD}, @code{SHUT_WR} or
@code{SHUT_RDWR}.  If successful return unspecified values, else raise
an exception.
@end defun


@defun socketpair @var{namespace} @var{style} @var{protocol}
Interface to the C function @cfunc{socketpair}, @glibcref{Socket Pairs,
socketpair}.  Create a pairs of connected sockets and return two values
being the descriptors as non--negative fixnums; if an error occurs raise
an exception.  All the arguments must be fixnums; @var{namespace} must
be @code{AF_LOCAL}.

@example
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let-values (((a b) (px.socketpair AF_LOCAL SOCK_DGRAM 0)))
  (px.posix-write a '#vu8(1 2 3 4) 4)
  (let ((buf (make-bytevector 4)))
    (px.posix-read b buf 4)
    (px.shutdown a SHUT_RDWR)
    (px.shutdown b SHUT_RDWR)
    buf))
@result{} #vu8(1 2 3 4)
@end example
@end defun

@c ------------------------------------------------------------

@defun connect @var{sock} @var{addr}
Interface to the C function @cfunc{connect}, @glibcref{Connecting,
connect}.  Connect the socket @var{sock} to the address specified by the
bytevector @var{addr} which must hold a concrete instance of
@code{struct sockaddr}.  If successful return unspecified values, else
raise an exception.
@end defun


@defun listen @var{sock} @var{pending_conns}
Interface to the C function @cfunc{listen}, @glibcref{Listening,
listen}.  Enable the socket @var{sock} to accept connections; the fixnum
@var{pending_conns} specifies the maximum length of the pending
connection requests queue.  If successful return unspecified values,
else raise an exception.
@end defun


@defun accept @var{sock}
Interface to the C function @cfunc{accept}, @glibcref{Accepting
Connections, accept}.  Accept an incoming connection to the server
socket @var{sock}.

If successful and a connection is accepted return two values: a
non--negative fixnum representing the socket, a bytevector representing
the client address as @code{struct sockaddr}.

If successful and no connection is accepted return two values both being
false; this is the case of @cfunc{accept} returning @code{EWOULDBLOCK}
which means that @var{sock} is in non--blocking mode and no pending
connections exist.

If an error occurs raise an exception.
@end defun


@defun bind @var{sock} @var{sockaddr}
Interface to the C function @cfunc{bind}, @glibcref{Setting Address,
bind}.  Bind the socket descriptor @var{sock} to the address specified
by the @code{struct sockaddr} in the bytevector @var{sockaddr}.  If
successful return unspecified values, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun getpeername @var{sock}
Interface to the C function @cfunc{getpeername}, @glibcref{Who is
Connected, getpeername}.  Retrieve informations about the address of the
socket to which the @var{sock} socket is connected to.  If successful
return a bytevector holding a @code{struct sockaddr}, else raise an
exception.
@end defun


@defun getsockname @var{sock}
Interface to the C function @cfunc{getsockanme}, @glibcref{Setting
Address, getsockname}.  Retrieve informations about the address bound to
the socket descriptor @var{sock}.  If successful return a bytevector
holding the @code{struct sockaddr}, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun send @var{sock} @var{buffer} @var{size} @var{flags}
Interface to the C function @cfunc{send}, @glibcref{Sending Data, send}.
Like @cfunc{write} but with the additional argument @var{flags} which
must be a fixnum: write data from the bytevector @var{buffer} to the
socket @var{sock}; if @var{size} is a fixnum, write @var{size} bytes; if
@var{size} is false, write a number of bytes equal to the length of
@var{buffer}.  If successful return a non--negative fixnum representing
the number of bytes actually sent, else raise an exception.
@end defun


@defun recv @var{sock} @var{buffer} @var{size} @var{flags}
Interface to the C function @cfunc{recv}, @glibcref{Receiving Data,
recv}.  Like @cfunc{read} but with the additional argument @var{flags}
which must be a fixnum: read data from @var{sock} and store it in the
bytevector @var{buffer}; if @var{size} is a fixnum, read @var{size}
bytes; if @var{size} is false, read a number of bytes equal to the
length of @var{buffer}.  If successful return a non--negative fixnum
representing the number of bytes actually received, else raise an
exception.
@end defun

@c ------------------------------------------------------------

@defun sendto @var{sock} @var{buffer} @var{size} @var{flags} @var{addr}
Interface to the C function @cfunc{sendto}, @glibcref{Sending Datagrams,
sendto}.  Like @cfunc{send} but with the additional argument @var{addr}
which must be a bytevector holding a @code{struct sockaddr}: write data
from the bytevector @var{buffer} to the socket @var{sock} to the
destination specified by @var{addr}.

If @var{size} is a fixnum, write @var{size} bytes; if @var{size} is
false, write a number of bytes equal to the length of @var{buffer}.

If successful return a non--negative fixnum representing the number of
bytes actually sent, else raise an exception.
@end defun


@defun recvfrom @var{sock} @var{buffer} @var{size} @var{flags}
Interface to the C function @cfunc{recvfrom}, @glibcref{Receiving
Datagrams, recvfrom}.  Like @cfunc{recv} but additionally retrieve
informations about the address of the sender: read data from @var{sock}
and store it in the bytevector @var{buffer}.

If @var{size} is a fixnum, read @var{size} bytes; if @var{size} is
false, read a number of bytes equal to the length of @var{buffer}.

If successful return two values: a non--negative fixnum representing the
number of bytes actually received, a bytevector holding a @code{struct
sockaddr} representing the address of the sender; else raise an
exception.
@end defun

@c ------------------------------------------------------------

@defun getsockopt @var{sock} @var{level} @var{option} @var{optval}
Interface to the C function @cfunc{getsockopt}, @glibcref{Socket Option
Function, getsockopt}.  Retrieve the value of @var{option} of socket
@var{sock} at @var{level} and store it in the bytevector @var{optval}.
@var{option} and @var{level} must be fixnums.  If successful return
unspecified values, else raise an exception.
@end defun


@defun setsockopt @var{sock} @var{level} @var{option} @var{optval}
Interface to the C function @cfunc{setsockopt}, @glibcref{Socket Option
Function, setsockopt}.  Set a new value for @var{option} of socket
@var{sock} at @var{level} reading it from the bytevector @var{optval}.
@var{option} and @var{level} must be fixnums.  If successful return
unspecified values, else raise an exception.
@end defun

@c page
@node posix socket misc
@subsection Error and miscellaneous functions


@defun h_errno->string @var{h_errno-code}
Convert an encoded @code{h_errno} value to the corresponding symbolic
string.
@end defun


@defun h_strerror @var{h_errno-code}
Convert an encoded @code{h_errno} value to the corresponding descriptive
error message string.
@end defun


@defun gai-strerror @var{error-code}
Interface to the C function @cfunc{gai_strerror}, see the manual page
@code{gai_strerror(3)}.  Convert an @code{EAI_} error code into the
corresponding error message, return a string holding such message.
@end defun

@c page
@node posix socket examples
@subsection Examples of clients and servers


Basically a @tcp{}/@ip{} server should do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let ((sockaddr    (make-sockaddr_in '#vu8(127 0 0 1) 8080))
      (server-sock (px.socket PF_INET SOCK_STREAM 0)))
  (px.bind   server-sock sockaddr)
  (px.listen server-sock 2)
  (let-values (((sock client-address)
                (px.accept server-sock)))
    ;; ... talk with the client through SOCK ...
    (px.close sock))
  (px.close server-sock))
@end example

@noindent
while a @tcp{}/@ip{} client should to:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let ((sockaddr (make-sockaddr_in '#vu8(127 0 0 1) 8080))
      (sock     (px.socket PF_INET SOCK_STREAM 0)))
  (px.connect sock sockaddr)
  ;; ... talk to the server through SOCK ...
  (px.close sock))
@end example

A @udp{}/@ip{} ``server'' should do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let ((sockaddr   (make-sockaddr_in '#vu8(127 0 0 1) 8080))
      (sock       (px.socket PF_INET SOCK_DGRAM 0))
      (in-buffer  (make-bytevector 1024))
      (out-buffer (make-bytevector 1024)))
  (px.bind sock sockaddr)
  (let-values (((len sockaddr)
                (px.recvfrom sock in-buffer #f 0)))
    ;; ... process the received packet ...
    ;; ... prepare the answer ...
    (px.sendto sock out-buffer #f 0 sockaddr))
  (px.close sock))
@end example

@noindent
while a @udp{}/@ip{} ``client'' should do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let ((sockaddr   (make-sockaddr_in '#vu8(127 0 0 1) 8081))
      (sock       (px.socket PF_INET SOCK_DGRAM 0))
      (out-buffer (make-bytevector 1024))
      (in-buffer  (make-bytevector 1024)))
  (px.bind sock sockaddr)
  ;; ... prepare the request ...
  (px.sendto sock out-buffer #f 0 sockaddr)
  (let-values (((len sockaddr)
                (px.recvfrom sock in-buffer #f 0)))
    ;; ... process the received packet ...
    )
  (px.close sock))
@end example

A Unix--domain socket server should do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let* ((tmpdir       (px.getenv "TMPDIR"))
       (pathname     (string-append tmpdir "/use-me"))
       (sockaddr     (make-sockaddr_un pathname))
       (server-sock  (px.socket PF_LOCAL SOCK_STREAM 0)))
  (px.bind   server-sock sockaddr)
  (px.listen server-sock 2)
  (let-values (((sock client-address)
                (px.accept server-sock)))
    ;; ... talk to the client through SOCK ...
    (px.close sock))
  (px.close server-sock))
@end example

@noindent
while a Unix--domain socket client should do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let* ((tmpdir    (px.getenv "TMPDIR"))
       (pathname  (string-append tmpdir "/use-me"))
       (sockaddr  (make-sockaddr_un pathname))
       (sock      (px.socket PF_LOCAL SOCK_STREAM 0)))
  (px.connect sock sockaddr)
  ;; ... talk to the server through SOCK ...
  (px.close sock))
@end example

To receive incoming data and Out Of Band data, a @tcp{}/@ip{} server
should do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let ((sockaddr    (make-sockaddr_in '#vu8(127 0 0 1) 8080))
      (server-sock (px.socket PF_INET SOCK_STREAM 0)))
  (px.bind   server-sock sockaddr)
  (px.listen server-sock 2)
  (let*-values
      (((sock client-address) (px.accept server-sock))
       ((bv)                  (make-bytevector 10)))
    (let loop ()
      (let-values (((rd wr ex) (select-fd sock 2 0)))
        (cond (ex ;process exceptional conditions first!!!
               ;; block until OOB data arrives
               (let ((len (px.recv sock bv #f MSG_OOB)))
                 ;; process data in BV between 0 and LEN,
                 ;; which should be 1
                 (loop)))
              (rd
               (let ((len (px.recv sock bv #f 0)))
                 (when (positive? len)
                   ;; process data in BV between 0
                   ;; and LEN
                   (loop))))
              (else (loop)))))
    (px.close sock))
  (px.close server-sock))
@end example

@noindent
to send outgoing data and Out Of Band data, a @tcp{}/@ip{} client should
do:

@example
#!r6rs
(import (rnrs)
  (prefix (vicare posix) px.)
  (vicare platform-constants))

(let ((sockaddr  (make-sockaddr_in '#vu8(127 0 0 1) 8080))
      (sock      (px.socket PF_INET SOCK_STREAM 0)))
  (px.connect sock sockaddr)
  (px.send sock '#vu8(1 2 3) #f 0)
  ;; only the single byte 6 (the last) is sent as
  ;; OOB data, 4 and 5 are sent as ordinary data
  (px.send sock '#vu8(4 5 6) #f MSG_OOB)
  (px.send sock '#vu8(7 8 9) #f 0)
  (px.close sock))
@end example

@c page
@node posix socket oob
@subsection Notes on transmission of @oob{} data


In a @tcp{}/@ip{} stream--oriented client/server architecture, the
scenario is the following:

@example
 --------------------        ------------
| sending appication |----->| sending OS |
 --------------------        ------------
                                  |
                                  v
 -----------------------     -------------
| receiving application |<--| receving OS |
 -----------------------     -------------
@end example

@noindent
sending ordinary data works as follows:

@enumerate
@item
The sending application calls (for example) the @func{send} function
asking the sending @os{} to send data to the remote host.

@item
The sending @os{} enqueues the data in a @fifo{} buffer, which it
progressively fragments in packets for delivery.

@item
The receiving @os{} orders and enqueues data from received packets in a
@fifo{} buffer.

@item
The receiving application calls (for example) the @cfunc{recv} function
to consume chunks of the input data.
@end enumerate

@noindent
sending a single byte of @oob{} data works as follows:

@enumerate
@item
The sending application calls the function @func{send} specifying the
@code{MSG_OOB} flag, asking the sending @os{} to deliver a single byte
of @oob{} data.

@item
The sending @os{} enqueues the single byte in its @fifo{} buffer and
tags the next outgoing packet to announce future delivery of the @oob{}
byte.

@item
The receiving @os{} orders and enqueues data from received packets in a
@fifo{} buffer; when it detects a tagged packet announcing the @oob{}
byte: it optionally informs the receiving application of its future
arrival, signaling an exceptional condition on the socket descriptor, if
requested.

@item
The sending @os{} proceeds in sending ordinary data from its @fifo{}
buffer and whenever it reaches the @oob{} byte: it sends it in a
specially tagged packet.

@item
The receiving @os{} orders and enqueues data from received packets in a
@fifo{} buffer; when it detects a tagged packet holding the @oob{} byte:
it makes it available to the receiving application.

@item
The receving application calls the function @func{recv} specifying the
@code{MSG_OOB} flag and retrieves the single @oob{} byte.
@end enumerate

If we send the @oob{} byte with the form:

@example
(posix.send sock '#vu8(8) #f MSG_OOB)
@end example

@noindent
the byte @code{8} will be the @oob{} byte; if we send the @oob{} byte
with the form:

@example
(posix.send sock '#vu8(1 2 3) #f MSG_OOB)
@end example

@noindent
the byte @code{3}, the last in the memory block, will be the @oob{} byte
and the bytes @code{1} and @code{2} will be sent as ordinary data; the
receiving application must @strong{not} assume that bytes @code{1} and
@code{2} will be made available before the @oob{} byte @code{3}.

When using @func{select} to be notified of incoming @oob{} data: the
receiving application must assume that the exceptional condition is
notified @strong{only once} and not persist in further calls to
@func{select}; for this reason the exceptional condition must be
recognised and registered by the application as soon as it is notified
by @func{select}.

The socket option @code{SO_OOBINLINE} allows the @oob{} byte to be
places in the ordinary data @fifo{} buffer, so that it can be
transparently consumed by a call to @func{read} or @func{recv} without
the @code{MSG_OOB} flag.

Notice that the single @oob{} byte, although limited, can represent
@math{256} symbols in an appropriate alphabet of commands.

@c page
@node posix users
@section Users and groups


@defun getuid
Interface to the C function @cfunc{getuid}, @glibcref{Reading Persona,
getuid}.  Return a fixnum representing the real user ID of the process.
@end defun


@defun getgid
Interface to the C function @cfunc{getgid}, @glibcref{Reading Persona,
getgid}.  Return a fixnum representing the real group ID of the process.
@end defun


@defun geteuid
Interface to the C function @cfunc{geteuid}, @glibcref{Reading Persona,
geteuid}.  Return a fixnum representing the effective user ID of the
process.
@end defun


@defun getegid
Interface to the C function @cfunc{getegid}, @glibcref{Reading Persona,
getegid}.  Return a fixnum representing the effective group ID of the
process.
@end defun


@defun getgroups
Interface to the C function @cfunc{getgroups}, @glibcref{Reading
Persona, getgroups}.  Return a list of fixnums representing the
supplementary group IDs of the process; if an error occurs an exception
is raised.
@end defun

@c ------------------------------------------------------------

@defun seteuid @var{new-uid}
Interface to the C function @cfunc{seteuid}, @glibcref{Setting User ID,
seteuid}.  Set the effective user ID to @var{new-uid}, which must be a
fixnum.  If successful return unspecified values, else raise an
exception.
@end defun


@defun setuid @var{new-uid}
Interface to the C function @cfunc{setuid}, @glibcref{Setting User ID,
setuid}.  Set both the real and effective user IDs to @var{new-uid},
which must be a fixnum.  If successful return unspecified values, else
raise an exception.
@end defun


@defun setreuid @var{real-uid} @var{effective-uid}
Interface to the C function @cfunc{setreuid}, @glibcref{Setting User ID,
setreuid}.  Set the real user ID to @var{real_uid} and the effective
user ID to @var{effective_uid}, both the arguments must be fixnums.  If
successful return unspecified values, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun setegid @var{new-gid}
Interface to the C function @cfunc{setegid}, @glibcref{Setting Group,
setegid}.  Set the effective group ID to @var{new-gid}, which must be a
fixnum.  If successful return unspecified values, else raise an
exception.
@end defun


@defun setgid @var{new-gid}
Interface to the C function @cfunc{setgid}, @glibcref{Setting Groups,
setgid}.  Set both the real and effective group IDs to @var{new-gid},
which must be a fixnum.  If successful return unspecified values, else
raise an exception.
@end defun


@defun setregid @var{real-gid} @var{effective-gid}
Interface to the C function @cfunc{setregid}, @glibcref{Setting Group,
setregid}.  Set the real group ID to @var{real_gid} and the effective
group ID to @var{effective_gid}, both the arguments must be fixnums.  If
successful return unspecified values, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun getlogin
@defunx getlogin/string
Interface to the C function @cfunc{getlogin}, @glibcref{Who Logged In,
getlogin}.  @func{getlogin} returns a bytevector holding the @ascii{}
coding of the name of the user logged in on the controlling terminal of
the process; @func{getlogin/string} returns a string; if the name cannot
be determined: return false.
@end defun

@c ------------------------------------------------------------

@deftp {Structure Type} struct-passwd
Scheme level representation of @code{struct passwd}.  It has the
following fields:

@table @code
@item pw_name
Bytevector, user login name.

@item pw_passwd
Bytevector, encrypted password.

@item pw_uid
Fixnum, user ID.

@item pw_gid
Fixnum, group ID.

@item pw_gecos
Bytevector, user data.

@item pw_dir
Bytevector, user's home directory.

@item pw_shell
Bytevector, user's default shell.
@end table
@end deftp


@defun make-struct-passwd @var{name} @var{passwd} @var{uid} @var{gid} @var{gecos} @var{dir} @var{shell}
Build and return a new instance of @code{struct-passwd}.
@end defun


@defun struct-passwd? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-passwd}.
@end defun


@defun struct-passwd-pw_name @var{passwd}
@defunx struct-passwd-pw_passwd @var{passwd}
@defunx struct-passwd-pw_uid @var{passwd}
@defunx struct-passwd-pw_gid @var{passwd}
@defunx struct-passwd-pw_gecos @var{passwd}
@defunx struct-passwd-pw_dir @var{passwd}
@defunx struct-passwd-pw_shell @var{passwd}
Accessors for the fields of @code{struct-passwd}.
@end defun


@defun getpwuid @var{uid}
Interface to the C function @cfunc{getpwuid}, @glibcref{Lookup User,
getpwuid}.  Retrieve informations on the user with identifier @var{uid},
which must be a fixnum.  If successful return an instance of
@code{struct-passwd}; if a user with such an ID does not exists: return
false.
@end defun


@defun getpwnam @var{name}
Interface to the C function @cfunc{getpwnam}, @glibcref{Lookup User,
getpwnam}.  Retrieve informations on the user with name represented in
@ascii{} coding in the string or bytevector @var{name}.  If successful
return an instance of @code{struct-passwd}; if a user with such an ID
does not exists: return false.
@end defun


@defun user-entries
Interface to the C functions @cfunc{setpwent}, @cfunc{getpwent} and
@cfunc{endpwent}, @glibcref{Scanning All Users, setpwent}.  Iterate the
database of users and return a list of @code{struct-passwd} representing
the entries.
@end defun

@c ------------------------------------------------------------

@deftp {Structure Type} struct-group
Scheme level representation of @code{struct group}.  It has the
following fields:

@table @code
@item gr_name
Bytevector, group name.

@item gr_gid
Fixnum, group ID.

@item gr_mem
List of bytevectors, user names.
@end table
@end deftp


@defun make-struct-group @var{name} @var{gid} @var{mem}
Build and return a new instance of @code{struct-group}.
@end defun


@defun struct-group-gr_name @var{group}
@defunx struct-group-gr_gid @var{group}
@defunx struct-group-gr_mem @var{group}
Accessors for the fields of @code{struct-group}.
@end defun


@defun getgrgid @var{gid}
Interface to the C function @cfunc{getgrgid}, @glibcref{Lookup Group,
getgrgid}.  Retrieve informations on the group with identifier
@var{gid}, which must be a fixnum.  If successful return an instance of
@code{struct-group}; if a group with such an ID does not exists: return
false.
@end defun


@defun getgrnam @var{name}
Interface to the C function @cfunc{getgrnam}, @glibcref{Lookup Group,
getgrnam}.  Retrieve informations on the group with name represented in
@ascii{} coding in the string or bytevector @var{name}.  If successful
return an instance of @code{struct-group}; if a group with such an ID
does not exists: return false.
@end defun


@defun group-entries
Interface to the C functions @cfunc{setgrent}, @cfunc{getgrent} and
@cfunc{endgrent}, @glibcref{Scanning All Groups, setgrent}.  Iterate the
database of groups and return a list of @code{struct-group} representing
the entries.
@end defun

@c page
@node posix job
@section Job control


@defun ctermid
@defunx ctermid/string
Interface to the C function @cfunc{ctermid}, @glibcref{Identifying the
Terminal, ctermid}.  Return a bytevector or string holding the @ascii{}
coded pathname of the controlling terminal of the current process; the
returned value may be the empty bytevector or string.
@end defun

@c ------------------------------------------------------------

@defun setsid
Interface to the C function @cfunc{setsid}, @glibcref{Process Group
Functions, setsid}.  Create a new session, making the current process
the group leader with no controlling terminal.  If successful return a
fixnum representing the new process groups ID, else raise an exception.
@end defun


@defun getsid @var{pid}
Interface to the C function @cfunc{getsid}, @glibcref{Process Group
Functions, getsid}.  If successful return a fixnum representing the
session ID of the process with process ID @var{pid}, which must be a
fixnum; else raise an exception.
@end defun


@defun getpgrp
Interface to the C function @cfunc{getpgrp}, @glibcref{Process Group
Functions, getpgrp}.  Return a fixnum representing the process group ID
of the calling process.
@end defun


@defun setpgid @var{pid} @var{pgid}
Interface to the C function @cfunc{setpgid}, @glibcref{Process Group
Functions, setpgid}.  Put the process @var{pid} in the process group
@var{pgid}; both the arguments must be fixnums.  If successful return
unspecified values, else raise an exception.
@end defun

@c ------------------------------------------------------------

@defun tcgetpgrp @var{fd}
Interface to the C function @cfunc{tcgetpgrp}, @glibcref{Terminal Access
Functions, tcgetpgrp}.  If successful return a fixnum representing the
process group ID of the foreground process group associated with the
terminal open on descriptor @var{fd}, which must be a fixnum; else raise
an exception.
@end defun


@defun tcsetpgrp @var{fd} @var{pgid}
Interface to the C function @cfunc{tcsetpgrp}, @glibcref{Terminal Access
Functions, tcsetpgrp}.  Set to process group ID @var{pgid} the
foreground process group for the terminal open on descriptor @var{fd};
both the arguments must be fixnums.  If successful return the fixnum
zero, else raise an exception.
@end defun


@defun tcgetsid @var{fd}
Interface to the C function @cfunc{tcgetsid}, @glibcref{Terminal Access
Functions, tcgetsid}.  If successful return a fixnum representing the
process group ID of the session for which the terminal open on
descriptor @var{fd} is the controlling terminal; else raise an
exception.
@end defun


@c page
@node posix time
@section Date and time


@menu
* posix time timeval::          Data structure @code{struct-timeval}.
* posix time timespec::         Data structure @code{struct-timespec}.
* posix time tms::              Data structure @code{struct-tms}.
* posix time tm::               Data structure @code{struct-tm}.
* posix time functions::        Date and time functions.
@end menu

@c page
@node posix time timeval
@subsection Data structure @code{struct-timeval}


@deftp {Structure Type} struct-timeval
Scheme level representation of @code{struct timeval}, @glibcref{Elapsed
Time, struct timeval}.  It has the
following fields:

@table @code
@item tv_sec
Exact integer, represents a count of seconds.

@item tv_usec
Exact integer, represents a count of microseconds.
@end table
@end deftp


@defun make-struct-timeval @var{sec} @var{usec}
Build and return a new instance of @code{struct-timeval}.
@end defun


@defun struct-timeval? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-timeval}.
@end defun


@defun struct-timeval-tv_sec @var{timeval}
@defunx struct-timeval-tv_usec @var{timeval}
Accessors for the fields of @code{struct-timeval}.
@end defun

@c page
@node posix time timespec
@subsection Data structure @code{struct-timespec}


@deftp {Structure Type} struct-timespec
Scheme level representation of @code{struct timespec}, @glibcref{Elapsed
Time, struct timeval}.  It has the following fields:

@table @code
@item tv_sec
Exact integer, represents a count of seconds.

@item tv_nsec
Exact integer, represents a count of nanoseconds.
@end table
@end deftp


@defun make-struct-timespec @var{sec} @var{usec}
Build and return a new instance of @code{struct-timespec}.
@end defun


@defun struct-timespec? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-timespec}.
@end defun


@defun struct-timespec-tv_sec @var{timespec}
@defunx struct-timespec-tv_usec @var{timespec}
Accessors for the fields of @code{struct-timespec}.
@end defun

@c page
@node posix time tms
@subsection Data structure @code{struct-tms}


@deftp {Structure Type} struct-tms
Scheme level representation of @code{struct tms}, @glibcref{Processor
Time, struct tms}.  It has the following fields:

@table @code
@item tms_utime
Exact integer.

@item tms_stime
Exact integer.

@item tms_cutime
Exact integer.

@item tms_cstime
Exact integer.
@end table
@end deftp


@defun make-struct-tms @var{utime} @var{stime} @var{cutime} @var{cstime}
Build and return a new instance of @code{struct-tms}.
@end defun


@defun struct-tms? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-tms}.
@end defun


@defun struct-tms-tms_utime @var{tms}
@defunx struct-tms-tms_stime @var{tms}
@defunx struct-tms-tms_cutime @var{tms}
@defunx struct-tms-tms_cstime @var{tms}
Accessors for the fields of @code{struct-tms}.
@end defun

@c page
@node posix time tm
@subsection Data structure @code{struct-tm}


@deftp {Structure Type} struct-tm
Scheme level representation of @code{struct tm}, @glibcref{Broken-down
Time, struct tm}.  It has the following fields:

@table @code
@item tm_sec
Exact integer.

@item tm_min
Exact integer.

@item tm_hour
Exact integer.

@item tm_mday
Exact integer.

@item tm_mon
Exact integer.

@item tm_year
Exact integer.

@item tm_wday
Exact integer.

@item tm_yday
Exact integer.

@item tm_isdst
Boolean.

@item tm_gmtoff
Exact integer.

@item tm_zone
Bytevector.
@end table
@end deftp


@defun make-struct-tm @var{tm_sec} @var{tm_min} @var{tm_hour} @var{tm_mday} @var{tm_mon} @var{tm_year} @var{tm_wday} @var{tm_yday} @var{tm_isdst} @var{tm_gmtoff} @var{tm_zone}
Build and return a new instance of @code{struct-tm}.
@end defun


@defun struct-tm? @var{obj}
Return @true{} if @var{obj} is an instance of @code{struct-tm}.
@end defun


@defun struct-tm-tm_sec @var{tm}
@defunx struct-tm-tm_min @var{tm}
@defunx struct-tm-tm_hour @var{tm}
@defunx struct-tm-tm_mday @var{tm}
@defunx struct-tm-tm_mon @var{tm}
@defunx struct-tm-tm_year @var{tm}
@defunx struct-tm-tm_wday @var{tm}
@defunx struct-tm-tm_yday @var{tm}
@defunx struct-tm-tm_isdst @var{tm}
@defunx struct-tm-tm_gmtoff @var{tm}
@defunx struct-tm-tm_zone @var{tm}
Accessors for instances of @var{struct-tm}
@end defun

@c page
@node posix time functions
@subsection Date and time functions


@defun clock
Interface to the C function @cfunc{clock}, @glibcref{CPU Time, clock}.
If successful return an exact integer representing the CPU time for the
calling process expressed in clock ticks; if the clock time is not
available return false.
@end defun

@c ------------------------------------------------------------

@defun times
Interface to the C function @cfunc{times}, @glibcref{Processor Time,
times}.  If successful return an instance of @code{struct-tms}
representing the current processor time, else return false.
@end defun

@c ------------------------------------------------------------

@defun posix-time
Interface to the C function @cfunc{time}, @glibcref{Simple Calendar
Time, time}.  If successful return the calendar time as an exact
integer, else return false.
@end defun


@defun gettimeofday
Interface to the C function @cfunc{gettimeofday},
@glibcref{High-Resolution Calendar, gettimeofday}.  Acquire the current
time.  If successful return an instance of @code{struct-timeval}, else
raise an exception.
@end defun


@defun localtime @var{time}
Interface to the C function @cfunc{localtime}, @glibcref{Broken-down
Time, localtime}.  Given an exact integer @var{time} representing the
local time as returned by the @func{posix-time} function: build and
return an instance of @code{struct-tm} representing the same time in
human readable form; if an error occurs raise an exception.
@end defun


@defun gmtime @var{time}
Interface to the C function @cfunc{gmtime}, @glibcref{Broken-down Time,
gmtime}.  Given an exact integer @var{time} representing the @utc{} time
as returned by the @func{posix-time} function: build and return an
instance of @code{struct-tm} representing the same time in human
readable form; if an error occurs raise an exception.
@end defun

@c ------------------------------------------------------------

@defun nanosleep @var{secs} @var{nsecs}
Interface to the C function @cfunc{nanosleep}, @glibcref{Sleeping,
nanosleep}.  Halt the current process for the specified amount of time.

The count of seconds @var{secs} must be an exact integer in the range
@math{[0, 2^32)}; the count of nanoseconds @var{nsecs} must be an exact
integer in the range @math{[0, 999999999]}.

If successful and the requested time is elapsed: return a pair whose car
is false and whose cdr is false.  If successful and the sleeping was
interrupted by an interprocess signal: return a pair whose car is an
exact integer representing the count of remaining seconds and whose cdr
is an exact integer representing the count of remaining nanoseconds.  If
an error occurs an exception is raised.
@end defun

@c page
@node posix misc
@section Miscellaneous functions


@defun strerror @var{error-code}
Return a string describing the @code{errno} code @var{error-code}.
Makes use of the system function @cfunc{strerror}.  If @var{error-code}
is not a valid @code{errno} value: return a string telling it.

@glibcref{Error Messages, Error Messages}
@end defun


@defun file-descriptor? @var{obj}
Return true if @var{obj} is a non--negative fixnum less than the value
of @code{FD_SETSIZE}.
@end defun

@c page
@node glibc
@chapter The @gnu{} C Library interface


The functions described in this chapter are exported by the library
@library{vicare glibc}.  The @api{} attempts to create a one--to--one
Scheme functions mapping towards @gnu{} C Library functions, keeping the
same semantics as much as possible; the platform's own documentation is
relevant at the Scheme level.

All the constants needed to use the interface are available as
identifier syntaxes exported by the @library{vicare platform-constants}
library; if a constant value is not exported file a feature request for
the project.  If a constant is not defined on a platform: its value is
set to @false{}.

On non--@gnu{} C Library platforms we must avoid calling these
functions, else the behaviour is undefined.

@menu
* glibc env::                   Operating system environment variables.
* glibc dir::                   File system directories.
* glibc temp::                  Temporary files and directories.
* glibc sync::                  File system synchronisation.
* glibc socket::                Network sockets.
@end menu

@c page
@node glibc env
@section Operating system environment variables


The following bindings are exported by the @library{vicare glibc}
library.


@defun clearenv
Interface to the C function @cfunc{clearenv}, @glibcref{Environment
Access, clearenv}.  Remove all the entries from the environment.  Return
unspecified values.
@end defun

@c page
@node glibc dir
@section File system directories


The following bindings are exported by the @library{vicare glibc}
library.


@defun dirfd @var{stream}
Interface to the C function @cfunc{dirfd}, @glibcref{Opening a
Directory, dirfd}.  Acquire a file descriptor associated to
@var{stream}, which must be an instance of @code{directory-stream};
@ref{posix dir} for details.  If successful return a fixnum representing
the file descriptor, else raise an exception.
@end defun

@c page
@node glibc temp
@section Temporary files and directories


The following bindings are exported by the @library{vicare glibc}
library.


@defun mkstemp @var{template}
Interface to the C function @cfunc{mkstemp}, @glibcref{Temporary Files,
mkstemp}.  Create a temporary file, create it and open a file descriptor
for reading and writing.  @var{template} must be a mutable bytevector
holding a template pathname on entering and the actual pathname on
returning.  If successful return a file descriptor, else raise an
exception.
@end defun


@defun mkdtemp @var{template}
Interface to the C function @cfunc{mkdtemp}, @glibcref{Temporary Files,
mkdtemp}.  Create a temporary directory for reading and writing.
@var{template} must be a mutable bytevector holding a template pathname
on entering and the actual pathname on returning.  If successful return
@var{template} itself, else raise an exception.
@end defun

@c page
@node glibc sync
@section File system synchronisation


The following bindings are exported by the @library{vicare glibc}
library.


@defun sync
Interface to the C function @cfunc{sync}, @glibcref{Synchronizing I/O}.
Flush kernel buffer data and meta informations to the file system
devices.  If successful return unspecified values, else raise an
exception.
@end defun


@defun fsync @var{fd}
Interface to the C function @cfunc{fsync}, @glibcref{Synchronizing I/O}.
Flush kernel buffer data and meta informations to the file system device
for the file descriptor @var{fd}.  If successful return unspecified
values, else raise an exception.
@end defun


@defun fdatasync @var{fd}
Interface to the C function @cfunc{fdatasync}, @glibcref{Synchronizing
I/O}.  Flush kernel buffer data to the file system device for the file
descriptor @var{fd}.  If successful return unspecified values, else
raise an exception.
@end defun

@c page
@node glibc socket
@section Network sockets


The following bindings are exported by the @library{vicare glibc}
library.


@defun if-nametoindex @var{name}
Interface to the C function @cfunc{if_nametoindex}, @glibcref{Interface
Naming, if_nametoindex}.  Convert the string @var{name} representing a
network interface to the corresponding internal index.  Return a fixnum
representing the index or false if @var{name} is invalid.

@example
(import (vicare))

(if-indextoname 0)      @result{} #f
(if-indextoname 1)      @result{} "lo"
(if-indextoname 2)      @result{} "eth0"
@end example
@end defun


@defun ikptr if-indextoname @var{index}
Interface to the C function @cfunc{if_indextoname}, @glibcref{Interface
Naming, if_indextoname}.  Convert the fixnum @var{index} associated to
an interface to the corresponding string name.  Return a string holding
the name or false if @var{index} is invalid.

@example
(import (vicare))

(if-nametoindex "lo")   @result{} 1
(if-nametoindex "eth0") @result{} 2
@end example
@end defun


@defun if-nameindex
Interface to the C function @cfunc{if_nameindex}, @glibcref{Interface
Naming, if_nameindex}.  Build and return an association list having
fixnums as keys and strings as values; the fixnums are the interface
indexes, the strings are the corresponding interface names.

@example
(import (vicare))

(if-nameindex)
@result{} ((4 . "wlan0")
    (2 . "eth0")
    (1 . "lo"))
@end example
@end defun

@c ------------------------------------------------------------

@defun gethostbyname2 @var{hostname} @var{addrtype}
Interface to the C function @cfunc{gethostbyname2}, @glibcref{Host Names,
gethostbyname2}.  Like @func{gethostbyname} but allows the selection of
the address type with the parameter @var{addrtype} which must be
@code{AF_INET} or @code{AF_INET6}.
@end defun

@c page
@node linux
@chapter The @gnu{}+Linux interface


The functions described in this chapter are exported by the library
@library{vicare linux}.  The @api{} attempts to create a one--to--one
Scheme functions mapping towards Linux functions, keeping the same
semantics as much as possible; the platform's own documentation is
relevant at the Scheme level.

All the constants needed to use the interface are available as
identifier syntaxes exported by the @library{vicare platform-constants}
library; if a constant value is not exported file a feature request for
the project.  If a constant is not defined on a platform: its value is
set to @false{}.

On non--Linux platforms we must avoid calling these functions, else the
behaviour is undefined.

@menu
* linux env::                   Operating system environment variables.
* linux status::                Process termination status.
@end menu

@c page
@node linux env
@section Operating system environment variables


The following bindings are exported by the @library{vicare linux}
library.


@defun clearenv
Interface to the C function @cfunc{clearenv}, @glibcref{Environment
Access, clearenv}.  Remove all the entries from the environment.  Return
unspecified values.
@end defun

@c page
@node linux status
@section Process termination status


The following bindings are exported by the @library{vicare linux}
library.


@defun waitid @var{idtype} @var{id} @var{options}
Interface to the Linux specific C function @cfunc{waitid}, see the
@cfunc{waitid} manual page for details.  Wait for the termination of one
or more child processes with finer control of @func{waitpid}.  All the
arguments must be fixnums.  If successful: return an instance of
structure @code{struct-siginfo_t}, else raise an exception.
@end defun


@deftp Struct struct-siginfo_t
Data structure used by @func{waitid} to report its result; it has the
following fields:

@example
si_pid si_uid si_signo si_status si_code
@end example

See the @cfunc{waitid} manual page for details.
@end deftp


@defun make-struct-siginfo_t @var{pid} @var{uid} @var{signo} @var{status} @var{code}
@defunx struct-siginfo_t? @var{obj}
@defunx struct-siginfo_t-si_pid
@defunx struct-siginfo_t-si_uid
@defunx struct-siginfo_t-si_signo
@defunx struct-siginfo_t-si_status
@defunx struct-siginfo_t-si_code
Constructor, predicate and field accessors for structures of type
@code{struct-siginfo_t}.
@end defun


The following functions accept as argument a fixnum representing the
process termination status, for example the return value of
@cfunc{system} or the status acquired by @cfunc{waitpid}.


@defun WIFCONTINUED @var{status}
Interface to the Linux specific C macro @cfunc{WIFCONTINUED}.  Return
true if the process was resumed by delivery of @code{SIGCONT}.
@end defun

@c page
@node syslib
@chapter Low level, fast, unsafe operations


The bindings documented in this chapter are low level operations inlined
by the compiler; mostly they are defined in the source file
@file{pass-specify-rep-primops.ss}.

They are unsafe because when acting upon wrong arguments will cause
undefined behaviour (probably a crash).  They are also faster than the
public interface exported by @library{ikarus} and @library{rnrs}.

@menu
* syslib symbols::              Low level symbol operations.
* syslib fixnums::              Low level fixnum operations.
* syslib bignums::              Low level bignum operations.
* syslib flonums::              Low level flonum operations.
* syslib ratnums::              Low level ratnum operations.
* syslib compnums::             Low level compnum operations.
* syslib cflonums::             Low level cflonum operations.
* syslib chars::                Low level character operations.
* syslib pairs::                Low level pair operations.
* syslib structs::              Low level structure operations.
* syslib vectors::              Low level vector operations.
* syslib bytevectors::          Low level bytevector operations.
* syslib strings::              Low level string operations.
* syslib ports::                Low level port structures.
* syslib transcoders::          Low level transcoder operations.
@end menu

@c page
@node syslib symbols
@section Low level symbol operations


A symbol is a variable length memory block referenced by machine words
tagged as vectors.  The first machine word of a symbol block is tagged
has symbol in its least significant bits and it has the most significant
bits set to zero.

@example
|------------------------|-------------| reference to symbol
      heap offset          vector tag

|------------------------|-------------| symbol first word
   all set to zero         symbol tag
@end example

A symbol memory block is @math{6} words wide and contains references to
the following fields: @code{string}, @code{ustring}, @code{value},
@code{proc}, @code{plist}.

The arguments @var{sym} must be references to symbol blocks, the
arguments @var{str} must be references to strings.  The following
bindings are exported by the @library{ikarus system $symbols} library.


@deffn {Unsafe Operation} $make-symbol @var{str}
Allocate a new symbol block and initialise the @code{string} field with
@var{str}; return the reference to the symbol block.

The @code{ustring} is initialised to the fixnum zero.  The @code{value}
and @code{proc} fields are initialised to a special machine word value
meaning ``unbound''.  The @code{plist} field is initialised to nil.
@end deffn


@deffn {Unsafe Operation} $symbol-string @var{sym}
@deffnx {Unsafe Operation} $symbol-unique-string @var{sym}
@deffnx {Unsafe Operation} $symbol-plist @var{sym}
@deffnx {Unsafe Operation} $symbol-value @var{sym}
Accessors for the fields of @var{sym}.
@end deffn


@deffn {Unsafe Operation} $set-symbol-string! @var{sym} @var{str}
@deffnx {Unsafe Operation} $set-symbol-unique-string! @var{sym} @var{str}
@deffnx {Unsafe Operation} $set-symbol-plist! @var{sym} @var{ell}
@deffnx {Unsafe Operation} $set-symbol-value! @var{sym} @var{val}
@deffnx {Unsafe Operation} $set-symbol-proc! @var{sym} @var{proc}
Mutators for the fields of @var{sym}.
@end deffn


@deffn {Unsafe Operation} $set-symbol-value/proc! @var{sym} @var{val}
Set both the fields @code{value} and @code{proc} of @var{sym} to
@var{val}.
@end deffn


@deffn {Unsafe Operation} $unbound-object? @var{sym}
Return true if the @func{$symbol-value} field of @var{sym} is set to the
special ``unbound'' machine word value.
@end deffn


@deffn {Unsafe Operation} top-level-value @var{sym}
Still to be documented.
@end deffn


@deffn {Unsafe Operation} $init-symbol-function! @var{sym} @var{proc}
Still to be documented.
@end deffn


The following bindings are related to the symbol table collecting
interned symbols.


@defun $symbol-table-size
Return the number of interned symbols.
@end defun


@defun $log-symbol-table-status
Write to the current error port a description of the current symbol
table status.  Example:

@example
vicare> (import (ikarus system $symbols))
vicare> ($log-symbol-table-status)
Vicare internal symbol table status:
        number of interned symbols: 2962
        number of hash table buckets: 4096

vicare>
@end example
@end defun

@c page
@node syslib fixnums
@section Low level fixnum operations


A fixnum is a machine word whose two least significant bits are set to
zero.  @rnrs{6} states that a fixnum must have at least @math{24} bits
in which to store the number; under @value{PRJNAME}, on a 32-bit
platform, @math{29} bits are available to store the number and @math{1}
bit to store the sign:

@example
(greatest-fixnum)       @result{} +536870911
(expt 2 29)             @result{} +536870912
(- (expt 2 29) 1)       @result{} +536870911

(least-fixnum)          @result{} -536870912
(- (expt 2 29))         @result{} -536870912
@end example

The arguments to these operations must be fixnums.  The following
bindings are exported by the @library{ikarus system $fx} library.


@deffn {Unsafe Operation} $fxzero? @var{fx}
Evaluate to true if @var{fx} is zero.
@end deffn


@deffn {Unsafe Operation} $fx= @vari{fx} @varii{fx}
Evaluate to true if the arguments are equal.
@end deffn


@deffn {Unsafe Operation} $fx< @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is less than @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fx<= @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is less than or equal to @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fx> @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is greater than @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fx>= @vari{fx} @varii{fx}
Evaluate to true if @vari{fx} is greater than or equal to @varii{fx}.
@end deffn


@deffn {Unsafe Operation} $fxadd1 @var{fx}
Increment the operand by one and return the result.
@end deffn


@deffn {Unsafe Operation} $fxsub1 @var{fx}
Decrement the operand by one and return the result.
@end deffn


@deffn {Unsafe Operation} $fx+ @vari{fx} @varii{fx}
Sum the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fx- @vari{fx} @varii{fx}
Subtract the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fx* @vari{fx} @varii{fx}
Multiply the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlognot @var{fx}
Perform the bitwise NOT on the operand and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlogand @vari{fx} @varii{fx}
Perform the bitwise AND on the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlogor @vari{fx} @varii{fx}
Perform the bitwise inclusive OR on the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxlogxor @vari{fx} @varii{fx}
Perform the bitwise exclusive OR on the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxsll @vari{fx} @varii{fx}
Perform bitwise shift left of @vari{fx} by @varii{fx} positions and
return the result.
@end deffn


@deffn {Unsafe Operation} $fxsra @vari{fx} @varii{fx}
Perform bitwise shift right of @vari{fx} by @varii{fx} positions and
return the result.
@end deffn


@deffn {Unsafe Operation} $fxquotient @vari{fx} @varii{fx}
Compute the quotient between the operands and return the result.
@end deffn


@deffn {Unsafe Operation} $fxinthash @var{fx}
Evaluate to a fixnum which can be used as hash value.

@quotation
@strong{NOTE}  This appears to be unused in the source.
@end quotation
@end deffn

@c page
@node syslib bignums
@section Low level bignum operations


Bignums are multi--precision exact integers bigger than fixnums; they
are implemented using the @code{mpn} @api{} of @gnu{} @gmp{},
@xref{Low-level Functions, mpn, Low-level Functions, gmp}.  @ref{iklib
numerics} for more functions acting on bignums.

A bignum is a variable length memory block referenced by machine words
tagged as vectors.  The first machine word of a bignum block is tagged
has bignum in its least significant bits; then comes a sign bit, zero if
positive; the remaining most significant bits represent the number of
words in the memory block after the first one.

@example
|------------------------|-------------| reference to bignum
      heap offset          vector tag

                     sign bit
|----------------------|-|-------------| bignum first word
   number of words         bignum tag
@end example

A pointer to the second machine word in a bignum memory block is the
pointer of type @code{mp_limb_t} accepted by the @code{mpn_} functions
of @gmp{}; @dfn{limb}, in @gmp{} jargon, is a machine word holding a
portion of multi--precision number.

@value{PRJNAME} only uses a bignum to represent an exact integer when
the value does not fit in a fixnum; it follows that the following ranges
are enforced:

@example
negative bignums < (least-fixnum) <= all fixnums

all fixnums <= (greatest-fixnum) < positive bignums
@end example

The arguments @var{bn} to these operations must be bignums.  The
following bindings are exported by the @library{ikarus system $bignums}
library.


@deffn {Unsafe Operation} $bignum-positive? @var{bn}
Evaluate to true if the operand is positive.
@end deffn


@deffn {Unsafe Operation} $bignum-byte-ref @var{bn} @var{fx}
Return a fixnum representing the byte at index @var{fx} in the data of
@var{bn}.
@end deffn


@deffn {Unsafe Operation} $bignum-size @var{bn}
Return a fixnum representing the number of machine words in the data
portion of a bignum memory block.
@end deffn

@c page
@node syslib flonums
@section Low level flonum operations


Flonums are double--precision floating point numbers (@math{8} bytes
wide) implemented as specified by @ieee{} 754 on the hosting platform.
@ref{iklib numerics} for more functions acting on flonums.

A flonum is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a flonum block is tagged
has flonum in its least significant bits and it has the most significant
bits set to zero.

@example
|------------------------|-------------| reference to flonum
      heap offset          vector tag

|------------------------|-------------| flonum first word
   all set to zero         flonum tag
@end example

A flonum memory block is @math{16} bytes wide on both 32-bit and 64-bit
platforms; to allow for the same binary layout on both platforms, on a
32-bit platform the actual number is stored in the last two words:

@example
   1st word     2nd word     3rd word     4th word
|------------|------------|------------|------------|
 tagged word     unused           data words
@end example

@noindent
on a 64-bit platform the actual number is stored in the second word:

@example
          1st word                 2nd word
|-------------------------|-------------------------|
         tagged word               data word
@end example

The arguments @var{fl} to these operations must be flonums, the
arguments @var{fx} must be fixnums.  The following bindings are exported
by the @library{ikarus system $flonums} library.


@deffn {Unsafe Operation} $make-flonum
Allocate a new flonum memory block and return a reference to it.  Does
not initialise the data area.
@end deffn


@deffn {Unsafe Operation} $flonum-u8-ref @var{fl} @var{fx}
Return the octet at index @var{fx} in the data area of @var{fl}.
@end deffn


@deffn {Unsafe Operation} $flonum-set! @var{fl} @var{fx-index} @var{fx-value}
Store the byte or octet represented by @var{fx-value} at index
@var{fx-index} in the data area of @var{fl}.
@end deffn


@deffn {Unsafe Operation} $fixnum->flonum @var{fx}
Convert the fixnum operand into a flonum and return a reference to the
result.
@end deffn


@deffn {Unsafe Operation} $fl+ @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl- @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl* @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl/ @vari{fl} @varii{fl}
Perform arithmetic operations.
@end deffn


@deffn {Unsafe Operation} $fl= @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl< @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl<= @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl> @vari{fl} @varii{fl}
@deffnx {Unsafe Operation} $fl>= @vari{fl} @varii{fl}
Perform comparison operations
@end deffn


@deffn {Unsafe Operation} $flonum-sbe @var{fl}
Return a fixnum@dots{} Still undocumented, read the code look at the
format of @ieee{} double precision flonums.
@end deffn

@c page
@node syslib ratnums
@section Low level ratnum operations


Ratnums are exact rational numbers, having a fixnum or bignum as
numerator and a fixnum or bignum as denominator.  @ref{iklib numerics}
for more functions acting on ratnums.

A ratnum is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a ratnum block is tagged
has ratnum in its least significant bits and it has the most significant
bits set to zero.

@example
|------------------------|-------------| reference to ratnum
      heap offset          vector tag

|------------------------|-------------| ratnum first word
   all set to zero         ratnum tag
@end example

A ratnum memory block is @math{4} words wide; a reference to the
numerator is stored in the second word and a reference to the
denominator is stored in the third word

@example
   1st word     2nd word     3rd word     4th word
|------------|------------|------------|------------|
 tagged word   numerator   denominator     unused
@end example

The arguments @var{rat} to these operations must be ratnums, the
arguments @var{num} must be references to either fixnums or bignums.
The following bindings are exported by the @library{ikarus system
$ratnums} library.


@deffn {Unsafe Operation} $make-ratnum @vari{num} @varii{num}
Allocate a new ratnum memory block, store @vari{num} as reference to the
numerator and @varii{num} as reference to the denominator.  Return a
reference to the ratnum.
@end deffn


@deffn {Unsafe Operation} $ratnum-n @var{rat}
Return the reference to the numerator.
@end deffn


@deffn {Unsafe Operation} $ratnum-d @var{rat}
Return the reference to the denominator.
@end deffn

@c page
@node syslib compnums
@section Low level compnum operations


Compnums are complex numbers having a fixnum, bignum or flonum as real
part and a fixnum, bignum or flonum as imaginary part, but @strong{not}
both flonums.  @ref{iklib numerics} for more functions acting on
compnums.

A compnum is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a compnum block is tagged
has compnum in its least significant bits and it has the most
significant bits set to zero.

@example
|------------------------|-------------| reference to compnum
      heap offset          vector tag

|------------------------|-------------| compnum first word
   all set to zero         compnum tag
@end example

A compnum memory block is @math{4} words wide; a reference to the real
part is stored in the second word and a reference to the imaginary part
is stored in the third word

@example
   1st word     2nd word     3rd word     4th word
|------------|------------|------------|------------|
 tagged word   real part    imag part     unused
@end example

The arguments @var{cmp} to these operations must be compnums, the
arguments @var{num} must be references to either fixnums, bignums or
flonums.  The following bindings are exported by the @library{ikarus
system $compnums} library.


@deffn {Unsafe Operation} $make-compnum @vari{num} @varii{num}
Allocate a new compnum memory block, store @vari{num} as reference to
the real part and @varii{num} as reference to the imaginary part.
Return a reference to the compnum.
@end deffn


@deffn {Unsafe Operation} $compnum-real @var{cmp}
Return the reference to the real part.
@end deffn


@deffn {Unsafe Operation} $compnum-imag @var{cmp}
Return the reference to the imaginary part.
@end deffn

@c page
@node syslib cflonums
@section Low level cflonum operations


Cflonums are complex numbers having a flonum as real part and flonum as
imaginary part.  @ref{iklib numerics} for more functions acting on
cflonums.

A cflonum is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a cflonum block is tagged
has cflonum in its least significant bits and it has the most
significant bits set to zero.

@example
|------------------------|-------------| reference to cflonum
      heap offset          vector tag

|------------------------|-------------| cflonum first word
   all set to zero         cflonum tag
@end example

A cflonum memory block is @math{4} words wide; a reference to the real
part is stored in the second word and a reference to the imaginary part
is stored in the third word

@example
   1st word     2nd word     3rd word     4th word
|------------|------------|------------|------------|
 tagged word   real part    imag part     unused
@end example

The arguments @var{cmp} to these operations must be cflonums, the
arguments @var{fl} must be references to flonums.  The following
bindings are exported by the @library{ikarus system $compnums} library.


@deffn {Unsafe Operation} $make-cflonum @vari{fl} @varii{fl}
Allocate a new cflonum memory block, store @vari{fl} as reference to the
real part and @varii{fl} as reference to the imaginary part.  Return a
reference to the cflonum.
@end deffn


@deffn {Unsafe Operation} $cflonum-real @var{cmp}
Return the reference to the real part.
@end deffn


@deffn {Unsafe Operation} $cflonum-imag @var{cmp}
Return the reference to the imaginary part.
@end deffn

@c page
@node syslib chars
@section Low level character operations


A character is a machine word whose least significant bits are set to
the character tag.

The arguments @var{ch} to these operations must be characters, the
arguments @var{fx} must be fixnums in the range @code{[0, #x10FFFF]} but
not in the range @code{[#xD800, #xDFFF]}.  The following bindings are
exported by the @library{ikarus system $chars} library.


@deffn {Unsafe Operation} $char= @vari{ch} @varii{ch}
Evaluate to true if the operands are equal.
@end deffn


@deffn {Unsafe Operation} $char< @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is less than @varii{ch}.
@end deffn


@deffn {Unsafe Operation} $char<= @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is less than or equal to @varii{ch}.
@end deffn


@deffn {Unsafe Operation} $char> @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is greater than @varii{ch}.
@end deffn


@deffn {Unsafe Operation} $char>= @vari{ch} @varii{ch}
Evaluate to true if the @vari{ch} is greater than or equal to
@varii{ch}.
@end deffn


@deffn {Unsafe Operation} $fixnum->char @var{fx}
Return a new character value whose code point equals @var{fx}.
@end deffn


@deffn {Unsafe Operation} $char->fixnum @var{ch}
Return a fixnum representing the code point of the operand.
@end deffn

@c page
@node syslib pairs
@section Low level pair operations


A pair is a fixed--length block of memory composed of two machine words;
the least significant bits of a reference to a pair are a pair tag.

@example
|------------------------|-------------| reference to pair
      heap offset           pair tag
@end example

The arguments @var{P} to these operations must be pairs.  The following
bindings are exported by the @library{ikarus system $pairs} library.


@deffn {Unsafe Operation} $car @var{P}
Return the car of the operand.
@end deffn


@deffn {Unsafe Operation} $cdr @var{P}
Return the cdr of the operand.
@end deffn


@deffn {Unsafe Operation} $set-car! @var{P} @var{value}
Store @var{value} in the car location of @var{P}.
@end deffn


@deffn {Unsafe Operation} $set-cdr! @var{P} @var{value}
Store @var{value} in the cdr location of @var{P}.
@end deffn

@c page
@node syslib structs
@section Low level structure operations


A data structure is a variable length block of memory allocated as a
vector; a reference to a structure value is a machine word tagged as
vector.  The first machine word of the structure is a reference to the
type descriptor; a type descriptor is itself a data structure.  A block
of memory is a data structure if and only if: a reference to it is
tagged as vector and its first word is tagged as vector.

@example
|----------------|----------| reference to structure
  heap offset     vector tag

|----------------|----------| first word of structure
  heap offset     vector tag    = reference to rtd
                                = reference to structure
@end example

The type descriptor of the type descriptors is the return value of
@func{base-rtd}.  @ref{iklib structs} for more informations on the
public interface of data structures.

The arguments @var{stru} to these operations must be references to data
structures, the arguments @var{rtd} must be references to structure type
descriptors, the arguments @var{fx} must be fixnums of appropriate
value.  The following bindings are exported by the @library{ikarus
system $structs} library.


@deffn {Unsafe Operation} base-rtd
Return a reference to the type descriptor used as type for all the type
descriptors.
@end deffn


@deffn {Unsafe Operation} $struct? @var{obj}
Evaluate to true if @var{obj} is the reference to a structure.
@end deffn


@deffn {Unsafe Operation} $struct/rtd? @var{stru} @var{rtd}
Evaluate to true if @var{stru} is a structure of type @var{rtd}.
@end deffn


@deffn {Unsafe Operation} $make-struct @var{rtd} @var{fx}
Allocate a new data structure of type @var{rtd} capable of holding
@var{fx} words and return a reference to it.
@end deffn


@deffn {Unsafe Operation} $struct-rtd @var{stru}
Return a reference to the type descriptor of @var{stru}.
@end deffn


@deffn {Unsafe Operation} $struct-ref @var{stru} @var{fx}
Return the value in the field at index @var{fx} of @var{stru}.
@end deffn


@deffn {Unsafe Operation} $struct-set! @var{stru} @var{fx} @var{value}
Store @var{value} in the field at index @var{fx} of @var{stru}.
@end deffn


@deffn {Unsafe Operation} $struct @var{rtd} @var{value} ...
Allocate a new data structure of type @var{rtd} capable of holding as
many words as given @var{value} arguments and initialise the fields with
such values.  Return a reference to the structure.
@end deffn

@c page
@node syslib vectors
@section Low level vector operations


Vectors are variable length blocks of memory referenced by machine words
tagged as vectors.  The first machine word of a vector block contains a
fixnum representing the vector length; a vector is capable of holding at
most a number of values equal to the return value of
@func{greatest-fixnum}.  This means that the first word of a vector is
tagged as a fixnum.

@example
|------------------------|-------------| reference to vector
      heap offset          vector tag

|------------------------|-------------| vector first word
     number of words       fixnum tag
@end example

The arguments @var{vec} to these operations must be fixnums, the
arguments @var{fx} must be fixnums.  The following bindings are exported
by the @library{ikarus system $vectors} library.


@deffn {Unsafe Operation} $make-vector @var{fx}
Allocate and return a new vector value of @var{fx} elements.
@end deffn


@deffn {Unsafe Operation} $vector-length @var{vec}
Evaluate to a fixnum representing the numbe of values in @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-ref @var{vec} @var{fx}
Return the value at index @var{fx} in @var{vec}.
@end deffn


@deffn {Unsafe Operation} $vector-set! @var{vec} @var{fx} @var{value}
Store @var{value} at index @var{fx} in @var{vec}.
@end deffn

@c page
@node syslib bytevectors
@section Low level bytevector operations


Bytevectors are blocks of memory referenced by machine words tagged as
bytevectors.  The first word in the memory block is a fixnum
representing the number of bytes in the data area; a bytevector is
capable of holding at most a number of values equal to the return value
of @func{greatest-fixnum}.

When allocating a bytevector capable of holding @math{N} bytes, the
actual size of the allocated data area is @math{N+1}; the additional
last byte is not part of the data area and is perpetually set to zero.

To allow for the same binary layout on both 32-bit and 64-bit platforms,
the data area starts @math{8} bytes after the beginning; on a 32-bit
platform the layout is:

@example
  1st word   2nd word                       last byte
|----------|----------|-------------------|-----------|
   length     unused        data area      set to zero
@end example

@noindent
on a 64-bit platform the layout is:

@example
       1st word                             last byte
|---------------------|-------------------|-----------|
       length               data area      set to zero
@end example

The arguments @var{bv} to these operations must be references to
bytevectors, the arguments @var{fx} must be fixnums in the appropriate
range, the arguments @var{fl} must be flonums.  The following bindings
are exported by the @library{ikarus system $bytevectors} library.


@deffn {Unsafe Operation} $make-bytevector @var{fx}
Allocate a new bytevector capable of holding @var{fx} bytes and return a
reference to it.
@end deffn


@deffn {Unsafe Operation} $bytevector-length @var{bv}
Return a fixnum representing the number of bytes in the operand.
@end deffn


@deffn {Unsafe Operation} $bytevector-u8-ref @var{bv} @var{fx}
Return a fixnum representing the octet at offset @var{fx} in @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-s8-ref @var{bv} @var{fx}
Return a fixnum representing the byte at offset @var{fx} in @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-set! @var{bv} @var{fx-index} @var{fx-value}
Store the octet or byte @var{fx-value} at index @var{fx-index} of
@var{bv}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Double--precision @ieee{} flonums


@deffn {Unsafe Operation} $bytevector-ieee-double-native-ref @var{bv} @var{fx}
Return a flonum representing the value at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-double-native-set! @var{bv} @var{fx} @var{fl}
Store @var{fl} at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-double-nonnative-ref @var{bv} @var{fx}
Return a flonum representing the value at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-double-nonnative-set! @var{bv} @var{fx} @var{fl}
Store @var{fl} at index @var{fx} of @var{bv}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Single--precision @ieee{} flonums


@deffn {Unsafe Operation} $bytevector-ieee-single-native-ref @var{bv} @var{fx}
Return a flonum representing the value at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-single-native-set! @var{bv} @var{fx} @var{fl}
Store @var{fl} at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-single-nonnative-ref @var{bv} @var{fx}
Return a flonum representing the value at index @var{fx} of @var{bv}.
@end deffn


@deffn {Unsafe Operation} $bytevector-ieee-single-nonnative-set! @var{bv} @var{fx} @var{fl}
Store @var{fl} at index @var{fx} of @var{bv}.
@end deffn

@c page
@node syslib strings
@section Low level string operations


Strings are blocks of memory referenced by machine words tagged as
strings.  The first word in the memory block is a fixnum representing
the number of characters in the data area; a string is capable of
holding at most a number of characters equal to the return value of
@func{greatest-fixnum}.

The arguments @var{str} to these operations must be references to
strings, the arguments @var{fx} must be fixnums in the appropriate
range, the arguments @var{ch} must be characters.  The following
bindings are exported by the @library{ikarus system $strings} library.


@deffn {Unsafe Operation} $make-string @var{fx}
Allocate a new string capable of holding @var{fx} characters and return
a reference to it.
@end deffn


@deffn {Unsafe Operation} $string-length @var{str}
Return a fixnum representing the length of the operand.
@end deffn


@deffn {Unsafe Operation} $string-ref @var{str} @var{fx}
Return the character at offset @var{fx} in @var{str}.
@end deffn


@deffn {Unsafe Operation} $string-set! @var{str} @var{fx} @var{ch}
Store @var{ch} at index @var{fx} of @var{str}.
@end deffn

@c page
@node syslib ports
@section Low level port structures


A port value is a block of memory allocated as a vector; a reference to
a port value is a reference to a vector.  The first word of the vector
is the bitwise OR between a port tag and a bitvector of port attributes.

@example
|----------------|----------| port value
  heap offset     vector tag

|----------------|----------| 1st word of port's memory block
 port attributes   port tag
@end example

At present the port tag is @math{6} bits wide, so we have: on 32 bits
platforms: 32 - 6 = 24 bits available for attributes; on 64 bits
platforms: 64 - 6 = 58 bits available for attributes.

See the source code for a more comprehensive documentation.

The following bindings are exported by the @library{ikarus system $io}
library.


@defun port? @var{obj}
Return true if @var{obj} is the reference to a port structure; return
false otherwise.
@end defun


@deffn {Unsafe Operation} $make-port @var{attrs} @var{idx} @var{sz} @var{buf} @var{tr} @var{id} @var{read} @var{write} @var{getp} @var{setp} @var{cl} @var{cookie}
Allocate a new port structure, initialise its fields with the arguments,
return a reference to it.
@end deffn


@deffn {Unsafe Operation} $port-index @var{port}
@deffnx {Unsafe Operation} $port-size @var{port}
@deffnx {Unsafe Operation} $port-buffer @var{port}
@deffnx {Unsafe Operation} $port-transcoder @var{port}
@deffnx {Unsafe Operation} $port-id @var{port}
@deffnx {Unsafe Operation} $port-read! @var{port}
@deffnx {Unsafe Operation} $port-write! @var{port}
@deffnx {Unsafe Operation} $port-get-position @var{port}
@deffnx {Unsafe Operation} $port-set-position! @var{port}
@deffnx {Unsafe Operation} $port-close @var{port}
@deffnx {Unsafe Operation} $port-cookie @var{port}
Accessors for the fields of a port structure.
@end deffn


@deffn {Unsafe Operation} $port-attrs @var{port}
Given a port value: return a fixnum representing the port attributes.
@end deffn


@deffn {Safe Operation} $port-tag @var{port}
Extract from a port reference a fixnum representing the port attributes;
if the argument is not a port reference the return value is zero.
@end deffn


@deffn {Unsafe Operation} $set-port-index! @var{port} @var{new-index}
Mutator for the buffer index field.
@end deffn


@deffn {Unsafe Operation} $set-port-size! @var{port} @var{new-used-size}
Mutator for the buffer used size field.
@end deffn


@deffn {Unsafe Operation} $set-port-attrs! @var{port} @var{new-attrs}
Mutator for the port attributes.
@end deffn

@c page
@node syslib transcoders
@section Low level transcoder operations


A transcoder is a machine word tagged to make it of a disjoint type.
The transcoder data (codec, @eol{} style, error handling) is encoded in
the most significant bits of this word.

@example
|---------------------------|------------| transcoder
       payload bits          transcoder-tag
@end example

The arguments @var{tran} to these operations must be transcoders, the
arguments @var{fx} must be fixnums in the appropriate range.  The
following bindings are exported by the @library{ikarus system
$transcoders} library.


@deffn {Unsafe Operation} $data->transcoder @var{fx}
Encode @var{fx} as payload bits of a transcoder word and return the
resulting transcoder.
@end deffn


@deffn {Unsafe Operation} $transcoder->data @var{tran}
Extract the payload bits from a transcoder and return them as fixnum.
@end deffn

@c page
@node capi
@chapter C language programming interface


The executable @value{EXECUTABLE} defines a number of C language
functions that can be invoked by compiled code to access various
services, both to handle startup and to access the operating system.

When on a @gnu{}+Linux system: the Linux specific functions are
available; when on other systems: calling such functions will terminate
the process.

@menu
* capi posix::                  C language level @posix{} interface.
* capi linux::                  C language level @gnu{}+Linux interface.
* capi glibc::                  C language level @gnu{} C Library
                                interface.
@end menu

@c page
@node capi posix
@section C language level @posix{} interface


Several files are involved in the full implementation of the @posix{}
interface:

@example
src/ikarus-posix.c
lib/vicare/unsafe-capi.sls
scheme/ikarus.posix.sls
scheme/makefile.sps
tests/test-vicare-posix.sps
@end example

File pathnames are bytevectors at the C language level and strings at
the Scheme language level; the conversion is performed with the function
in the parameter @func{string->filename-func}.

The authoritative documentation for all the interface functions is the
one of the C library on the platform's operating system; this file gives
only a brief overview of the features and explains the Scheme
adaptation.

@menu
* capi posix adding::           How to add a @posix{} primitive.
* capi posix errno::            Handling @code{errno} codes.
* capi posix env::              Operating system environment variables.
* capi posix port::             File descriptors and Scheme ports.
* capi posix pid::              Process identifier functions.
* capi posix process::          Forking and executing processes.
* capi posix status::           Process termination status.
* capi posix signals::          Delivering interprocess signals.
* capi posix stat::             File system inspection.
* capi posix file::             File system interface.
* capi posix link::             Hard and symbolic links.
* capi posix dir::              File system directories.
* capi posix fd::               File descriptors at low level.
* capi posix socket::           Network sockets.
* capi posix users::            Users and groups.
* capi posix job::              Job control.
* capi posix time::             Time and date.
@end menu

@c page
@node capi posix adding
@subsection How to add a @posix{} primitive


We must remember that the @posix{} primitives end up exported by both
the @library{vicare} and @library{ikarus} libraries; following the
example of the @cfunc{getpid} function, to add a @posix{} primitive we
should follow these steps:

@enumerate
@item
In the file @file{src/ikarus-posix.c} add the primitive C language
function:

@example
ikptr
ikrt_posix_getpid(void)
@{
  int   retval = getpid();
  return fix(retval);
@}
@end example

@item
In the file @file{lib/vicare/unsafe-capi.sls} add the following macro
definition to the library:

@example
(define-inline (posix-getpid)
  (foreign-call "ikrt_posix_getpid"))
@end example

@noindent
and add the binding to the export list.

@item
In the file @file{scheme/ikarus.posix.sls}: add the binding to both the
export list of the library and to the @code{except} import list from
@library{ikarus}; add the function implementation calling a syntax
associated to the foreign function:

@example
(define (getpid)
  (posix-getpid))
@end example

@item
In the file @file{scheme/makefile.sps}: add an entry for the function to
the list bound to @code{identifier->library-map} to have the function
exported by @library{ikarus} and @library{vicare}:

@example
(getpid         i v)
@end example

@item
In the file @file{tests/test-vicare-posix.sps} add test cases for the
function.
@end enumerate

@c page
@node capi posix errno
@subsection Handling @code{errno} codes


@value{PRJNAME} makes use of the platform's own @code{errno} codes; they
are negated to make them different from file descriptors, and so
distinguishable when used as single return values from C functions, and
converted to fixnums.  Example: if the C language code for @code{EPERM}
is the integer @code{1}, the corresponding Scheme language value is the
fixnum @code{-1}.


@deftypefun ikptr ik_errno_to_code (void)
Negate the current @code{errno} value and convert the result into a
fixnum, return the fixnum.  When an error occurs: many functions call
this function and return its return value.
@end deftypefun


@deftypefun ikptr ikrt_strerror (ikptr @var{ec}, ikpcb * @var{pcb})
Interface to the C function @cfunc{strerror}, @glibcref{Error Messages,
strerror}.  Convert a fixnum representing an encoded @code{errno} code
into a bytevector holding the string message which describes it; return
a reference to the bytevector; if @var{ec} is invalid: return false.
@end deftypefun


@deftypefun ikptr ikrt_last_errno (ikpcb * pcb)
Return a fixnum representing the negated value of @code{errno} right
after the last call to a foreign function through the @ffi{}.
@end deftypefun

@c page
@node capi posix env
@subsection Accessing environment variables


@deftypefun ikptr ikrt_posix_getenv (ikptr @var{variable}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getenv}, @glibcref{Environment
Access, getenv}.  Retrieve the value of environment variables.
@var{variable} must reference a bytevector object representing the name
of the environment variable.  If the environment variable is set: return
a bytevector representing its value; else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_setenv (ikptr @var{variable}, ikptr @var{value}, ikptr @var{overwrite})
Interface to the C function @cfunc{setenv}, @glibcref{Environment
Access, setenv}.  Set a new value for an environment variable.

@var{variable} must reference a bytevector object representing the name
of the environment variable; @var{value} must reference a bytevector
object representing the new value.  If @var{overwrite} is
@code{false_object} and the environment variable already exists: the
environment variable is left untouched; else the new value is set,
either creating a new environment variable or replacing the old value.

If successful return @code{true_object}; if an error occurs in
@cfunc{setenv} return @code{false_object}.
@end deftypefun


@deftypefun ikptr ikrt_posix_unsetenv (ikptr @var{variable})
Interface to the C function @cfunc{unsetenv}, @glibcref{Environment
Access, unsetenv}.  Unset an environment variable.  @var{variable} must
reference a bytevector object representing the name of the environment
variable.  Return true if @var{variable} has the correct format, else
return false; there is no way to know if a variable was actually unset.
@end deftypefun


@deftypefun ikptr ikrt_posix_environ (ikpcb * @var{pcb})
Interface to the global C variable @code{environ}, @glibcref{Environment
Access, unsetenv}.  Retrieve the full environment.  Return a list of
bytevectors representing the contents of the @code{environ} array; if
the environment is empty (no environment variables set) return nil.
@end deftypefun

@c page
@node capi posix port
@subsection File descriptors and Scheme ports


@menu
* capi posix port open::        Opening and closing file descriptors.
* capi posix port seek::        Handling file descriptor cursor.
* capi posix port rw::          Reading and writing.
* capi posix port event::       Handling file descriptor events.
* capi posix port net::         Handling sockets.
@end menu

@c page
@node capi posix port open
@subsubsection Opening and closing file descriptors


@deftypefun ikptr ikrt_close_fd (ikptr @var{fd})
Interface to the @cfunc{close} C function.  @glibcref{Opening and
Closing Files, close}.  Close a file descriptor.

@var{fd} must be a fixnum representing a file descriptor.

If successful return @code{false_object}; if an error occurs in
@cfunc{close} return the return value of @cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_open_input_fd (ikptr @var{pathname})
Interface to the @cfunc{open} C function.  @glibcref{Opening and Closing
Files, open}.  Open a file for reading, using open mode @code{O_RDONLY}.

@var{pathname} must reference a bytevector object holding the file
pathname.

If successful return a fixnum representing the file descriptor; if an
error occurs in @cfunc{open} return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_open_output_fd (ikptr @var{pathname}, ikptr @var{opts})
Interface to the @cfunc{open} C function.  @glibcref{Opening and Closing
Files, open}.  Open a file for writing with configurable mode based on
@code{O_WRONLY}; the access permissions when a new file is created are
@code{S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH}.

@var{pathname} must reference a bytevector object holding the file
pathname; @var{opts} must be a fixnum with the following encoding:

@table @code
@item 0
The open mode is @code{O_WRONLY | O_CREAT | O_EXCL}.

@item 1
The open mode is @code{O_WRONLY | O_TRUNC}.

@item 2
The open mode is @code{O_WRONLY | O_TRUNC | O_CREAT}.

@item 3
The open mode is @code{O_WRONLY | O_TRUNC}.

@item 4
The open mode is @code{O_WRONLY | O_CREAT | O_EXCL}.

@item 5
The open mode is @code{O_WRONLY | O_CREAT}.

@item 6
The open mode is @code{O_WRONLY | O_CREAT}.

@item 7
The open mode is @code{O_WRONLY}.
@end table

If successful return a fixnum representing the file descriptor; if an
error occurs in @cfunc{open} return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_open_input_output_fd (ikptr @var{pathname}, ikptr @var{opts})
Interface to the @cfunc{open} C function.  @glibcref{Opening and Closing
Files, open}.  Open a file for reading and writing with configurable
mode based on @code{O_RDWR}; the access permissions when a new file is
created are @code{S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH}.

@var{pathname} must reference a bytevector object holding the file
pathname; @var{opts} must be a fixnum representing the opening flags, it
has the same format of the @var{opts} argument to
@func{ikrt_open_output_fd}.

If successful return a fixnum representing the file descriptor; if an
error occurs in @cfunc{open} return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun

@c page
@node capi posix port seek
@subsubsection Handling file descriptor cursor


@deftypefun ikptr ikrt_set_position (ikptr @var{fd}, ikptr @var{pos})
Interface to the @cfunc{lseek} C function.  @glibcref{File Position
Primitive, lseek}.  Set the cursor position.

@var{fd} must be a fixnum representing a file descriptor; @var{pos} must
be an exact integer in the range of the @code{off_t} platform type.

If successful return @code{false_object}; if an error occurs in
@cfunc{lseek} return the return value of @cfunc{ik_errno_to_code}.
@end deftypefun

@c page
@node capi posix port rw
@subsubsection Reading and writing


@deftypefun ikptr ikrt_read_fd (ikptr @var{fd}, ikptr @var{buffer}, ikptr @var{buffer-start}, ikptr @var{size})
Interface to the @cfunc{read} C function.  @glibcref{Input and Output
Primitives, read}.  Read data from a file descriptor.

@var{fd} must be a fixnum representing a file descriptor; @var{buffer}
must reference a bytevector object in which the data will be stored;
@var{buffer-start} must be a fixnum representing the offset in the
buffer at which data will be written; @var{size} must be a fixnum
representing the number of bytes to read.

If successful return a fixnum representing the number of bytes actually
read and stored in the buffer; if an error occurs in @cfunc{read} return
the return value of @cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_write_fd (ikptr @var{fd}, ikptr @var{buffer}, ikptr @var{buffer-start}, ikptr @var{size})
Interface to the @cfunc{write} C function.  @glibcref{Input and Output
Primitives, write}.  Write data to a file descriptor.

@var{fd} must be a fixnum representing a file descriptor; @var{buffer}
must reference a bytevector object from which the data will be read;
@var{buffer-start} must be a fixnum representing the offset in the
buffer from which data will be read; @var{size} must be a fixnum
representing the number of bytes to write.

If successful return a fixnum representing the number of bytes actually
written; if an error occurs in @cfunc{write} return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun

@c page
@node capi posix port event
@subsubsection Handling file descriptor events


@deftypefun ikptr ikrt_select (ikptr @var{max-fd}, ikptr @var{rfds}, ikptr @var{wfds}, ikptr @var{xfds})
Interface to the @cfunc{select} C function.  @glibcref{Waiting for I/O,
select}.  Poll for events on sets of file descriptors, without timeout.

@var{max-fd} must be a fixnum representing the maximum file descriptor
for which to wait for events; @var{rfds}, @var{wfds} and @var{xfds} must
reference bytevectors holding @code{fd_set} data structures.

If successful return a fixnum representing the return value from
@cfunc{select}; if an error occurs in @cfunc{select} return the return
value of @cfunc{ik_errno_to_code}.  Notice that if the call is
interrupted by a signal, so it returns with @code{EINTR}, the function
returns with error without reattempting the call.
@end deftypefun


@deftypefun ikptr ikrt_make_fd_nonblocking (ikptr @var{fd})
Interface to the @cfunc{fcntl} C function.  @glibcref{Control
Operations, fcntl}.  Set non--blocking mode for a file descriptor.

@var{fd} must be a fixnum representing the file descriptor.

If successful return the raw C language @cnull{} pointer; if an error
occurs in @cfunc{fcntl} return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun

@c page
@node capi posix port net
@subsubsection Handling sockets


@deftypefun ikptr ikrt_tcp_connect (ikptr @var{host}, ikptr @var{srvc})
@deftypefunx ikptr ikrt_ucp_connect (ikptr @var{host}, ikptr @var{srvc})
Interface to the @cfunc{getaddrinfo}, @cfunc{socket} and @cfunc{connect}
C functions.  @glibcref{Sockets, Sockets}.  Establish a client
connection to a remote server using the @code{SOCK_STREAM} or
@code{SOCK_DGRAM} style.

@var{host} must reference a bytevector holding the remote server
hostname; @var{srvc} must reference a bytevector holding the service
specification.

If successful return a fixnum representing the socket; if an error
occurs resolving the host name and address, return @code{false_object};
if an error occurs in one of the C function calls, return the return
value of @cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_listen (ikptr @var{port-number})
Interface to the @cfunc{socket}, @cfunc{bind}, @cfunc{listen} and
@cfunc{setsockopt} C functions.  @glibcref{Sockets, Sockets}.  Create a
server socket bound to the given port number for the local host, using
the @code{AF_INET} namespace and the @code{SOCK_STREAM} style; the
option @code{SO_REUSEADDR} is set for the server socket; at most
@math{1024} concurrent connections to the socket will be enqueued.

@var{port-number} must be a fixnum representing the port number to use.

If successful return a fixnum representing the server socket; if an
error occurs in one of the C function calls, return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_accept (ikptr @var{sock}, ikptr @var{sockaddr})
Interface to the @cfunc{accept} C function.  @glibcref{Accepting
Connections, accept}.  Accept a connection to a server socket.

@var{sock} must be a fixnum representing the server socket;
@var{sockaddr} must reference a bytevector object which will hold the
@code{struct sockaddr} describing the client's address.

If successful return a fixnum representing the client socket and fill
@var{sockaddr} with the client address; if an error occurs in
@cfunc{accept}, return the return value of @cfunc{ik_errno_to_code}.
@end deftypefun


@deftypefun ikptr ikrt_shutdown (ikptr @var{sock})
Interface to the @cfunc{shutdown} C function.  @glibcref{Closing a
Socket, shutdown}.  Close a socket for both reading and writing.

@var{sock} must be a fixnum representing the socket.

If successful return the raw C language @cnull{} pointer; if an error
occurs in @cfunc{shutdown}, return the return value of
@cfunc{ik_errno_to_code}.
@end deftypefun

@c page
@node capi posix pid
@subsection Process identifier functions


@deftypefun ikptr ikrt_posix_getpid (void)
Return the process identifier as fixnum.  @glibcref{Process
Identification, getpid}.
@end deftypefun


@deftypefun ikptr ikrt_posix_getppid (void)
Return the parent process identifier as fixnum.  @glibcref{Process
Identification, getpid}.
@end deftypefun

@c page
@node capi posix process
@subsection Forking and executing processes


@deftypefun ikptr ikrt_posix_system (ikptr @var{command})
Interface to the C function @cfunc{system}, @glibcref{Running a Command,
system}.  Execute a command through the system shell; @var{command} must
reference a bytevector object holding the command to execute.  If
successful return the termination status of the executed process,
@ref{capi posix status} for details; if an error occurs: return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_fork (void)
Interface to the C function @cfunc{fork}, @glibcref{Creating a Process,
fork}.  Create a new process by forking the current; if successful
return a non--negative fixnum representing the the return value of
@cfunc{fork}; if an error occurs: return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_execv (ikptr @var{filename}, ikptr @var{argv})
Interface to the C function @cfunc{execv}, @glibcref{Executing a File,
execv}.  @var{filename} must be a bytevector representing the pathname
of an executable file; @var{argv} must be a list of bytevectors
representing command line arguments.  Execute the command; if the
function returns: an error has occurred, return an encoded @code{errno}
value.
@end deftypefun


@deftypefun ikptr ikrt_posix_execve (ikptr @var{filename}, ikptr @var{argv}, ikptr @var{env})
Interface to the C function @cfunc{execve}, @glibcref{Executing a File,
execve}.  @var{filename} must be a bytevector representing the pathname
of an executable file; @var{argv} must be a list of bytevectors
representing command line arguments; @var{env} must be a list of
bytevectors representing environment variables assignments.  Execute the
command; if the function returns: an error has occurred, return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_execvp (ikptr @var{filename}, ikptr @var{argv})
Interface to the C function @cfunc{execvp}, @glibcref{Executing a File,
execvp}.  @var{filename} must be a bytevector representing the file name
of an executable file reachable in the current @env{PATH}; @var{argv}
must be a list of bytevectors representing command line arguments.
Execute the command; if the function returns: an error has occurred,
return an encoded @code{errno} value.
@end deftypefun

@c page
@node capi posix status
@subsection Process termination status


The following functions accept as argument a fixnum representing the
process termination status, for example the return value of
@cfunc{system} or the status acquired by @cfunc{waitpid}.


@deftypefun ikptr ikrt_posix_waitpid (ikptr @var{pid}, ikptr @var{options})
Interface to the C function @cfunc{waitpid}, @glibcref{Process
Completion, waitpid}.  Request status informations on a process or group
of processes knowing the identifier.  If successful return a fixnum
representing the status; if an error occurs: return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_wait (void)
Interface to the C function @cfunc{wait}, @glibcref{Process Completion,
wait}.  Request status informations on any process or group of
processes.  If successful return a fixnum representing the status; if an
error occurs: return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_WIFEXITED (ikptr @var{status})
Interface to the C macro @cfunc{WIFEXITED}, @glibcref{Process Completion
Status, WIFEXITED}.  Return true if the process terminated normally with
@cfunc{exit}.
@end deftypefun


@deftypefun ikptr ikrt_posix_WEXITSTATUS (ikptr @var{status})
Interface to the C macro @cfunc{WEXITSTATUS}, @glibcref{Process
Completion Status, WEXITSTATUS}.  If @cfunc{WIFEXITED} applied to
@var{status} would return true: return the low--order @math{8} bits from
the exit status, which is the process exit status selected with
@cfunc{exit}.
@end deftypefun


@deftypefun ikptr ikrt_posix_WIFSIGNALED (ikptr @var{status})
Interface to the C macro @cfunc{WIFSIGNALED}, @glibcref{Process
Completion Status, WIFSIGNALED}.  Return true if the process terminated
because it received an interprocess signal which was not handled.
@end deftypefun


@deftypefun ikptr ikrt_posix_WTERMSIG (ikptr @var{status})
Interface to the C macro @cfunc{WTERMSIG}, @glibcref{Process Completion
Status, WTERMSIG}.  If @cfunc{WIFSIGNALED} applied to @var{status} would
return true: return the number of the interprocess signal that
terminated the process.
@end deftypefun


@deftypefun ikptr ikrt_posix_WCOREDUMP (ikptr @var{status})
Interface to the C macro @cfunc{WCOREDUMP}, @glibcref{Process Completion
Status, WCOREDUMP}.  Return true if the process terminated and produced
a core dump.
@end deftypefun


@deftypefun ikptr ikrt_posix_WIFSTOPPED (ikptr @var{status})
Interface to the C macro @cfunc{WIFSTOPPED}, @glibcref{Process
Completion Status, WIFSTOPPED}.  Return true if the process is stopped.
@end deftypefun


@deftypefun ikptr ikrt_posix_WSTOPSIG (ikptr @var{status})
Interface to the C macro @cfunc{WSTOPSIG}, @glibcref{Process Completion
Status, WSTOPSIG}.  If @cfunc{WIFSTOPPED} applied to @var{status} would
return true: return the number of the interprocess signal that caused
the process to stop.
@end deftypefun

@c page
@node capi posix signals
@subsection Delivering interprocess signals


@deftypefun ikptr ikrt_posix_raise (ikptr @var{signum})
Interface to the C function @cfunc{raise}, @glibcref{Signaling Yourself,
raise}.  Send the selected signal to the calling process.  If successful
return zero, else return an encoded @code{errno} code.
@end deftypefun


@deftypefun ikptr ikrt_posix_kill (ikptr @var{pid}, ikptr @var{signum})
Interface to the C function @cfunc{kill}, @glibcref{Signaling Another
Process, kill}.  Send the selected signal to selected process.  If
successful return zero, else return an encoded @code{errno} code.
@end deftypefun


@deftypefun ikptr ikrt_posix_pause (void)
Interface to the C function @cfunc{pause}, @glibcref{Using Pause,
pause}.  Suspend the process until a signal is received.  Return the
void object.
@end deftypefun

@c page
@node capi posix stat
@subsection File system inspection


@deftypefun ikptr ikrt_posix_stat (ikptr @var{pathname}, ikptr @var{stat}, ikpcb * @var{pcb})
@deftypefunx ikptr ikrt_posix_lstat (ikptr @var{pathname}, ikptr @var{stat}, ikpcb * @var{pcb})
Interfaces to the C functions @cfunc{stat} and @cfunc{lstat},
@glibcref{Reading Attributes, stat}.  Inspect the file system entry
selected by @var{pathname}, which must be a bytevector, and fill the
@code{struct-stat} instance referenced by @var{stat} with the results.
If successful return zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_fstat (ikptr @var{fd}, ikptr @var{stat}, ikpcb * @var{pcb})
Interface to the C function @cfunc{fstat}, @glibcref{Reading Attributes,
fstat}.  Inspect the file system entry associated to the file descriptor
@var{fd}, which must be a fixnum, and fill the @code{struct-stat}
instance referenced by @var{stat} with the results.  If successful
return zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_file_is_directory (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_char_device (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_block_device (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_regular_file (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_symbolic_link (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_socket (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_fifo (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_message_queue (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_semaphore (ikptr @var{pathname}, ikptr @var{follow})
@deftypefunx ikptr ikrt_posix_file_is_shared_memory (ikptr @var{pathname}, ikptr @var{follow})
Return @true{} or @false{} whether the file system entry selected by
@var{pathname}, which must be a bytevector, is of the specified type; if
an error occurs return an encoded @code{errno} value.  When @var{follow}
is true: @cfunc{stat} is used to inspect the entry, else @cfunc{lstat}
is used.
@end deftypefun


@deftypefun ikptr ikrt_posix_access (ikptr @var{pathname}, ikptr @var{how})
Interface to the C function @cfunc{access}, @glibcref{Testing File
Access, access}.  Test the access mode selected by @var{how}, which must
be a fixnum, for the file system entry selected by @var{pathname}, which
must be a bytevector.  Return @true{} or @false{} or an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_file_size (ikptr @var{filename}, ikpcb * @var{pcb})
Determine the size of the file selected by @var{filename}, which must be
a bytevector, relying on a call to @cfunc{stat}.  If successful: return
an exact integer representing the size, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_file_atime (ikptr @var{pathname}, ikptr @var{vector}, ikpcb * @var{pcb})
@deftypefunx ikptr ikrt_posix_file_mtime (ikptr @var{pathname}, ikptr @var{vector}, ikpcb * @var{pcb})
@deftypefunx ikptr ikrt_posix_file_ctime (ikptr @var{pathname}, ikptr @var{vector}, ikpcb * @var{pcb})
Compute an exact integer representing the access, modification and
creation times for @var{pathname}, which must be a bytevector.  If
successful return zero, else return an encoded @code{errno} value.

The @var{vector} argument must be a vector which is mutated as follows:
the first item holds an exact integer representing the number of
seconds, the second item holds an exact integer representing the number
of microseconds.
@end deftypefun

@c page
@node capi posix file
@subsection File system interface


@deftypefun ikptr ikrt_posix_chown (ikptr @var{pathname}, ikptr @var{owner}, ikptr @var{group})
Interface to the C function @cfunc{chown}, @glibcref{File Owner, chown}.
Changes the owner and group of the file system entry selected by
@var{pathname}, which must be a bytevector.  @var{owner} and @var{group}
must be fixnums.  If successful return zero, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_fchown (ikptr @var{fd}, ikptr @var{owner}, ikptr @var{group})
Interface to the C function @cfunc{fchown}, @glibcref{File Owner,
fchown}.  Changes the owner and group of the file system entry selected
by @var{fd}, which must be a fixnum representing a platform file
descriptor.  @var{owner} and @var{group} must be fixnums.  If successful
return zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_chmod (ikptr @var{pathname}, ikptr @var{mode})
Interface to the C function @cfunc{chmod}, @glibcref{Setting
Permissions, chmod}.  Change to @var{mode}, which must be a fixnum, the
access permissions for the file system entry selected by @var{pathname},
which must be a bytevector.  If successful return zero, else return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_fchmod (ikptr @var{fd}, ikptr @var{mode})
Interface to the C function @cfunc{fchmod}, @glibcref{Setting
Permissions, fchmod}.  Change to @var{mode}, which must be a fixnum, the
access permissions for the file system entry associated to @var{fd},
which must be a fixnum representing a platform file descriptor.  If
successful return zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_umask (ikptr @var{mask})
Interface to the C function @cfunc{umask}, @glibcref{Setting
Permissions, umask}.  Set the current file creation mask to @var{mask}
which must be a fixnum and return the previous mask as a fixnum.
@end deftypefun


@deftypefun ikptr ikrt_posix_getumask (void)
Interface to the C function @cfunc{getumask}, @glibcref{Setting
Permissions, getumask}.  Return the current file creation mask as a
fixnum.
@end deftypefun


@deftypefun ikptr ikrt_posix_utime (ikptr @var{pathname}, ikptr @var{atime_sec}, ikptr @var{mtime_sec})
Interface to the C function @cfunc{utime}, @glibcref{File Times, utime}.
Set the access and modification times of the file system entry selected
by @var{pathname}, which must be a bytevector, to the specified counts
of seconds; both @var{atime_sec} and @var{mtime_sec} must be fixnums.
If successful return zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_utimes (ikptr @var{pathname}, ikptr @var{atime_sec}, ikptr @var{atime_usec}, ikptr @var{mtime_sec}, ikptr @var{mtime_usec})
@deftypefunx ikptr ikrt_posix_lutimes (ikptr @var{pathname}, ikptr @var{atime_sec}, ikptr @var{atime_usec}, ikptr @var{mtime_sec}, ikptr @var{mtime_usec})
Interface to the C functions @cfunc{utimes} and @cfunc{lutimes},
@glibcref{File Times, utimes}.  Set the access and modification times of
the file system entry selected by @var{pathname}, which must be a
bytevector, to the specified counts of seconds and microseconds; all the
numeric arguments must be fixnums.  If successful return zero, else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_futimes (ikptr @var{fd}, ikptr @var{atime_sec}, ikptr @var{atime_usec}, ikptr @var{mtime_sec}, ikptr @var{mtime_usec})
Interface to the C function @cfunc{futimes}, @glibcref{File Times,
futimes}.  Set the access and modification times of the file system
entry associated to @var{fd}, which must be a fixnum representing a file
descriptor, to the specified counts of seconds and microseconds; all the
numeric arguments must be fixnums.  If successful return zero, else
return an encoded @code{errno} value.
@end deftypefun

@c page
@node capi posix link
@subsection Hard and symbolic links


@deftypefun ikptr ikrt_posix_link (ikptr @var{old_pathname}, ikptr @var{new_pathname})
Interface to the C function @cfunc{link}, @glibcref{Hard Links, link}.
Create a hard link @var{new_pathname} to the source file system entry
@var{old_pathname}.  If successful return zero, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_symlink (ikptr @var{file_pathname}, ikptr @var{link_pathname})
Interface to the C function @cfunc{symlink}, @glibcref{Symbolic Links,
symlink}.  Create a symbolic link @var{link_pathname} to the source file
system entry @var{file_pathname}.  If successful return zero, else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_readlink (ikptr @var{link_pathname}, ikpcb * @var{pcb})
Interface to the C function @cfunc{readlink}, @glibcref{Symbolic Links,
readlink}.  If @var{pathname} references a symbolic link: follow it once
and return the referenced pathname as bytevector; if an error occurs:
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_realpath (ikptr @var{pathname})
Interface to the C function @cfunc{realpath}, @glibcref{Symbolic Links,
realpath}.  If @var{pathname} references a symbolic link: follow it and
return the real pathname as bytevector; if an error occurs: return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_unlink (ikptr @var{pathname})
Interface to the C function @cfunc{unlink}, @glibcref{Deleting Files,
unlink}.  Delete the file system entry referenced by @var{pathname},
which must be a bytevector and referencing a file.  If successful return
zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_remove (ikptr @var{pathname})
Interface to the C function @cfunc{remove}, @glibcref{Deleting Files,
remove}.  Delete the file system entry referenced by @var{pathname},
which must be a bytevector and referencing a file or directory.  If
successful return zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_rename (ikptr @var{old_pathname}, ikptr @var{new_pathname})
Interface to the C function @cfunc{rename}, @glibcref{Renaming Files,
rename}.  Rename the file system entry @var{old_pathname} to
@var{new_pathname}, both of which must be bytevectors.  If successful
return zero, else return an encoded @code{errno} value.
@end deftypefun

@c page
@node capi posix dir
@subsection File system directories


@deftypefun ikptr ikrt_posix_mkdir (ikptr @var{pathname}, ikptr @var{mode})
Interface to the C function @cfunc{mkdir}, @glibcref{Creating
Directories, mkdir}.  Create a new directory file system entry with name
@var{pathname}, which must be a bytevector; @var{mode} must be a fixnum
specifying access permissions.  If successful return the fixnum zero,
else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_rmdir (ikptr @var{pathname})
Interface to the C function @cfunc{rmdir}, @glibcref{Creating
Directories, rmdir}.  Remove the directory file system entry selected by
@var{pathname}, which must be a bytevector.  If successful return the
fixnum zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_getcwd (ikpcb * @var{pcb})
Interface to the C function @cfunc{getcwd}, @glibcref{Working Directory,
getcwd}.  Acquire the pathname of the current working directory.  If
successful return a bytevector holding the pathname, else return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_chdir (ikptr @var{pathname})
Interface to the C function @cfunc{chdir}, @glibcref{Working Directory,
chdir}.  Change the current working directory to the file system entry
selected by @var{pathname}, which must be a bytevector.  If successful
return the fixnum zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_fchdir (ikptr @var{fd})
Interface to the C function @cfunc{fchdir}, @glibcref{Working Directory,
fchdir}.  Change the current working directory to the file system entry
associated to @var{fd}, which must be a fixnum representing a file
descriptor.  If successful return the fixnum zero, else return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_opendir (ikptr @var{pathname}, ikpcb * @var{pcb})
Interface to the C function @cfunc{opendir}, @glibcref{Opening a
Directory, opendir}.  Open a directory stream for the inspection of the
file system entry @var{pathname}, which must be a bytevector.  If
successful return a pointer object, else return an encoded @code{errno}
value.
@end deftypefun


@deftypefun ikptr ikrt_posix_fdopendir (ikptr @var{fd}, ikpcb * @var{pcb})
Interface to the C function @cfunc{fdopendir}, @glibcref{Opening a
Directory, fdopendir}.  Open a directory stream for the inspection of
the file system entry associated to @var{fd}, which must be a fixnum
representing a file descriptor.  If successful return a pointer object,
else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_readdir (ikptr @var{pointer}, ikpcb * @var{pcb})
Interface to the C function @cfunc{readdir}, @glibcref{Reading/Closing
Directory, readdir}.  Acquire the next entry from a directory stream
referenced by @var{pointer}, which must be a pointer object.  If
successful and an entry is available: return a pointer object; if
successful and no more entries are available: return the false object;
else return an encoded @code{errno} value.

When no more entries are available or an error occurs: the directory
stream is closed.
@end deftypefun


@deftypefun ikptr ikrt_posix_closedir (ikptr @var{pointer}, ikpcb * @var{pcb})
Interface to the C function @cfunc{closedir}, @glibcref{Reading/Closing
Directory, closedir}.  Close the directory stream referenced by
@var{pointer}, which must be a pointer object.  If successful return the
fixnum zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_rewinddir (ikptr @var{pointer})
Interface to the C function @cfunc{rewinddir}, @glibcref{Random Access
Directory, rewinddir}.  Rewind to the beginning the directory stream
referenced by @var{pointer}, which must be a pointer object.  Return the
void object.
@end deftypefun


@deftypefun ikptr ikrt_posix_telldir (ikptr @var{pointer})
Interface to the C function @cfunc{telldir}, @glibcref{Random Access
Directory, telldir}.  Return an exact integer representing the current
position in the directory stream referenced by @var{pointer}, which must
be a pointer object.
@end deftypefun


@deftypefun ikptr ikrt_posix_seekdir (ikptr @var{pointer}, ikptr @var{pos})
Interface to the C function @cfunc{seekdir}, @glibcref{Random Access
Directory, seekdir}.  Set to @var{pos} the position of the directory
stream referenced by @var{pointer}, which must be a pointer object;
@var{pos} must be the return value of a previous call to
@cfunc{telldir}.  Return the void object.
@end deftypefun

@c page
@node capi posix fd
@subsection File descriptors at low level


@deftypefun ikptr ikrt_posix_open (ikptr @var{pathname}, ikptr @var{flags}, ikptr @var{mode})
Interface to the C function @cfunc{open}, @glibcref{Opening and Closing
Files, open}.  Open a file descriptor for the file system entry
@var{pathname}, which must be a bytevector; @var{flags} and @var{mode}
must be fixnums.  If successful return a fixnum representing the file
descriptor, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_close (ikptr @var{fd})
Interface to the C function @cfunc{close}, @glibcref{Opening and Closing
Files, close}.  Close a file descriptor represented by @var{fd}, which
must be a fixnum.  If successful return the fixnum zero, else return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_read (ikptr @var{fd}, ikptr @var{buffer}, ikptr @var{size})
Interface to the C function @cfunc{read}, @glibcref{I/O Primitives,
read}.  Read bytes from the file descriptor @var{fd} and store them in
the bytevector @var{buffer}; if @var{size} is a fixnum, read @var{size}
bytes; if @var{size} is false, read a number of bytes equal to the
length of @var{buffer}.  If successful return a non--negative fixnum
representing the number of bytes read, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_pread (ikptr @var{fd}, ikptr @var{buffer}, ikptr @var{size}, ikptr @var{off})
Interface to the C function @cfunc{pread}, @glibcref{I/O Primitives,
pread}.  Like @cfunc{ikrt_posix_read}, but start reading at offset
@var{off} from the start of the file; @var{off} must be a non--negative
exact integer.
@end deftypefun


@deftypefun ikptr ikrt_posix_write (ikptr @var{fd}, ikptr @var{buffer}, ikptr @var{size})
Interface to the C function @cfunc{write}, @glibcref{I/O Primitives,
write}.  Write bytes to the file descriptor @var{fd} from the bytevector
@var{buffer}; if @var{size} is a fixnum, write @var{size} bytes; if
@var{size} is false, write a number of bytes equal to the length of
@var{buffer}.  If successful return a non--negative fixnum representing
the number of written bytes, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_pwrite (ikptr @var{fd}, ikptr @var{buffer}, ikptr @var{size}, ikptr @var{off})
Interface to the C function @cfunc{pwrite}, @glibcref{I/O Primitives,
pwrite}.  Like @cfunc{ikrt_posix_write}, but start writing at offset
@var{off} from the start of the file; @var{off} must be a non--negative
exact integer.
@end deftypefun


@deftypefun ikptr ikrt_posix_lseek (ikptr @var{fd}, ikptr @var{off}, ikptr @var{whence}, ikpcb * @var{pcb})
Interface to the C function @cfunc{lseek}, @glibcref{File Position
Primitive, lseek}.  Change the file position of the file descriptor
@var{fd} to @var{off} from @var{whence}; @var{fd} and @var{whence} must
be fixnums, @var{off} must be an exact integer.  If successful return a
non--negative exact integer representing the number of bytes from the
beginning of the file, else return an encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_readv (ikptr @var{fd}, ikptr @var{buffers}, ikpcb * @var{pcb})
Interface to the C function @cfunc{readv}, @glibcref{Scatter-Gather,
readv}.  Read bytes from the file descriptor @var{fd} and store them
into the list of bytevectors referenced by @var{buffers}.  If successful
return a non--negative exact integer representing the number of bytes
actually read, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_writev (ikptr @var{fd}, ikptr @var{buffers}, ikpcb * @var{pcb})
Interface to the C function @cfunc{writev}, @glibcref{Scatter-Gather,
writev}.  Write bytes to the file descriptor @var{fd} from the list of
bytevectors referenced by @var{buffers}.  If successful return a
non--negative exact integer representing the number of bytes actually
written, else return an encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_select (ikptr @var{nfds}, ikptr @var{read_fds}, ikptr @var{write_fds}, ikptr @var{except_fds}, ikptr @var{sec}, ikptr @var{usec}, ikpcb * @var{pcb})
Interface to the C function @cfunc{select}, @glibcref{Waiting for I/O,
select}.  Wait for read, write or exceptional events on selected lists
of file descriptors.

@var{nfds} must be false or a non--negative fixnum, when false it
defaults to the maximum file descriptor value in the given lists; it is
the maximum file descriptor number in the sets to be checked for events,
plus one.  @var{read_fds}, @var{write_fds} and @var{except_fds} must be
nil or lists of file descriptors to be checked for events.  @var{sec}
and @var{usec} must be fixnums representing timeout seconds and
microseconds.

Return the fixnum zero if the timeout expired before any event arrived;
else return a vector of 3 elements being lists of file descriptors,
respectively, ready for reading, writing or an exceptional condition.
If an error occurs: return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_select_fd (ikptr @var{fd}, ikptr @var{sec}, ikptr @var{usec}, ikpcb * @var{pcb})
Interface to the C function @cfunc{select}, @glibcref{Waiting for I/O,
select}.  Wait for read, write or exceptional events on the single file
descriptor @var{fd}.  @var{sec} and @var{usec} must be fixnums
representing timeout seconds and microseconds.

Return the fixnum zero if the timeout expired before any event arrived;
else return a vector of 3 elements being false or @var{fd},
respectively, if @var{fd} is ready for reading, writing or an
exceptional condition.  If an error occurs: return an encoded
@code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_fcntl (ikptr @var{fd}, ikptr @var{command}, ikptr @var{arg})
Interface to the C function @cfunc{fcntl}, @glibcref{Control Operations,
fcntl}.  Perform the operation specified by @var{command} on the file
descriptor @var{fd} using @var{arg}; @var{fd} and @var{command} must be
fixnums; @var{arg} must be the false object, a fixnum, a bytevector or a
pointer, if it is @false{} no argument is handed to @cfunc{fcntl}.  If
successful return a fixnum representing the return value of
@cfunc{fcntl}, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_ioctl (ikptr @var{fd}, ikptr @var{command}, ikptr @var{arg})
Interface to the C function @cfunc{ioctl}, @glibcref{IOCTLs, ioctl}.
Perform the operation specified by @var{command} on the file descriptor
@var{fd} using @var{arg}; @var{fd} and @var{command} must be fixnums;
@var{arg} must be the false object, a fixnum, a bytevector or a pointer,
if it is @false{} no argument is handed to @cfunc{ioctl}.  If successful
return a fixnum representing the return value of @cfunc{ioctl}, else
return an encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_dup (ikptr @var{fd})
Interface to the C function @cfunc{dup}, @glibcref{Duplicating
Descriptors, dup}.  Duplicate the file descriptor @var{fd}.  If
successful return a non--negative fixnum representing the new
descriptor, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_dup2 (ikptr @var{old}, ikptr @var{new})
Interface to the C function @cfunc{dup2}, @glibcref{Duplicating
Descriptors, dup}.  Duplicate the file descriptor @var{old} to
@var{new}.  If successful return the fixnum zero, else return an encoded
@code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_pipe (ikpcb * @var{pcb})
Interface to the C function @cfunc{pipe}, @glibcref{Creating a Pipe,
pipe}.  Create a pair of file descriptors connected through a pipe.  If
successful return a pair whose car and cdr are fixnums representing the
file descriptors, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_mkfifo (ikptr @var{pathname}, ikptr @var{mode})
Interface to the C function @cfunc{mkfifo}, @glibcref{FIFO Special
Files, mkfifo}.  Create a FIFO special file with name @var{pathname},
which must be a bytevector, and mode @var{mode}, which must be a fixnum.
If successful return the fixnum zero, else return an encoded
@code{errno} value.
@end deftypefun

@c page
@node capi posix socket
@subsection Network sockets


@subsubheading Address structures

@deftypefun ikptr ikrt_posix_make_sockaddr_un (ikptr @var{pathname}, ikpcb * @var{pcb})
Given a bytevector @var{pathname} representing the pathname of a local
socket, build and return a bytevector holding the @code{struct
sockaddr_un} representing it.
@end deftypefun


@deftypefun ikptr ikrt_posix_sockaddr_un_pathname (ikptr @var{socket_address}, ikpcb * @var{pcb})
Given a bytevector @var{socket_address}, which must be the return value
of a previous call to @cfunc{ikrt_posix_make_sockaddr_un}, holding a
@code{struct sockaddr_un} build and return a bytevector holding the
corresponding socket pathname.  If the data in @var{socket_address} is
invalid: return false.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_make_sockaddr_in (ikptr @var{host_address}, ikptr @var{port}, ikpcb * @var{pcb})
Given a bytevector @var{host_address} holding a @code{struct in_addr}
and a fixnum @var{port} representing a network port number, build and
return a bytevector holding a @code{struct sockaddr_in} initialised with
this data.
@end deftypefun


@deftypefun ikptr ikrt_posix_sockaddr_in_in_addr (ikptr @var{socket_address}, ikpcb * @var{pcb})
@deftypefunx ikptr ikrt_posix_sockaddr_in_in_port (ikptr @var{socket_address})
Given a bytevector @var{socket_address} holding a @code{struct
sockaddr_in}, extract the @code{in_addr} and @code{in_port} fields and
return them as bytevector holding the corresponding @code{struct
in_addr} and as fixnum.  If the data in @var{socket_address} is invalid:
return false.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_make_sockaddr_in6 (ikptr @var{host_address}, ikptr @var{port}, ikpcb * @var{pcb})
Given a bytevector @var{host_address} holding a @code{struct in6_addr}
and a fixnum @var{port} representing a network port number, build and
return a bytevector holding a @code{struct sockaddr_in6} initialised
with this data.
@end deftypefun


@deftypefun ikptr ikrt_posix_sockaddr_in6_in6_addr (ikptr @var{socket_address}, ikpcb * @var{pcb})
@deftypefunx ikptr ikrt_posix_sockaddr_in6_in6_port (ikptr @var{socket_address})
Given a bytevector @var{socket_address} holding a @code{struct
sockaddr_in6}, extract the @code{in6_addr} and @code{in6_port} fields
and return them as bytevector holding the corresponding @code{struct
in6_addr} and as fixnum.  If the data in @var{socket_address} is
invalid: return false.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_in6addr_loopback (ikpcb * @var{pcb})
@deftypefunx ikptr ikrt_posix_in6addr_any (ikpcb * @var{pcb})
Build and return a bytevector holding the constant structures of type
@code{struct in6_addr} defined by @code{in6addr_loopback} and
@code{in6addr_any}.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_inet_aton (ikptr @var{dotted_quad}, ikpcb * @var{pcb})
Given the bytevector @var{dotted_quad} holding the @ascii{} dotted quad
representation of a host address, build and return a bytevector holding
the corresponding @code{struct in_addr}.  If @var{dotted_quad} is
invalid: return false.
@end deftypefun


@deftypefun ikptr ikrt_inet_ntoa (ikptr @var{host_address}, ikpcb * @var{pcb})
Given the bytevector @var{host_address} holding a @code{struct in_addr},
build and return a bytevector holding the corresponding @ascii{} dotted
quad representation.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_inet_pton (ikptr @var{af}, ikptr @var{presentation}, ikpcb * @var{pcb})
Given the fixnum @var{af}, being @code{AF_INET} or @code{AF_INET6}, and
the bytevector @var{presentation} holding the @ascii{} presentation of
an Internet address, build and return a bytevector holding the
corresponding @code{struct in_addr} or @code{struct in6_addr}.  If
either @var{af} or @var{presentation} is invalid: return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_inet_ntop (ikptr @var{af}, ikptr @var{host_address}, ikpcb * @var{pcb})
Given the fixnum @var{af}, being @code{AF_INET} or @code{AF_INET6}, and
the bytevector @var{host_address} holding a @code{struct in_addr} or
@code{struct in6_addr}, build and return a bytevector holding the
corresponding @ascii{} presentation of the Internet address .  If the
arguments are invalid: return false.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Host address resolution


@deftypefun ikptr ikrt_posix_gethostbyname (ikptr @var{rtd}, ikptr @var{hostname}, ikpcb * @var{pcb})
Interface to the C function @cfunc{gethostbyname}, @glibcref{Host Names,
gethostbyname}.  Given the bytevector @var{hostname} holding the
@ascii{} representation of a host name, build and return an instance of
@code{struct-hostent} using @var{rtd} as its type descriptor.  If an
error occurs, return an encoded @code{h_errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_gethostbyaddr (ikptr @var{rtd}, ikptr @var{addr}, ikpcb * @var{pcb})
Interface to the C function @cfunc{gethostbyaddr}, @glibcref{Host Names,
gethostbyaddr}.  Given the bytevector @var{addr} holding a @code{struct
in_addr} or a @code{struct in6_addr}, build and return an instance of
@code{struct-hostent} using @var{rtd} as its type descriptor; the type
of address is automatically inferred from the length of the bytevector.
If an error occurs, return an encoded @code{h_errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_host_entries (ikptr @var{rtd}, ikpcb * pcb)
Interface to the C functions @cfunc{sethostent}, @cfunc{gethostent} and
@cfunc{endhostent}, @glibcref{Host Names, gethostbyaddr}.  Build and
return a list of @code{struct-hostent} representing the entries in the
hosts database, using @var{rtd} as type descriptor.
@end deftypefun


@deftypefun ikptr ikrt_posix_getaddrinfo (ikptr @var{rtd}, ikptr @var{node}, ikptr @var{service}, ikptr @var{hints}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getaddrinfo}, see the manual page
@code{getaddrinfo(3)}.  Given the bytevectors @var{node} and
@var{service} identifying an Internet host and a service, build a list
of @code{struct-addrinfo} instances representing addresses to which
sockets can be bound or connected.

Both @var{node} and @var{service} can be false, in which case the
corresponding arguments handed to the C function are @code{NULL}.

@var{hints} must be an instance of @code{struct-addrinfo} used to select
matching hosts.  @var{rtd} must be the type descriptor of
@code{struct-addrinfo}.

If successful: return the list of data structures, else return a fixnum
representing an @code{EAI_} error code.
@end deftypefun


@deftypefun ikptr ikrt_posix_gai_strerror (ikptr @var{error_code}, ikpcb * @var{pcb})
Interface to the C function @cfunc{gai_strerror}, see the manual page
@code{gai_strerror(3)}.  Convert a @code{EAI_} error code into the
corresponding error message, return a bytevector holding such message in
@ascii{} coding.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Network protocols


@deftypefun ikptr ikrt_posix_getprotobyname (ikptr @var{rtd}, ikptr @var{name}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getprotobyname}, @glibcref{Protocols
Database, getprotobyname}.  Given a bytevector @var{name} holding the
@ascii{} coding of a network protocol name, query the network protocols
database and build an instance of @code{struct-protoent} mirroring the
resulting @code{struct protoent} entry; @var{rtd} must be the type
descriptor of @code{struct-protoent}.  If successful return the data
structure, else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_getprotobynumber (ikptr @var{rtd}, ikptr @var{proto_num}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getprotobynumber},
@glibcref{Protocols Database, getprotobynumber}.  Given a fixnum
@var{proto_num} being the number of a network protocol, query the
network protocols database and build an instance of
@code{struct-protoent} mirroring the resulting @code{struct protoent}
entry; @var{rtd} must be the type descriptor of @code{struct-protoent}.
If successful return the data structure, else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_protocol_entries (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C functions @cfunc{setprotoent}, @cfunc{getprotoent}
and @cfunc{endprotoent}, @glibcref{Protocols Database, setprotoent}.
Scan the network protocol database and build a list of
@code{struct-protoent} mirroring the resulting @code{struct protoent}
entries; @var{rtd} must be the type descriptor of
@code{struct-protoent}.  Return the list of structures.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Network services


@deftypefun ikptr ikrt_posix_getservbyname (ikptr @var{rtd}, ikptr @var{name}, ikptr @var{protocol}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getservbyname}, @glibcref{Services
Database, getservbyname}.  Given the bytevectors @var{name} and
@var{protocol} holding the @ascii{} coding of a network service name and
protocol, query the network services database and build an instance of
@code{struct-servent} mirroring the resulting @code{struct servent}
entry.  @var{rtd} must be the type descriptor of @code{struct-servent}.
If successful return the data structure, else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_getservbynumber (ikptr @var{rtd}, ikptr @var{port}, ikptr @var{protocol}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getservbynumber}, @glibcref{Services
Database, getservbynumber}.  Given a fixnum @var{port} and a string or
bytevector @var{protocol} being the port number and protocol name of a
network service, query the network services database and build an
instance of @code{struct-servent} mirroring the resulting @code{struct
servent} entry.  @var{rtd} must be the type descriptor of
@code{struct-servent}.  If successful return the data structure, else
return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_service_entries (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C functions @cfunc{setservent}, @cfunc{getservent} and
@cfunc{endservent}, @glibcref{Services Database, setservent}.  Scan the
network service database and build a list of @code{struct-servent}
mirroring the resulting @code{struct servent} entries.  @var{rtd} must
be the type descriptor of @code{struct-servent}.  Return the list of
structures.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Networks database


@deftypefun ikptr ikrt_posix_getnetbyname (ikptr @var{rtd}, ikptr @var{name}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getnetbyname}, @glibcref{Networks
Database, getnetbyname}.  Given the bytevector @var{name} holding the
@ascii{} coding of a network name, query the networks database and build
an instance of @code{struct-netent} mirroring the resulting @code{struct
netent} entry.  @var{rtd} must be the type descriptor of
@code{struct-netent}.  If successful return the data structure, else
return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_getnetbyaddr (ikptr @var{rtd}, ikptr @var{net}, ikptr @var{type}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getnetbyaddr}, @glibcref{Networks
Database, getnetbyaddr}.  Given an exact integer @var{net} representing
a network number and the fixnum @var{type} representing a network type,
query the networks database and build an instance of
@code{struct-netent} mirroring the resulting @code{struct netent} entry.
@var{rtd} must be the type descriptor of @code{struct-netent}.  If
successful return the data structure, else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_network_entries (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C functions @cfunc{setnetent}, @cfunc{getnetent} and
@cfunc{endnetent}, @glibcref{Networks Database, setnetent}.  Scan the
networks database and build a list of @code{struct-netent} mirroring the
resulting @code{struct netent} entries.  @var{rtd} must be the type
descriptor of @code{struct-netent}.  Return the list of structures.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Sockets creation and shutdown


@deftypefun ikptr ikrt_posix_socket (ikptr @var{namespace}, ikptr @var{style}, ikptr @var{protocol})
Interface to the C function @cfunc{socket}, @glibcref{Creating a Socket,
socket}.  Create a new socket descriptor and return it as non--negative
fixnum; if an error occurs return an encoded @code{errno} value.  All
the arguments must be fixnums.
@end deftypefun


@deftypefun ikptr ikrt_posix_shutdown (ikptr @var{sock}, ikptr @var{how})
Interface to the C function @cfunc{shutdown}, @glibcref{Closing a
Socket, shutdown}.  Close the socket @var{sock} according to @var{how}.
If successful return the fixnum zero, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_socketpair (ikptr @var{namespace}, ikptr @var{style}, ikptr @var{protocol}, ikpcb * @var{pcb})
Interface to the C function @cfunc{socketpair}, @glibcref{Socket Pairs,
socketpair}.  Create a pairs of connected sockets and return a pair
holding the descriptors as non--negative fixnums; if an error occurs
return an encoded @code{errno} value.  All the arguments must be
fixnums, but @var{pcb}.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Socket operations


@deftypefun ikptr ikrt_posix_connect (ikptr @var{sock}, ikptr @var{addr})
Interface to the C function @cfunc{connect}, @glibcref{Connecting,
connect}.  Connect the socket @var{sock} to the address specified by the
bytevector @var{addr} which must hold a concrete instance of
@code{struct sockaddr}.  If successful return the fixnum zero, else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_listen (ikptr @var{sock}, ikptr @var{pending_conns})
Interface to the C function @cfunc{listen}, @glibcref{Listening,
listen}.  Enable the socket @var{sock} to accept connections; the fixnum
@var{pending_conns} specifies the maximum length of the pending
connection requests queue.  If successful return the fixnum zero, else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_accept (ikptr @var{sock}, ikpcb * @var{pcb})
Interface to the C function @cfunc{accept}, @glibcref{Accepting
Connections, accept}.  Accept an incoming connection to the server
socket @var{sock}.  If successful return a pair whose car is a
non--negative fixnum representing the socket and whose cdr is a
bytevector representing the client address as @code{struct sockaddr};
else return an encoded @code{errno} value, including @code{EWOULDBLOCK}
which means that @var{sock} is in non--blocking mode and no pending
connections exist.
@end deftypefun


@deftypefun ikptr ikrt_posix_bind (ikptr @var{sock}, ikptr @var{sockaddr})
Interface to the C function @cfunc{bind}, @glibcref{Setting Address,
bind}.  Bind the socket descriptor @var{sock} to the address specified
by the @code{struct sockaddr} in the bytevector @var{sockaddr}.  If
successful return the fixnum zero, else return an encoded @code{errno}
value.
@end deftypefun


@deftypefun ikptr ikrt_posix_getpeername (ikptr @var{sock}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getpeername}, @glibcref{Who is
Connected, getpeername}.  Retrieve informations about the address of the
socket to which the @var{sock} socket is connected to.  If successful
return a bytevector holding a @code{struct sockaddr}, else return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_getsockname (ikptr @var{sock}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getsockanme}, @glibcref{Setting
Address, getsockname}.  Retrieve informations about the address bound to
the socket descriptor @var{sock}.  If successful return a bytevector
holding the @code{struct sockaddr}, else return an encoded @code{errno}
value.
@end deftypefun


@deftypefun ikptr ikrt_posix_send (ikptr @var{sock}, ikptr @var{buffer}, ikptr @var{size}, ikptr @var{flags})
Interface to the C function @cfunc{send}, @glibcref{Sending Data, send}.
Like @cfunc{write} but with the additional argument @var{flags} which
must be a fixnum: write data from the bytevector @var{buffer} to the
socket @var{sock}; if @var{size} is a fixnum, write @var{size} bytes; if
@var{size} is false, write a number of bytes equal to the length of
@var{buffer}.  If successful return a non--negative fixnum representing
the number of bytes actually sent, else return an encoded @code{errno}
value.
@end deftypefun


@deftypefun ikptr ikrt_posix_recv (ikptr @var{sock}, ikptr @var{buffer}, ikptr @var{size}, ikptr @var{flags})
Interface to the C function @cfunc{recv}, @glibcref{Receiving Data,
recv}.  Like @cfunc{read} but with the additional argument @var{flags}
which must be a fixnum: read data from @var{sock} and store it in the
bytevector @var{buffer}; if @var{size} is a fixnum, read @var{size}
bytes; if @var{size} is false, read a number of bytes equal to the
length of @var{buffer}.  If successful return a non--negative fixnum
representing the number of bytes actually received, else return an
encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_sendto (ikptr @var{sock}, ikptr @var{buffer}, ikptr @var{size}, ikptr @var{flags}, ikptr @var{addr})
Interface to the C function @cfunc{sendto}, @glibcref{Sending Datagrams,
sendto}.  Like @cfunc{send} but with the additional argument @var{addr}
which must be a bytevector holding a @code{struct sockaddr}: write data
from the bytevector @var{buffer} to the socket @var{sock} to the
destination specified by @var{addr}.

If @var{size} is a fixnum, write @var{size} bytes; if @var{size} is
false, write a number of bytes equal to the length of @var{buffer}.

If successful return a non--negative fixnum representing the number of
bytes actually sent, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_recvfrom (ikptr @var{sock}, ikptr @var{buffer}, ikptr @var{size}, ikptr @var{flags}, ikpcb * @var{pcb})
Interface to the C function @cfunc{recvfrom}, @glibcref{Receiving
Datagrams, recvfrom}.  Like @cfunc{recv} but additionally retrieve
informations about the address of the sender: read data from @var{sock}
and store it in the bytevector @var{buffer}.

If @var{size} is a fixnum, read @var{size} bytes; if @var{size} is
false, read a number of bytes equal to the length of @var{buffer}.

If successful return a pair whose car is a non--negative fixnum
representing the number of bytes actually received and whose cdr is a
bytevector holding a @code{struct sockaddr} representing the address of
the sender; else return an encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_getsockopt (ikptr @var{sock}, ikptr @var{level}, ikptr @var{option}, ikptr @var{optval}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getsockopt}, @glibcref{Socket Option
Function, getsockopt}.  Retrieve the value of @var{option} of socket
@var{sock} at @var{level} and store it in the bytevector @var{optval}.
@var{option} and @var{level} must be fixnums.  If successful return the
fixnum zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_setsockopt (ikptr @var{sock}, ikptr @var{level}, ikptr @var{option}, ikptr @var{optval}, ikpcb * @var{pcb})
Interface to the C function @cfunc{setsockopt}, @glibcref{Socket Option
Function, setsockopt}.  Set a new value for @var{option} of socket
@var{sock} at @var{level} reading it from the bytevector @var{optval}.
@var{option} and @var{level} must be fixnums.  If successful return the
fixnum zero, else return an encoded @code{errno} value.
@end deftypefun

@c page
@node capi posix users
@subsection Users and groups


@deftypefun ikptr ikrt_posix_getuid (void)
Interface to the C function @cfunc{getuid}, @glibcref{Reading Persona,
getuid}.  Return a fixnum representing the real user ID of the process.
@end deftypefun


@deftypefun ikptr ikrt_posix_getgid (void)
Interface to the C function @cfunc{getgid}, @glibcref{Reading Persona,
getgid}.  Return a fixnum representing the real group ID of the process.
@end deftypefun


@deftypefun ikptr ikrt_posix_geteuid (void)
Interface to the C function @cfunc{geteuid}, @glibcref{Reading Persona,
geteuid}.  Return a fixnum representing the effective user ID of the
process.
@end deftypefun


@deftypefun ikptr ikrt_posix_getegid (void)
Interface to the C function @cfunc{getegid}, @glibcref{Reading Persona,
getegid}.  Return a fixnum representing the effective group ID of the
process.
@end deftypefun


@deftypefun ikptr ikrt_posix_getgroups (ikpcb * @var{pcb})
Interface to the C function @cfunc{getgroups}, @glibcref{Reading
Persona, getgroups}.  Return a list of fixnums representing the
supplementary group IDs of the process; if an error occurs return an
encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_seteuid (ikptr @var{new_uid})
Interface to the C function @cfunc{seteuid}, @glibcref{Setting User ID,
seteuid}.  Set the effective user ID to @var{new_uid}, which must be a
fixnum.  If successful return the fixnum zero, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_setuid (ikptr @var{new_uid})
Interface to the C function @cfunc{setuid}, @glibcref{Setting User ID,
setuid}.  Set both the real and effective user IDs to @var{new_uid},
which must be a fixnum.  If successful return the fixnum zero, else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_setreuid (ikptr @var{real_uid}, ikptr @var{effective_uid})
Interface to the C function @cfunc{setreuid}, @glibcref{Setting User ID,
setreuid}.  Set the real user ID to @var{real_uid} and the effective
user ID to @var{effective_uid}, both the arguments must be fixnums.  If
successful return the fixnum zero, else return an encoded @code{errno}
value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_setegid (ikptr @var{new_gid})
Interface to the C function @cfunc{setegid}, @glibcref{Setting Groups,
setegid}.  Set the effective group ID to @var{new_gid}, which must be a
fixnum.  If successful return the fixnum zero, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_setgid (ikptr @var{new_gid})
Interface to the C function @cfunc{setgid}, @glibcref{Setting Groups,
setgid}.  Set both the real and effective group IDs to @var{new_gid},
which must be a fixnum.  If successful return the fixnum zero, else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_setregid (ikptr @var{real_gid}, ikptr @var{effective_gid})
Interface to the C function @cfunc{setregid}, @glibcref{Setting Groups,
setregid}.  Set the real group ID to @var{real_gid} and the effective
group ID to @var{effective_gid}, both the arguments must be fixnums.  If
successful return the fixnum zero, else return an encoded @code{errno}
value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_getlogin (ikpcb * @var{pcb})
Interface to the C function @cfunc{getlogin}, @glibcref{Who Logged In,
getlogin}.  Return a bytevector holding the @ascii{} coding of the name
of the user logged in on the controlling terminal of the process; if the
name cannot be determined: return false.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_getpwuid (ikptr @var{rtd}, ikptr @var{uid}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getpwuid}, @glibcref{Lookup User,
getpwuid}.  Retrieve informations on the user with identifier @var{uid},
which must be a fixnum.  If successful return an instance of
@code{struct-passwd} initialised with @var{rtd}, which must be its type
descriptor; if a user with such an ID does not exists: return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_getpwnam (ikptr @var{rtd}, ikptr @var{name}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getpwnam}, @glibcref{Lookup User,
getpwnam}.  Retrieve informations on the user with name represented in
@ascii{} coding by the bytevector @var{name}.  If successful return an
instance of @code{struct-passwd} initialised with @var{rtd}, which must
be its type descriptor; if a user with such an ID does not exists:
return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_user_entries (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C functions @cfunc{setpwent}, @cfunc{getpwent} and
@cfunc{endpwent}, @glibcref{Scanning All Users, setpwent}.  Iterate the
database of users and return a list of @code{struct-passwd} representing
the entries; the structures are initialised with @var{rtd} which must be
the type descriptor of @code{struct-passwd}.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_getgrgid (ikptr @var{rtd}, ikptr @var{gid}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getgrgid}, @glibcref{Lookup Group,
getgrgid}.  Retrieve informations on the group with identifier
@var{gid}, which must be a fixnum.  If successful return an instance of
@code{struct-group} initialised with @var{rtd}, which must be its type
descriptor; if a group with such an ID does not exists: return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_getgrnam (ikptr @var{rtd}, ikptr @var{name}, ikpcb * @var{pcb})
Interface to the C function @cfunc{getgrnam}, @glibcref{Lookup Group,
getgrnam}.  Retrieve informations on the group with name represented in
@ascii{} coding by the bytevector @var{name}.  If successful return an
instance of @code{struct-group} initialised with @var{rtd}, which must
be its type descriptor; if a group with such an ID does not exists:
return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_group_entries (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C functions @cfunc{setgrent}, @cfunc{getgrent} and
@cfunc{endgrent}, @glibcref{Scanning All Groups, setgrent}.  Iterate the
database of groups and return a list of @code{struct-group} representing
the entries; the structures are initialised with @var{rtd} which must be
the type descriptor of @code{struct-group}.
@end deftypefun

@c page
@node capi posix job
@subsection Job control


@deftypefun ikptr ikrt_posix_ctermid (ikpcb * @var{pcb})
Interface to the C function @cfunc{ctermid}, @glibcref{Identifying the
Terminal, ctermid}.  Return a bytevector holding the @ascii{} coded
pathname of the controlling terminal of the current process; the
returned value may be the empty bytevector.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_setsid (void)
Interface to the C function @cfunc{setsid}, @glibcref{Process Group
Functions, setsid}.  Create a new session, making the current process
the group leader with no controlling terminal.  If successful return a
fixnum representing the new process groups ID, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_getsid (ikptr @var{pid})
Interface to the C function @cfunc{getsid}, @glibcref{Process Group
Functions, getsid}.  If successful return a fixnum representing the
session ID of the process with process ID @var{pid}, which must be a
fixnum; else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_getpgrp (void)
Interface to the C function @cfunc{getpgrp}, @glibcref{Process Group
Functions, getpgrp}.  Return a fixnum representing the process group ID
of the calling process.
@end deftypefun


@deftypefun ikptr ikrt_posix_setpgid (ikptr @var{pid}, ikptr @var{pgid})
Interface to the C function @cfunc{setpgid}, @glibcref{Process Group
Functions, setpgid}.  Put the process @var{pid} in the process group
@var{pgid}.  If successful return the fixnum zero, else return an
encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_posix_tcgetpgrp (ikptr @var{fd})
Interface to the C function @cfunc{tcgetpgrp}, @glibcref{Terminal Access
Functions, tcgetpgrp}.  If successful return a fixnum representing the
process group ID of the foreground process group associated with the
terminal open on descriptor @var{fd}, which must be a fixnum; else
return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_tcsetpgrp (ikptr @var{fd}, ikptr @var{pgid})
Interface to the C function @cfunc{tcsetpgrp}, @glibcref{Terminal Access
Functions, tcsetpgrp}.  Set to process group ID @var{pgid} the
foreground process group for the terminal open on descriptor @var{fd};
both the arguments must be fixnums.  If successful return the fixnum
zero, else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_posix_tcgetsid (ikptr @var{fd})
Interface to the C function @cfunc{tcgetsid}, @glibcref{Terminal Access
Functions, tcgetsid}.  If successful return a fixnum representing the
process group ID of the session for which the terminal open on
descriptor @var{fd} is the controlling terminal; else return an encoded
@code{errno} value.
@end deftypefun

@c page
@node capi posix time
@subsection Date and time


@deftypefun ikptr ikrt_posix_clock (ikpcb * @var{pcb})
Interface to the C function @cfunc{clock}, @glibcref{CPU Time, clock}.
If successful return an @strong{inexact} integer representing the CPU
time for the calling process expressed in clock ticks; if the clock time
is not available return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_times (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C function @cfunc{times}, @glibcref{Processor Time,
times}.  If successful return an instance of @code{struct-tms}
representing the current processor time with all the fields set to
inexact integers, else return false; @var{rtd} must be the type
descriptor of @code{struct-tms}.
@end deftypefun


@deftypefun ikptr ikrt_posix_time (ikpcb * @var{pcb})
Interface to the C function @cfunc{time}, @glibcref{Simple Calendar
Time, time}.  If successful return the calendar time as an
@strong{inexact} integer, else return false.
@end deftypefun


@deftypefun ikptr ikrt_posix_gettimeofday (ikptr @var{rtd}, ikpcb * @var{pcb})
Interface to the C function @cfunc{gettimeofday},
@glibcref{High-Resolution Calendar, gettimeofday}.  Acquire the current
time.  If successful return an instance of @code{struct-timeval}, else
return an encoded @code{errno} value.  @var{rtd} must be the type
descriptor of @code{struct-timeval}.
@end deftypefun


@deftypefun ikptr ikrt_posix_localtime (ikptr @var{rtd}, ikptr @var{time}, ikpcb * @var{pcb})
Interface to the C function @cfunc{localtime}, @glibcref{Broken-down
Time, localtime}.  Given an exact integer @var{time} representing the
local time as returned by the @func{posix-time} function: build and
return an instance of @code{struct-tm} representing the same time in
human readable form; if an error occurs return false.  @var{rtd} must be
the type descriptor of @code{struct-tm}.
@end deftypefun


@deftypefun ikptr ikrt_posix_gmtime (ikptr @var{rtd}, ikptr @var{time}, ikpcb * @var{pcb})
Interface to the C function @cfunc{gmtime}, @glibcref{Broken-down Time,
gmtime}.  Given an exact integer @var{time} representing the @utc{} time
as returned by the @func{posix-time} function: build and return an
instance of @code{struct-tm} representing the same time in human
readable form; if an error occurs return false.  @var{rtd} must be the
type descriptor of @code{struct-tm}.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_nanosleep (ikptr @var{secs}, ikptr @var{nsecs})
Interface to the C function @cfunc{nanosleep}, @glibcref{Sleeping,
nanosleep}.  Halt the current process for the specified amount of time.

The count of seconds @var{secs} must be an exact integer in the range
@math{[0, 2^32)}; the count of nanoseconds @var{nsecs} must be an exact
integer in the range @math{[0, 999999999]}.

If successful and the requested time is elapsed: return a pair whose car
is false and whose cdr is false.  If successful and the sleeping was
interrupted by an interprocess signal: return a pair whose car is an
exact integer representing the count of remaining seconds and whose cdr
is an exact integer representing the count of remaining nanoseconds.  If
an error occurs return an encoded @code{errno} value.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_current_time (ikptr @var{time})
Interface to the @cfunc{gettimeofday} C function.
@glibcref{High-Resolution Calendar, gettimeofday}.  Retrieve the current
time.  @var{time} must reference a @code{time} internal structure, which
is filled with three values: megaseconds, seconds and microseconds.
Always return @var{time} itself.
@end deftypefun


@deftypefun ikptr ikrt_gmt_offset (ikptr @var{time})
Compute the offset in seconds between the local time and the
@acronym{UTC} time.  @var{time} must reference a @code{time} internal
structure, already filled with megaseconds, seconds and microseconds.
Return a fixnum representing the offset.
@end deftypefun


@c page
@node capi linux
@section C language level @gnu{}+Linux interface


@menu
* capi linux status::           Process termination status.
@end menu

@c page
@node capi linux status
@subsection Process termination status


@deftypefun ikptr ikrt_linux_waitid (ikptr @var{idtype}, ikptr @var{id}, ikptr @var{info}, ikptr @var{options})
Interface to the Linux specific C function @cfunc{waitid}, see the
@cfunc{waitid} manual page for details.  Wait for the termination of one
or more child processes with finer control of @cfunc{waitpid}.  The
arguments @var{idtype}, @var{id} and @var{options} must be fixnums.
@var{info} must be a reference to a structure of type
@code{struct-siginfo_t}, @ref{linux status} for details.  If successful:
return @var{info} itself, else raise an exception.
@end deftypefun


The following functions accept as argument a fixnum representing the
process termination status, for example the return value of
@cfunc{system} or the status acquired by @cfunc{waitpid}.


@deftypefun ikptr ikrt_linux_WIFCONTINUED (ikptr @var{status})
Interface to the Linux specific C macro @cfunc{WIFCONTINUED}.  Return
true if the process was resumed by delivery of @code{SIGCONT}.
@end deftypefun

@c page
@node capi glibc
@section C language level @gnu{} C Library interface


@menu
* capi glibc env::              Operating system environment variables.
* capi glibc dir::              File system directories.
* capi glibc temp::             Temporary files and directories.
* capi glibc sync::             File system synchronisation.
* capi glibc socket::           Network sockets.
@end menu

@c page
@node capi glibc env
@subsection Operating system environment variables


@deftypefun ikrt ikrt_glibc_clearenv (void)
Interface to the C function @cfunc{clearenv}, @glibcref{Environment
Access, clearenv}.  Remove all the entries from the environment.  Return
the void object.
@end deftypefun

@c page
@node capi glibc dir
@subsection File system directories


@deftypefun ikptr ikrt_glibc_dirfd (ikptr @var{pointer})
Interface to the C function @cfunc{dirfd}, @glibcref{Opening a
Directory, dirfd}.  Acquire a file descriptor associated to the
directory entry referenced by @var{pointer}, which must be a pointer
object to a directory entry.  If successful return a fixnum representing
the file descriptor, else return an encoded @code{errno} value.
@end deftypefun

@c page
@node capi glibc temp
@subsection Temporary files and directories


@deftypefun ikptr ikrt_glibc_mkstemp (ikptr @var{template}, ikpcb * @var{pcb})
Interface to the C function @cfunc{mkstemp}, @glibcref{Temporary Files,
mkstemp}.  Create a temporary file, open it and open a file descriptor
for reading and writing.  @var{template} must be a mutable bytevector
holding a template pathname on entering and the actual pathname on
returning.  If successful return a file descriptor, else return an
encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_glibc_mkdtemp (ikptr @var{template}, ikpcb * @var{pcb})
Interface to the C function @cfunc{mkdtemp}, @glibcref{Temporary Files,
mkdtemp}.  Create a temporary directory for reading and writing.
@var{template} must be a mutable bytevector holding a template pathname
on entering and the actual pathname on returning.  If successful return
@var{template} itself, else return an encoded @code{errno} value.
@end deftypefun

@c page
@node capi glibc sync
@subsection File system synchronisation


@deftypefun ikptr ikrt_glibc_sync (void)
Interface to the C function @cfunc{sync}, @glibcref{Synchronizing I/O}.
Flush kernel buffer data and meta informations to the file system
devices.  If successful return the fixnum zero, else return an encoded
@code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_glibc_fsync (ikptr @var{fd})
Interface to the C function @cfunc{fsync}, @glibcref{Synchronizing I/O}.
Flush kernel buffer data and meta informations to the file system device
for the file descriptor @var{fd}.  If successful return the fixnum zero,
else return an encoded @code{errno} value.
@end deftypefun


@deftypefun ikptr ikrt_glibc_fdatasync (ikptr @var{fd})
Interface to the C function @cfunc{fdatasync}, @glibcref{Synchronizing
I/O}.  Flush kernel buffer data to the file system device for the file
descriptor @var{fd}.  If successful return the fixnum zero, else return
an encoded @code{errno} value.
@end deftypefun

@c page
@node capi glibc socket
@subsection Network sockets


@deftypefun ikptr ikrt_glibc_if_nametoindex (ikptr @var{name})
Interface to the C function @cfunc{if_nametoindex}, @glibcref{Interface
Naming, if_nametoindex}.  Convert a string representing a network
interface to the corresponding internal index.  @var{name} must be a
bytevector holding the @utf{}-8 representation of the string.  Return a
fixnum representing the index or false if @var{name} is invalid.
@end deftypefun


@deftypefun ikptr ikrt_glibc_if_indextoname (ikptr @var{index}, ikpcb * @var{pcb})
Interface to the C function @cfunc{if_indextoname}, @glibcref{Interface
Naming, if_indextoname}.  Convert the index associated to an interface
to the corresponding string name.  @var{index} must be a fixnum
representing the index.  Return a bytevector holding the name or false
if @var{index} is invalid.
@end deftypefun


@deftypefun ikptr ikrt_glibc_if_nameindex (ikpcb * @var{pcb})
Interface to the C function @cfunc{if_nameindex}, @glibcref{Interface
Naming, if_nameindex}.  Build and return an association list having
fixnums as keys and bytevectors as values; the fixnums are the interface
indexes, the bytevectors are the corresponding interface names.
@end deftypefun

@c ------------------------------------------------------------

@deftypefun ikptr ikrt_glibc_gethostbyname2 (ikptr @var{rtd}, ikptr @var{hostname}, ikptr @var{addrtype}, ikpcb * @var{pcb})
Interface to the C function @cfunc{gethostbyname2}, @glibcref{Host
Names, gethostbyname2}.  Like @cfunc{ikrt_posix_gethostbyname} but
allows the selection of the address type with @var{addrtype} which must
be @code{AF_INET} or @code{AF_INET6}.
@end deftypefun

@c page
@node objects
@chapter Built in objects


Built in objects are implemented in the C language portion of the source
code; the overall definitions are in the C language file
@file{ikarus-data.h} and the definition of many values is duplicated in
the Scheme language compiler @file{ikarus.compiler.sls}.

@menu
* objects refs::                Builtin object references.
* objects const::               Constant values.
* objects alloc::               Allocating memory for builtin objects.
* objects fixnum::              Fixnum objects.
* objects pair::                Pair objects.
* objects bytevector::          Bytevector objects.
* objects vector::              Vector objects.
* objects struct::              Struct objects.
@end menu

@c page
@node objects refs
@section Built in object references


@deftp {Object Reference} ikptr
An immediate built in object or a reference to a built in object;
implemented as an @code{unsigned long int} it is meant to be the size of
a machine word.  The definition assumes that:

@itemize
@item
On 32 bits platforms, @code{unsigned long int} is a 32 bits value.

@item
On 64 bits platforms, @code{unsigned long int} is a 64 bits value.

@item
The type @code{unsigned long int} is big enough to hold a pointer for
the underlying platform.
@end itemize

If an @code{ikptr} value is neither a fixnum nor a constant value, the
@math{3} least significant bits of an @code{ikptr} represent the ``tag''
of the referenced object's type.

Notice that the type definition of @code{ikptr} is @strong{not} a
pointer; this means that when storing a pointer into an @code{ikptr} and
then adding offsets to it, the offset is in bytes:

@example
uint8_t *p = ...;
ikptr    q = (ikptr)p;

void *   r = (void *)(p + 3);  /* pointer to the 4th byte */
@end example
@end deftp


@defmac tagof (@var{ref})
Extract the @math{3} least significant bits of an @code{ikptr} value.
@end defmac


@defmac ref (@var{ptr}, @var{offset})
Expand to the machine word at @var{offset} past @var{ptr}; it can be
used either as operand or as left--side of an assignment.  The ``word''
is the unsigned integer type used in the type definition of
@code{ikptr}; @var{ptr} can be a pointer of any type: it is cast to a
``pointer to words''.  Example:

@example
char *   p = ...;
ikptr    q;

ref(p, 1) = 123L;       /* store the value in the first
                           word of the array */

q = ref(p, 3);          /* retrieve the third word in
                           the array */
@end example
@end defmac

@c page
@node objects const
@section Constant values


@defmac false_object 0x2F
Special machine word value representing @false{}.
@end defmac


@defmac true_object 0x3F
Special machine word value representing @true{}.
@end defmac


@defmac null_object 0x4F
Special machine word value representing nil, the empty list.
@end defmac


@defmac void_object 0x7F
Special machine word value representing @void{}, the return value of
functions returning no value.
@end defmac


@defmac bwp_object 0x8F
Special machine word value stored in locations that used to hold weak
references to values which have been already garbage collected.
@end defmac


@defmac unbound_object 0x6F
Special machine word value stored in the @code{value} and @code{proc}
field of Scheme symbol memory blocks to signal that these fields are
unset.
@end defmac

@c page
@node objects alloc
@section Allocating memory for built in objects


In short, memory allocation is performed as follows:

@example
ikpcb     pcb = ...;
long int  number_of_bytes = ...;
ikptr     p = ik_safe_alloc(pcb, align(number_of_bytes));
@end example

@noindent
where @code{pcb} is the pointer to a data structure describing the
memory heap.  Memory blocks, subject to garbage collection, are
allocated on the heap, a contiguous region of memory:

@example
    allocated  allocated      allocated
    block      block          block
...|----------|--------------|--------|------...
    ^          ^              ^        ^
    |          |              |        |
  pointer    pointer        pointer   pointer to
                                      next block
@end example

@noindent
every pointer must satisfy alignment constraints with the following
purposes:

@enumerate
@item
To make pointer indirection efficient on the underlying platform.

@item
To have pointer values with the @math{3} least significant bits set to
zero.
@end enumerate

@noindent
for this reason we must always filter the requested size (in bytes)
through the @func{align} macro.  The @code{pcb} always references a
``pointer to the next free block'' with alignment constraints satisfied;
if we filter the requested number of bytes through @func{align}, we
obtain a number of bytes which, added to the pointer, gives a correctly
aligned pointer:

@example
uint8_t * allocated_block = (uint8_t *)pcb->allocation_pointer;
long int  requested_size  = ...;
long int  aligned_size    = align(requested_size);
uint8_t * next_free_block = allocated_block + aligned_size;
pcb->allocation_pointer   = (ikptr)next_free_block;

/* use "allocated_block" */


            requested size
       |.......................|
            aligned size
       |..........................|
...----|--------------------------|-----------....
        ^                          ^
        |                          |
      pointer to an              pointer to the
      allocated block            next block
@end example


@defmac align (@var{number_of_bytes})
Convert @var{number_of_bytes}, which must be an integer of type
@code{long int}, to the number of bytes requested to satisfy pointer
alignment constraints.  We can simulate the computation with:

@example
(import (ikarus))

(define sizeof-ikptr
  (make-parameter #f))

(define (align n)
  (let* ((wordsize      (sizeof-ikptr))
         (wordshift     (if (= wordsize 4) 2 3))
         (align_shift   (+ 1 wordshift))
         (align_size    (* 2 wordsize))
         (<<            bitwise-arithmetic-shift-left)
         (>>            bitwise-arithmetic-shift-right))
    (<< (>> (- (+ n align_size) 1)
            align_shift)
        align_shift)))

(define (print-align n)
  (let ((m (align n))
        (base-pointer (expt 2 (- (* 8 (sizeof-ikptr)) 1))))
    (display n)
    (display " -> ")
    (display m)
    (display "\t")
    (display (number->string base-pointer 2))
    (display " -> ")
    (display (number->string (+ base-pointer m) 2))
    (newline)))

(parameterize ((sizeof-ikptr 4)) ; 32 bits platform
  (print-align 12)
  (print-align 17)
  (print-align 1234))
@end example
@end defmac


@deftypefun ikptr ik_safe_alloc (ikpcb * @var{pcb}, int @var{aligned_size})
Allocate a memory block on the heap and return a reference to it as an
untagged pointer.  @var{pcb} must reference the heap, @var{aligned_size}
must be the requested number of bytes filtered through @func{align}.

If not enough memory is available on the heap, a garbage collection is
triggered; then allocation is tried again: if it still fails the process
is terminated with exit status @code{-1}.
@end deftypefun


@c page
@node objects fixnum
@section Fixnum objects


Fixnums are ``small'' exact integers.  In Vicare's jargon, ``word size''
is the number of bytes in an @code{ikptr}; if the word size is @math{4},
@math{30} bits are used for fixnum representation, else the number of
bits used is the number of bits in a word minus @math{3}:

@example
#define wordsize ((int)(sizeof(ikptr)))
#define wordshift ((wordsize == 4)?2:3)
@end example

Let's say @code{ikptr} is a @math{32} bits value, which means the word
size is @math{4} bytes; then the representation of a fixnum is:

@example
   30 bits fixnum representation
|.................................|00

|--------|--------|--------|------+--|
  byte3    byte2    byte1    byte0
@end example

@noindent
the two least significant bits are set to zero: this ``tags'' the
@code{ikptr} which embed fixnums.


@defmac fix (@var{num})
Convert a small exact integer in the correct range for a fixnum, into a
@code{ikptr} value.
@end defmac


@defmac unfix (@var{ref})
Convert an @code{ikptr} value holding a fixnum into a fixnum of type
@code{long int}.
@end defmac


@defmac is_fixnum (@var{ref})
Expand to true if @var{ref} is an @code{ikptr} embedding a fixnum.  It
just tests if the least significant bits in the tag are set to zero.
@end defmac


Examples:

@example
long int  n = 123L;
ikptr     p = fix(n);
long int  m = unfix(p);
@end example

@c page
@node objects pair
@section Pair objects


Pairs are allocated as follows:

@example
ikpcb *  pcb = ...;
ikptr    pair;

pair = ik_safe_alloc(pcb, pair_size) + pair_tag;
@end example

@noindent
the car and cdr of a pair are extracted as follows:

@example
ikptr   pair, the_car, the_cdr;

the_car = ref(pair, off_car);
the_cdr = ref(pair, off_cdr);
@end example

@noindent
the car and cdr of a pair are set as follows:

ikptr   pair, the_car, the_cdr;

@example
ref(pair, off_car) = the_car;
ref(pair, off_cdr) = the_car;
@end example


@defmac is_pair (ikptr @var{X})
Evaluate to true if the machine word @var{X} is tagged as pair.
@end defmac


@defmac pair_mask
@defmacx pair_tag
The constant @code{pair_mask} is the bit pattern used to isolate a pair
tag from a machine word; the constant @code{pair_tag} is the bit pattern
that identifies machine words as references to pairs.

@example
ikptr  word = ...;
long   pattern;
int    true_if_pair;

pattern      = ((long)word) & pair_mask;
true_if_pair = (pattern == pair_tag);
@end example
@end defmac

@defmac pair_size
The number of bytes in a pair memory block.
@end defmac


@defmac disp_car
@defmacx disp_cdr
Integer constant values representing the offsets of the car and cdr from
the beginning of a pair memory block.
@end defmac


@defmac off_car
@defmacx off_cdr
Integer constant values to be added to a pointer tagged as pair to
retrieve the car and the cdr from a pair memory block.  To be used as
second argument to @cfunc{ref}.
@end defmac

@c page
@node objects bytevector
@section Bytevector objects


Bytevector objects are allocated on the heap using
@cfunc{ik_safe_alloc}; to perform the allocation we compute the whole
size of the bytevector data area, add to it room for meta data and
finally compute the aligned block size:

@example
ikpcb     pcb        = ...;
long int  bv_len     = ...;
long int  block_size = disp_bytevector_data + bv_len + 1;
lont int  align_size = align(block_size);
ikptr     bv = ik_safe_alloc(pcb, aligned_size)
             + bytevector_tag;
@end example

@noindent
we have to remember that it is convention of the internal functions of
@value{PRJNAME} to allocate one byte more than the requested size and to
set that final byte to zero; whenever the functions modify the contents
of a bytevector data area, they always set the byte after the last used
one to zero, to allow for the bytevector to be used as C string.
@ref{syslib bytevectors} for details on memory layout of bytevectors.

@cfunc{ik_safe_alloc} returns an @code{ikptr} value representing the
aligned pointer, having the @math{3} least significant bits set to zero;
we add to it the bytevector tag (an integer value fitting in @math{3}
bits) which allows to recognise bytevectors among all the other built in
objects.

We have to explicitly store the bytevector length in the memory block as
a fixnum and set the last byte to zero, so usually a full allocation
looks like this:

@example
ikptr
ik_bytevector_alloc (ikpcb * pcb, long int bv_len)
@{
  long int  aligned_size;
  ikptr     bv;
  char *    data;
  aligned_size = align(disp_bytevector_data + bv_len + 1);
  bv           = ik_safe_alloc(pcb, aligned_size)
                 + bytevector_tag;
  ref(bv, off_bytevector_length) = fix(bv_len);
  data = (char *)(long)(bv + off_bytevector_data);
  data[bv_len] = '\0';
  return bv;
@}
@end example

@noindent
and to access the data area we do:

@example
ikptr      bv = ...;
uint8_t *  data_area;

data_area = (uint8_t *)(long)(bv + off_bytevector_data);
@end example


@defmac bytevector_tag
An integer used to tag pointers to bytevector memory blocks.
@end defmac


@defmac disp_bytevector_length
Displacement of length.  The number of bytes to add to an untagged
pointer to bytevector to get the pointer to the first byte in the word
holding the bytevector length as fixnum.
@end defmac


@defmac disp_bytevector_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to bytevector to get the pointer to the first byte in the data
area.
@end defmac


@defmac off_bytevector_length
An integer to add to a tagged bytevector reference (@code{ikptr}) to
retrieve the pointer to the first byte of the bytevector length.  The
bytevector length is a fixnum.
@end defmac


@defmac off_bytevector_data
An integer to add to a tagged bytevector reference (@code{ikptr}) to
retrieve the pointer to the first byte of the bytevector length.  The
bytevector length is a fixnum.

Notice that on both @math{32} bits and @math{64} bits platforms: the
first byte of the data area is at the same offset from the first byte of
the bytevector memory block.
@end defmac

@c page
@node objects vector
@section Vector objects


Vector objects are allocated on the heap; the function
@cfunc{ikrt_make_vector1} can allocate a vector, but we can also call
@cfunc{ik_safe_alloc} explicitly; to perform the allocation we compute
the whole size of the vector data area, add to it room for meta data and
finally compute the aligned block size:

@example
ikpcb     pcb = ...;
long int  number_of_elements = ...;
long int  requested_size = wordsize * number_of_elements;
long int  block_size     = disp_vector_data + requested_size;
lont int  aligned_size   = align(block_size);
ikptr     vec = ik_safe_alloc(pcb, aligned_size) + vector_tag;
@end example

@noindent
@cfunc{ik_safe_alloc} returns an @code{ikptr} value representing the
aligned pointer, having the @math{3} least significant bits set to zero;
we add to it the vector tag (an integer value fitting in @math{3} bits)
which allows to recognise vectors among all the other built in objects.

We have to explicitly store the vector length in the memory block as a
fixnum, so usually a full allocation looks like this:

@example
ikpcb     pcb;
long int  len;
ikptr     vec;

pcb  = ...;
len  = ...;
vec  = ik_safe_alloc(pcb, align(disp_vector_data+wordsize*len))
       + vector_tag;

ref(vec, off_vector_length) = fix(len);
@end example

@noindent
to fill a vector of 5 items with fixnums we should do:

@example
ref(vec, off_vector_data+0*wordsize) = fix(10);
ref(vec, off_vector_data+1*wordsize) = fix(20);
ref(vec, off_vector_data+2*wordsize) = fix(30);
ref(vec, off_vector_data+3*wordsize) = fix(40);
ref(vec, off_vector_data+4*wordsize) = fix(50);
@end example


@defmac vector_tag
An integer used to tag pointers to vector memory blocks.
@end defmac


@defmac disp_vector_length
Displacement of length.  The number of bytes to add to an untagged
pointer to vector to get the pointer to the first byte in the word
holding the vector length as fixnum.
@end defmac


@defmac disp_vector_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to vector to get the pointer to the first byte in the data area.
@end defmac


@defmac off_vector_length
An integer to add to a tagged vector reference (@code{ikptr}) to
retrieve the pointer to the first byte of the vector length.  The
vector length is a fixnum.
@end defmac


@defmac off_vector_data
An integer to add to a tagged vector reference (@code{ikptr}) to
retrieve the pointer to the first byte of the vector length.  The
vector length is a fixnum.

Notice that on both @math{32} bits and @math{64} bits platforms: the
first byte of the data area is at the same offset from the first byte of
the vector memory block.
@end defmac

@c page
@node objects struct
@section Struct objects


Data structure objects are allocated on the heap, @ref{syslib structs}
for details on the binary layout; structures are best allocated at the
Scheme level using the functions from the @library{vicare} library,
@ref{iklib structs} for details.  It is sometimes convenient to access a
structure at the C level, especially when interfacing with foreign
libraries.


@defmac disp_record_rtd
Displacement of the @rtd{} from the beginning of a structure block.  The
number of bytes to add to an untagged pointer to structure to get the
pointer to the first byte in the word holding the @rtd{}.
@end defmac


@defmac disp_record_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to structure to get the pointer to the first byte of the first
field in the data area.
@end defmac


@defmac off_record_rtd
An integer to add to a tagged structure reference (@code{ikptr}) to
retrieve the pointer to the first byte of the @rtd{}.
@end defmac


@defmac off_record_data
An integer to add to a tagged structure reference (@code{ikptr}) to
retrieve the pointer to the first byte of the first field of the
structure.

Example, to fill a structure of 5 fields with fixnums we should do:

@example
void
some_function (ikptr the_struct)
@{
  ref(the_struct, off_vector_data+0*wordsize) = fix(10);
  ref(the_struct, off_vector_data+1*wordsize) = fix(20);
  ref(the_struct, off_vector_data+2*wordsize) = fix(30);
  ref(the_struct, off_vector_data+3*wordsize) = fix(40);
  ref(the_struct, off_vector_data+4*wordsize) = fix(50);
@}
@end example
@end defmac

@c page
@node debug int
@chapter Internals: debug mode


@menu
* debug int intro::             Introduction to debug mode.
@end menu

@c page
@node debug int intro
@section Introduction to debug mode


Debug mode is driven with the following options:

@table @option
@item -d
@itemx --debug
Turn on debugging mode.  The parameter @func{generate-debug-calls} is
set to true.

@item -nd
@itemx --no-debug
Turn off debugging mode.  The parameter @func{generate-debug-calls} is
set to false.
@end table

The implementation is mostly in @file{ikarus.debugger.sls} and
@file{ikarus.compiler.sls}.


@deffn Parameter generate-debug-calls
Set to true when debug mode is turned on.  Defined in
@file{ikarus.compiler.sls}, configured in @file{ikarus.main.sls}.
@end deffn


@defun guarded-start @var{proc}
Evaluate the procedure @var{proc} under the debugging infrastructure.
It is used in the @library{ikarus main} library (@file{ikarus.main.sls})
to start the execution of a program and all the other execution modes.

@var{proc} is evaluated under the installation of an exception handler
displaying the stack trace and offering the continuation alternatives.
@end defun

@c page
@node compiler
@chapter Wild notes on the compiler internals


@quotation
This chapter is a collection of notes on the internals of the compiler;
there is guarantee of neither their correctness nor their completeness,
because the original compiler code is fully undocumented.
@end quotation

@menu
* compiler intro::              Introduction to the compiler.
* compiler conventions::        Coding conventions in the compiler
                                code.
* compiler cogen::              Stuff in @file{ikarus.compiler.altcogen.ss}.
@end menu

@c page
@node compiler intro
@section Introduction to the compiler


@value{PACKAGE}'s compiler supports only the Intel architecture.  The
compiler is coded in the following files

@table @file
@item ikarus.compiler.altcogen.ss
Generate assembly code in S--expression format.
@end table


How do we generate assembly code?  First we need to generate a single
line of assembly code; this is done by @func{make-asm-instr} which
accepts as first argument a Scheme symbol representing the instruction,
for example: @samp{move}, @samp{idiv}, @samp{int+}.

Then we need to generate blocks of assembly instructions: sequences of
instructions which must be executed in order.  There are two types of
blocks: the ones which at the end generate a value to be stored in a
location (register or memory), the ones which perform some operation but
do not generate a value.  The first kind are blocks which ``impose a
value'', the second kind are the ``side effects''.

@c page
@node compiler conventions
@section Coding conventions in the compiler code


Throughout the compiler code variables with the following names appear:

@table @var
@item op
Scheme symbol representing an @strong{operation} to be directly
translated into assembly.  Examples: @samp{alloc}, @samp{mref},
@samp{mref32}, @samp{bref}, @samp{logand}, @samp{logxor}, @samp{logor},
@samp{int+}, @samp{int-}, @samp{int*}, @samp{int-quotient},
@samp{int-remainder}, @samp{sll}, @samp{sra}.

@item rator
Represents a reference to an @strong{operator}: a function coded in
assembly or C language.

@item rands
Scheme list holding the @strong{operands} to which an operation must be
applied.  These operands are in such a format that can be directly used
in the assembly S--expression like:

@example
(make-set eax (car rands))
@end example

@noindent
which generate an assignment operation to store the first element of
@var{rands} into the @code{eax} processor register.
@end table

@c page
@node compiler cogen
@section Stuff in @file{ikarus.compiler.altcogen.ss}



@c page
@node missing
@appendix Missing Features


@value{PRJNAME} does not fully conform to @rnrs{6} yet.  Although it
implements most of @rnrs{6}'s macros and procedures, some are still
missing.  This appendix summarizes the set of missing features and
procedures.

@itemize
@item
@func{number->string} does not accept the third argument (precision).
Similarly, @func{string->number} and the reader do not recognize the
@code{|p} notation.
@end itemize

@c page
@node building
@appendix Building infrastructure


This appendix contains instructions on how to use and modify the
building infrastructure of @value{PACKAGE}.  The source of the package
is manage by a Git repository, so some bits of the infrastructure depend
on Git.

@menu
* building revision::           Package revision in the banner.
@end menu

@c page
@node building revision
@appendixsec Package revision in the banner


When running @value{EXECUTABLE} in a terminal, it prints a banner
showing the revision number:

@smallexample
$ vicare
Vicare Scheme version 0.1d0+ \
  (revision master/21da24720f161708372756e1324c230bd5ff6ac9, \
   build 2010-05-01)
Copyright (c) 2006-2010 Abdulaziz Ghuloum
@end smallexample

The revision specification shows the branch name and the commit hash;
they are read from the file @file{./scheme/last-revision}, which is
generated by the following chunk of code in the
@file{.git/hooks/post-commit} script:

@smallexample
LAST_REVISION_FILE=./scheme/last-revision
BRANCH_NAME=$(git branch 2>/dev/null | \
                sed -e '/^[^*]/d' -e 's/^* //')
COMMIT_HASH=$(git show | head -1 | cut -d' ' -f2)
echo "$BRANCH_NAME/$COMMIT_HASH" >$LAST_REVISION_FILE
@end smallexample

@c page
@node credits
@appendix Credits for this document


The skeleton of this document is the original ``Ikarus User's Guide'' in
XeLaTeX format, by Abdulaziz Ghulom.  That document is available in the
Ikarus distribution and is covered by the @gnu{} General Public License
version 3 as published by the Free Software Foundation.  It is available
at the following @aurl{}s:

@center @url{http://www.cs.indiana.edu/~aghuloum/ikarus/}
@center @url{https://launchpad.net/ikarus}

@c page
@node package license
@appendix @gnu{} General Public License

@c The GNU General Public License.
@center Version 3, 29 June 2007

@display
Copyright @copyright{} 2007 Free Software Foundation, Inc. @url{http://fsf.org/}

Everyone is permitted to copy and distribute verbatim copies of this
license document, but changing it is not allowed.
@end display

@heading Preamble

The GNU General Public License is a free, copyleft license for
software and other kinds of works.

The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom
to share and change all versions of a program---to make sure it remains
free software for all its users.  We, the Free Software Foundation,
use the GNU General Public License for most of our software; it
applies also to any other work released this way by its authors.  You
can apply it to your programs, too.

When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you
have certain responsibilities if you distribute copies of the
software, or if you modify it: responsibilities to respect the freedom
of others.

For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too,
receive or can get the source code.  And you must show them these
terms so they know their rights.

Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the
manufacturer can do so.  This is fundamentally incompatible with the
aim of protecting users' freedom to change the software.  The
systematic pattern of such abuse occurs in the area of products for
individuals to use, which is precisely where it is most unacceptable.
Therefore, we have designed this version of the GPL to prohibit the
practice for those products.  If such problems arise substantially in
other domains, we stand ready to extend this provision to those
domains in future versions of the GPL, as needed to protect the
freedom of users.

Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish
to avoid the special danger that patents applied to a free program
could make it effectively proprietary.  To prevent this, the GPL
assures that patents cannot be used to render the program non-free.

The precise terms and conditions for copying, distribution and
modification follow.

@heading TERMS AND CONDITIONS

@enumerate 0
@item
Definitions.

``This License'' refers to version 3 of the GNU General Public License.

``Copyright'' also means copyright-like laws that apply to other kinds
of works, such as semiconductor masks.

``The Program'' refers to any copyrightable work licensed under this
License.  Each licensee is addressed as ``you''.  ``Licensees'' and
``recipients'' may be individuals or organizations.

To ``modify'' a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of
an exact copy.  The resulting work is called a ``modified version'' of
the earlier work or a work ``based on'' the earlier work.

A ``covered work'' means either the unmodified Program or a work based
on the Program.

To ``propagate'' a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

To ``convey'' a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user
through a computer network, with no transfer of a copy, is not
conveying.

An interactive user interface displays ``Appropriate Legal Notices'' to
the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent @item
in the list meets this criterion.

@item
Source Code.

The ``source code'' for a work means the preferred form of the work for
making modifications to it.  ``Object code'' means any non-source form
of a work.

A ``Standard Interface'' means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

The ``System Libraries'' of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
``Major Component'', in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

The ``Corresponding Source'' for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

The Corresponding Source need not include anything that users can
regenerate automatically from other parts of the Corresponding Source.

The Corresponding Source for a work in source code form is that same
work.

@item
Basic Permissions.

All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

You may make, run and propagate covered works that you do not convey,
without conditions so long as your license otherwise remains in force.
You may convey covered works to others for the sole purpose of having
them make modifications exclusively for you, or provide you with
facilities for running those works, provided that you comply with the
terms of this License in conveying all material for which you do not
control copyright.  Those thus making or running the covered works for
you must do so exclusively on your behalf, under your direction and
control, on terms that prohibit them from making any copies of your
copyrighted material outside their relationship with you.

Conveying under any other circumstances is permitted solely under the
conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

@item
Protecting Users' Legal Rights From Anti-Circumvention Law.

No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such
circumvention is effected by exercising rights under this License with
respect to the covered work, and you disclaim any intention to limit
operation or modification of the work as a means of enforcing, against
the work's users, your or third parties' legal rights to forbid
circumvention of technological measures.

@item
Conveying Verbatim Copies.

You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

@item
Conveying Modified Source Versions.

You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these
conditions:

@enumerate a
@item

The work must carry prominent notices stating that you modified it,
and giving a relevant date.

@item

The work must carry prominent notices stating that it is released
under this License and any conditions added under section 7.  This
requirement modifies the requirement in section 4 to ``keep intact all
notices''.

@item

You must license the entire work, as a whole, under this License to
anyone who comes into possession of a copy.  This License will
therefore apply, along with any applicable section 7 additional terms,
to the whole of the work, and all its parts, regardless of how they
are packaged.  This License gives no permission to license the work in
any other way, but it does not invalidate such permission if you have
separately received it.

@item

If the work has interactive user interfaces, each must display
Appropriate Legal Notices; however, if the Program has interactive
interfaces that do not display Appropriate Legal Notices, your work
need not make them do so.
@end enumerate

A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
``aggregate'' if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

@item
 Conveying Non-Source Forms.

You may convey a covered work in object code form under the terms of
sections 4 and 5, provided that you also convey the machine-readable
Corresponding Source under the terms of this License, in one of these
ways:

@enumerate a
@item

Convey the object code in, or embodied in, a physical product
(including a physical distribution medium), accompanied by the
Corresponding Source fixed on a durable physical medium customarily
used for software interchange.

@item

Convey the object code in, or embodied in, a physical product
(including a physical distribution medium), accompanied by a written
offer, valid for at least three years and valid for as long as you
offer spare parts or customer support for that product model, to give
anyone who possesses the object code either (1) a copy of the
Corresponding Source for all the software in the product that is
covered by this License, on a durable physical medium customarily used
for software interchange, for a price no more than your reasonable
cost of physically performing this conveying of source, or (2) access
to copy the Corresponding Source from a network server at no charge.

@item

Convey individual copies of the object code with a copy of the written
offer to provide the Corresponding Source.  This alternative is
allowed only occasionally and noncommercially, and only if you
received the object code with such an offer, in accord with subsection
6b.

@item

Convey the object code by offering access from a designated place
(gratis or for a charge), and offer equivalent access to the
Corresponding Source in the same way through the same place at no
further charge.  You need not require recipients to copy the
Corresponding Source along with the object code.  If the place to copy
the object code is a network server, the Corresponding Source may be
on a different server (operated by you or a third party) that supports
equivalent copying facilities, provided you maintain clear directions
next to the object code saying where to find the Corresponding Source.
Regardless of what server hosts the Corresponding Source, you remain
obligated to ensure that it is available for as long as needed to
satisfy these requirements.

@item

Convey the object code using peer-to-peer transmission, provided you
inform other peers where the object code and Corresponding Source of
the work are being offered to the general public at no charge under
subsection 6d.

@end enumerate

A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

A ``User Product'' is either (1) a ``consumer product'', which means any
tangible personal property which is normally used for personal,
family, or household purposes, or (2) anything designed or sold for
incorporation into a dwelling.  In determining whether a product is a
consumer product, doubtful cases shall be resolved in favor of
coverage.  For a particular product received by a particular user,
``normally used'' refers to a typical or common use of that class of
product, regardless of the status of the particular user or of the way
in which the particular user actually uses, or expects or is expected
to use, the product.  A product is a consumer product regardless of
whether the product has substantial commercial, industrial or
non-consumer uses, unless such uses represent the only significant
mode of use of the product.

``Installation Information'' for a User Product means any methods,
procedures, authorization keys, or other information required to
install and execute modified versions of a covered work in that User
Product from a modified version of its Corresponding Source.  The
information must suffice to ensure that the continued functioning of
the modified object code is in no case prevented or interfered with
solely because modification has been made.

If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or
updates for a work that has been modified or installed by the
recipient, or for the User Product in which it has been modified or
installed.  Access to a network may be denied when the modification
itself materially and adversely affects the operation of the network
or violates the rules and protocols for communication across the
network.

Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

@item
Additional Terms.

``Additional permissions'' are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders
of that material) supplement the terms of this License with terms:

@enumerate a
@item

Disclaiming warranty or limiting liability differently from the terms
of sections 15 and 16 of this License; or

@item

Requiring preservation of specified reasonable legal notices or author
attributions in that material or in the Appropriate Legal Notices
displayed by works containing it; or

@item

Prohibiting misrepresentation of the origin of that material, or
requiring that modified versions of such material be marked in
reasonable ways as different from the original version; or

@item

Limiting the use for publicity purposes of names of licensors or
authors of the material; or

@item

Declining to grant rights under trademark law for use of some trade
names, trademarks, or service marks; or

@item

Requiring indemnification of licensors and authors of that material by
anyone who conveys the material (or modified versions of it) with
contractual assumptions of liability to the recipient, for any
liability that these contractual assumptions directly impose on those
licensors and authors.
@end enumerate

All other non-permissive additional terms are considered ``further
restrictions'' within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions; the
above requirements apply either way.

@item
Termination.

You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.

Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

@item
Acceptance Not Required for Having Copies.

You are not required to accept this License in order to receive or run
a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

@item
Automatic Licensing of Downstream Recipients.

Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

An ``entity transaction'' is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

@item
Patents.

A ``contributor'' is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's ``contributor version''.

A contributor's ``essential patent claims'' are all patent claims owned
or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, ``control'' includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

In the following three paragraphs, a ``patent license'' is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To ``grant'' such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  ``Knowingly relying'' means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

A patent license is ``discriminatory'' if it does not include within the
scope of its coverage, prohibits the exercise of, or is conditioned on
the non-exercise of one or more of the rights that are specifically
granted under this License.  You may not convey a covered work if you
are a party to an arrangement with a third party that is in the
business of distributing software, under which you make payment to the
third party based on the extent of your activity of conveying the
work, and under which the third party grants, to any of the parties
who would receive the covered work from you, a discriminatory patent
license (a) in connection with copies of the covered work conveyed by
you (or copies made from those copies), or (b) primarily for and in
connection with specific products or compilations that contain the
covered work, unless you entered into that arrangement, or that patent
license was granted, prior to 28 March 2007.

Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

@item
No Surrender of Others' Freedom.

If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey
a covered work so as to satisfy simultaneously your obligations under
this License and any other pertinent obligations, then as a
consequence you may not convey it at all.  For example, if you agree
to terms that obligate you to collect a royalty for further conveying
from those to whom you convey the Program, the only way you could
satisfy both those terms and this License would be to refrain entirely
from conveying the Program.

@item
Use with the GNU Affero General Public License.

Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

@item
Revised Versions of this License.

The Free Software Foundation may publish revised and/or new versions
of the GNU General Public License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies that a certain numbered version of the GNU General Public
License ``or any later version'' applies to it, you have the option of
following the terms and conditions either of that numbered version or
of any later version published by the Free Software Foundation.  If
the Program does not specify a version number of the GNU General
Public License, you may choose any version ever published by the Free
Software Foundation.

If the Program specifies that a proxy can decide which future versions
of the GNU General Public License can be used, that proxy's public
statement of acceptance of a version permanently authorizes you to
choose that version for the Program.

Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

@item
Disclaimer of Warranty.

THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM ``AS IS'' WITHOUT
WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE
DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
CORRECTION.

@item
Limitation of Liability.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR
CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT
NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR
LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM
TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER
PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

@item
Interpretation of Sections 15 and 16.

If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

@end enumerate

@heading END OF TERMS AND CONDITIONS

@heading How to Apply These Terms to Your New Programs

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the ``copyright'' line and a pointer to where the full notice is found.

@smallexample
@var{one line to give the program's name and a brief idea of what it does.}
Copyright (C) @var{year} @var{name of author}

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see @url{http://www.gnu.org/licenses/}.
@end smallexample

Also add information on how to contact you by electronic and paper mail.

If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

@smallexample
@var{program} Copyright (C) @var{year} @var{name of author}
This program comes with ABSOLUTELY NO WARRANTY; for details type @samp{show w}.
This is free software, and you are welcome to redistribute it
under certain conditions; type @samp{show c} for details.
@end smallexample

The hypothetical commands @samp{show w} and @samp{show c} should show
the appropriate parts of the General Public License.  Of course, your
program's commands might be different; for a GUI interface, you would
use an ``about box''.

You should also get your employer (if you work as a programmer) or school,
if any, to sign a ``copyright disclaimer'' for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
@url{http://www.gnu.org/licenses/}.

The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use
the GNU Lesser General Public License instead of this License.  But
first, please read @url{http://www.gnu.org/philosophy/why-not-lgpl.html}.


@c page
@node references
@appendix Bibliography and references


@noindent
``Revised^6 Report on the Algorithmic Language Scheme.''  Michael
Sperber and R. Kent Dybvig and Matthew Flatt and Anton Van Straaten
(Editors).  2007.

@noindent
``Revised^6 Report on the Algorithmic Language Scheme---Standard
Libraries.''  Michael Sperber and R. Kent Dybvig and Matthew Flatt and
Anton Van Straaten (Editors). 2007.

@noindent
``Scheme Request for Implementation 41: Streams.''  Philip L. Bewig.
2007.  @url{http://@/srfi.schemers.org/@/srfi-41/@/srfi-41.html}

@noindent
``Guardians in a generation--based garbage collector''.  R. Kent Dybvig
and Carl Bruggeman and David Eby.  PLDI '93, pages 207--216, June 1993.
Introduces guardians and describes the implementation of guardians and
weak pairs in Chez Scheme.

@noindent
``Don't stop the BiBOP: Flexible and efficient storage management
for dynamically--typed languages.''  R. Kent Dybvig and David Eby and
Carl Bruggeman.  Technical Report 400, Indiana University, March 1994.
Describes Chez Scheme's storage management system.

@noindent
``Generation Friendly Eq Hash Tables.''  Abdulaziz Ghuloum and
R. Kent Dybvig. In ``Proceedings of the 2007 Workshop on Scheme and
Functional Programming'', pages 207--216.  Universite Laval Technical
Report DIUL-RT-0701, 2007.

@noindent
``Extending the Scope of Syntactic Abstraction.''  Oscar Waddell.
PhD thesis, Indiana University Computer Science Department, August 1999.
@url{http://www.cs.indiana.edu/@/~owaddell/@/papers/@/thesis.ps.gz}

@noindent
``Extending the Scope of Syntactic Abstraction.''  Oscar Waddell and
R. Kent Dybvig.  In ``Conference Record of POPL'99: The 26th ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages'', pages
203--213, January 1999.
@url{http://www.cs.indiana.edu/@/~dyb/@/papers/@/popl99.ps.gz}

@noindent
``Chez Scheme Version 7 User's Guide.''  R. Kent Dybvig.  Cadence
Research Systems, 2005.  User's guide and reference manual for Chez
Scheme Version 7.  @url{http://@/www.scheme.com/@/csug7/}

@noindent
``Implicit phasing for R6RS libraries.''  Abdulaziz Ghuloum and
R. Kent Dybvig.  In ``ICFP '07: Proceedings of the 2007 ACM SIGPLAN
international conference on Functional programming'', pages 303--314.
New York, NY, USA, 2007.  ACM.

@noindent
Michael D.  Adams and R.  Kent Dybvig.  ``Efficient nondestructive
equality checking for trees and graphs.''  In ICFP '08: Proceeding of
the 13th ACM SIGPLAN international conference on Functional programming,
pages 179-188.  ACM, New York, NY, USA, 2008.  ISBN
978-1-59593-919-7. doi: 10.1145/1411204.1411230.

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@bye

@c end of file
@c Local Variables:
@c mode: texinfo
@c TeX-master: t
@c End:
